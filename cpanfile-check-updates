#!/usr/bin/env perl
use 5.8.1;

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/CpanfileSlipstop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANFILESLIPSTOP';
  package App::CpanfileSlipstop;use 5.008001;use strict;use warnings;our$VERSION="0.02";1;
APP_CPANFILESLIPSTOP

$fatpacked{"App/CpanfileSlipstop/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANFILESLIPSTOP_CLI';
  package App::CpanfileSlipstop::CLI;use strict;use warnings;use Carton::Snapshot;use Getopt::Long qw/:config posix_default no_ignore_case gnu_compat bundling/;use Module::CPANfile;use Pod::Find qw(pod_where);use Pod::Usage qw(pod2usage);use App::CpanfileSlipstop::Resolver;use App::CpanfileSlipstop::Writer;sub new {my ($class)=@_;bless +{cpanfile=>'./cpanfile',snapshot=>'./cpanfile.snapshot',stopper=>'exact',dry_run=>0,with_core=>0,silent=>0,remove=>0,help=>0,},$class}sub run {my ($self,@argv)=@_;$self->parse_options(@argv);return$self->cmd_help if$self->{help};return$self->cmd_remove if$self->{remove};return$self->cmd_feedback}sub parse_options {my ($self,@argv)=@_;GetOptions('cpanfile=s'=>\($self->{cpanfile}),'snapshot=s'=>\($self->{snapshot}),'stopper=s'=>\($self->{stopper}),'dry-run'=>\($self->{dry_run}),'with-core'=>\($self->{with_core}),'silent'=>\($self->{silent}),'remove'=>\($self->{remove}),'help|h'=>\($self->{help}),)}sub cmd_feedback {my ($self)=@_;my$cpanfile=Module::CPANfile->load($self->{cpanfile});my$snapshot=Carton::Snapshot->new(path=>$self->{snapshot});$snapshot->load;my$resolver=App::CpanfileSlipstop::Resolver->new(cpanfile=>$cpanfile,snapshot=>$snapshot,with_core=>$self->{with_core},);$resolver->read_cpanfile_requirements;$resolver->merge_snapshot_versions($self->versioning_method,$self->{with_core});my$writer=App::CpanfileSlipstop::Writer->new(cpanfile_path=>$self->{cpanfile},dry_run=>$self->{dry_run},);$writer->set_versions(sub {$resolver->get_version_range($_[0])},sub {!$self->{silent}&& $self->log(@_)},);return 0}sub cmd_remove {my ($self)=@_;my$cpanfile=Module::CPANfile->load($self->{cpanfile});my$writer=App::CpanfileSlipstop::Writer->new(cpanfile_path=>$self->{cpanfile},dry_run=>$self->{dry_run},);$writer->remove_versions(sub {!$self->{silent}&& $self->log(@_)},);return 0}sub cmd_help {my ($self)=@_;pod2usage(-input=>pod_where({-inc=>1 },'App::CpanfileSlipstop'),-exitval=>0,)}sub versioning_method {my ($self)=@_;return +{minimum=>'add_minimum',maximum=>'add_maximum',exact=>'exact_version',}->{$self->{stopper}}}sub log {my ($self,$log)=@_;return if ($log->{before}|| '')eq ($log->{after}|| '');my$quote=$log->{quote};print sprintf "%s: %s -> %s\n",$log->{module},$log->{before}? $log->{before}: '(unspecified)',$log->{after}? $log->{after}: '(unspecified)'}1;
APP_CPANFILESLIPSTOP_CLI

$fatpacked{"App/CpanfileSlipstop/Resolver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANFILESLIPSTOP_RESOLVER';
  package App::CpanfileSlipstop::Resolver;use strict;use warnings;use CPAN::Meta::Requirements;sub new {my ($class,%args)=@_;my$self=bless +{reqs=>CPAN::Meta::Requirements->new,cpanfile=>$args{cpanfile},snapshot=>$args{snapshot},},$class;return$self}sub reqs {$_[0]->{reqs}}sub cpanfile {$_[0]->{cpanfile}}sub snapshot {$_[0]->{snapshot}}sub read_cpanfile_requirements {my ($self)=@_;for my$phase (qw(configure build runtime test develop)){$self->reqs->add_requirements($self->cpanfile->prereqs->requirements_for($phase,'requires'))}return}sub merge_snapshot_versions {my ($self,$merge_method,$with_core)=@_;my$find_method=$with_core ? 'find_or_core' : 'find';my$cpanfile_modules=[keys %{$self->reqs->as_string_hash}];for my$module (@$cpanfile_modules){next if$self->ignore_module($module);my$installed_dist=$self->snapshot->$find_method($module);if ($installed_dist){my$version=$installed_dist->version_for($module);$self->reqs->$merge_method($module,$version)if$version}}}sub ignore_module {my ($self,$module)=@_;my$opts=$self->cpanfile->options_for_module($module)|| {};return 1 if$opts->{dist};return 1 if$opts->{url};return 0}sub get_version_range {my ($self,$module)=@_;my$version_range=$self->reqs->requirements_for_module($module);return undef if!$version_range || $version_range eq '0';$version_range =~ s/\A>= 0, //;return$version_range}1;
APP_CPANFILESLIPSTOP_RESOLVER

$fatpacked{"App/CpanfileSlipstop/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANFILESLIPSTOP_WRITER';
  package App::CpanfileSlipstop::Writer;use strict;use warnings;use List::Util qw(first);use PPI::Document;use PPI::Find;sub new {my ($class,%opts)=@_;bless +{cpanfile_path=>$opts{cpanfile_path},dry_run=>$opts{dry_run},},$class}sub cpanfile_path {$_[0]->{cpanfile_path}}sub dry_run {$_[0]->{dry_run}? 1 : 0}my$statement_finder=sub {my (undef,$elem)=@_;return$elem->isa('PPI::Statement')&& $elem->schild(0)->content eq 'requires'};sub set_versions {my ($self,$version_getter,$logger)=@_;my$doc=PPI::Document->new($self->cpanfile_path);my$requirements=$doc->find($statement_finder);for my$statement (@$requirements){my ($type,$module,@args)=$statement->schildren;my$version_range=$version_getter->($module->string);next unless$version_range;my@words=grep {!($_->isa('PPI::Token::Operator')|| $_->content eq ';')}@args;if (@words % 2==0){$self->insert_version($module,$version_range);$logger->({type=>'insert',module=>$module->content,before=>undef,after=>$version_range,quote=>quote($module),})}else {my$current_version=$words[0];$self->replace_version($module,$current_version,$version_range);$logger->({type=>'replace',module=>$module->content,before=>$current_version->content,after=>$version_range,quote=>quote($module),})}}$self->writedown_cpanfile($doc)}sub remove_versions {my ($self,$logger)=@_;my$doc=PPI::Document->new($self->cpanfile_path);my$requirements=$doc->find($statement_finder);for my$statement (@$requirements){my ($type,$module,@args)=$statement->schildren;my@words=grep {!($_->isa('PPI::Token::Operator')|| $_->content eq ';')}@args;if (@words %2==1){my ($op,$version)=@args;my$whitespaces=[];my$token=$op->next_sibling;while ($token && $token->isa('PPI::Token::Whitespace')){push @$whitespaces,$token;$token=$token->next_sibling}$op->remove;$_->remove for @$whitespaces;$version->remove;$logger->({type=>'delete',module=>$module->string,before=>$version->string,after=>undef,quote=>quote($module),})}}$self->writedown_cpanfile($doc)}sub writedown_cpanfile {my ($self,$ppi_doc)=@_;return if$self->dry_run;open my$out,">",$self->cpanfile_path or die sprintf('%s, %s',$self->cpanfile_path,$!);print$out $ppi_doc->serialize;close$out}sub insert_version {my ($self,$module_elem,$version_range)=@_;my$quote=quote($module_elem);$module_elem->__insert_after(PPI::Token->new(qq{, $quote$version_range$quote}))}sub replace_version {my ($self,$module_elem,$version_elem,$version_range)=@_;my$quote=quote($module_elem);return if!($version_elem->isa('PPI::Token::Quote')|| $version_elem->isa('PPI::Token::Number'));my$prev_token=$version_elem->previous_sibling;$version_elem->remove;$prev_token->__insert_after(PPI::Token->new(qq{$quote$version_range$quote}))}sub quote {my ($elem)=@_;return$elem->isa('PPI::Token::Quote::Double')? '"' : "'"}1;
APP_CPANFILESLIPSTOP_WRITER

$fatpacked{"App/ccu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU';
  package App::ccu;use strict;use warnings;use App::CpanfileSlipstop::Writer;use CPAN::DistnameInfo;use HTTP::Tinyish;use IO::Uncompress::Gunzip qw/$GunzipError/;use App::ccu::CPANfile;use App::ccu::ModuleDetails;use Class::Tiny {cpanfile=>'cpanfile',snapshot=>'cpanfile.snapshot',phase=>undef,relationship=>undef,interactive=>undef,module_details=>sub {App::ccu::ModuleDetails->new},releases=>sub {$_[0]->_build_releases},};our$VERSION="0.01";our ($GIT_DESCRIBE,$GIT_URL);sub _build_releases {my$self=shift;my%releases;my$inheader=1;my$z=$self->_fetch_packages;while (defined(my$line=$z->getline)){if ($line =~ /^$/ && $inheader){$inheader=0;next}next if$inheader;my ($module,$version,$path)=split(/\s+/,$line);my$di=CPAN::DistnameInfo->new($path);if ($di && defined$di->dist && defined$di->version){if (!exists$releases{$di->dist}){$releases{$di->dist}={distinfo=>$di,modules=>[],}}elsif ($releases{$di->dist}->{distinfo}->version lt $di->version){$releases{$di->dist}{distinfo}=$di}push @{$releases{$di->dist}{modules}},$module}}return \%releases}sub _fetch_packages {my$res=HTTP::Tinyish->new->get('http://www.cpan.org/modules/02packages.details.txt.gz');unless ($res->{success}){die "$res->{status} $res->{reason}"}my$z=IO::Uncompress::Gunzip->new(\$res->{content})or die "gunzip failed: $GunzipError";return$z}sub run {my$self=shift;my$modules=App::ccu::CPANfile->load($self->cpanfile,$self->snapshot,);my%updated_modules;for my$module_name (sort keys %$modules){my$module=$modules->{$module_name};next if$self->phase && $self->phase ne $module->{phase};next if$self->relationship && $self->relationship ne $module->{relationship};my$release=$self->find_release($module->{dist},$module_name);next unless$release;next if$release->dist eq 'perl';if ($release && $release->version ne $module->{version}){$updated_modules{$module_name}=$release->version;$self->module_details->show($module,$release)}}if (%updated_modules){my$writer=App::CpanfileSlipstop::Writer->new(cpanfile_path=>$self->cpanfile,);$writer->set_versions(sub {my$module=shift;return$updated_modules{$module}},sub {})}}sub find_release {my ($self,$dist,$module)=@_;if (defined$dist){my$release=$self->releases->{$dist};if ($release){return$release->{distinfo}}}my$releases=$self->releases;for my$release (values %$releases){for my$m (@{$release->{modules}}){if ($m eq $module){return$release->{distinfo}}}}return undef}1;
APP_CCU

$fatpacked{"App/ccu/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_CLI';
  package App::ccu::CLI;use strict;use warnings;use Getopt::Long ();use App::ccu;binmode STDOUT,':encoding(utf8)';sub new {bless {},shift}sub run {my ($self,@argv)=@_;my%opt=(cpanfile=>'cpanfile',snapshot=>'cpanfile.snapshot',phase=>undef,relationship=>undef,interactive=>0,);my$exitcode;my$p=Getopt::Long::Parser->new(config=>['gnu_getopt'],);my$parsed=$p->getoptionsfromarray(\@argv,'cpanfile=s'=>\$opt{cpanfile},'snapshot=s'=>\$opt{snapshot},'phase'=>\$opt{phase},'relationship'=>\$opt{relationship},'interactive'=>\$opt{interactive},'version'=>sub {$exitcode=0;version()},'help'=>sub {$exitcode=0;usage()},);if (!$parsed){usage(1);$exitcode=1}return$exitcode if defined$exitcode;my$app=App::ccu->new(%opt);$app->run;return 0}sub usage {my$fh=$_[0]? *STDERR : *STDOUT;print$fh "    cpanfile-check-updates [--cpanfile file] [--snapshot file] [--interactive] [--version] [--help]\n"}sub version {my$fh=$_[0]? *STDERR : *STDOUT;print$fh "App::ccu version $App::ccu::VERSION\n";if (defined$App::ccu::GIT_DESCRIBE){print$fh "This is a self-contained version, $App::ccu::GIT_DESCRIBE ($App::ccu::GIT_URL)\n"}}1;
APP_CCU_CLI

$fatpacked{"App/ccu/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_CPANFILE';
  package App::ccu::CPANfile;use strict;use warnings;use Carton::Snapshot;use CPAN::DistnameInfo;use Module::CPANfile;sub load {my ($class,$cpanfile,$snapshot)=@_;$cpanfile=Module::CPANfile->load($cpanfile);$snapshot=Carton::Snapshot->new(path=>$snapshot);$snapshot->load;my%modules;my$prereqs=$cpanfile->prereqs->as_string_hash;for my$phase (keys %$prereqs){for my$relationship (keys %{$prereqs->{$phase}}){for my$module (keys %{$prereqs->{$phase}{$relationship}}){next if$module eq 'perl';my$dist=$snapshot->find_or_core($module)or next;if ($dist->is_core){$modules{$module}={module=>$module,dist=>undef,version=>$dist->version_for,author_release=>undef,phase=>$phase,relationship=>$relationship,}}else {my$di=CPAN::DistnameInfo->new($dist->pathname);$modules{$module}={module=>$module,dist=>$di->dist,version=>$di->version,author_release=>$di->cpanid .'/' .$di->distvname,phase=>$phase,relationship=>$relationship,}}}}}return \%modules}1;
APP_CCU_CPANFILE

$fatpacked{"App/ccu/ChangesParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_CHANGESPARSER';
  package App::ccu::ChangesParser;use strict;use warnings;use CPAN::Changes;my%months;my$m=0;$months{$_}=++$m for qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);sub load {my ($class,$file)=@_;open my$fh,'<',$file or die "can't open $file: $!";my$content=do {local $/;<$fh>};$class->parse($content)}sub parse {my ($class,$string)=@_;my@lines=split /\r\n?|\n/,$string;my$preamble=q{};my@releases;my$release;my@indents;for my$linenr (0 .. $#lines){my$line=$lines[$linenr];if ($line =~ /^(?:version\s+)?($version::LAX(?:-TRIAL)?)(\s+(.*))?$/i){my$version=$1;my$note=$3;if ($note){$note =~ s/^[\W\s]+//;$note =~ s/\s+$//}my$date;if ($note){if ($note =~ s{^($CPAN::Changes::UNKNOWN_VALS)}{}i){$date=$1}elsif ($note =~ s{^\D{3}\s+(\D{3})\s+(\d{1,2})\s+([\d:]+)?\D*(\d{4})}{}){if ($3){$date=sprintf('%d-%02d-%02dT%sZ',$4,$months{$1},$2,$3)}else {$date =sprintf('%d-%02d-%02d',$4,$months{$1},$2)}}elsif ($note =~ s{^\D{3}, (\d{1,2}) (\D{3}) (\d{4}) (\d\d:\d\d:\d\d) ([+-])(\d{2})(\d{2})}{}){$date=sprintf('%d-%02d-%02dT%s%s%02d:%02d',$3,$months{$2},$1,$4,$5,$6,$7)}elsif ($note =~ s{^(\d{4}-\d\d-\d\d)\s+(\d\d:\d\d(?::\d\d)?)(?:\s+[A-Za-z]+/[A-Za-z_-]+)}{}){$date=sprintf('%sT%sZ',$1,$2)}elsif ($note =~ m{^($CPAN::Changes::W3CDTF_REGEX)}){$date=$1;$date =~ s{ }{T};$date .= 'Z' if length($date)==16 || length($date)==19 || $date =~ m{\.\d+$}}$note =~ s{^\s+}{}}$release={version=>$version,date=>$date,note=>$note,entries=>[],line=>$linenr,};push@releases,$release;@indents=($release)}elsif (@indents){if ($line =~ /^[-_*+~#=\s]*$/){$indents[-1]{done}++ if@indents > 1;next}$line =~ s/\s+$//;$line =~ s/^(\s*)//;my$indent=1 + length _expand_tab($1);my$change;my$done;my$nest;if ($line =~ /^\[\s*([^\[\]]*)\]$/){$done=1;$nest=1;$change=$1;$change =~ s/\s+$//}elsif ($line =~ /^[-*+=#]+\s+(.*)/){$change=$1}else {$change=$line;if ($indent >= $#indents && $indents[-1]{text}&&!$indents[-1]{done}){$indents[-1]{text}.= " $change";next}}my$group;my$nested;if (!$nest && $indents[$indent]{nested}){$nested=$group=$indents[$indent]{nested}}elsif (!$nest && $indents[$indent]{nest}){$nested=$group=$indents[$indent]}else {($group)=grep {defined}reverse@indents[0 .. $indent - 1 ]}my$entry={text=>$change,line=>$linenr,done=>$done,nest=>$nest,nested=>$nested,};push @{$group->{entries}||= []},$entry;if ($indent <= $#indents){$#indents=$indent}$indents[$indent]=$entry}elsif (@releases){}else {$preamble .= "$line\n"}}$preamble =~ s/^\s*\n//;$preamble =~ s/\s+$//;my@entries=@releases;while (my$entry=shift@entries){push@entries,@{$entry->{entries}}if$entry->{entries};delete @{$entry}{qw(done nest nested)}}return {preamble=>$preamble,releases=>[reverse@releases ],}}sub _expand_tab {my$string="$_[0]";$string =~ s/([^\t]*)\t/$1 . (" " x (8 - (length $1) % 8))/eg;return$string}my$rt_cpan_base='https://rt.cpan.org/Ticket/Display.html?id=';my$rt_perl_base='https://rt.perl.org/Ticket/Display.html?id=';my$sep=qr{[-:]|\s*[#]?};sub _link_issues {my ($class,$change,$gh_base,$rt_base)=@_;$change =~ s{(
          (?:
          (
          \b(?:blead)?perl\s+(?:RT|bug)$sep
          |
          (?<=\[)(?:blead)?perl\s+$sep
          |
          \brt\.perl\.org\s+\#
          |
          \bP5\#
          )
          |
          (
          \bCPAN\s+(?:RT|bug)$sep
          |
          (?<=\[)CPAN\s+$sep
          |
          \brt\.cpan\.org\s+\#
          )
          |
          (\bRT$sep)
          |
          (\b(?:GH|PR)$sep)
          |
          ((?:\bbug\s*)?\#)
          )
          (\d+)\b
          )}{
              my $text = $1;
          my $issue = $7;
          my $base
              = $2 ? $rt_perl_base
              : $3 ? $rt_cpan_base
              : $4 ? $rt_base
              : $5 ? $gh_base
              # this form is non-specific, so guess based on issue number
              : ($gh_base && $issue < 10000)
              ? $gh_base
              : $rt_base;
          $base ? qq{[$text]($base$issue)} : $text;
      }xgei;return$change}sub filter_release_changes {my ($class,$changelog,$release)=@_;my$gh_base;my$rt_base;my$bt=$release->{resources}{bugtracker}&& $release->{resources}{bugtracker}{web};my$repo=$release->{resources}{repository};$repo=ref$repo ? $repo->{url}: $repo;if ($bt && $bt =~ m|^https?://github\.com/|){$gh_base=$bt;$gh_base =~ s{/*$}{/}}elsif ($repo && $repo =~ m|\bgithub\.com/([^/]+/[^/]+)|){my$name=$1;$name =~ s/\.git$//;$gh_base="https://github.com/$name/issues/"}if ($bt && $bt =~ m|\brt\.perl\.org\b|){$rt_base=$rt_perl_base}else {$rt_base=$rt_cpan_base}my@entries_list=$changelog->{entries};while (my$entries=shift@entries_list){for my$entry (@$entries){for ($entry->{text}){s/&/&amp;/g;s/</&lt;/g;s/>/&gt;/g;s/"/&quot;/g}$entry->{text}=$class->_link_issues($entry->{text},$gh_base,$rt_base);push@entries_list,$entry->{entries}if$entry->{entries}}}return$changelog}1;
APP_CCU_CHANGESPARSER

$fatpacked{"App/ccu/MetaCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_METACPAN';
  package App::ccu::MetaCPAN;use strict;use warnings;use HTTP::Tinyish;use JSON::PP qw/decode_json encode_json/;use Class::Tiny {http=>sub {HTTP::Tinyish->new},};sub author_release {my ($self,$module,$version)=@_;my$res=$self->http->post("https://fastapi.metacpan.org/v1/module/_search?size=1",{content=>encode_json({_source=>[qw/author release/],query=>{bool=>{must=>[{term=>{'module.name'=>$module}},{term=>{version=>$version}},],},},}),});unless ($res->{success}){die "$res->{status} $res->{reason}"}my$r=decode_json($res->{content});if ($r->{hits}{total}> 0){my$m=$r->{hits}{hits}[0]{_source};return$m->{author}.'/' .$m->{release}}return}sub release {my ($self,$author_release)=@_;my$res=$self->http->get("https://fastapi.metacpan.org/v1/release/$author_release");unless ($res->{success}){die "$res->{status} $res->{reason}"}return decode_json($res->{content})->{release}}sub changes {my ($self,$author_release)=@_;my$res=$self->http->get("https://fastapi.metacpan.org/v1/changes/$author_release");unless ($res->{success}){die "$res->{status} $res->{reason}"}return decode_json($res->{content})->{content}}sub diff_file_url {my ($self,$source_author_release,$target_author_release)=@_;my$metacpan_diff_uri=URI->new('https://metacpan.org/diff/file');$metacpan_diff_uri->query_form(source=>$source_author_release,target=>$target_author_release,);return$metacpan_diff_uri->as_string}1;
APP_CCU_METACPAN

$fatpacked{"App/ccu/ModuleDetails.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_MODULEDETAILS';
  package App::ccu::ModuleDetails;use strict;use warnings;use CPAN::Audit::DB;use CPAN::Audit::Version;use URI;use App::ccu::ChangesParser;use App::ccu::MetaCPAN;use Class::Tiny {audit_db=>sub {CPAN::Audit::DB->db},audit_version=>sub {CPAN::Audit::Version->new},metacpan=>sub {App::ccu::MetaCPAN->new},};sub show {my ($self,$module,$release)=@_;my$source_author_release=$module->{author_release}|| $self->metacpan->author_release($module->{module},$module->{version});my$target_author_release=$release->cpanid .'/' .$release->distvname;printf "## %s\n",$module->{module};printf "[`%s` -> `%s`](%s)\n",$module->{version},$release->version,$self->metacpan->diff_file_url($source_author_release,$target_author_release);$self->print_advisory($release->dist,$module->{version});$self->print_changes($target_author_release,$module->{version},$release->version)}sub print_advisory {my ($self,$dist,$version)=@_;my$db=$self->audit_db->{dists}{$dist}or return;my@affected_advisories=grep {$self->audit_version->in_range($version,$_->{affected_versions})}@{$db->{advisories}};return unless@affected_advisories;printf "### :warning: Affected security updates\n";for my$advisory (@affected_advisories){my$description=$advisory->{description};$description =~ s/\s+$//;$description =~ s/\s+/ /g;my$cves='';if (exists$advisory->{cves}){$cves=join(', ',@{$advisory->{cves}}).': '}printf "- %s%s\n",$cves,$description;if (exists$advisory->{references}){printf "  - %s\n",$_ for @{$advisory->{references}}}}}sub print_changes {my ($self,$author_release,$version,$latest_version)=@_;my$release=$self->metacpan->release($author_release);my$changes_text=$self->metacpan->changes($author_release);my$changes=eval {App::ccu::ChangesParser->parse($changes_text)}or return;my@changelogs;my$skip=1;for my$changelog (reverse @{$changes->{releases}}){my$v=$changelog->{version};if ($v eq $latest_version){$skip=0}elsif ($v eq $version){last}unless ($skip){push@changelogs,App::ccu::ChangesParser->filter_release_changes($changelog,$release)}}return unless@changelogs;printf "### Changes\n";for my$changelog (@changelogs){printf "#### %s: %s\n",$changelog->{version},$changelog->{date}|| '';for my$entry (@{$changelog->{entries}}){$self->_print_entry($entry,0)}}}sub _print_entry {my ($self,$entry,$level)=@_;printf "%s- %s\n",'  ' x $level,$entry->{text};for my$e (@{$entry->{entries}}){$self->_print_entry($e,$level + 1)}}1;
APP_CCU_MODULEDETAILS

$fatpacked{"CPAN/Audit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT';
  package CPAN::Audit;use 5.008001;use strict;use warnings;use version;use CPAN::Audit::Installed;use CPAN::Audit::Discover;use CPAN::Audit::Version;use CPAN::Audit::Query;use CPAN::Audit::DB;use Module::CoreList;our$VERSION="0.15";sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{ascii}=$params{ascii};$self->{verbose}=$params{verbose};$self->{quiet}=$params{quiet};$self->{no_color}=$params{no_color};$self->{no_corelist}=$params{no_corelist};$self->{interactive}=$params{interactive};if (!$self->{interactive}){$self->{ascii}=1;$self->{no_color}=1}$self->{db}=CPAN::Audit::DB->db;$self->{query}=CPAN::Audit::Query->new(db=>$self->{db});$self->{discover}=CPAN::Audit::Discover->new(db=>$self->{db});return$self}sub command {my$self=shift;my ($command,@args)=@_;my%dists;if (!$self->{no_corelist}&& ($command eq 'dependencies' || $command eq 'deps' || $command eq 'installed')){if (my$core=$Module::CoreList::version{$]}){while (my ($mod,$ver)=each %$core){my$dist=$self->{db}{module2dist}{$mod}or next;$dists{$dist}=$ver if version->parse($ver)> $dists{$dist}}}}if ($command eq 'module'){my ($module,$version_range)=@args;$self->fatal("Usage: module <module> [version-range]")unless$module;my$distname=$self->{db}->{module2dist}->{$module};if (!$distname){$self->message("__GREEN__Module '$module' is not in database");return 0}$dists{$distname}=$version_range || ''}elsif ($command eq 'release' || $command eq 'dist'){my ($distname,$version_range)=@args;$self->fatal("Usage: dist|release <module> [version-range]")unless$distname;if (!$self->{db}->{dists}->{$distname}){$self->message("__GREEN__Distribution '$distname' is not in database");return 0}$dists{$distname}=$version_range || ''}elsif ($command eq 'show'){my ($advisory_id)=@args;$self->fatal("Usage: show <advisory-id>")unless$advisory_id;my ($release)=$advisory_id =~ m/^CPANSA-(.*?)-(\d+)-(\d+)$/;$self->fatal("Invalid advisory id")unless$release;my$dist=$self->{db}->{dists}->{$release};$self->fatal("Unknown advisory id")unless$dist;my ($advisory)=grep {$_->{id}eq $advisory_id}@{$dist->{advisories}};$self->fatal("Unknown advisory id")unless$advisory;$self->print_advisory($advisory);return 0}elsif ($command eq 'dependencies' || $command eq 'deps'){my ($path)=@args;$path='.' unless defined$path;$self->fatal("Usage: deps <path>")unless -d $path;my@deps=$self->{discover}->discover($path);$self->message('Discovered %d dependencies',scalar(@deps));for my$dep (@deps){my$dist=$dep->{dist}|| $self->{db}->{module2dist}->{$dep->{module}};next unless$dist;$dists{$dist}=$dep->{version}}}elsif ($command eq 'installed'){$self->message_info('Collecting all installed modules. This can take a while...');my@deps=CPAN::Audit::Installed->new(db=>$self->{db},$self->{verbose}? (cb=>sub {my ($info)=@_;$self->message('%s: %s-%s',$info->{path},$info->{distname},$info->{version})}): ())->find(@ARGV);for my$dep (@deps){my$dist=$dep->{dist}|| $self->{db}->{module2dist}->{$dep->{module}};next unless$dist;$dists{$dep->{dist}}=$dep->{version}}}else {$self->fatal("Error: unknown command: $command. See -h")}my$total_advisories=0;if (%dists){my$query=$self->{query};for my$distname (sort keys%dists){my$version_range=$dists{$distname};my@advisories=$query->advisories_for($distname,$version_range);$version_range='Any' if$version_range eq '' || $version_range eq '0';if (@advisories){$self->message('__RED__%s (requires %s) has %d advisories__RESET__',$distname,$version_range,scalar(@advisories));for my$advisory (@advisories){$self->print_advisory($advisory)}}$total_advisories += @advisories}}if ($total_advisories){$self->message('__RED__Total advisories found: %d__RESET__',$total_advisories);return$total_advisories}else {$self->message_info('__GREEN__No advisories found__RESET__');return 0}}sub message_info {my$self=shift;return if$self->{quiet};$self->message(@_)}sub message {my$self=shift;$self->_print(*STDOUT,@_)}sub fatal {my$self=shift;my ($msg,@args)=@_;$self->_print(*STDERR,"Error: $msg",@args);exit 255}sub print_advisory {my$self=shift;my ($advisory)=@_;$self->message("  __BOLD__* $advisory->{id}");print "    $advisory->{description}\n";if ($advisory->{affected_versions}){print "    Affected range: $advisory->{affected_versions}\n"}if ($advisory->{fixed_versions}){print "    Fixed range: $advisory->{fixed_versions}\n"}if ($advisory->{cves}){print "\n    CVEs: ";print join ', ',@{$advisory->{cves}};print "\n"}if ($advisory->{references}){print "\n    References:\n";for my$reference (@{$advisory->{references}|| []}){print "    $reference\n"}}print "\n"}sub _print {my$self=shift;my ($fh,$format,@params)=@_;my$msg=@params ? (sprintf($format,@params)): ($format);if ($self->{no_color}){$msg =~ s{__BOLD__}{}g;$msg =~ s{__GREEN__}{}g;$msg =~ s{__RED__}{}g;$msg =~ s{__RESET__}{}g}else {$msg =~ s{__BOLD__}{\e[39;1m}g;$msg =~ s{__GREEN__}{\e[32m}g;$msg =~ s{__RED__}{\e[31m}g;$msg =~ s{__RESET__}{\e[0m}g;$msg .= "\e[0m"}print$fh "$msg\n"}1;
CPAN_AUDIT

$fatpacked{"CPAN/Audit/DB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_DB';
  package CPAN::Audit::DB;use strict;use warnings;sub db {{'dists'=>{'Apache-AuthCAS'=>{'advisories'=>[{'affected_versions'=>'<0.5','cves'=>['CVE-2007-6342' ],'description'=>'A tainted cookie could be sent by a malicious user and it would be used in an SQL query without protection against SQL injection.
  ','distribution'=>'Apache-AuthCAS','fixed_versions'=>'>=0.5','id'=>'CPANSA-Apache-AuthCAS-2007-01','references'=>['https://metacpan.org/changes/distribution/Apache-AuthCAS','https://cxsecurity.com/issue/WLB-2007120031' ],'reported'=>'2007-12-13','severity'=>'high' }],'main_module'=>'Apache::AuthCAS','versions'=>[{'date'=>'2004-09-15T19:17:43','version'=>'0.1' },{'date'=>'2004-09-15T20:11:40','version'=>'0.2' },{'date'=>'2004-10-05T22:51:50','version'=>'0.3' },{'date'=>'2004-10-13T00:45:52','version'=>'0.4' },{'date'=>'2008-03-23T23:03:16','version'=>'0.5' }]},'Apache-SessionX'=>{'advisories'=>[{'affected_versions'=>'<2.01','description'=>'Problem in session_id validation, which allows createtion of session with invalid ids.
  ','distribution'=>'Apache-SessionX','fixed_versions'=>'>=2.01','id'=>'CPANSA-Apache-SessionX-2005-01','references'=>['https://metacpan.org/changes/distribution/Apache-SessionX' ],'reported'=>'2005-11-15' }],'main_module'=>'Apache::SessionX','versions'=>[{'date'=>'2001-11-20T15:36:53','version'=>'2.00' },{'date'=>'2003-03-02T14:18:57','version'=>'2.00' },{'date'=>'2005-11-15T05:21:49','version'=>'2.01' }]},'App-Github-Email'=>{'advisories'=>[{'affected_versions'=>'<0.3.3','cves'=>['CVE-2015-7686' ],'description'=>'Insecure dependency on Email::Address.
  ','distribution'=>'App-Github-Email','fixed_versions'=>'>=0.3.3','id'=>'CPANSA-App-Github-Email-2018-01','references'=>['https://metacpan.org/changes/distribution/App-Github-Email','https://github.com/faraco/App-Github-Email/commit/b7f052280d1c8ae97bdefc106ca3cbba4aea7213' ],'reported'=>'2018-01-20' }],'main_module'=>'App::Github::Email','versions'=>[{'date'=>'2017-01-16T08:03:02','version'=>'0.0.1' },{'date'=>'2017-01-16T12:56:51','version'=>'0.0.2' },{'date'=>'2017-01-16T17:38:16','version'=>'0.0.3' },{'date'=>'2017-03-11T10:45:23','version'=>'0.0.4' },{'date'=>'2017-04-05T11:19:02','version'=>'0.0.5' },{'date'=>'2017-04-15T17:35:18','version'=>'0.0.6' },{'date'=>'2017-05-19T05:05:24','version'=>'0.0.7' },{'date'=>'2017-12-18T14:11:19','version'=>'0.1.0' },{'date'=>'2017-12-21T08:24:12','version'=>'0.1.1' },{'date'=>'2018-01-15T03:18:05','version'=>'0.2.0' },{'date'=>'2018-01-20T12:55:34','version'=>'0.2.1' },{'date'=>'2018-08-30T16:07:18','version'=>'0.3.1' },{'date'=>'2018-08-30T16:13:54','version'=>'0.3.2' },{'date'=>'2018-08-31T03:49:31','version'=>'0.3.3' }]},'Archive-Tar'=>{'advisories'=>[{'affected_versions'=>'<2.28','cves'=>['CVE-2018-12015' ],'description'=>'In Perl through 5.26.2, the Archive::Tar module allows remote attackers to bypass a directory-traversal protection mechanism, and overwrite arbitrary files, via an archive file containing a symlink and a regular file with the same name.
  ','distribution'=>'Archive-Tar','id'=>'CPANSA-Archive-Tar-2018-01','references'=>['https://security-tracker.debian.org/tracker/CVE-2018-12015','https://github.com/jib/archive-tar-new/commit/ae65651eab053fc6dc4590dbb863a268215c1fc5' ],'reported'=>'2018-06-12','severity'=>'medium' }],'main_module'=>'Archive::Tar','versions'=>[{'date'=>'1998-02-02T06:13:59','version'=>'0.071' },{'date'=>'1998-04-10T17:07:35','version'=>'0.072' },{'date'=>'1998-07-30T00:56:03','version'=>'0.08' },{'date'=>'1999-01-10T02:22:23','version'=>'0.20' },{'date'=>'1999-02-02T19:01:41','version'=>'0.21' },{'date'=>'2000-04-28T00:37:46','version'=>'0.22' },{'date'=>'2003-01-21T23:07:30','version'=>'0.23' },{'date'=>'2003-03-18T17:08:50','version'=>'0.99_01' },{'date'=>'2003-03-26T14:57:35','version'=>'0.99_02' },{'date'=>'2003-04-28T16:01:24','version'=>'0.99_03' },{'date'=>'2003-04-28T16:57:58','version'=>'0.99_04' },{'date'=>'2003-04-30T12:52:19','version'=>'0.99_05' },{'date'=>'2003-05-05T12:06:35','version'=>'0.99_06' },{'date'=>'2003-05-31T09:27:33','version'=>'1.00' },{'date'=>'2003-06-08T10:46:56','version'=>'1.01' },{'date'=>'2003-06-12T09:47:58','version'=>'1.02' },{'date'=>'2003-06-26T12:52:19','version'=>'1.03' },{'date'=>'2003-07-27T17:07:50','version'=>'1.04' },{'date'=>'2003-08-25T13:38:44','version'=>'1.05' },{'date'=>'2003-10-15T14:35:12','version'=>'1.06' },{'date'=>'2003-10-17T11:42:14','version'=>'1.07' },{'date'=>'2004-01-05T12:59:23','version'=>'1.08' },{'date'=>'2004-05-22T12:32:02','version'=>'1.09' },{'date'=>'2004-06-11T19:24:06','version'=>'1.10' },{'date'=>'2004-11-09T16:12:40','version'=>'1.20' },{'date'=>'2004-11-10T16:04:13','version'=>'1.21' },{'date'=>'2004-11-21T10:09:52','version'=>'1.22' },{'date'=>'2004-12-03T15:53:06','version'=>'1.23' },{'date'=>'2005-05-03T13:11:19','version'=>'1.24' },{'date'=>'2005-08-20T10:14:40','version'=>'1.25' },{'date'=>'2005-08-22T09:29:53','version'=>'1.26' },{'date'=>'2006-01-19T13:31:53','version'=>'1.28' },{'date'=>'2006-03-03T13:56:20','version'=>'1.29' },{'date'=>'2006-08-02T15:00:41','version'=>'1.30' },{'date'=>'2007-05-18T12:18:49','version'=>'1.31' },{'date'=>'2007-05-25T09:32:48','version'=>'1.32' },{'date'=>'2007-08-15T14:20:33','version'=>'1.34' },{'date'=>'2007-09-16T09:13:21','version'=>'1.36' },{'date'=>'2007-11-11T11:59:00','version'=>'1.37_01' },{'date'=>'2007-12-24T11:02:07','version'=>'1.38' },{'date'=>'2008-08-22T16:33:49','version'=>'1.39_01' },{'date'=>'2008-08-25T03:56:58','version'=>'1.39_02' },{'date'=>'2008-08-25T22:07:56','version'=>'1.39_03' },{'date'=>'2008-09-08T12:14:37','version'=>'1.39_04' },{'date'=>'2008-10-13T13:42:10','version'=>'1.40' },{'date'=>'2008-12-13T17:10:15','version'=>'1.42' },{'date'=>'2009-01-19T17:08:08','version'=>'1.44' },{'date'=>'2009-03-05T16:10:06','version'=>'1.46' },{'date'=>'2009-04-20T17:07:30','version'=>'1.48' },{'date'=>'2009-06-12T12:01:54','version'=>'1.50' },{'date'=>'2009-06-13T11:29:50','version'=>'1.52' },{'date'=>'2009-09-10T12:13:03','version'=>'1.54' },{'date'=>'2010-02-03T14:40:15','version'=>'1.56' },{'date'=>'2010-02-17T21:47:16','version'=>'1.58' },{'date'=>'2010-04-23T14:12:31','version'=>'1.60' },{'date'=>'2010-06-28T21:02:59','version'=>'1.62' },{'date'=>'2010-07-09T11:04:45','version'=>'1.64' },{'date'=>'2010-07-26T08:44:00','version'=>'1.66' },{'date'=>'2010-08-17T16:06:19','version'=>'1.68' },{'date'=>'2010-11-15T22:02:53','version'=>'1.70' },{'date'=>'2010-11-18T19:22:01','version'=>'1.72' },{'date'=>'2010-12-18T21:19:51','version'=>'1.74' },{'date'=>'2011-01-07T22:27:40','version'=>'1.76' },{'date'=>'2011-09-08T22:13:33','version'=>'1.78' },{'date'=>'2011-10-13T10:25:39','version'=>'1.80' },{'date'=>'2011-11-21T12:14:43','version'=>'1.82' },{'date'=>'2012-03-03T00:00:05','version'=>'1.84' },{'date'=>'2012-05-24T11:38:09','version'=>'1.86' },{'date'=>'2012-06-01T11:06:25','version'=>'1.88' },{'date'=>'2012-09-05T18:19:00','version'=>'1.90' },{'date'=>'2013-06-18T15:13:27','version'=>'1.92' },{'date'=>'2013-10-22T14:28:22','version'=>'0.93_01' },{'date'=>'2013-10-22T14:36:08','version'=>'1.93_02' },{'date'=>'2013-10-24T18:02:48','version'=>'1.94' },{'date'=>'2013-10-24T19:10:34','version'=>'1.96' },{'date'=>'2014-06-14T17:12:02','version'=>'1.98' },{'date'=>'2014-06-15T14:59:24','version'=>'2.00' },{'date'=>'2014-09-14T18:03:23','version'=>'2.02' },{'date'=>'2014-12-14T20:13:33','version'=>'2.04' },{'date'=>'2016-04-24T14:05:11','version'=>'2.06' },{'date'=>'2016-05-12T08:57:35','version'=>'2.08' },{'date'=>'2016-07-27T12:40:29','version'=>'2.10' },{'date'=>'2016-10-16T11:27:58','version'=>'2.12' },{'date'=>'2016-10-20T12:38:57','version'=>'2.14' },{'date'=>'2016-11-01T19:19:36','version'=>'2.16' },{'date'=>'2016-11-07T13:36:15','version'=>'2.18' },{'date'=>'2016-12-15T10:54:40','version'=>'2.20' },{'date'=>'2016-12-16T09:46:28','version'=>'2.22' },{'date'=>'2016-12-16T15:27:38','version'=>'2.24' },{'date'=>'2017-05-12T12:46:05','version'=>'2.26' },{'date'=>'2018-06-08T10:57:04','version'=>'2.28' },{'date'=>'2018-06-19T11:55:28','version'=>'2.30' },{'date'=>'2018-09-13T07:17:10','version'=>'2.32' }]},'Archive-Zip'=>{'advisories'=>[{'affected_versions'=>'<1.61','cves'=>['CVE-2018-10860' ],'description'=>'perl-archive-zip is vulnerable to a directory traversal in Archive::Zip. It was found that the Archive::Zip module did not properly sanitize paths while extracting zip files. An attacker able to provide a specially crafted archive for processing could use this flaw to write or overwrite arbitrary files in the context of the perl interpreter.
  ','distribution'=>'Archive-Zip','id'=>'CPANSA-Archive-Zip-2018-01','references'=>['https://security-tracker.debian.org/tracker/CVE-2018-10860','https://github.com/redhotpenguin/perl-Archive-Zip/pull/33' ],'reported'=>'2018-06-28','severity'=>'medium' }],'main_module'=>'Archive::Zip','versions'=>[{'date'=>'2000-03-22T00:10:21','version'=>'0.06' },{'date'=>'2000-03-29T17:03:46','version'=>'0.07' },{'date'=>'2000-06-16T16:48:41','version'=>'0.09' },{'date'=>'2000-08-08T20:56:31','version'=>'0.10' },{'date'=>'2001-01-17T08:06:58','version'=>'0.11' },{'date'=>'2002-04-22T15:32:49','version'=>'1.00' },{'date'=>'2002-05-11T02:45:20','version'=>'1.01' },{'date'=>'2002-08-24T00:19:19','version'=>'1.02' },{'date'=>'2002-09-03T04:40:33','version'=>'1.03' },{'date'=>'2002-09-11T15:17:37','version'=>'1.04' },{'date'=>'2002-09-11T19:35:26','version'=>'1.05' },{'date'=>'2003-07-17T18:18:14','version'=>'1.06' },{'date'=>'2003-10-20T13:59:00','version'=>'1.07' },{'date'=>'2003-10-21T17:04:03','version'=>'1.08' },{'date'=>'2003-11-27T18:02:03','version'=>'1.09' },{'date'=>'2004-03-25T14:39:05','version'=>'1.10' },{'date'=>'2004-07-05T23:25:19','version'=>'1_11' },{'date'=>'2004-07-08T17:31:27','version'=>'1.11' },{'date'=>'2004-07-08T19:14:46','version'=>'1.12' },{'date'=>'2004-07-27T22:50:39','version'=>'1.12_02' },{'date'=>'2004-07-29T15:15:49','version'=>'1.12_03' },{'date'=>'2004-08-23T15:39:23','version'=>'1.13' },{'date'=>'2004-10-21T15:28:12','version'=>'1.14' },{'date'=>'2005-03-10T04:34:04','version'=>'1.15_01' },{'date'=>'2005-03-12T15:29:48','version'=>'1.15_02' },{'date'=>'2005-06-22T18:29:34','version'=>'1.15' },{'date'=>'2005-07-04T17:55:17','version'=>'1.16' },{'date'=>'2006-04-30T03:53:15','version'=>'1.17_01' },{'date'=>'2006-05-07T02:49:30','version'=>'1.17_02' },{'date'=>'2006-09-15T15:56:10','version'=>'1.17_03' },{'date'=>'2006-10-24T15:06:32','version'=>'1.17_05' },{'date'=>'2006-10-25T12:24:52','version'=>'1.18' },{'date'=>'2007-06-05T01:50:42','version'=>'1.20' },{'date'=>'2007-11-01T02:59:20','version'=>'1.21' },{'date'=>'2007-11-02T01:52:47','version'=>'1.22' },{'date'=>'2007-11-07T13:04:41','version'=>'1.23' },{'date'=>'2008-08-23T23:35:50','version'=>'1.24' },{'date'=>'2008-10-10T05:28:17','version'=>'1.25' },{'date'=>'2008-10-12T14:13:05','version'=>'1.26' },{'date'=>'2008-12-16T13:23:21','version'=>'1.27_01' },{'date'=>'2009-06-16T10:09:03','version'=>'1.28' },{'date'=>'2009-06-29T13:27:17','version'=>'1.29' },{'date'=>'2009-06-30T14:13:29','version'=>'1.30' },{'date'=>'2010-03-05T05:11:20','version'=>'1.31_01' },{'date'=>'2011-03-08T15:52:02','version'=>'1.31_02' },{'date'=>'2011-08-23T03:42:14','version'=>'1.31_03' },{'date'=>'2012-01-23T06:28:16','version'=>'1.31_04' },{'date'=>'2013-11-09T00:05:06','version'=>'1.32' },{'date'=>'2013-11-10T03:50:45','version'=>'1.33' },{'date'=>'2013-12-02T22:16:54','version'=>'1.34' },{'date'=>'2013-12-30T19:16:52','version'=>'1.35' },{'date'=>'2013-12-30T22:12:14','version'=>'1.36' },{'date'=>'2014-01-13T18:32:19','version'=>'1.37' },{'date'=>'2014-09-02T23:23:11','version'=>'1.38' },{'date'=>'2014-10-22T04:17:15','version'=>'1.39' },{'date'=>'2015-01-05T05:58:46','version'=>'1.40' },{'date'=>'2015-01-10T02:47:42','version'=>'1.41' },{'date'=>'2015-01-12T00:46:36','version'=>'1.42' },{'date'=>'2015-01-15T06:37:32','version'=>'1.43' },{'date'=>'2015-01-24T06:12:21','version'=>'1.44' },{'date'=>'2015-01-27T07:51:17','version'=>'1.45' },{'date'=>'2015-03-25T05:19:23','version'=>'1.46' },{'date'=>'2015-06-17T18:26:02','version'=>'1.47' },{'date'=>'2015-06-18T21:13:37','version'=>'1.48' },{'date'=>'2015-07-31T19:01:40','version'=>'1.49' },{'date'=>'2015-08-26T00:11:35','version'=>'1.50' },{'date'=>'2015-09-22T06:03:54','version'=>'1.51' },{'date'=>'2015-09-23T17:43:44','version'=>'1.53' },{'date'=>'2015-12-04T19:36:41','version'=>'1.55' },{'date'=>'2015-12-17T18:29:06','version'=>'1.56' },{'date'=>'2016-04-01T18:06:36','version'=>'1.57' },{'date'=>'2016-08-02T17:50:20','version'=>'1.58' },{'date'=>'2016-08-11T20:09:16','version'=>'1.59' },{'date'=>'2017-12-19T18:44:16','version'=>'1.60' },{'date'=>'2018-08-19T03:35:10','version'=>'1.61' },{'date'=>'2018-08-20T03:29:01','version'=>'1.62' },{'date'=>'2018-08-22T15:42:15','version'=>'1.63' },{'date'=>'2018-09-12T15:50:29','version'=>'1.64' }]},'CGI'=>{'advisories'=>[{'affected_versions'=>'<3.63','description'=>'CR escaping for Set-Cookie and P3P headers, a potential for newline injection.
  ','distribution'=>'CGI','fixed_versions'=>'>=3.63','id'=>'CPANSA-CGI-2012-01','reported'=>'2012-11-12' },{'affected_versions'=>'<3.56','cves'=>['CVE-2011-2766' ],'description'=>'Usage of deprecated FCGI.pm API.
  ','distribution'=>'CGI','fixed_versions'=>'>=3.56','id'=>'CPANSA-CGI-2011-01','references'=>['https://rt.cpan.org/Public/Bug/Display.html?id=68380','http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-2766' ],'reported'=>'2011-11-08' },{'affected_versions'=>'<3.50','description'=>'Non-random MIME boundary.
  ','distribution'=>'CGI','fixed_versions'=>'>=3.50','id'=>'CPANSA-CGI-2010-02','reported'=>'2010-11-08' },{'affected_versions'=>'<3.49','description'=>'Newlines in headers.
  ','distribution'=>'CGI','fixed_versions'=>'>=3.49','id'=>'CPANSA-CGI-2010-01','reported'=>'2010-02-05' }],'main_module'=>'CGI','versions'=>[{'date'=>'1995-11-25T09:21:00','version'=>'2.10' },{'date'=>'1995-12-28T09:08:00','version'=>'2.13' },{'date'=>'1996-05-22T22:30:00','version'=>'2.20' },{'date'=>'1996-05-31T05:31:00','version'=>'2.21' },{'date'=>'1996-08-07T09:24:00','version'=>'2.22' },{'date'=>'1996-08-14T08:17:00','version'=>'2.23' },{'date'=>'1996-08-21T09:09:00','version'=>'2.24' },{'date'=>'1996-09-10T14:23:00','version'=>'2.25' },{'date'=>'1996-10-22T11:17:00','version'=>'2.26' },{'date'=>'1996-10-24T18:21:00','version'=>'2.27' },{'date'=>'1996-12-02T11:48:00','version'=>'2.28' },{'date'=>'1996-12-09T13:39:00','version'=>'2.29' },{'date'=>'1997-01-02T16:40:00','version'=>'2.30' },{'date'=>'1997-02-15T15:36:00','version'=>'2.31' },{'date'=>'1997-03-25T08:58:00','version'=>'2.32' },{'date'=>'1997-04-04T20:45:00','version'=>'2.33' },{'date'=>'1997-04-10T15:41:00','version'=>'2.34' },{'date'=>'1997-04-20T18:29:00','version'=>'2.35' },{'date'=>'1997-05-09T09:33:00','version'=>'2.36' },{'date'=>'1997-08-29T04:42:00','version'=>'2.37' },{'date'=>'1997-09-15T17:51:00','version'=>'2.37' },{'date'=>'1997-10-01T04:15:00','version'=>'2.37' },{'date'=>'1997-10-12T07:10:00','version'=>'2.37' },{'date'=>'1997-11-23T11:37:00','version'=>'2.37' },{'date'=>'1997-12-20T09:57:00','version'=>'2.37' },{'date'=>'1998-01-16T12:22:00','version'=>'2.37' },{'date'=>'1998-01-19T11:34:00','version'=>'2.37' },{'date'=>'1998-01-26T11:00:00','version'=>'2.37' },{'date'=>'1998-01-29T19:48:00','version'=>'2.37' },{'date'=>'1998-02-02T13:37:00','version'=>'2.37' },{'date'=>'1998-02-05T08:25:00','version'=>'2.37' },{'date'=>'1998-02-09T13:58:00','version'=>'2.37' },{'date'=>'1998-02-16T16:21:00','version'=>'2.37' },{'date'=>'1998-02-23T08:33:00','version'=>'2.37' },{'date'=>'1998-02-24T16:52:00','version'=>'2.37' },{'date'=>'1998-03-13T15:33:00','version'=>'2.37' },{'date'=>'1998-03-22T21:12:00','version'=>'2.38' },{'date'=>'1998-03-24T22:37:08','version'=>'2.39' },{'date'=>'1998-05-20T09:17:00','version'=>'2.40' },{'date'=>'1998-05-28T15:03:00','version'=>'2.41' },{'date'=>'1998-06-09T09:00:00','version'=>'2.42' },{'date'=>'1998-10-14T19:06:31','version'=>'2.43' },{'date'=>'1998-11-24T19:41:41','version'=>'2.44' },{'date'=>'1998-11-26T11:07:27','version'=>'2.45' },{'date'=>'1998-12-06T10:22:46','version'=>'2.46' },{'date'=>'1999-02-18T03:50:16','version'=>'2.47' },{'date'=>'1999-02-19T14:10:25','version'=>'2.48' },{'date'=>'1999-02-23T22:00:33','version'=>'2.49' },{'date'=>'1999-06-08T15:13:15','version'=>'2.52' },{'date'=>'1999-06-09T14:56:06','version'=>'2.53' },{'date'=>'1999-08-09T14:18:33','version'=>'2.54' },{'date'=>'1999-08-31T17:11:00','version'=>'2.55' },{'date'=>'1999-09-13T21:11:51','version'=>'2.56' },{'date'=>'2000-03-23T23:00:12','version'=>'2.58' },{'date'=>'2000-03-24T12:31:52','version'=>'2.59' },{'date'=>'2000-03-27T22:11:34','version'=>'2.60' },{'date'=>'2000-03-28T02:50:18','version'=>'2.61' },{'date'=>'2000-03-28T21:38:03','version'=>'2.62' },{'date'=>'2000-04-10T15:19:54','version'=>'2.63' },{'date'=>'2000-04-11T15:25:13','version'=>'2.64' },{'date'=>'2000-04-11T15:55:40','version'=>'2.65' },{'date'=>'2000-04-12T20:16:46','version'=>'2.66' },{'date'=>'2000-05-16T01:38:08','version'=>'2.67' },{'date'=>'2000-05-18T17:55:55','version'=>'2.68' },{'date'=>'2000-07-28T03:06:11','version'=>'2.69' },{'date'=>'2000-08-04T19:37:27','version'=>'2.70' },{'date'=>'2000-08-13T16:09:25','version'=>'2.71' },{'date'=>'2000-08-20T17:35:50','version'=>'2.72' },{'date'=>'2000-08-24T13:33:37','version'=>'3.' },{'date'=>'2000-09-13T02:55:51','version'=>'2.73' },{'date'=>'2000-09-13T16:35:14','version'=>'2.74' },{'date'=>'2001-02-02T15:43:07','version'=>'2.75' },{'date'=>'2001-02-02T15:50:53','version'=>'2.751' },{'date'=>'2001-02-04T23:49:27','version'=>'2.752' },{'date'=>'2001-03-12T17:00:13','version'=>'2.753' },{'date'=>'2001-06-15T15:33:28','version'=>'3.02' },{'date'=>'2001-06-29T14:47:39','version'=>'3.02_' },{'date'=>'2001-07-05T16:13:55','version'=>'3.03_01' },{'date'=>'2001-07-26T21:29:22','version'=>'2.76' },{'date'=>'2001-08-07T12:33:22','version'=>'2.77' },{'date'=>'2001-09-26T02:26:36','version'=>'2.78' },{'date'=>'2001-12-09T21:39:11','version'=>'2.79' },{'date'=>'2002-01-12T02:47:17','version'=>'2.80' },{'date'=>'2002-04-10T19:39:49','version'=>'2.81' },{'date'=>'2002-09-11T12:27:48','version'=>'2.84' },{'date'=>'2002-09-11T14:01:02','version'=>'2.85' },{'date'=>'2002-09-12T03:58:40','version'=>'2.86' },{'date'=>'2002-10-07T02:00:58','version'=>'2.87' },{'date'=>'2002-10-14T13:58:09','version'=>'2.88' },{'date'=>'2002-10-16T17:50:26','version'=>'2.89' },{'date'=>'2002-11-22T23:03:39','version'=>0 },{'date'=>'2003-02-10T20:11:57','version'=>'2.90' },{'date'=>'2003-02-11T14:15:15','version'=>'2.91' },{'date'=>'2003-04-28T00:44:10','version'=>'2.92' },{'date'=>'2003-04-28T13:37:43','version'=>'2.93' },{'date'=>'2003-06-09T12:15:29','version'=>'2.94' },{'date'=>'2003-06-13T02:35:42','version'=>'2.95' },{'date'=>'2003-06-16T18:42:38','version'=>'2.96' },{'date'=>'2003-06-17T23:32:52','version'=>'2.97' },{'date'=>'2003-07-16T17:06:29','version'=>'2.98' },{'date'=>'2003-08-01T14:43:54','version'=>'2.99' },{'date'=>'2003-08-18T17:51:48','version'=>'3.00' },{'date'=>'2003-12-10T17:05:47','version'=>'3.01' },{'date'=>'2004-01-13T16:34:47','version'=>'3.03' },{'date'=>'2004-01-19T12:44:30','version'=>'3.04' },{'date'=>'2004-04-12T20:39:57','version'=>'3.05' },{'date'=>'2005-03-09T21:06:46','version'=>'3.06' },{'date'=>'2005-03-14T16:34:03','version'=>'3.07' },{'date'=>'2005-04-20T15:31:11','version'=>'3.08' },{'date'=>'2005-05-05T20:16:55','version'=>'3.09' },{'date'=>'2005-05-13T21:48:46','version'=>'3.10' },{'date'=>'2005-08-03T21:17:14','version'=>'3.11' },{'date'=>'2005-12-04T16:46:53','version'=>'3.12' },{'date'=>'2005-12-05T13:54:26','version'=>'3.13' },{'date'=>'2005-12-06T22:14:19','version'=>'3.14' },{'date'=>'2005-12-07T20:16:49','version'=>'3.15' },{'date'=>'2006-02-08T18:50:56','version'=>'3.16' },{'date'=>'2006-02-24T19:04:58','version'=>'3.17' },{'date'=>'2006-04-17T13:56:06','version'=>'3.19' },{'date'=>'2006-04-23T14:27:55','version'=>'3.20' },{'date'=>'2006-08-21T19:12:36','version'=>'3.21' },{'date'=>'2006-08-23T15:24:41','version'=>'3.22' },{'date'=>'2006-08-24T11:53:26','version'=>'3.23' },{'date'=>'2006-09-28T17:09:45','version'=>'3.25' },{'date'=>'2007-02-27T15:42:54','version'=>'3.27' },{'date'=>'2007-03-29T15:38:01','version'=>'3.28' },{'date'=>'2007-04-16T17:00:18','version'=>'3.29' },{'date'=>'2007-11-30T19:06:19','version'=>'3.31' },{'date'=>'2007-12-27T18:41:32','version'=>'3.32' },{'date'=>'2008-01-03T15:03:17','version'=>'3.33' },{'date'=>'2008-03-18T16:04:41','version'=>'3.34' },{'date'=>'2008-03-27T14:26:48','version'=>'3.35' },{'date'=>'2008-04-23T13:09:44','version'=>'3.37' },{'date'=>'2008-06-25T14:58:32','version'=>'3.38' },{'date'=>'2008-07-29T15:01:52','version'=>'3.39' },{'date'=>'2008-08-06T18:21:51','version'=>'3.40' },{'date'=>'2008-08-26T13:56:27','version'=>'3.41' },{'date'=>'2008-09-08T14:15:41','version'=>'3.42' },{'date'=>'2009-04-06T18:35:19','version'=>'3.43' },{'date'=>'2009-07-30T16:34:17','version'=>'3.44' },{'date'=>'2009-08-14T13:37:12','version'=>'3.45' },{'date'=>'2009-09-09T15:39:42','version'=>'3.46' },{'date'=>'2009-09-09T20:03:01','version'=>'3.47' },{'date'=>'2009-09-25T15:07:03','version'=>'3.48' },{'date'=>'2010-02-05T16:24:53','version'=>'3.49' },{'date'=>'2010-11-08T21:53:26','version'=>'3.50' },{'date'=>'2011-01-05T18:28:41','version'=>'3.51' },{'date'=>'2011-01-25T04:30:05','version'=>'3.52' },{'date'=>'2011-04-25T23:01:21','version'=>'3.53' },{'date'=>'2011-04-28T14:36:41','version'=>'3.54' },{'date'=>'2011-06-03T15:39:16','version'=>'3.55' },{'date'=>'2011-11-09T02:00:20','version'=>'3.56' },{'date'=>'2011-11-09T15:59:18','version'=>'3.57' },{'date'=>'2011-11-12T03:36:07','version'=>'3.58' },{'date'=>'2011-12-30T13:35:35','version'=>'3.59' },{'date'=>'2012-08-16T03:21:13','version'=>'3.60' },{'date'=>'2012-11-03T02:10:42','version'=>'3.61' },{'date'=>'2012-11-10T01:40:50','version'=>'3.62' },{'date'=>'2012-11-14T23:45:29','version'=>'3.63' },{'date'=>'2013-11-24T01:22:00','version'=>'3.64' },{'date'=>'2014-02-12T03:13:58','version'=>'3.65' },{'date'=>'2014-05-15T12:59:58','version'=>'3.65_01' },{'date'=>'2014-05-16T11:43:33','version'=>'3.65_02' },{'date'=>'2014-05-20T12:31:46','version'=>'3.65_03' },{'date'=>'2014-05-22T19:58:14','version'=>'4.00' },{'date'=>'2014-05-27T13:13:51','version'=>'4.01' },{'date'=>'2014-06-09T13:55:49','version'=>'4.02' },{'date'=>'2014-07-02T14:53:06','version'=>'4.03' },{'date'=>'2014-07-28T18:30:34','version'=>'4.03_01' },{'date'=>'2014-07-30T14:26:40','version'=>'4.03_02' },{'date'=>'2014-08-13T11:40:14','version'=>'4.03_03' },{'date'=>'2014-09-04T14:42:14','version'=>'4.04' },{'date'=>'2014-09-20T16:08:55','version'=>'4.04_01' },{'date'=>'2014-09-28T19:57:05','version'=>'4.04_02' },{'date'=>'2014-09-29T09:50:07','version'=>'4.04_03' },{'date'=>'2014-10-06T12:01:14','version'=>'4.04_04' },{'date'=>'2014-10-06T12:24:10','version'=>'4.04_05' },{'date'=>'2014-10-08T07:42:49','version'=>'4.05' },{'date'=>'2014-10-10T11:35:49','version'=>'4.06' },{'date'=>'2014-10-12T16:29:35','version'=>'4.07' },{'date'=>'2014-10-18T11:00:38','version'=>'4.08' },{'date'=>'2014-10-21T07:33:36','version'=>'4.09' },{'date'=>'2014-11-25T21:06:50','version'=>'4.09_01' },{'date'=>'2014-11-27T12:53:51','version'=>'4.10' },{'date'=>'2014-11-30T12:12:26','version'=>'4.10_01' },{'date'=>'2014-12-03T07:25:15','version'=>'4.11' },{'date'=>'2014-12-18T08:35:52','version'=>'4.12' },{'date'=>'2014-12-18T09:21:52','version'=>'4.13' },{'date'=>'2015-02-12T14:19:13','version'=>'4.13_01' },{'date'=>'2015-02-13T08:01:29','version'=>'4.13_02' },{'date'=>'2015-03-01T13:28:25','version'=>'4.13_03' },{'date'=>'2015-03-08T16:09:21','version'=>'4.13_04' },{'date'=>'2015-03-25T17:55:15','version'=>'4.13_05' },{'date'=>'2015-04-01T06:51:57','version'=>'4.14' },{'date'=>'2015-04-17T14:27:39','version'=>'4.14_01' },{'date'=>'2015-04-20T07:15:45','version'=>'4.15' },{'date'=>'2015-05-29T14:48:42','version'=>'4.20' },{'date'=>'2015-06-22T07:50:02','version'=>'4.21' },{'date'=>'2015-10-16T09:46:31','version'=>'4.22' },{'date'=>'2015-12-20T18:33:35','version'=>'4.24' },{'date'=>'2015-12-21T09:29:19','version'=>'4.25' },{'date'=>'2016-02-04T16:37:12','version'=>'4.26' },{'date'=>'2016-03-02T08:03:46','version'=>'4.27' },{'date'=>'2016-03-14T07:21:48','version'=>'4.28' },{'date'=>'2016-05-22T12:23:19','version'=>'4.28_01' },{'date'=>'2016-05-22T12:54:23','version'=>'4.28_02' },{'date'=>'2016-05-23T08:25:25','version'=>'4.28_03' },{'date'=>'2016-06-09T12:01:20','version'=>'4.29' },{'date'=>'2016-06-09T12:11:54','version'=>'4.30' },{'date'=>'2016-06-14T07:14:00','version'=>'4.31' },{'date'=>'2016-07-19T07:05:46','version'=>'4.32' },{'date'=>'2016-09-16T09:47:49','version'=>'4.33' },{'date'=>'2016-10-13T11:58:55','version'=>'4.34' },{'date'=>'2016-10-13T13:56:21','version'=>'4.35' },{'date'=>'2017-03-29T08:56:26','version'=>'4.35_01' },{'date'=>'2017-04-06T14:42:12','version'=>'4.36' },{'date'=>'2017-11-01T10:17:40','version'=>'4.37' },{'date'=>'2017-12-01T08:41:02','version'=>'4.38' },{'date'=>'2018-08-13T15:57:52','version'=>'4.39' },{'date'=>'2018-08-15T08:39:39','version'=>'4.40' }]},'CGI-Application-Dispatch'=>{'advisories'=>[{'affected_versions'=>'<1.02','description'=>'Untainted module names.
  ','distribution'=>'CGI-Application-Dispatch','fixed_versions'=>'>=1.02','id'=>'CPANSA-CGI-Application-Dispatch-2005-001','references'=>['https://metacpan.org/changes/distribution/CGI-Application-Dispatch' ],'reported'=>'2005-01-20' }],'main_module'=>'CGI::Application::Dispatch','versions'=>[{'date'=>'2004-09-13T01:35:58','version'=>'0.01' },{'date'=>'2004-10-19T18:26:01','version'=>'0.02' },{'date'=>'2004-10-29T16:53:40','version'=>'0.03' },{'date'=>'2005-01-06T15:34:49','version'=>'1.00' },{'date'=>'2005-01-08T12:42:00','version'=>'1.01' },{'date'=>'2005-01-20T14:43:28','version'=>'1.02' },{'date'=>'2005-03-04T16:28:16','version'=>'1.03' },{'date'=>'2005-07-12T21:44:54','version'=>'1.04' },{'date'=>'2006-01-12T15:56:53','version'=>'2.00_02' },{'date'=>'2006-02-06T15:50:52','version'=>'2.00_03' },{'date'=>'2006-02-14T15:41:25','version'=>'2.00_04' },{'date'=>'2006-04-12T14:18:22','version'=>'2.00_05' },{'date'=>'2006-06-27T04:29:04','version'=>'2.00_06' },{'date'=>'2006-07-03T15:52:12','version'=>'2.00' },{'date'=>'2006-08-14T14:14:10','version'=>'2.01' },{'date'=>'2006-08-17T14:57:55','version'=>'2.02' },{'date'=>'2006-09-30T02:13:40','version'=>'2.03' },{'date'=>'2007-01-03T18:12:57','version'=>'2.10_01' },{'date'=>'2007-01-11T18:55:41','version'=>'2.10_02' },{'date'=>'2007-01-15T14:08:30','version'=>'2.10' },{'date'=>'2007-12-28T20:23:49','version'=>'2.11' },{'date'=>'2007-12-31T20:43:51','version'=>'2.12_01' },{'date'=>'2008-01-03T14:39:57','version'=>'2.12' },{'date'=>'2008-03-08T18:33:34','version'=>'2.13_01' },{'date'=>'2008-03-11T16:41:27','version'=>'2.13_02' },{'date'=>'2008-09-17T00:44:02','version'=>'2.13' },{'date'=>'2008-11-03T01:33:21','version'=>'2.14' },{'date'=>'2008-12-04T16:00:05','version'=>'2.15' },{'date'=>'2009-03-24T02:03:51','version'=>'2.16' },{'date'=>'2009-12-30T19:06:27','version'=>'2.17' },{'date'=>'2011-01-05T03:42:59','version'=>'2.18' },{'date'=>'2011-06-16T17:42:14','version'=>'3.00' },{'date'=>'2011-06-24T02:53:20','version'=>'3.01' },{'date'=>'2011-06-24T22:33:01','version'=>'3.02' },{'date'=>'2011-06-26T03:52:14','version'=>'3.03' },{'date'=>'2011-06-29T13:45:53','version'=>'3.04' },{'date'=>'2011-09-07T22:21:15','version'=>'3.05' },{'date'=>'2011-09-09T15:29:58','version'=>'3.06' },{'date'=>'2011-09-09T17:32:11','version'=>'3.07' },{'date'=>'2012-09-03T04:04:19','version'=>'3.10' },{'date'=>'2012-09-14T01:02:58','version'=>'3.11' },{'date'=>'2012-09-14T01:19:52','version'=>'3.12' }]},'CGI-Application-Plugin-AutoRunmode'=>{'advisories'=>[{'affected_versions'=>'<0.04','description'=>'Non-word characters are allowed in runmode name.
  ','distribution'=>'CGI-Application-Plugin-AutoRunmode','fixed_versions'=>'>=0.04','id'=>'CPANSA-CGI-Application-Plugin-AutoRunmode-2005-01','references'=>['https://metacpan.org/changes/distribution/CGI-Application-Plugin-AutoRunmode' ],'reported'=>'2005-03-04' }],'main_module'=>'CGI::Application::Plugin::AutoRunmode','versions'=>[{'date'=>'2005-03-04T06:59:51','version'=>'0.04' },{'date'=>'2005-03-10T07:22:55','version'=>'0.05' },{'date'=>'2005-06-15T10:20:17','version'=>'0.06' },{'date'=>'2005-06-18T02:09:08','version'=>'0.07' },{'date'=>'2005-07-17T00:49:10','version'=>'0.08' },{'date'=>'2005-09-22T12:31:22','version'=>'0.09' },{'date'=>'2005-10-16T00:17:47','version'=>'0.10' },{'date'=>'2005-10-18T13:23:50','version'=>'0.11' },{'date'=>'2005-11-03T01:10:37','version'=>'0.12' },{'date'=>'2006-04-08T07:18:44','version'=>'0.13' },{'date'=>'2006-05-21T05:04:48','version'=>'0.14' },{'date'=>'2006-12-17T07:46:24','version'=>'0.15' },{'date'=>'2009-02-14T09:16:39','version'=>'0.16' },{'date'=>'2010-05-21T04:24:45','version'=>'0.17' },{'date'=>'2011-02-18T09:23:15','version'=>'0.18' }]},'CGI-Application-Plugin-RunmodeDeclare'=>{'advisories'=>[{'affected_versions'=>'<0.03','description'=>'Wrong order of arguments.
  ','distribution'=>'CGI-Application-Plugin-RunmodeDeclare','fixed_versions'=>'>=0.03','id'=>'CPANSA-CGI-Application-Plugin-RunmodeDeclare-2008-01','references'=>['https://metacpan.org/changes/distribution/CGI-Application-Plugin-RunmodeDeclare' ],'reported'=>'2008-10-20' }],'main_module'=>'CGI::Application::Plugin::RunmodeDeclare','versions'=>[{'date'=>'2008-09-26T19:59:14','version'=>'0.01' },{'date'=>'2008-09-26T21:37:11','version'=>'0.02' },{'date'=>'2008-10-19T23:22:06','version'=>'0.03' },{'date'=>'2008-10-23T14:18:23','version'=>'0.03_01' },{'date'=>'2008-10-24T13:32:43','version'=>'0.03_02' },{'date'=>'2008-10-24T16:20:27','version'=>'0.03_03' },{'date'=>'2008-10-25T10:54:25','version'=>'0.04' },{'date'=>'2008-10-25T11:46:28','version'=>'0.05' },{'date'=>'2008-10-25T16:39:34','version'=>'0.06' },{'date'=>'2009-01-10T02:32:39','version'=>'0.07' },{'date'=>'2009-05-17T22:29:18','version'=>'0.08' },{'date'=>'2010-01-07T13:24:09','version'=>'0.09' },{'date'=>'2012-02-10T00:53:54','version'=>'0.10' }]},'CGI-Auth-Basic'=>{'advisories'=>[{'affected_versions'=>'<1.11','description'=>'TBD
  ','distribution'=>'CGI-Auth-Basic','fixed_versions'=>'>=1.11','id'=>'CPANSA-CGI-Auth-Basic-2007-01','references'=>['https://metacpan.org/changes/distribution/CGI-Auth-Basic' ],'reported'=>'2007-12-30' }],'main_module'=>'CGI::Auth::Basic','versions'=>[{'date'=>'2004-02-21T14:58:09','version'=>'1.0' },{'date'=>'2004-08-31T13:29:28','version'=>'1.01' },{'date'=>'2004-11-07T03:34:32','version'=>'1.02' },{'date'=>'2006-06-18T01:12:15','version'=>'1.10' },{'date'=>'2007-12-30T20:53:33','version'=>'1.11' },{'date'=>'2009-04-18T04:22:51','version'=>'1.20' },{'date'=>'2009-04-23T17:00:50','version'=>'1.21' },{'date'=>'2009-04-24T15:07:48','version'=>'1.21' },{'date'=>'2012-08-27T01:50:53','version'=>'1.22' },{'date'=>'2015-01-21T00:26:01','version'=>'1.23' },{'date'=>'2018-12-23T21:03:03','version'=>'1.24' }]},'CGI-Simple'=>{'advisories'=>[{'affected_versions'=>'<1.113','cves'=>['CVE-2010-4410' ],'description'=>'Newlines in headers, which could lead to header injection attacks.
  ','distribution'=>'CGI-Simple','fixed_versions'=>'>=1.113','id'=>'CPANSA-CGI-Simple-2010-02','references'=>['https://metacpan.org/changes/distribution/CGI-Simple' ],'reported'=>'2010-12-27' },{'affected_versions'=>'<1.113','description'=>'Non-random multipart boundary.
  ','distribution'=>'CGI-Simple','fixed_versions'=>'>=1.113','id'=>'CPANSA-CGI-Simple-2010-01','references'=>['https://metacpan.org/changes/distribution/CGI-Simple' ],'reported'=>'2010-12-27' }],'main_module'=>'CGI::Simple','versions'=>[{'date'=>'2007-01-09T22:31:27','version'=>'0.078' },{'date'=>'2007-02-23T16:22:19','version'=>'0.079' },{'date'=>'2007-03-30T20:15:35','version'=>'0.080' },{'date'=>'2007-05-20T19:19:40','version'=>'0.081' },{'date'=>'2007-05-22T18:43:01','version'=>'0.082' },{'date'=>'2007-05-22T18:54:06','version'=>'0.83' },{'date'=>'2007-05-24T03:15:01','version'=>'1.0' },{'date'=>'2007-07-13T18:58:16','version'=>'1.1' },{'date'=>'2007-07-31T01:57:01','version'=>'1.1.1' },{'date'=>'2007-07-31T02:04:25','version'=>'1.1.2' },{'date'=>'2007-07-31T02:10:47','version'=>'1.103' },{'date'=>'2008-05-13T15:46:18','version'=>'1.104' },{'date'=>'2008-05-16T14:37:31','version'=>'1.105' },{'date'=>'2008-09-14T13:29:51','version'=>'1.106' },{'date'=>'2009-03-07T21:24:59','version'=>'1.107' },{'date'=>'2009-03-13T14:06:24','version'=>'1.108' },{'date'=>'2009-04-16T17:54:13','version'=>'1.109' },{'date'=>'2009-05-24T21:25:22','version'=>'1.110' },{'date'=>'2009-05-28T18:02:08','version'=>'1.111' },{'date'=>'2009-05-31T10:43:56','version'=>'1.112' },{'date'=>'2010-12-27T13:11:56','version'=>'1.113' },{'date'=>'2014-10-19T12:53:24','version'=>'1.115' },{'date'=>'2018-03-01T15:09:42','version'=>'1.13' },{'date'=>'2018-03-03T10:42:06','version'=>'1.14' },{'date'=>'2018-03-04T03:42:20','version'=>'1.15' },{'date'=>'2018-07-25T15:17:39','version'=>'1.16' },{'date'=>'2018-10-02T09:48:08','version'=>'1.17' },{'date'=>'2018-10-03T14:21:12','version'=>'1.18' },{'date'=>'2018-10-04T12:05:58','version'=>'1.19' },{'date'=>'2018-10-05T11:30:05','version'=>'1.20' },{'date'=>'2018-10-06T07:21:31','version'=>'1.21' }]},'CGI-apacheSSI'=>{'advisories'=>[{'affected_versions'=>'<0.95','description'=>'Security and parsing problems with "include" calls.
  ','distribution'=>'CGI-apacheSSI','fixed_versions'=>'>=0.95','id'=>'CPANSA-CGI-apacheSSI-2016-01','references'=>['https://metacpan.org/changes/distribution/CGI-apacheSSI' ],'reported'=>'2016-01-31' }],'main_module'=>'CGI::apacheSSI','versions'=>[{'date'=>'2014-08-20T22:55:20','version'=>'0.93' },{'date'=>'2016-01-30T12:57:47','version'=>'0.94' },{'date'=>'2016-01-31T22:48:55','version'=>'0.95' },{'date'=>'2016-02-01T00:36:49','version'=>'0.96' }]},'CPAN'=>{'advisories'=>[{'affected_versions'=>'<1.93','description'=>'Archive::Tar preserves permissions in the tarball; extracted file permissions will be set from users umask instead.
  ','distribution'=>'CPAN','fixed_versions'=>'>=1.93','id'=>'CPANSA-CPAN-2009-01','references'=>['https://github.com/andk/cpanpm/commit/079fa2e7ee77d626eab8bb06d0465c6a05f6c8b6' ],'reported'=>'2009-09-23' }],'main_module'=>'CPAN','versions'=>[{'date'=>'1996-09-10T17:13:59','version'=>'0.17' },{'date'=>'1996-09-10T20:51:00','version'=>'0.20' },{'date'=>'1996-09-12T05:53:35','version'=>'0.26' },{'date'=>'1996-09-12T14:01:39','version'=>'0.27' },{'date'=>'1996-09-16T20:18:59','version'=>'0.28' },{'date'=>'1996-09-17T17:14:51','version'=>'0.29' },{'date'=>'1996-09-19T05:24:17','version'=>'0.30' },{'date'=>'1996-09-20T10:40:01','version'=>'0.31' },{'date'=>'1996-09-22T19:30:33','version'=>'0.35' },{'date'=>'1996-09-23T12:55:23','version'=>'0.36' },{'date'=>'1996-09-23T14:05:44','version'=>'0.37' },{'date'=>'1996-09-27T12:52:07','version'=>'0.39' },{'date'=>'1996-09-28T20:51:31','version'=>'0.40' },{'date'=>'1996-10-01T21:14:27','version'=>'0.41' },{'date'=>'1996-11-17T07:56:02','version'=>'0.42' },{'date'=>'1996-11-17T14:51:59','version'=>'0.43' },{'date'=>'1996-11-30T17:04:28','version'=>'0.44' },{'date'=>'1996-12-01T12:19:19','version'=>'0.45' },{'date'=>'1996-12-01T18:24:17','version'=>'0.46' },{'date'=>'1996-12-10T00:58:25','version'=>'1.00' },{'date'=>'1996-12-10T10:17:15','version'=>'1.01' },{'date'=>'1996-12-11T01:31:55','version'=>'1.02' },{'date'=>'1996-12-21T03:10:23','version'=>'1.03' },{'date'=>'1996-12-21T20:08:49','version'=>'1.04' },{'date'=>'1996-12-22T13:04:58','version'=>'1.05' },{'date'=>'1996-12-22T14:16:08','version'=>'1.06' },{'date'=>'1996-12-23T04:05:01','version'=>'1.07' },{'date'=>'1996-12-23T13:18:01','version'=>'1.08' },{'date'=>'1996-12-24T00:46:19','version'=>'1.09' },{'date'=>'1997-01-17T02:29:49','version'=>'1.09_01' },{'date'=>'1997-01-21T01:06:40','version'=>'1.10' },{'date'=>'1997-01-22T18:50:00','version'=>'1.11' },{'date'=>'1997-01-23T00:07:58','version'=>'1.12' },{'date'=>'1997-01-24T01:07:44','version'=>'1.14' },{'date'=>'1997-01-24T12:32:12','version'=>'1.15' },{'date'=>'1997-02-02T13:51:48','version'=>'1.16_01' },{'date'=>'1997-02-02T21:05:12','version'=>'1.17' },{'date'=>'1997-02-03T00:38:36','version'=>'1.18' },{'date'=>'1997-02-03T09:13:48','version'=>'1.19' },{'date'=>'1997-02-05T09:38:00','version'=>'1.20' },{'date'=>'1997-02-11T06:32:42','version'=>'1.21' },{'date'=>'1997-03-13T23:14:59','version'=>'1.22_01' },{'date'=>'1997-03-31T12:03:55','version'=>'1.23' },{'date'=>'1997-03-31T22:47:11','version'=>'1.24' },{'date'=>'1997-06-30T18:13:23','version'=>'1.25' },{'date'=>'1997-07-28T13:58:09','version'=>'1.27' },{'date'=>'1997-08-04T06:09:33','version'=>'1.28' },{'date'=>'1997-08-11T23:33:58','version'=>'1.29' },{'date'=>'1997-08-29T14:34:37','version'=>'1.30' },{'date'=>'1997-09-21T08:53:03','version'=>'1.31' },{'date'=>'1997-09-23T18:45:50','version'=>'1.3101' },{'date'=>'1998-01-02T18:22:35','version'=>'1.32' },{'date'=>'1998-01-10T18:24:23','version'=>'1.33' },{'date'=>'1998-02-03T18:06:41','version'=>'1.35' },{'date'=>'1998-02-08T08:55:55','version'=>'1.36' },{'date'=>'1998-06-12T06:51:25','version'=>'1.37' },{'date'=>'1998-06-14T20:18:08','version'=>'1.38' },{'date'=>'1998-07-24T20:13:41','version'=>'1.40' },{'date'=>'1998-12-01T02:20:32','version'=>'1.41' },{'date'=>'1998-12-01T07:58:35','version'=>'1.42' },{'date'=>'1998-12-01T22:16:27','version'=>'1.43' },{'date'=>'1998-12-03T17:07:54','version'=>'1.43' },{'date'=>'1999-01-09T18:38:33','version'=>'1.44' },{'date'=>'1999-01-10T19:38:27','version'=>'1.44_51' },{'date'=>'1999-01-13T12:15:42','version'=>'1.44_52' },{'date'=>'1999-01-15T09:26:40','version'=>'1.44_53' },{'date'=>'1999-01-15T09:27:45','version'=>'1.44_54' },{'date'=>'1999-01-23T14:56:16','version'=>'1.45' },{'date'=>'1999-01-25T01:43:42','version'=>'1.46' },{'date'=>'1999-01-25T13:11:23','version'=>'1.47' },{'date'=>'1999-03-06T19:34:54','version'=>'1.48' },{'date'=>'1999-05-22T16:45:00','version'=>'1.49' },{'date'=>'1999-05-23T14:32:20','version'=>'1.50' },{'date'=>'1999-10-23T03:06:39','version'=>'1.50_01' },{'date'=>'1999-12-29T22:30:22','version'=>'1.51' },{'date'=>'2000-01-08T15:32:55','version'=>'1.52' },{'date'=>'2000-03-23T23:39:41','version'=>'1.53' },{'date'=>'2000-03-25T22:51:15','version'=>'1.54' },{'date'=>'2000-07-30T11:15:04','version'=>'1.55' },{'date'=>'2000-08-01T20:47:09','version'=>'1.56' },{'date'=>'2000-08-16T12:54:07','version'=>'1.57' },{'date'=>'2000-08-21T19:44:18','version'=>'1.57_51' },{'date'=>'2000-08-27T22:09:36','version'=>'1.57_53' },{'date'=>'2000-08-30T16:54:50','version'=>'1.57_54' },{'date'=>'2000-08-31T08:11:01','version'=>'1.57_55' },{'date'=>'2000-08-31T22:16:21','version'=>'1.57_56' },{'date'=>'2000-09-01T12:18:43','version'=>'1.57_57' },{'date'=>'2000-09-03T22:19:20','version'=>'1.57_58' },{'date'=>'2000-09-05T09:44:05','version'=>'1.57_59' },{'date'=>'2000-09-05T19:55:34','version'=>'1.57_60' },{'date'=>'2000-09-06T10:54:07','version'=>'1.57_61' },{'date'=>'2000-09-08T02:19:06','version'=>'1.57_62' },{'date'=>'2000-09-10T08:54:37','version'=>'1.57_65' },{'date'=>'2000-09-12T08:46:40','version'=>'1.57_66' },{'date'=>'2000-09-17T10:24:31','version'=>'1.57_67' },{'date'=>'2000-10-08T14:25:04','version'=>'1.57_68' },{'date'=>'2000-10-18T14:53:45','version'=>'1.58' },{'date'=>'2000-10-21T14:21:06','version'=>'1.58_51' },{'date'=>'2000-10-25T07:05:38','version'=>'1.58_52' },{'date'=>'2000-10-26T11:03:29','version'=>'1.58_53' },{'date'=>'2000-10-26T15:34:21','version'=>'1.58_54' },{'date'=>'2000-10-27T07:59:03','version'=>'1.58_55' },{'date'=>'2000-11-04T09:36:53','version'=>'1.58_56' },{'date'=>'2000-11-06T19:30:27','version'=>'1.58_57' },{'date'=>'2000-11-08T08:10:51','version'=>'1.58_90' },{'date'=>'2000-11-13T10:26:38','version'=>'1.58_91' },{'date'=>'2000-11-14T18:24:18','version'=>'1.58_92' },{'date'=>'2000-11-15T07:19:56','version'=>'1.58_93' },{'date'=>'2000-12-01T06:05:58','version'=>'1.59' },{'date'=>'2000-12-01T08:19:58','version'=>'1.59_51' },{'date'=>'2000-12-26T13:54:06','version'=>'1.59_52' },{'date'=>'2001-01-02T16:37:24','version'=>'1.59_53' },{'date'=>'2001-02-09T21:44:55','version'=>'1.59_54' },{'date'=>'2002-04-19T13:29:54','version'=>'1.60' },{'date'=>'2002-04-20T02:18:41','version'=>'1.60' },{'date'=>'2002-04-21T11:31:25','version'=>'1.60' },{'date'=>'2002-05-07T10:38:54','version'=>'1.61' },{'date'=>'2002-07-28T10:51:47','version'=>'1.62' },{'date'=>'2002-08-30T08:58:10','version'=>'1.63' },{'date'=>'2003-02-06T10:04:06','version'=>'1.64' },{'date'=>'2003-02-08T17:10:13','version'=>'1.65' },{'date'=>'2003-03-04T19:38:21','version'=>'1.70' },{'date'=>'2003-04-11T04:33:18','version'=>'1.70_52' },{'date'=>'2003-04-13T12:43:40','version'=>'1.70_53' },{'date'=>'2003-05-15T21:04:52','version'=>'1.70_54' },{'date'=>'2003-07-04T09:48:08','version'=>'1.71' },{'date'=>'2003-07-27T20:35:05','version'=>'1.72' },{'date'=>'2003-07-28T08:21:47','version'=>'1.73' },{'date'=>'2003-07-28T22:58:08','version'=>'1.74' },{'date'=>'2003-07-29T15:14:13','version'=>'1.75' },{'date'=>'2003-07-31T15:14:02','version'=>'1.76' },{'date'=>'2003-09-21T21:25:41','version'=>'1.76_01' },{'date'=>'2005-09-19T06:37:38','version'=>'1.76_51' },{'date'=>'2005-09-22T07:02:02','version'=>'1.76_52' },{'date'=>'2005-09-22T07:09:48','version'=>'1.76_53' },{'date'=>'2005-10-01T08:23:38','version'=>'1.76_54' },{'date'=>'2005-10-19T06:10:58','version'=>'1.76_55' },{'date'=>'2005-10-21T04:59:36','version'=>'1.76_56' },{'date'=>'2005-10-27T07:08:29','version'=>'1.76_57' },{'date'=>'2005-11-02T04:03:28','version'=>'1.76_58' },{'date'=>'2005-11-03T06:37:52','version'=>'1.76_59' },{'date'=>'2005-11-03T07:38:40','version'=>'1.76_60' },{'date'=>'2005-11-06T10:36:53','version'=>'1.76_61' },{'date'=>'2005-11-07T04:22:19','version'=>'1.76_62' },{'date'=>'2005-11-07T04:47:05','version'=>'1.76_63' },{'date'=>'2005-11-07T21:58:06','version'=>'1.76_64' },{'date'=>'2005-11-07T22:18:44','version'=>'1.76_65' },{'date'=>'2005-12-03T10:12:08','version'=>'1.80' },{'date'=>'2005-12-18T11:29:26','version'=>'1.80_51' },{'date'=>'2005-12-21T12:13:15','version'=>'1.80_53' },{'date'=>'2005-12-22T08:42:59','version'=>'1.80_54' },{'date'=>'2005-12-24T07:25:34','version'=>'1.80_55' },{'date'=>'2005-12-24T09:59:47','version'=>'1.80_56' },{'date'=>'2005-12-31T11:58:10','version'=>'1.80_57' },{'date'=>'2006-01-01T09:01:43','version'=>'1.80_58' },{'date'=>'2006-01-02T23:15:15','version'=>'1.81' },{'date'=>'2006-01-04T07:47:25','version'=>'1.82' },{'date'=>'2006-01-05T08:03:36','version'=>'1.83' },{'date'=>'2006-01-08T13:35:16','version'=>'1.83_51' },{'date'=>'2006-01-10T05:00:26','version'=>'1.83_52' },{'date'=>'2006-01-12T07:54:36','version'=>'1.83_53' },{'date'=>'2006-01-13T08:20:42','version'=>'1.83_54' },{'date'=>'2006-01-14T11:34:47','version'=>'1.83_55' },{'date'=>'2006-01-18T06:03:44','version'=>'1.83_56' },{'date'=>'2006-01-19T08:00:02','version'=>'1.83_57' },{'date'=>'2006-01-22T12:05:01','version'=>'1.83_58' },{'date'=>'2006-01-25T13:10:20','version'=>'1.83_59' },{'date'=>'2006-01-30T10:35:47','version'=>'1.83_60' },{'date'=>'2006-01-30T23:18:09','version'=>'1.83_61' },{'date'=>'2006-01-31T10:28:57','version'=>'1.83_62' },{'date'=>'2006-02-01T07:49:36','version'=>'1.83_63' },{'date'=>'2006-02-02T09:17:39','version'=>'1.83_64' },{'date'=>'2006-02-04T11:20:05','version'=>'1.83_65' },{'date'=>'2006-02-04T17:05:00','version'=>'1.83_66' },{'date'=>'2006-02-06T00:46:27','version'=>'1.83_67' },{'date'=>'2006-02-08T07:43:36','version'=>'1.83_68' },{'date'=>'2006-02-14T08:17:55','version'=>'1.83_69' },{'date'=>'2006-02-15T07:01:02','version'=>'1.84' },{'date'=>'2006-02-19T17:05:36','version'=>'1.85' },{'date'=>'2006-02-20T08:36:51','version'=>'1.86' },{'date'=>'2006-02-21T06:05:05','version'=>'1.86_51' },{'date'=>'2006-02-22T22:29:54','version'=>'1.86_52' },{'date'=>'2006-02-24T08:24:09','version'=>'1.86_53' },{'date'=>'2006-02-27T07:01:10','version'=>'1.87' },{'date'=>'2006-03-06T08:02:28','version'=>'1.87_51' },{'date'=>'2006-07-21T22:33:11','version'=>'1.87_52' },{'date'=>'2006-07-22T18:55:13','version'=>'1.87_53' },{'date'=>'2006-07-23T21:37:11','version'=>'1.87_54' },{'date'=>'2006-07-29T19:36:50','version'=>'1.87_55' },{'date'=>'2006-08-24T05:57:41','version'=>'1.87_56' },{'date'=>'2006-08-26T17:05:56','version'=>'1.87_57' },{'date'=>'2006-08-31T06:50:49','version'=>'1.87_58' },{'date'=>'2006-09-03T21:05:29','version'=>'1.87_59' },{'date'=>'2006-09-10T11:57:33','version'=>'1.87_61' },{'date'=>'2006-09-11T21:24:18','version'=>'1.87_62' },{'date'=>'2006-09-13T05:44:15','version'=>'1.87_63' },{'date'=>'2006-09-16T11:02:25','version'=>'1.87_64' },{'date'=>'2006-09-19T03:44:51','version'=>'1.87_65' },{'date'=>'2006-09-21T20:30:41','version'=>'1.88' },{'date'=>'2006-09-22T20:40:40','version'=>'1.8801' },{'date'=>'2006-09-30T10:41:20','version'=>'1.88_51' },{'date'=>'2006-10-03T09:51:49','version'=>'1.88_52' },{'date'=>'2006-10-09T19:31:56','version'=>'1.88_53' },{'date'=>'2006-10-14T09:37:15','version'=>'1.88_54' },{'date'=>'2006-10-16T06:59:27','version'=>'1.88_55' },{'date'=>'2006-10-22T10:34:16','version'=>'1.88_56' },{'date'=>'2006-10-23T07:17:30','version'=>'1.8802' },{'date'=>'2006-10-24T07:18:16','version'=>'1.88_57' },{'date'=>'2006-10-28T15:00:07','version'=>'1.88_58' },{'date'=>'2006-11-05T21:24:52','version'=>'1.88_59' },{'date'=>'2006-11-10T08:39:55','version'=>'1.88_61' },{'date'=>'2006-11-13T07:44:27','version'=>'1.88_62' },{'date'=>'2006-11-29T08:11:50','version'=>'1.88_63' },{'date'=>'2006-12-04T07:53:37','version'=>'1.88_64' },{'date'=>'2006-12-11T21:36:04','version'=>'1.88_65' },{'date'=>'2006-12-19T08:21:17','version'=>'1.88_66' },{'date'=>'2006-12-31T17:18:53','version'=>'1.88_67' },{'date'=>'2007-01-07T21:22:12','version'=>'1.88_68' },{'date'=>'2007-01-08T03:42:56','version'=>'1.88_69' },{'date'=>'2007-01-27T16:57:49','version'=>'1.88_71' },{'date'=>'2007-01-31T07:11:33','version'=>'1.88_72' },{'date'=>'2007-02-13T05:24:13','version'=>'1.88_73' },{'date'=>'2007-02-15T07:12:17','version'=>'1.88_74' },{'date'=>'2007-02-18T16:52:49','version'=>'1.88_75' },{'date'=>'2007-02-19T06:20:20','version'=>'1.88_76' },{'date'=>'2007-02-19T21:26:47','version'=>'1.88_77' },{'date'=>'2007-03-05T23:26:57','version'=>'1.88_78' },{'date'=>'2007-03-16T01:54:55','version'=>'1.88_79' },{'date'=>'2007-04-07T07:41:18','version'=>'1.90' },{'date'=>'2007-04-19T07:03:03','version'=>'1.91' },{'date'=>'2007-04-23T00:09:11','version'=>'1.9101' },{'date'=>'2007-05-08T20:35:04','version'=>'1.9102' },{'date'=>'2007-07-07T16:15:40','version'=>'1.91_51' },{'date'=>'2007-07-14T18:45:58','version'=>'1.91_52' },{'date'=>'2007-08-09T06:49:38','version'=>'1.91_53' },{'date'=>'2007-09-14T21:18:33','version'=>'1.91_54' },{'date'=>'2007-09-15T07:14:26','version'=>'1.91_55' },{'date'=>'2007-09-23T11:15:08','version'=>'1.92' },{'date'=>'2007-09-27T07:11:10','version'=>'1.9201' },{'date'=>'2007-09-28T06:58:04','version'=>'1.9202' },{'date'=>'2007-09-28T07:13:26','version'=>'1.9203' },{'date'=>'2007-11-04T23:04:18','version'=>'1.92_51' },{'date'=>'2007-11-05T23:30:06','version'=>'1.9204' },{'date'=>'2007-11-11T11:27:20','version'=>'1.92_52' },{'date'=>'2007-11-11T18:49:37','version'=>'1.9205' },{'date'=>'2007-12-09T23:27:18','version'=>'1.92_53' },{'date'=>'2007-12-27T04:57:34','version'=>'1.92_54' },{'date'=>'2007-12-30T15:24:13','version'=>'1.92_55' },{'date'=>'2008-02-04T21:56:28','version'=>'1.92_56' },{'date'=>'2008-02-27T05:13:49','version'=>'1.92_57' },{'date'=>'2008-03-12T07:56:18','version'=>'1.92_58' },{'date'=>'2008-03-16T18:57:04','version'=>'1.92_59' },{'date'=>'2008-03-26T07:53:08','version'=>'1.92_60' },{'date'=>'2008-04-25T04:47:52','version'=>'1.92_61' },{'date'=>'2008-05-23T04:07:04','version'=>'1.92_62' },{'date'=>'2008-06-19T06:42:18','version'=>'1.92_63' },{'date'=>'2008-09-03T05:27:35','version'=>'1.92_64' },{'date'=>'2008-09-14T09:54:03','version'=>'1.92_65' },{'date'=>'2008-09-29T23:15:10','version'=>'1.92_66' },{'date'=>'2008-10-12T16:07:51','version'=>'1.93' },{'date'=>'2008-10-13T19:37:43','version'=>'1.9301' },{'date'=>'2009-01-11T22:07:01','version'=>'1.93_02' },{'date'=>'2009-02-01T12:38:23','version'=>'1.93_03' },{'date'=>'2009-02-01T21:06:21','version'=>'1.93_51' },{'date'=>'2009-02-28T15:58:39','version'=>'1.9304' },{'date'=>'2009-04-13T19:24:43','version'=>'1.93_52' },{'date'=>'2009-05-04T06:11:28','version'=>'1.93_53' },{'date'=>'2009-05-07T20:13:16','version'=>'1.93_54' },{'date'=>'2009-05-24T05:37:28','version'=>'1.94' },{'date'=>'2009-06-14T19:53:52','version'=>'1.94_01' },{'date'=>'2009-06-27T02:55:22','version'=>'1.9402' },{'date'=>'2009-09-14T02:47:24','version'=>'1.94_51' },{'date'=>'2009-10-15T19:33:19','version'=>'1.94_52' },{'date'=>'2009-12-18T07:00:09','version'=>'1.94_53' },{'date'=>'2010-01-14T08:01:42','version'=>'1.94_54' },{'date'=>'2010-02-03T03:43:49','version'=>'1.94_55' },{'date'=>'2010-02-17T13:39:33','version'=>'1.94_56' },{'date'=>'2010-05-24T19:33:41','version'=>'1.94_57' },{'date'=>'2010-06-24T06:34:13','version'=>'1.94_58' },{'date'=>'2010-09-26T20:23:30','version'=>'1.94_59' },{'date'=>'2010-09-28T20:44:58','version'=>'1.94_60' },{'date'=>'2010-10-03T17:29:37','version'=>'1.94_61' },{'date'=>'2010-10-26T06:43:51','version'=>'1.94_62' },{'date'=>'2011-01-16T17:58:10','version'=>'1.94_63' },{'date'=>'2011-01-21T04:58:35','version'=>'1.94_64' },{'date'=>'2011-02-14T12:10:12','version'=>'1.94_65' },{'date'=>'2011-03-12T11:30:03','version'=>'1.9600' },{'date'=>'2011-06-27T06:56:01','version'=>'1.97_51' },{'date'=>'2011-08-07T09:40:33','version'=>'1.9800' },{'date'=>'2012-10-16T21:42:49','version'=>'1.99_51' },{'date'=>'2013-02-06T07:41:54','version'=>'2.00-TRIAL' },{'date'=>'2013-04-12T16:57:44','version'=>'2.00' },{'date'=>'2013-06-22T20:27:32','version'=>'2.01-TRIAL' },{'date'=>'2013-06-23T07:33:40','version'=>'2.02-TRIAL' },{'date'=>'2013-09-15T09:42:33','version'=>'2.03-TRIAL' },{'date'=>'2014-03-18T22:33:22','version'=>'2.04-TRIAL' },{'date'=>'2014-03-31T20:55:24','version'=>'2.05-TRIAL' },{'date'=>'2014-04-04T02:07:20','version'=>'2.05-TRIAL2' },{'date'=>'2014-04-18T13:35:51','version'=>'2.05' },{'date'=>'2014-08-06T19:32:53','version'=>'2.06-TRIAL' },{'date'=>'2015-01-04T18:54:54','version'=>'2.06-TRIAL' },{'date'=>'2015-01-05T06:31:55','version'=>'2.08-TRIAL' },{'date'=>'2015-02-02T04:41:02','version'=>'2.09-TRIAL' },{'date'=>'2015-02-22T15:57:42','version'=>'2.10-TRIAL' },{'date'=>'2015-03-13T07:45:04','version'=>'2.10' },{'date'=>'2015-12-31T11:00:08','version'=>'2.12-TRIAL' },{'date'=>'2016-05-16T09:56:01','version'=>'2.13-TRIAL' },{'date'=>'2016-06-04T14:41:28','version'=>'2.14-TRIAL' },{'date'=>'2016-06-25T04:32:45','version'=>'2.14' },{'date'=>'2016-07-17T12:10:30','version'=>'2.15-TRIAL' },{'date'=>'2017-01-16T16:20:27','version'=>'2.16-TRIAL' },{'date'=>'2017-01-16T21:27:06','version'=>'2.16-TRIAL2' },{'date'=>'2017-02-14T16:22:20','version'=>'2.16' },{'date'=>'2017-02-15T09:37:10','version'=>'2.17-TRIAL' },{'date'=>'2017-02-16T09:48:46','version'=>'2.17-TRIAL2' },{'date'=>'2017-03-30T21:38:23','version'=>'2.18-TRIAL' },{'date'=>'2017-11-04T23:27:47','version'=>'2.19-TRIAL' },{'date'=>'2017-11-26T22:10:39','version'=>'2.20-TRIAL' },{'date'=>'2018-09-22T20:46:35','version'=>'2.21-TRIAL' },{'date'=>'2018-12-16T10:35:04','version'=>'2.22-TRIAL' },{'date'=>'2018-12-23T09:11:29','version'=>'2.22' },{'date'=>'2019-02-10T20:28:53','version'=>'2.23-TRIAL' },{'date'=>'2019-02-14T21:21:03','version'=>'2.24-TRIAL' },{'date'=>'2019-02-16T05:56:23','version'=>'2.25-TRIAL' },{'date'=>'2019-03-03T06:27:10','version'=>'2.25' }]},'Catalyst-Authentication-Store-LDAP'=>{'advisories'=>[{'affected_versions'=>'<1.013','description'=>'Incorrect password check binds to the unauthenticated user.
  ','distribution'=>'Catalyst-Authentication-Store-LDAP','fixed_versions'=>'>=1.013','id'=>'CPANSA-Catalyst-Authentication-Store-LDAP-2012-01','references'=>['https://rt.cpan.org/Public/Bug/Display.html?id=81908' ],'reported'=>'2012-12-11','severity'=>'high' }],'main_module'=>'Catalyst::Authentication::Store::LDAP','versions'=>[{'date'=>'2008-02-05T18:18:24','version'=>'0.1000' },{'date'=>'2008-04-10T02:06:58','version'=>'0.1001' },{'date'=>'2008-07-09T20:45:43','version'=>'0.1002' },{'date'=>'2008-09-10T13:21:33','version'=>'0.1003' },{'date'=>'2008-10-22T01:57:27','version'=>'0.1003' },{'date'=>'2009-05-01T02:34:18','version'=>'0.1005' },{'date'=>'2009-12-11T18:54:26','version'=>'1.006' },{'date'=>'2010-03-19T10:07:13','version'=>'1.007' },{'date'=>'2010-04-03T03:04:13','version'=>'1.008' },{'date'=>'2010-05-15T07:14:41','version'=>'1.009' },{'date'=>'2010-07-06T21:39:55','version'=>'1.010' },{'date'=>'2010-07-07T20:41:22','version'=>'1.011' },{'date'=>'2010-10-05T08:11:56','version'=>'1.012' },{'date'=>'2013-01-09T14:58:46','version'=>'1.013' },{'date'=>'2013-04-26T19:51:28','version'=>'1.014' },{'date'=>'2015-02-20T18:07:31','version'=>'1.015' },{'date'=>'2016-02-11T17:50:52','version'=>'1.016' }]},'Catalyst-Controller-Combine'=>{'advisories'=>[{'affected_versions'=>'<0.12','description'=>'Allows to use url-encoded path-parts to crawl along the file system and read files outside the intended directory.
  ','distribution'=>'Catalyst-Controller-Combine','fixed_versions'=>'>=0.12','id'=>'CPANSA-Catalyst-Controller-Combine-2010-01','references'=>['https://metacpan.org/changes/distribution/Catalyst-Controller-Combine' ],'reported'=>'2010-05-21' }],'main_module'=>'Catalyst::Controller::Combine','versions'=>[{'date'=>'2009-07-11T17:58:25','version'=>'0.06' },{'date'=>'2009-07-13T06:49:00','version'=>'0.07' },{'date'=>'2009-10-24T12:48:21','version'=>'0.08' },{'date'=>'2010-03-13T19:31:13','version'=>'0.09' },{'date'=>'2010-03-27T18:44:05','version'=>'0.10' },{'date'=>'2010-06-21T20:47:02','version'=>'0.12' },{'date'=>'2011-07-28T19:53:12','version'=>'0.13' },{'date'=>'2012-02-20T20:59:00','version'=>'0.14' },{'date'=>'2012-05-04T10:43:12','version'=>'0.15' }]},'Catalyst-Plugin-Static'=>{'advisories'=>[{'affected_versions'=>'<0.10','description'=>'Serving files outside of $config->{root} directory.
  ','distribution'=>'Catalyst-Plugin-Static','fixed_versions'=>'>=0.10','id'=>'CPANSA-Catalyst-Plugin-Static-2005-01','reported'=>'2005-11-14' }],'main_module'=>'Catalyst::Plugin::Static','versions'=>[{'date'=>'2005-01-29T00:00:20','version'=>'0.01' },{'date'=>'2005-02-19T20:28:50','version'=>'0.02' },{'date'=>'2005-03-17T01:01:03','version'=>'0.03' },{'date'=>'2005-03-17T19:10:36','version'=>'0.04' },{'date'=>'2005-03-21T13:34:27','version'=>'0.05' },{'date'=>'2005-03-23T06:48:05','version'=>'0.05' },{'date'=>'2005-04-15T16:58:18','version'=>'0.06' },{'date'=>'2005-04-17T14:50:45','version'=>'0.07' },{'date'=>'2005-09-06T13:42:42','version'=>'0.08' },{'date'=>'2005-11-14T08:38:35','version'=>'0.09' },{'date'=>'2005-11-14T10:26:31','version'=>'0.10' },{'date'=>'2009-10-18T18:13:00','version'=>'0.11' }]},'Catalyst-Runtime'=>{'advisories'=>[{'affected_versions'=>'<5.90020','description'=>'Passing a special host to the redirect page link makes it vulnerable to XSS attack.
  ','distribution'=>'Catalyst-Runtime','fixed_versions'=>'>=5.90020','id'=>'CPANSA-Catalyst-Runtime-2013-01','references'=>['http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=catagits/Catalyst-Runtime.git;a=commitdiff;h=7af54927870a7c6f89323ac1876d49f92e7841f5' ],'reported'=>'2013-01-23' },{'affected_versions'=>'<5.58','description'=>'Path traversal in Static::Simple plugin.
  ','distribution'=>'Catalyst-Runtime','fixed_versions'=>'>=5.58','id'=>'CPANSA-Catalyst-Runtime-2005-01','reported'=>'2005-11-24' }],'main_module'=>'Catalyst::Runtime','versions'=>[{'date'=>'2006-06-25T19:20:53','version'=>'5.70_01' },{'date'=>'2006-06-27T18:10:20','version'=>'5.70_02' },{'date'=>'2006-06-28T21:50:30','version'=>'5.70_03' },{'date'=>'2006-07-07T22:47:30','version'=>'5.7000' },{'date'=>'2006-07-20T06:00:58','version'=>'5.7001' },{'date'=>'2006-09-19T07:36:29','version'=>'5.7002' },{'date'=>'2006-09-23T17:43:12','version'=>'5.7003' },{'date'=>'2006-11-06T23:28:40','version'=>'5.7004' },{'date'=>'2006-11-07T19:43:56','version'=>'5.7005' },{'date'=>'2006-11-15T08:27:59','version'=>'5.7006' },{'date'=>'2007-03-14T11:13:37','version'=>'5.7007' },{'date'=>'2007-08-13T06:36:11','version'=>'5.7008' },{'date'=>'2007-08-21T22:23:53','version'=>'5.7009' },{'date'=>'2007-08-22T05:51:41','version'=>'5.7010' },{'date'=>'2007-10-18T18:11:24','version'=>'5.7011' },{'date'=>'2007-12-17T08:19:28','version'=>'5.7012' },{'date'=>'2008-05-17T12:41:13','version'=>'5.7013' },{'date'=>'2008-05-25T21:16:45','version'=>'5.7013' },{'date'=>'2008-06-25T20:43:41','version'=>'5.7099_01' },{'date'=>'2008-07-18T11:41:25','version'=>'5.7099_02' },{'date'=>'2008-07-20T08:15:02','version'=>'5.7099_02' },{'date'=>'2008-10-13T20:55:41','version'=>'5.7099_02' },{'date'=>'2008-10-14T06:06:06','version'=>'5.7099_02' },{'date'=>'2008-10-15T21:44:15','version'=>'5.7015' },{'date'=>'2008-10-17T12:42:53','version'=>'5.8000_03' },{'date'=>'2008-12-05T15:11:14','version'=>'5.8000_04' },{'date'=>'2009-01-12T15:46:59','version'=>'5.7099_04' },{'date'=>'2009-01-19T17:36:04','version'=>'5.71000' },{'date'=>'2009-01-29T08:56:09','version'=>'5.8000_05' },{'date'=>'2009-02-04T20:08:22','version'=>'5.8000_06' },{'date'=>'2009-03-27T09:21:12','version'=>'5.71001' },{'date'=>'2009-04-13T19:03:36','version'=>'5.8000_07' },{'date'=>'2009-04-18T20:26:00','version'=>'5.80001' },{'date'=>'2009-04-21T23:45:45','version'=>'5.80002' },{'date'=>'2009-04-29T14:39:21','version'=>'5.80003' },{'date'=>'2009-05-18T15:16:38','version'=>'5.80004' },{'date'=>'2009-06-06T12:49:15','version'=>'5.80005' },{'date'=>'2009-06-29T22:11:48','version'=>'5.80006' },{'date'=>'2009-06-30T22:11:36','version'=>'5.80007' },{'date'=>'2009-08-21T16:14:33','version'=>'5.80008' },{'date'=>'2009-08-21T20:29:33','version'=>'5.80009' },{'date'=>'2009-08-21T21:42:08','version'=>'5.80010' },{'date'=>'2009-08-23T11:57:26','version'=>'5.80011' },{'date'=>'2009-09-09T18:01:32','version'=>'5.80012' },{'date'=>'2009-09-17T09:35:20','version'=>'5.80013' },{'date'=>'2009-11-21T02:32:20','version'=>'5.80014' },{'date'=>'2009-11-22T20:24:47','version'=>'5.80014_01' },{'date'=>'2009-12-01T01:14:00','version'=>'5.80014_02' },{'date'=>'2009-12-02T15:42:50','version'=>'5.80015' },{'date'=>'2009-12-11T23:37:44','version'=>'5.80016' },{'date'=>'2010-01-10T02:01:50','version'=>'5.80017' },{'date'=>'2010-01-12T21:39:47','version'=>'5.80018' },{'date'=>'2010-01-29T00:18:07','version'=>'5.80019' },{'date'=>'2010-02-04T06:19:31','version'=>'5.80020' },{'date'=>'2010-03-03T23:16:29','version'=>'5.80021' },{'date'=>'2010-03-28T19:25:48','version'=>'5.80022' },{'date'=>'2010-05-07T22:07:08','version'=>'5.80023' },{'date'=>'2010-05-15T09:57:52','version'=>'5.80024' },{'date'=>'2010-07-29T00:59:16','version'=>'5.80025' },{'date'=>'2010-09-01T15:10:42','version'=>'5.80026' },{'date'=>'2010-09-02T11:33:03','version'=>'5.80027' },{'date'=>'2010-09-28T20:14:11','version'=>'5.80028' },{'date'=>'2010-10-03T16:24:08','version'=>'5.80029' },{'date'=>'2011-01-04T12:56:30','version'=>'5.80030' },{'date'=>'2011-01-24T10:50:27','version'=>'5.89000' },{'date'=>'2011-01-31T08:25:21','version'=>'5.80031' },{'date'=>'2011-02-23T08:28:58','version'=>'5.80032' },{'date'=>'2011-03-01T14:56:37','version'=>'5.89001' },{'date'=>'2011-03-02T10:37:42','version'=>'5.89002' },{'date'=>'2011-07-24T15:58:37','version'=>'5.80033' },{'date'=>'2011-07-28T20:05:01','version'=>'5.89003' },{'date'=>'2011-08-15T21:35:34','version'=>'5.9000' },{'date'=>'2011-08-15T21:59:58','version'=>'5.90001' },{'date'=>'2011-08-22T20:55:10','version'=>'5.90002' },{'date'=>'2011-10-05T07:48:57','version'=>'5.90003' },{'date'=>'2011-10-11T15:19:05','version'=>'5.90004' },{'date'=>'2011-10-22T21:01:24','version'=>'5.90005' },{'date'=>'2011-10-25T17:54:34','version'=>'5.90006' },{'date'=>'2011-11-22T20:40:44','version'=>'5.90007' },{'date'=>'2012-02-06T21:08:28','version'=>'5.90008' },{'date'=>'2012-02-16T09:29:44','version'=>'5.90009' },{'date'=>'2012-02-18T00:49:30','version'=>'5.90010' },{'date'=>'2012-03-08T21:53:00','version'=>'5.90011' },{'date'=>'2012-05-19T07:13:21','version'=>'5.90012' },{'date'=>'2012-06-08T00:37:40','version'=>'5.90013' },{'date'=>'2012-06-21T20:41:41','version'=>'5.90013' },{'date'=>'2012-06-26T14:34:56','version'=>'5.90014' },{'date'=>'2012-06-30T18:00:53','version'=>'5.90015' },{'date'=>'2012-08-17T01:39:42','version'=>'5.90016' },{'date'=>'2012-10-19T21:51:54','version'=>'5.90017' },{'date'=>'2012-10-24T01:01:44','version'=>'5.90018' },{'date'=>'2012-12-04T22:04:19','version'=>'5.90019' },{'date'=>'2013-02-22T14:05:39','version'=>'5.90020' },{'date'=>'2013-04-12T17:09:27','version'=>'5.90030' },{'date'=>'2013-06-12T21:26:14','version'=>'5.90040' },{'date'=>'2013-06-15T02:10:17','version'=>'5.90041' },{'date'=>'2013-06-16T01:57:47','version'=>'5.90042' },{'date'=>'2013-07-26T19:13:01','version'=>'5.90049_001' },{'date'=>'2013-08-21T02:39:45','version'=>'5.90049_002' },{'date'=>'2013-09-20T19:03:54','version'=>'5.90049_003' },{'date'=>'2013-10-18T22:19:33','version'=>'5.90049_004' },{'date'=>'2013-10-31T20:48:42','version'=>'5.90049_005' },{'date'=>'2013-11-05T03:25:31','version'=>'5.90049_006' },{'date'=>'2013-11-05T22:35:22','version'=>'5.90050' },{'date'=>'2013-11-07T17:14:35','version'=>'5.90051' },{'date'=>'2013-12-18T20:03:22','version'=>'5.90052' },{'date'=>'2013-12-19T14:33:08','version'=>'5.90059_001' },{'date'=>'2013-12-22T16:18:16','version'=>'5.90053' },{'date'=>'2013-12-22T16:34:11','version'=>'5.90059_002' },{'date'=>'2013-12-27T02:27:08','version'=>'5.90059_003' },{'date'=>'2014-01-27T17:20:51','version'=>'5.90059_004' },{'date'=>'2014-01-28T19:36:58','version'=>'5.90059_005' },{'date'=>'2014-02-06T20:41:25','version'=>'5.90059_006' },{'date'=>'2014-02-08T03:11:11','version'=>'5.90060' },{'date'=>'2014-03-10T14:46:10','version'=>'5.90061' },{'date'=>'2014-04-14T18:53:26','version'=>'5.90062' },{'date'=>'2014-05-02T00:15:16','version'=>'5.90063' },{'date'=>'2014-05-05T14:55:25','version'=>'5.90064' },{'date'=>'2014-05-27T18:08:08','version'=>'5.90069_001' },{'date'=>'2014-06-05T12:44:59','version'=>'5.90065' },{'date'=>'2014-06-10T00:22:42','version'=>'5.90069_002' },{'date'=>'2014-08-06T15:09:29','version'=>'5.90069_003' },{'date'=>'2014-08-07T15:59:15','version'=>'5.90069_004' },{'date'=>'2014-08-07T21:49:59','version'=>'5.90070' },{'date'=>'2014-08-10T13:15:52','version'=>'5.90071' },{'date'=>'2014-09-15T16:30:58','version'=>'5.90072' },{'date'=>'2014-09-23T17:24:54','version'=>'5.90073' },{'date'=>'2014-10-01T21:45:12','version'=>'5.90074' },{'date'=>'2014-10-07T00:07:51','version'=>'5.90075' },{'date'=>'2014-11-14T00:20:16','version'=>'5.90076' },{'date'=>'2014-11-19T00:28:27','version'=>'5.90077' },{'date'=>'2014-12-02T21:50:30','version'=>'5.90079_001' },{'date'=>'2014-12-02T23:22:07','version'=>'5.90079_002' },{'date'=>'2014-12-03T19:45:16','version'=>'5.90079_003' },{'date'=>'2014-12-26T23:05:46','version'=>'5.90079_004' },{'date'=>'2014-12-31T16:26:20','version'=>'5.90078' },{'date'=>'2014-12-31T21:04:56','version'=>'5.90079_005' },{'date'=>'2015-01-02T15:11:55','version'=>'5.90079_006' },{'date'=>'2015-01-02T18:11:38','version'=>'5.90079' },{'date'=>'2015-01-07T20:01:40','version'=>'5.90079_007' },{'date'=>'2015-01-07T23:26:17','version'=>'5.90079_008' },{'date'=>'2015-01-09T17:04:47','version'=>'5.90080' },{'date'=>'2015-01-10T22:39:56','version'=>'5.90081' },{'date'=>'2015-01-10T23:33:56','version'=>'5.90082' },{'date'=>'2015-02-17T02:29:50','version'=>'5.90083' },{'date'=>'2015-02-23T22:24:50','version'=>'5.90084' },{'date'=>'2015-03-25T18:58:11','version'=>'5.90085' },{'date'=>'2015-03-26T21:30:15','version'=>'5.90089_001' },{'date'=>'2015-04-17T21:32:30','version'=>'5.90089_002' },{'date'=>'2015-04-27T20:20:40','version'=>'5.90089_003' },{'date'=>'2015-04-28T18:24:12','version'=>'5.90089_004' },{'date'=>'2015-04-29T14:04:24','version'=>'5.90090' },{'date'=>'2015-05-08T20:36:59','version'=>'5.90091' },{'date'=>'2015-05-19T16:48:30','version'=>'5.90092' },{'date'=>'2015-05-29T17:06:23','version'=>'5.90093' },{'date'=>'2015-07-24T20:17:46','version'=>'5.90094' },{'date'=>'2015-07-27T14:32:30','version'=>'5.90095' },{'date'=>'2015-07-27T15:44:59','version'=>'5.90096' },{'date'=>'2015-07-28T20:33:41','version'=>'5.90097' },{'date'=>'2015-08-24T16:30:12','version'=>'5.90100' },{'date'=>'2015-09-04T22:57:40','version'=>'5.90101' },{'date'=>'2015-10-29T19:39:24','version'=>'5.90102' },{'date'=>'2015-11-12T10:19:42','version'=>'5.90103' },{'date'=>'2016-04-04T17:18:38','version'=>'5.90104' },{'date'=>'2016-06-08T20:06:53','version'=>'5.90105' },{'date'=>'2016-07-06T01:21:42','version'=>'5.90106' },{'date'=>'2016-07-20T19:12:32','version'=>'5.90110' },{'date'=>'2016-07-20T20:07:16','version'=>'5.90111' },{'date'=>'2016-07-25T21:03:05','version'=>'5.90112' },{'date'=>'2016-12-15T21:35:30','version'=>'5.90113' },{'date'=>'2016-12-19T16:54:08','version'=>'5.90114' },{'date'=>'2017-05-01T16:42:46','version'=>'5.90115' },{'date'=>'2018-01-19T20:55:15','version'=>'5.90116' },{'date'=>'2018-01-21T23:47:21','version'=>'5.90117' },{'date'=>'2018-05-01T09:59:20','version'=>'5.90118' },{'date'=>'2018-09-24T00:25:48','version'=>'5.90119' },{'date'=>'2018-10-19T06:13:58','version'=>'5.90120' },{'date'=>'2018-10-22T20:39:48','version'=>'5.90_121' },{'date'=>'2018-11-03T14:52:06','version'=>'5.90122' },{'date'=>'2018-11-27T15:39:35','version'=>'5.90123' },{'date'=>'2019-01-18T22:36:07','version'=>'5.90124' }]},'Cmd-Dwarf'=>{'advisories'=>[{'affected_versions'=>'<1.20','description'=>'JSON highjacking possibility.
  ','distribution'=>'Cmd-Dwarf','fixed_versions'=>'>=1.20','id'=>'CPANSA-Cmd-Dwarf-2014-01','references'=>['https://github.com/seagirl/dwarf/commit/14cf7a1d55db635a07f4838e16f3d9a28e63f529','https://metacpan.org/changes/distribution/Cmd-Dwarf' ],'reported'=>'2014-12-03' }],'main_module'=>'Cmd::Dwarf','versions'=>[{'date'=>'2015-07-30T06:48:35','version'=>'1.27' },{'date'=>'2015-08-26T13:27:51','version'=>'1.28' },{'date'=>'2015-08-28T08:58:33','version'=>'1.29' },{'date'=>'2015-09-17T08:17:32','version'=>'1.30' },{'date'=>'2016-01-20T06:39:15','version'=>'1.31' },{'date'=>'2016-10-25T05:56:33','version'=>'1.41' },{'date'=>'2017-03-29T04:42:05','version'=>'1.42' },{'date'=>'2017-06-21T07:06:05','version'=>'1.50' },{'date'=>'2017-10-05T08:08:01','version'=>'1.60' },{'date'=>'2018-03-17T07:35:19','version'=>'1.70' },{'date'=>'2018-08-18T11:43:10','version'=>'1.80' }]},'Compress-LZ4'=>{'advisories'=>[{'affected_versions'=>'<0.20','description'=>'Outdated LZ4 source code with security issue on 32bit systems.
  ','distribution'=>'Compress-LZ4','fixed_versions'=>'>=0.20','id'=>'CPANSA-Compress-LZ4-2014-01','references'=>['https://metacpan.org/changes/distribution/Compress-LZ4','https://github.com/gray/compress-lz4/commit/fc503812b4cbba16429658e1dfe20ad8bbfd77a0' ],'reported'=>'2014-07-07' }],'main_module'=>'Compress::LZ4','versions'=>[{'date'=>'2012-02-11T16:33:26','version'=>'0.01' },{'date'=>'2012-02-20T21:26:48','version'=>'0.02' },{'date'=>'2012-03-02T04:47:50','version'=>'0.03' },{'date'=>'2012-03-18T07:09:30','version'=>'0.04' },{'date'=>'2012-03-18T19:45:25','version'=>'0.05' },{'date'=>'2012-03-22T09:23:45','version'=>'0.06' },{'date'=>'2012-03-22T16:12:43','version'=>'0.07' },{'date'=>'2012-03-23T16:29:14','version'=>'0.08' },{'date'=>'2012-03-23T17:27:12','version'=>'0.09' },{'date'=>'2012-03-26T11:28:24','version'=>'0.10' },{'date'=>'2012-04-03T21:36:24','version'=>'0.11' },{'date'=>'2012-04-04T12:55:22','version'=>'0.12' },{'date'=>'2012-06-01T18:55:41','version'=>'0.13' },{'date'=>'2012-08-10T00:21:56','version'=>'0.14' },{'date'=>'2012-08-11T16:37:53','version'=>'0.15' },{'date'=>'2012-09-08T18:18:41','version'=>'0.16' },{'date'=>'2013-03-19T00:39:07','version'=>'0.17' },{'date'=>'2013-11-19T00:56:57','version'=>'0.18' },{'date'=>'2014-02-08T00:35:09','version'=>'0.19' },{'date'=>'2014-07-07T21:08:49','version'=>'0.20' },{'date'=>'2015-05-12T19:01:36','version'=>'0.21' },{'date'=>'2015-05-20T06:16:53','version'=>'0.22' },{'date'=>'2016-07-25T20:45:05','version'=>'0.23' },{'date'=>'2017-03-23T04:34:45','version'=>'0.24' },{'date'=>'2017-04-06T16:38:31','version'=>'0.25' }]},'Compress-Raw-Bzip2'=>{'advisories'=>[{'affected_versions'=>'<2.031','cves'=>['VE-2010-0405' ],'description'=>'Integer overflow in the BZ2_decompress function in decompress.c in bzip2 and libbzip2 before 1.0.6 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted compressed file.
  ','distribution'=>'Compress-Raw-Bzip2','fixed_versions'=>'>=2.031','id'=>'CPANSA-Compress-Raw-Bzip2-2010-01','references'=>['https://metacpan.org/changes/distribution/Compress-Raw-Bzip2' ],'reported'=>'2010-01-27' }],'main_module'=>'Compress::Raw::Bzip2','versions'=>[{'date'=>'2006-03-13T16:14:00','version'=>'2.000_10' },{'date'=>'2006-04-15T21:23:09','version'=>'2.000_11' },{'date'=>'2006-05-17T12:43:30','version'=>'2.000_12' },{'date'=>'2006-06-20T12:43:47','version'=>'2.000_13' },{'date'=>'2006-10-26T14:15:45','version'=>'2.000_14' },{'date'=>'2006-11-01T10:35:27','version'=>'2.001' },{'date'=>'2006-12-29T20:40:23','version'=>'2.002' },{'date'=>'2007-01-02T13:03:45','version'=>'2.003' },{'date'=>'2007-03-03T15:50:04','version'=>'2.004' },{'date'=>'2007-07-01T00:06:51','version'=>'2.005' },{'date'=>'2007-09-01T19:44:48','version'=>'2.006' },{'date'=>'2007-11-10T11:59:25','version'=>'2.008' },{'date'=>'2008-04-20T14:41:25','version'=>'2.009' },{'date'=>'2008-05-05T17:18:15','version'=>'2.010' },{'date'=>'2008-05-17T11:16:17','version'=>'2.011' },{'date'=>'2008-07-15T22:23:56','version'=>'2.012' },{'date'=>'2008-09-02T20:20:05','version'=>'2.014' },{'date'=>'2008-09-03T20:47:15','version'=>'2.015' },{'date'=>'2009-04-04T09:47:36','version'=>'2.017' },{'date'=>'2009-05-03T16:26:57','version'=>'2.018' },{'date'=>'2009-05-04T09:42:06','version'=>'2.019' },{'date'=>'2009-06-03T17:48:18','version'=>'2.020' },{'date'=>'2009-08-30T20:25:24','version'=>'2.021' },{'date'=>'2009-11-09T23:25:19','version'=>'2.023' },{'date'=>'2010-01-09T17:56:12','version'=>'2.024' },{'date'=>'2010-03-28T12:56:33','version'=>'2.025' },{'date'=>'2010-04-07T19:49:29','version'=>'2.026' },{'date'=>'2010-04-24T19:15:32','version'=>'2.027' },{'date'=>'2010-07-24T14:29:17','version'=>'2.030' },{'date'=>'2010-09-21T19:44:52','version'=>'2.031' },{'date'=>'2011-01-06T11:26:00','version'=>'2.032' },{'date'=>'2011-01-11T14:02:05','version'=>'2.033' },{'date'=>'2011-05-02T21:50:15','version'=>'2.034' },{'date'=>'2011-05-07T08:30:09','version'=>'2.035' },{'date'=>'2011-06-18T21:45:13','version'=>'2.036' },{'date'=>'2011-06-22T07:17:56','version'=>'2.037' },{'date'=>'2011-10-28T14:27:59','version'=>'2.039' },{'date'=>'2011-10-28T22:18:59','version'=>'2.040' },{'date'=>'2011-11-17T23:44:58','version'=>'2.042' },{'date'=>'2011-11-20T21:31:34','version'=>'2.043' },{'date'=>'2011-12-03T22:48:47','version'=>'2.044' },{'date'=>'2011-12-04T19:19:58','version'=>'2.045' },{'date'=>'2012-01-28T23:26:44','version'=>'2.047' },{'date'=>'2012-01-29T16:58:55','version'=>'2.048' },{'date'=>'2012-02-18T15:56:34','version'=>'2.049' },{'date'=>'2012-04-29T12:40:06','version'=>'2.052' },{'date'=>'2012-08-05T20:35:37','version'=>'2.055' },{'date'=>'2012-11-10T19:08:29','version'=>'2.057' },{'date'=>'2012-11-12T22:14:16','version'=>'2.058' },{'date'=>'2012-11-25T13:38:19','version'=>'2.059' },{'date'=>'2013-01-07T20:02:08','version'=>'2.060' },{'date'=>'2013-05-27T09:54:30','version'=>'2.061' },{'date'=>'2013-08-12T19:06:20','version'=>'2.062' },{'date'=>'2013-11-02T17:14:54','version'=>'2.063' },{'date'=>'2014-02-01T23:19:50','version'=>'2.064' },{'date'=>'2014-09-21T12:40:58','version'=>'2.066' },{'date'=>'2014-12-08T15:12:21','version'=>'2.067' },{'date'=>'2014-12-23T17:44:34','version'=>'2.068' },{'date'=>'2015-09-27T14:33:57','version'=>'2.069' },{'date'=>'2016-12-28T23:07:42','version'=>'2.070' },{'date'=>'2017-02-12T20:39:20','version'=>'2.072' },{'date'=>'2017-02-19T20:35:17','version'=>'2.073' },{'date'=>'2017-02-19T22:11:17','version'=>'2.074' },{'date'=>'2018-04-03T18:20:04','version'=>'2.080' },{'date'=>'2018-04-08T15:01:21','version'=>'2.081' },{'date'=>'2018-12-30T22:38:05','version'=>'2.083' },{'date'=>'2019-01-06T08:56:52','version'=>'2.084' }]},'Compress-Raw-Zlib'=>{'advisories'=>[{'affected_versions'=>'<2.075','cves'=>['CVE-2016-9843','CVE-2016-9841','CVE-2016-9840','CVE-2016-9842' ],'description'=>'Zlib vulnerabilities.
  ','distribution'=>'Compress-Raw-Zlib','fixed_versions'=>'>=2.075','id'=>'CPANSA-Compress-Raw-Zlib-2017-01','references'=>['https://metacpan.org/changes/distribution/Compress-Raw-Zlib' ],'reported'=>'2017-11-14' }],'main_module'=>'Compress::Raw::Zlib','versions'=>[{'date'=>'2006-03-03T23:06:38','version'=>'2.000_09' },{'date'=>'2006-03-13T16:14:20','version'=>'2.000_10' },{'date'=>'2006-04-15T21:23:24','version'=>'2.000_11' },{'date'=>'2006-05-17T12:43:41','version'=>'2.000_12' },{'date'=>'2006-06-20T12:45:30','version'=>'2.000_13' },{'date'=>'2006-10-26T14:15:34','version'=>'2.000_09' },{'date'=>'2006-11-01T10:35:38','version'=>'2.001' },{'date'=>'2006-12-29T20:40:35','version'=>'2.002' },{'date'=>'2007-01-02T13:03:57','version'=>'2.003' },{'date'=>'2007-03-03T15:50:15','version'=>'2.004' },{'date'=>'2007-07-01T00:07:02','version'=>'2.005' },{'date'=>'2007-09-01T19:44:59','version'=>'2.006' },{'date'=>'2007-11-10T11:59:36','version'=>'2.008' },{'date'=>'2008-04-20T14:42:52','version'=>'2.009' },{'date'=>'2008-05-05T17:18:27','version'=>'2.010' },{'date'=>'2008-05-17T11:16:28','version'=>'2.011' },{'date'=>'2008-07-15T22:24:07','version'=>'2.012' },{'date'=>'2008-09-02T20:20:16','version'=>'2.014' },{'date'=>'2008-09-03T20:47:27','version'=>'2.015' },{'date'=>'2009-04-04T09:49:03','version'=>'2.017' },{'date'=>'2009-05-03T16:27:08','version'=>'2.018' },{'date'=>'2009-05-04T09:42:17','version'=>'2.019' },{'date'=>'2009-06-03T17:48:30','version'=>'2.020' },{'date'=>'2009-08-30T20:25:35','version'=>'2.021' },{'date'=>'2009-11-09T23:26:59','version'=>'2.023' },{'date'=>'2010-01-09T17:56:35','version'=>'2.024' },{'date'=>'2010-03-28T12:57:08','version'=>'2.025' },{'date'=>'2010-04-07T19:51:09','version'=>'2.026' },{'date'=>'2010-04-24T19:15:54','version'=>'2.027' },{'date'=>'2010-07-24T14:31:01','version'=>'2.030' },{'date'=>'2011-01-06T11:23:45','version'=>'2.032' },{'date'=>'2011-01-11T14:03:45','version'=>'2.033' },{'date'=>'2011-05-02T22:05:37','version'=>'2.034' },{'date'=>'2011-05-07T08:31:57','version'=>'2.035' },{'date'=>'2011-06-18T21:45:36','version'=>'2.036' },{'date'=>'2011-06-22T07:18:22','version'=>'2.037' },{'date'=>'2011-10-28T14:28:35','version'=>'2.039' },{'date'=>'2011-10-28T22:20:38','version'=>'2.040' },{'date'=>'2011-11-17T23:45:21','version'=>'2.042' },{'date'=>'2011-11-20T21:33:33','version'=>'2.043' },{'date'=>'2011-12-03T22:49:10','version'=>'2.044' },{'date'=>'2011-12-04T19:21:36','version'=>'2.045' },{'date'=>'2012-01-28T23:28:28','version'=>'2.047' },{'date'=>'2012-01-29T17:00:33','version'=>'2.048' },{'date'=>'2012-02-18T15:58:12','version'=>'2.049' },{'date'=>'2012-02-21T19:35:18','version'=>'2.050' },{'date'=>'2012-02-22T20:43:23','version'=>'2.051' },{'date'=>'2012-04-29T12:41:57','version'=>'2.052' },{'date'=>'2012-05-06T08:40:06','version'=>'2.053' },{'date'=>'2012-05-08T19:22:47','version'=>'2.054' },{'date'=>'2012-08-05T20:36:06','version'=>'2.055' },{'date'=>'2012-08-10T22:20:09','version'=>'2.056' },{'date'=>'2012-11-10T19:08:56','version'=>'2.057' },{'date'=>'2012-11-12T22:14:42','version'=>'2.058' },{'date'=>'2012-11-25T13:38:42','version'=>'2.059' },{'date'=>'2013-01-07T20:02:22','version'=>'2.060' },{'date'=>'2013-05-27T09:54:54','version'=>'2.061' },{'date'=>'2013-08-12T19:08:05','version'=>'2.062' },{'date'=>'2013-11-02T17:15:17','version'=>'2.063' },{'date'=>'2014-02-01T23:21:28','version'=>'2.064' },{'date'=>'2014-02-03T20:23:00','version'=>'2.065' },{'date'=>'2014-09-21T12:42:35','version'=>'2.066' },{'date'=>'2014-12-08T15:14:00','version'=>'2.067' },{'date'=>'2014-12-23T17:44:57','version'=>'2.068' },{'date'=>'2015-09-26T18:41:58','version'=>'2.069' },{'date'=>'2016-12-28T23:09:21','version'=>'2.070' },{'date'=>'2016-12-30T22:58:08','version'=>'2.071' },{'date'=>'2017-02-12T20:41:25','version'=>'2.072' },{'date'=>'2017-02-19T20:37:20','version'=>'2.073' },{'date'=>'2017-02-19T22:11:41','version'=>'2.074' },{'date'=>'2017-11-14T15:43:26','version'=>'2.075' },{'date'=>'2017-11-21T22:29:23','version'=>'2.076' },{'date'=>'2018-04-03T18:22:06','version'=>'2.080' },{'date'=>'2018-04-08T15:02:55','version'=>'2.081' },{'date'=>'2018-12-30T22:40:08','version'=>'2.083' },{'date'=>'2019-01-06T08:57:15','version'=>'2.084' }]},'Config-Model'=>{'advisories'=>[{'affected_versions'=>'<2.102','cves'=>['CVE-2017-0373' ],'description'=>'The gen_class_pod implementation in lib/Config/Model/Utils/GenClassPod.pm in Config-Model (aka libconfig-model-perl) before 2.102 has a dangerous "use lib" line, which allows remote attackers to have an unspecified impact via a crafted Debian package file.
  ','distribution'=>'Config-Model','fixed_versions'=>'>=2.102','id'=>'CPANSA-Config-Model-2017-03','references'=>['https://metacpan.org/changes/distribution/Config-Model','https://github.com/dod38fr/config-model/commit/9bd64d9ec6c0939166a2216a37d58dd19a725951' ],'reported'=>'2017-05-10' },{'affected_versions'=>'<2.102','cves'=>['CVE-2017-0374' ],'description'=>'Loads models from a local directory, making it possible to substitute the model.
  ','distribution'=>'Config-Model','fixed_versions'=>'>=2.102','id'=>'CPANSA-Config-Model-2017-02','references'=>['https://metacpan.org/changes/distribution/Config-Model','https://github.com/dod38fr/config-model/commit/4d37c75b0c4f9633b67999f8260b08027a6bc524' ],'reported'=>'2017-05-10' },{'affected_versions'=>'<2.102','description'=>'YAML or YAML::XS can be loaded automatically making it possible to run arbitrary code loading a specially crafted YAML file.
  ','distribution'=>'Config-Model','fixed_versions'=>'>=2.102','id'=>'CPANSA-Config-Model-2017-01','references'=>['https://metacpan.org/changes/distribution/Config-Model','https://github.com/dod38fr/config-model/commit/01d212348bfbadf31bd74aadd26b1e391ff2fd92' ],'reported'=>'2017-05-10' }],'main_module'=>'Config::Model','versions'=>[{'date'=>'2006-04-21T12:27:44','version'=>'0.505' },{'date'=>'2006-05-19T13:32:14','version'=>'0.506' },{'date'=>'2006-06-15T12:10:38','version'=>'0.507' },{'date'=>'2006-07-20T12:28:36','version'=>'0.601' },{'date'=>'2006-09-07T12:06:17','version'=>'0.602' },{'date'=>'2006-10-19T11:24:40','version'=>'0.603' },{'date'=>'2006-12-06T12:58:35','version'=>'0.604' },{'date'=>'2007-01-08T13:16:42','version'=>'0.605' },{'date'=>'2007-01-11T12:42:09','version'=>'0.606' },{'date'=>'2007-01-12T13:06:38','version'=>'0.607' },{'date'=>'2007-02-23T13:00:34','version'=>'0.608' },{'date'=>'2007-05-14T11:41:18','version'=>'0.609' },{'date'=>'2007-06-06T12:28:06','version'=>'0.610' },{'date'=>'2007-07-03T15:35:21','version'=>'0.611' },{'date'=>'2007-07-27T11:38:57','version'=>'0.612' },{'date'=>'2007-10-01T15:52:56','version'=>'0.613' },{'date'=>'2007-10-23T16:10:29','version'=>'0.614' },{'date'=>'2007-11-15T12:36:18','version'=>'0.615' },{'date'=>'2007-12-04T12:41:22','version'=>'0.616' },{'date'=>'2008-01-28T11:55:50','version'=>'0.617' },{'date'=>'2008-02-14T12:56:25','version'=>'0.618' },{'date'=>'2008-02-29T12:08:41','version'=>'0.619' },{'date'=>'2008-03-18T17:40:57','version'=>'0.620' },{'date'=>'2008-03-20T07:49:00','version'=>'0.6201' },{'date'=>'2008-04-04T11:38:49','version'=>'0.621' },{'date'=>'2008-04-25T16:23:31','version'=>'0.622' },{'date'=>'2008-05-19T11:47:46','version'=>'0.623' },{'date'=>'2008-07-25T11:35:07','version'=>'0.624' },{'date'=>'2008-07-30T12:02:43','version'=>'0.625' },{'date'=>'2008-09-22T12:20:00','version'=>'0.626' },{'date'=>'2008-09-23T11:05:58','version'=>'0.627' },{'date'=>'2008-09-29T12:35:05','version'=>'0.628' },{'date'=>'2008-10-13T15:09:27','version'=>'0.629' },{'date'=>'2008-10-21T11:59:27','version'=>'0.630' },{'date'=>'2008-11-10T14:37:44','version'=>'0.631' },{'date'=>'2008-12-16T13:32:26','version'=>'0.632' },{'date'=>'2008-12-23T15:36:48','version'=>'0.633' },{'date'=>'2009-03-05T13:06:32','version'=>'0.634' },{'date'=>'2009-04-20T12:21:46','version'=>'0.635' },{'date'=>'2009-05-30T16:19:54','version'=>'0.636' },{'date'=>'2009-06-23T12:07:41','version'=>'0.637' },{'date'=>'2009-06-30T11:31:35','version'=>'0.638' },{'date'=>'2009-09-08T11:35:25','version'=>'0.639' },{'date'=>'2009-09-09T16:10:41','version'=>'0.640' },{'date'=>'2010-01-20T17:30:14','version'=>'0.641' },{'date'=>'2010-01-21T17:17:34','version'=>'0.642' },{'date'=>'2010-02-25T13:04:52','version'=>'0.643' },{'date'=>'2010-03-12T15:24:45','version'=>'0.644' },{'date'=>'2010-03-28T14:53:46','version'=>'1.001' },{'date'=>'2010-04-22T12:22:00','version'=>'1.202' },{'date'=>'2010-06-03T11:09:45','version'=>'1.203' },{'date'=>'2010-06-03T11:20:09','version'=>'1.204' },{'date'=>'2010-06-07T16:04:03','version'=>'1.205' },{'date'=>'2010-08-13T10:53:09','version'=>'1.206' },{'date'=>'2010-09-14T16:14:40','version'=>'1.207' },{'date'=>'2010-09-16T11:46:11','version'=>'1.208' },{'date'=>'2010-09-20T12:29:12','version'=>'1.209' },{'date'=>'2010-09-30T16:34:27','version'=>'1.210' },{'date'=>'2010-10-08T10:46:45','version'=>'1.211' },{'date'=>'2010-10-15T11:08:52','version'=>'1.212' },{'date'=>'2010-10-19T12:29:03','version'=>'1.213' },{'date'=>'2010-10-19T15:17:01','version'=>'1.214' },{'date'=>'2010-10-19T15:28:56','version'=>'1.215' },{'date'=>'2010-10-26T12:16:51','version'=>'1.216' },{'date'=>'2010-10-30T12:44:11','version'=>'1.217' },{'date'=>'2010-11-05T11:53:14','version'=>'1.218' },{'date'=>'2010-11-09T13:20:51','version'=>'1.219' },{'date'=>'2010-11-10T08:41:22','version'=>'1.220' },{'date'=>'2010-11-21T17:40:10','version'=>'1.221' },{'date'=>'2010-11-22T14:01:55','version'=>'1.222' },{'date'=>'2010-11-28T17:34:03','version'=>'1.223' },{'date'=>'2010-12-06T13:18:53','version'=>'1.224' },{'date'=>'2010-12-07T08:01:43','version'=>'1.225' },{'date'=>'2010-12-08T18:48:08','version'=>'1.226' },{'date'=>'2011-01-07T18:12:45','version'=>'1.227' },{'date'=>'2011-01-09T12:27:15','version'=>'1.228' },{'date'=>'2011-01-10T19:57:53','version'=>'1.229' },{'date'=>'2011-01-20T16:47:27','version'=>'1.230' },{'date'=>'2011-01-30T11:30:23','version'=>'1.231' },{'date'=>'2011-01-30T13:51:34','version'=>'1.232' },{'date'=>'2011-02-11T12:25:32','version'=>'1.233' },{'date'=>'2011-02-21T17:11:22','version'=>'1.234' },{'date'=>'2011-03-01T13:06:28','version'=>'1.235' },{'date'=>'2011-04-01T14:09:03','version'=>'1.236' },{'date'=>'2011-04-04T12:57:04','version'=>'1.237' },{'date'=>'2011-04-05T14:45:45','version'=>'1.238' },{'date'=>'2011-04-05T17:40:17','version'=>'1.240' },{'date'=>'2011-04-07T18:09:49','version'=>'1.241' },{'date'=>'2011-04-25T15:28:14','version'=>'1.242' },{'date'=>'2011-05-02T12:33:33','version'=>'1.243' },{'date'=>'2011-05-16T15:52:46','version'=>'1.244' },{'date'=>'2011-06-17T12:10:22','version'=>'1.245' },{'date'=>'2011-06-20T12:32:24','version'=>'1.246' },{'date'=>'2011-06-27T14:14:52','version'=>'1.247' },{'date'=>'2011-07-05T15:48:52','version'=>'1.248' },{'date'=>'2011-07-12T09:54:39','version'=>'1.249' },{'date'=>'2011-07-22T12:40:47','version'=>'1.250' },{'date'=>'2011-08-30T12:16:32','version'=>'1.251' },{'date'=>'2011-09-01T16:06:19','version'=>'1.252' },{'date'=>'2011-09-02T16:03:35','version'=>'1.253' },{'date'=>'2011-09-04T15:21:52','version'=>'1.254' },{'date'=>'2011-09-15T15:23:39','version'=>'1.255' },{'date'=>'2011-09-16T12:28:51','version'=>'1.256' },{'date'=>'2011-09-23T10:52:00','version'=>'1.257' },{'date'=>'2011-10-14T14:45:06','version'=>'1.258' },{'date'=>'2011-10-16T10:17:53','version'=>'1.259' },{'date'=>'2011-10-28T13:28:02','version'=>'1.260' },{'date'=>'2011-11-18T17:02:26','version'=>'1.261' },{'date'=>'2011-11-19T11:55:30','version'=>'1.262' },{'date'=>'2011-11-29T15:43:38','version'=>'1.263' },{'date'=>'2011-11-30T07:50:25','version'=>'1.264' },{'date'=>'2011-12-06T18:26:54','version'=>'1.265' },{'date'=>'2012-02-06T11:55:29','version'=>'2.001' },{'date'=>'2012-02-08T09:49:49','version'=>'2.002' },{'date'=>'2012-02-08T13:14:22','version'=>'2.003' },{'date'=>'2012-02-09T11:28:18','version'=>'2.004' },{'date'=>'2012-02-23T18:25:32','version'=>'2.005' },{'date'=>'2012-02-25T11:30:41','version'=>'2.006' },{'date'=>'2012-02-26T16:34:50','version'=>'2.007' },{'date'=>'2012-03-01T12:40:23','version'=>'2.008' },{'date'=>'2012-03-13T13:11:49','version'=>'2.009' },{'date'=>'2012-03-13T13:15:03','version'=>'2.010' },{'date'=>'2012-03-19T21:41:44','version'=>'2.011' },{'date'=>'2012-04-05T11:41:54','version'=>'2.012' },{'date'=>'2012-04-06T12:10:46','version'=>'2.013' },{'date'=>'2012-05-04T13:57:13','version'=>'2.014' },{'date'=>'2012-05-14T10:06:13','version'=>'2.015' },{'date'=>'2012-05-20T08:38:36','version'=>'2.016' },{'date'=>'2012-05-21T10:56:35','version'=>'2.017' },{'date'=>'2012-05-29T13:53:06','version'=>'2.018' },{'date'=>'2012-06-05T12:34:15','version'=>'2.019' },{'date'=>'2012-06-18T08:34:26','version'=>'2.020' },{'date'=>'2012-06-27T14:44:55','version'=>'2.021_01' },{'date'=>'2012-06-28T15:30:52','version'=>'2.021' },{'date'=>'2012-07-03T14:47:31','version'=>'2.022' },{'date'=>'2012-07-04T13:50:37','version'=>'2.023' },{'date'=>'2012-09-04T11:30:02','version'=>'2.024' },{'date'=>'2012-09-10T10:52:02','version'=>'2.025' },{'date'=>'2012-09-20T17:12:09','version'=>'2.026_1' },{'date'=>'2012-09-21T10:38:47','version'=>'2.026_2' },{'date'=>'2012-09-27T11:53:42','version'=>'2.026' },{'date'=>'2012-10-30T12:48:16','version'=>'2.027' },{'date'=>'2012-11-27T12:44:55','version'=>'2.028' },{'date'=>'2012-11-28T13:31:04','version'=>'2.029' },{'date'=>'2013-02-27T18:37:05','version'=>'2.030_01' },{'date'=>'2013-03-23T09:47:53','version'=>'2.030' },{'date'=>'2013-04-03T17:22:28','version'=>'2.031' },{'date'=>'2013-04-15T11:28:33','version'=>'2.032' },{'date'=>'2013-04-15T19:27:14','version'=>'2.033' },{'date'=>'2013-04-17T19:29:52','version'=>'2.034' },{'date'=>'2013-04-27T15:05:09','version'=>'2.035' },{'date'=>'2013-05-25T17:53:04','version'=>'2.036' },{'date'=>'2013-06-15T17:46:45','version'=>'2.037' },{'date'=>'2013-07-03T19:30:32','version'=>'2.038' },{'date'=>'2013-07-18T18:12:07','version'=>'2.039' },{'date'=>'2013-07-20T09:46:11','version'=>'2.040' },{'date'=>'2013-08-14T17:58:40','version'=>'2.041' },{'date'=>'2013-09-15T17:41:45','version'=>'2.042' },{'date'=>'2013-09-20T17:35:06','version'=>'2.043' },{'date'=>'2013-10-13T16:02:40','version'=>'2.044' },{'date'=>'2013-10-18T17:48:15','version'=>'2.045' },{'date'=>'2013-12-15T13:07:37','version'=>'2.046' },{'date'=>'2014-01-25T15:54:37','version'=>'2.047' },{'date'=>'2014-02-23T18:02:19','version'=>'2.048' },{'date'=>'2014-02-26T19:45:44','version'=>'2.049' },{'date'=>'2014-02-27T18:12:32','version'=>'2.050' },{'date'=>'2014-03-06T18:23:11','version'=>'2.051' },{'date'=>'2014-03-23T16:20:43','version'=>'2.052' },{'date'=>'2014-03-25T19:11:57','version'=>'2.053' },{'date'=>'2014-04-01T17:51:50','version'=>'2.054' },{'date'=>'2014-05-02T11:33:28','version'=>'2.055' },{'date'=>'2014-05-18T19:34:53','version'=>'2.056' },{'date'=>'2014-06-12T19:32:47','version'=>'2.057' },{'date'=>'2014-06-19T19:43:18','version'=>'2.058' },{'date'=>'2014-06-29T15:08:02','version'=>'2.059' },{'date'=>'2014-08-19T12:43:59','version'=>'2.060' },{'date'=>'2014-09-23T19:21:04','version'=>'2.061' },{'date'=>'2014-11-23T19:45:05','version'=>'2.062' },{'date'=>'2014-11-28T17:55:21','version'=>'2.063' },{'date'=>'2014-12-04T18:47:05','version'=>'2.064' },{'date'=>'2015-01-06T20:16:15','version'=>'2.065' },{'date'=>'2015-02-15T16:13:00','version'=>'2.066' },{'date'=>'2015-03-01T18:38:28','version'=>'2.067' },{'date'=>'2015-03-29T13:39:56','version'=>'2.068' },{'date'=>'2015-04-25T19:29:15','version'=>'2.069' },{'date'=>'2015-05-03T14:00:52','version'=>'2.070' },{'date'=>'2015-05-23T11:15:16','version'=>'2.071' },{'date'=>'2015-07-18T19:31:43','version'=>'2.072' },{'date'=>'2015-07-19T07:35:51','version'=>'2.073' },{'date'=>'2015-09-30T18:56:39','version'=>'2.074' },{'date'=>'2015-11-22T20:11:19','version'=>'2.075' },{'date'=>'2016-01-14T18:13:20','version'=>'2.076' },{'date'=>'2016-01-20T19:55:36','version'=>'2.077' },{'date'=>'2016-01-24T18:48:46','version'=>'2.078' },{'date'=>'2016-02-12T20:44:28','version'=>'2.079' },{'date'=>'2016-02-27T17:59:55','version'=>'2.080' },{'date'=>'2016-02-29T19:01:45','version'=>'2.081' },{'date'=>'2016-03-29T18:22:30','version'=>'2.082' },{'date'=>'2016-04-20T18:32:29','version'=>'2.083' },{'date'=>'2016-05-26T17:35:53','version'=>'2.084' },{'date'=>'2016-05-29T17:13:14','version'=>'2.085' },{'date'=>'2016-06-04T19:28:08','version'=>'2.086' },{'date'=>'2016-06-29T17:35:35','version'=>'2.087' },{'date'=>'2016-07-09T18:06:03','version'=>'2.088' },{'date'=>'2016-09-04T13:17:52','version'=>'2.089' },{'date'=>'2016-09-10T16:07:07','version'=>'2.090' },{'date'=>'2016-09-13T17:05:56','version'=>'2.091' },{'date'=>'2016-09-23T17:46:04','version'=>'2.092' },{'date'=>'2016-11-08T18:33:39','version'=>'2.093' },{'date'=>'2016-11-09T18:23:05','version'=>'2.094' },{'date'=>'2016-12-06T18:01:00','version'=>'2.095' },{'date'=>'2016-12-11T20:28:14','version'=>'2.096' },{'date'=>'2016-12-22T17:35:34','version'=>'2.097' },{'date'=>'2017-02-26T18:58:23','version'=>'2.098' },{'date'=>'2017-03-05T17:09:37','version'=>'2.099' },{'date'=>'2017-03-18T12:06:34','version'=>'2.100' },{'date'=>'2017-04-28T17:40:56','version'=>'2.101' },{'date'=>'2017-05-14T19:10:40','version'=>'2.102' },{'date'=>'2017-05-25T08:15:17','version'=>'2.103' },{'date'=>'2017-06-03T13:23:33','version'=>'2.104' },{'date'=>'2017-06-09T17:26:55','version'=>'2.105' },{'date'=>'2017-07-16T14:07:23','version'=>'2.106' },{'date'=>'2017-08-30T19:12:10','version'=>'2.107' },{'date'=>'2017-08-31T17:23:43','version'=>'2.108' },{'date'=>'2017-09-18T17:52:57','version'=>'2.109' },{'date'=>'2017-09-21T19:12:32','version'=>'2.110' },{'date'=>'2017-09-22T18:41:04','version'=>'2.111' },{'date'=>'2017-10-01T09:12:45','version'=>'2.112' },{'date'=>'2017-10-12T19:07:46','version'=>'2.113' },{'date'=>'2017-11-11T16:35:03','version'=>'2.114' },{'date'=>'2017-12-14T18:03:18','version'=>'2.115' },{'date'=>'2017-12-16T09:52:09','version'=>'2.116' },{'date'=>'2018-02-03T18:09:35','version'=>'2.117' },{'date'=>'2018-03-26T18:33:19','version'=>'2.118' },{'date'=>'2018-04-02T16:55:50','version'=>'2.119' },{'date'=>'2018-04-08T07:56:03','version'=>'2.120' },{'date'=>'2018-04-15T17:08:18','version'=>'2.121' },{'date'=>'2018-04-17T17:20:14','version'=>'2.122' },{'date'=>'2018-05-01T17:18:09','version'=>'2.123' },{'date'=>'2018-06-09T17:16:59','version'=>'2.124' },{'date'=>'2018-06-24T12:47:24','version'=>'2.125' },{'date'=>'2018-08-20T13:10:09','version'=>'2.126' },{'date'=>'2018-09-30T16:44:13','version'=>'2.127' },{'date'=>'2018-11-21T19:33:41','version'=>'2.128' },{'date'=>'2018-12-05T18:44:58','version'=>'2.129' },{'date'=>'2018-12-07T19:02:10','version'=>'2.130' },{'date'=>'2018-12-16T18:32:58','version'=>'2.131' },{'date'=>'2018-12-22T17:50:27','version'=>'2.132' },{'date'=>'2019-01-13T20:17:07','version'=>'2.133' }]},'Cpanel-JSON-XS'=>{'advisories'=>[{'affected_versions'=>'<3.0225','description'=>'Overflow during processing of ill-formed UTF-8 strings.
  ','distribution'=>'Cpanel-JSON-XS','fixed_versions'=>'>=3.0225','id'=>'CPANSA-Cpanel-JSON-XS-2016-02','references'=>['https://metacpan.org/changes/distribution/Cpanel-JSON-XS','https://github.com/rurban/Cpanel-JSON-XS/commit/f71768984ba7f50b0476c17a4f3b3f2ca88a6951','https://github.com/dankogai/p5-encode/issues/64' ],'reported'=>'2016-11-23' },{'affected_versions'=>'<3.0218','description'=>'Possible overflows in av and hv length types.
  ','distribution'=>'Cpanel-JSON-XS','fixed_versions'=>'>=3.0218','id'=>'CPANSA-Cpanel-JSON-XS-2016-01','references'=>['https://metacpan.org/changes/distribution/Cpanel-JSON-XS','https://github.com/rurban/Cpanel-JSON-XS/commit/6554531b39fac236321d8601d35eaaa75ae45e20' ],'reported'=>'2016-10-06' }],'main_module'=>'Cpanel::JSON::XS','versions'=>[{'date'=>'2013-03-01T00:52:41','version'=>'2.33_03' },{'date'=>'2013-03-01T22:07:06','version'=>'2.33_04' },{'date'=>'2013-03-27T16:53:34','version'=>'2.3305' },{'date'=>'2013-03-27T17:17:51','version'=>'2.3306' },{'date'=>'2013-03-27T22:58:47','version'=>'2.3307' },{'date'=>'2013-03-28T14:28:56','version'=>'2.3308' },{'date'=>'2013-03-28T15:12:42','version'=>'2.3309' },{'date'=>'2013-03-28T17:33:21','version'=>'2.3310' },{'date'=>'2013-06-26T16:24:40','version'=>'2.3313' },{'date'=>'2013-09-09T05:54:40','version'=>'2.3314' },{'date'=>'2013-10-02T20:06:47','version'=>'2.3401' },{'date'=>'2013-11-02T14:42:20','version'=>'2.3402' },{'date'=>'2013-11-02T15:17:41','version'=>'2.3403' },{'date'=>'2014-01-30T15:58:58','version'=>'2.3404' },{'date'=>'2014-04-15T21:17:11','version'=>'3.0101' },{'date'=>'2014-04-17T18:37:34','version'=>'3.0102' },{'date'=>'2014-04-21T17:49:09','version'=>'3.0103' },{'date'=>'2014-04-26T16:04:39','version'=>'3.0104' },{'date'=>'2014-11-06T10:38:31','version'=>'3.0105' },{'date'=>'2014-11-11T21:57:49','version'=>'3.0106' },{'date'=>'2014-11-28T12:16:29','version'=>'3.0107' },{'date'=>'2014-12-11T17:02:07','version'=>'3.0108' },{'date'=>'2014-12-12T10:24:33','version'=>'3.0109' },{'date'=>'2014-12-12T22:35:37','version'=>'3.0110' },{'date'=>'2014-12-13T18:40:06','version'=>'3.0111' },{'date'=>'2014-12-14T16:34:01','version'=>'3.0112' },{'date'=>'2014-12-15T12:23:32','version'=>'3.0113' },{'date'=>'2015-01-04T14:06:03','version'=>'3.0114' },{'date'=>'2015-01-31T21:42:51','version'=>'3.0115' },{'date'=>'2015-11-26T08:58:33','version'=>'3.0201' },{'date'=>'2015-11-26T13:16:40','version'=>'3.0202' },{'date'=>'2015-11-26T13:42:02','version'=>'3.0203' },{'date'=>'2015-11-26T22:30:26','version'=>'3.0204' },{'date'=>'2015-11-29T14:09:00','version'=>'3.0205' },{'date'=>'2015-11-30T16:16:48','version'=>'3.0206' },{'date'=>'2015-12-02T16:34:35','version'=>'3.0207' },{'date'=>'2015-12-02T22:46:58','version'=>'3.0208' },{'date'=>'2015-12-03T09:45:04','version'=>'3.0209' },{'date'=>'2015-12-03T11:59:24','version'=>'3.0210' },{'date'=>'2016-01-10T17:38:25','version'=>'3.0211' },{'date'=>'2016-02-27T13:30:04','version'=>'3.0212' },{'date'=>'2016-03-02T10:28:37','version'=>'3.0213' },{'date'=>'2016-04-12T08:40:05','version'=>'3.0213_01' },{'date'=>'2016-04-13T10:40:03','version'=>'3.0213_02' },{'date'=>'2016-06-02T16:18:51','version'=>'3.0214' },{'date'=>'2016-06-06T13:28:49','version'=>'3.0215' },{'date'=>'2016-06-12T12:14:20','version'=>'3.0216' },{'date'=>'2016-06-18T09:59:27','version'=>'3.0217' },{'date'=>'2016-10-04T10:11:33','version'=>'3.0217_01' },{'date'=>'2016-10-04T14:47:29','version'=>'3.0217_02' },{'date'=>'2016-10-06T08:46:17','version'=>'3.0217_03' },{'date'=>'2016-10-07T12:11:03','version'=>'3.0217_04' },{'date'=>'2016-10-07T17:22:48','version'=>'3.0217_05' },{'date'=>'2016-10-08T08:01:50','version'=>'3.0217_06' },{'date'=>'2016-10-13T12:47:31','version'=>'3.0218' },{'date'=>'2016-10-26T11:45:35','version'=>'3.0219' },{'date'=>'2016-10-28T08:34:28','version'=>'3.0220' },{'date'=>'2016-10-30T12:27:36','version'=>'3.0221' },{'date'=>'2016-10-30T15:04:32','version'=>'3.0222' },{'date'=>'2016-11-16T11:47:38','version'=>'3.0223' },{'date'=>'2016-11-20T11:31:34','version'=>'3.0224' },{'date'=>'2016-11-23T18:43:00','version'=>'3.0225' },{'date'=>'2017-02-11T13:24:48','version'=>'3.0226' },{'date'=>'2017-02-13T10:57:06','version'=>'3.0227' },{'date'=>'2017-03-07T23:57:39','version'=>'3.0228' },{'date'=>'2017-03-10T14:08:07','version'=>'3.0229' },{'date'=>'2017-03-12T09:52:13','version'=>'3.0230' },{'date'=>'2017-03-29T09:51:51','version'=>'3.0231' },{'date'=>'2017-05-01T05:35:12','version'=>'3.0232' },{'date'=>'2017-05-01T14:54:56','version'=>'3.0233' },{'date'=>'2017-07-27T15:43:41','version'=>'3.0234' },{'date'=>'2017-07-27T16:21:47','version'=>'3.0235' },{'date'=>'2017-07-27T20:15:25','version'=>'3.0236' },{'date'=>'2017-07-28T11:15:05','version'=>'3.0237' },{'date'=>'2017-08-25T20:53:56','version'=>'3.0238' },{'date'=>'2017-08-28T20:48:37','version'=>'3.0239' },{'date'=>'2018-01-30T11:52:27','version'=>'3.99_01' },{'date'=>'2018-01-31T12:58:24','version'=>'3.99_02' },{'date'=>'2018-01-31T17:18:58','version'=>'3.99_03' },{'date'=>'2018-02-02T01:57:54','version'=>'4.00' },{'date'=>'2018-02-03T11:50:36','version'=>'4.01' },{'date'=>'2018-02-27T16:08:55','version'=>'4.02' },{'date'=>'2018-06-21T11:16:14','version'=>'4.03' },{'date'=>'2018-06-22T17:37:07','version'=>'4.04' },{'date'=>'2018-08-19T16:55:22','version'=>'4.05' },{'date'=>'2018-08-23T07:50:22','version'=>'4.06' },{'date'=>'2018-11-02T09:51:34','version'=>'4.07' },{'date'=>'2018-11-28T14:26:40','version'=>'4.08' },{'date'=>'2019-02-15T10:09:53','version'=>'4.09' }]},'Crypt-CBC'=>{'advisories'=>[{'affected_versions'=>'<2.17','description'=>'Incorrect use of using 8 byte IVs when generating the old-style RandomIV style header. This affects data encrypted using the Rijndael algorithm, which has a 16 byte blocksize, and is a significant security issue.
  ','distribution'=>'Crypt-CBC','fixed_versions'=>'>=2.17','id'=>'CPANSA-Crypt-CBC-2006-01','references'=>['https://metacpan.org/changes/distribution/Crypt-CBC' ],'reported'=>'2006-01-09','severity'=>'high' }],'main_module'=>'Crypt::CBC','versions'=>[{'date'=>'1998-06-19T19:48:52','version'=>'1.00' },{'date'=>'1998-09-22T18:30:35','version'=>'1.10' },{'date'=>'1998-12-20T23:36:49','version'=>'1.20' },{'date'=>'2000-01-27T00:27:56','version'=>'1.22' },{'date'=>'2000-02-22T15:20:56','version'=>'1.23' },{'date'=>'2000-06-07T18:55:59','version'=>'1.24' },{'date'=>'2000-06-08T15:59:07','version'=>'1.25' },{'date'=>'2001-12-10T17:16:25','version'=>'2.01' },{'date'=>'2002-01-24T05:30:16','version'=>'2.02' },{'date'=>'2002-06-02T18:40:15','version'=>'2.03' },{'date'=>'2002-06-12T02:20:51','version'=>'2.04' },{'date'=>'2002-06-22T13:02:09','version'=>'2.05' },{'date'=>'2002-08-08T18:47:49','version'=>'2.07' },{'date'=>'2002-09-11T12:17:23','version'=>'2.08' },{'date'=>'2004-05-27T15:20:52','version'=>'2.09' },{'date'=>'2004-05-29T17:29:19','version'=>'2.10' },{'date'=>'2004-06-03T16:22:32','version'=>'2.11' },{'date'=>'2004-06-17T15:55:19','version'=>'2.11' },{'date'=>'2005-05-05T20:11:50','version'=>'2.14' },{'date'=>'2005-08-01T14:02:45','version'=>'2.15' },{'date'=>'2006-02-16T14:08:57','version'=>'2.17' },{'date'=>'2006-06-06T23:22:02','version'=>'2.18' },{'date'=>'2006-08-12T19:52:11','version'=>'2.19' },{'date'=>'2006-10-16T23:40:13','version'=>'2.21' },{'date'=>'2006-10-29T21:55:34','version'=>'2.22' },{'date'=>'2007-09-28T15:25:53','version'=>'2.24' },{'date'=>'2008-03-28T14:17:29','version'=>'2.27' },{'date'=>'2008-03-31T14:56:52','version'=>'2.28' },{'date'=>'2008-04-22T14:27:07','version'=>'2.29' },{'date'=>'2008-09-30T15:17:58','version'=>'2.30' },{'date'=>'2012-10-30T11:08:06','version'=>'2.31' },{'date'=>'2012-12-14T19:30:14','version'=>'2.32' },{'date'=>'2013-07-30T20:03:53','version'=>'2.33' }]},'Crypt-OpenSSL-DSA'=>{'advisories'=>[{'affected_versions'=>'<0.14','cves'=>['CVE-2009-0129' ],'description'=>'Missing error check in do_verify, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature.
  ','distribution'=>'Crypt-OpenSSL-DSA','fixed_versions'=>'>=0.14','id'=>'CPANSA-Crypt-OpenSSL-DSA-2009-01','references'=>['https://metacpan.org/changes/distribution/Crypt-OpenSSL-DSA','https://www.openwall.com/lists/oss-security/2009/01/12/4','https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=511519' ],'reported'=>'2009-01-15' }],'main_module'=>'Crypt::OpenSSL::DSA','versions'=>[{'date'=>'2001-09-19T04:45:14','version'=>'0.01' },{'date'=>'2001-09-24T17:32:49','version'=>'0.02' },{'date'=>'2002-02-07T05:57:36','version'=>'0.03' },{'date'=>'2002-09-24T04:52:06','version'=>'0.04' },{'date'=>'2002-09-26T00:21:17','version'=>'0.10' },{'date'=>'2003-01-06T19:08:08','version'=>'0.11' },{'date'=>'2005-05-23T01:44:36','version'=>'0.12' },{'date'=>'2005-10-15T21:37:10','version'=>'0.13' },{'date'=>'2012-10-16T22:55:16','version'=>'0.14' },{'date'=>'2015-02-03T21:57:37','version'=>'0.15' },{'date'=>'2016-10-27T11:25:18','version'=>'0.16' },{'date'=>'2016-10-27T18:54:42','version'=>'0.17' },{'date'=>'2016-11-17T10:33:35','version'=>'0.18' },{'date'=>'2017-01-13T08:24:56','version'=>'0.19' }]},'Crypt-Passwd-XS'=>{'advisories'=>[{'affected_versions'=>'<0.601','cves'=>['CVE-2012-2143' ],'description'=>'The crypt_des (aka DES-based crypt) function does not process the complete cleartext password if this password contains a 0x80 character, which makes it easier for context-dependent attackers to obtain access via an authentication attempt with an initial substring of the intended password, as demonstrated by a Unicode password.
  ','distribution'=>'Crypt-Passwd-XS','fixed_versions'=>'>=0.601','id'=>'CPANSA-Crypt-Passwd-XS-2012-01','references'=>['https://metacpan.org/changes/distribution/Crypt-Passwd-XS' ],'reported'=>'2012-05-07' }],'main_module'=>'Crypt::Passwd::XS','versions'=>[{'date'=>'2010-11-14T21:18:18','version'=>'0.4' },{'date'=>'2010-11-17T02:03:54','version'=>'0.501' },{'date'=>'2010-11-17T23:25:17','version'=>'0.503' },{'date'=>'2010-11-20T00:37:33','version'=>'0.504' },{'date'=>'2010-11-24T00:59:34','version'=>'0.505' },{'date'=>'2011-03-09T16:18:01','version'=>'0.506' },{'date'=>'2011-03-09T21:40:38','version'=>'0.507' },{'date'=>'2011-07-26T16:37:20','version'=>'0.600' },{'date'=>'2012-12-06T19:57:57','version'=>'0.601' }]},'DBD-MariaDB'=>{'advisories'=>[{'affected_versions'=>'<1.00','cves'=>['CVE-2018-2767' ],'description'=>'SSL problems of MySQL and MariaDB clients.
  ','distribution'=>'DBD-MariaDB','fixed_versions'=>'>=1.00','id'=>'CPANSA-DBD-MariaDB-2018-01','references'=>['https://metacpan.org/changes/distribution/DBD-MariaDB' ],'reported'=>'2017-07-01' },{'affected_versions'=>'<1.00','cves'=>['CVE-2017-10788' ],'description'=>'Use-after-free after calling mysql_stmt_close().
  ','distribution'=>'DBD-MariaDB','fixed_versions'=>'>=1.00','id'=>'CPANSA-DBD-MariaDB-2017-02','references'=>['https://metacpan.org/changes/distribution/DBD-MariaDB' ],'reported'=>'2017-07-01' },{'affected_versions'=>'<1.00','cves'=>['CVE-2017-3302' ],'description'=>'Leaking dangling pointers.
  ','distribution'=>'DBD-MariaDB','fixed_versions'=>'>=1.00','id'=>'CPANSA-DBD-MariaDB-2017-01','references'=>['https://metacpan.org/changes/distribution/DBD-MariaDB' ],'reported'=>'2017-07-01' }],'main_module'=>'DBD::MariaDB','versions'=>[{'date'=>'2018-06-26T14:23:29','version'=>'0.90_01' },{'date'=>'2018-07-12T13:36:05','version'=>'1.00' },{'date'=>'2018-12-05T12:21:26','version'=>'1.10' },{'date'=>'2019-01-02T15:38:57','version'=>'1.11' },{'date'=>'2019-02-22T16:31:33','version'=>'1.20' },{'date'=>'2019-02-27T11:08:40','version'=>'1.21' }]},'DBD-mysql'=>{'advisories'=>[{'affected_versions'=>'<4.044','cves'=>['CVE-2017-10788' ],'description'=>'The DBD::mysql module through 4.043 for Perl allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact by triggering (1) certain error responses from a MySQL server or (2) a loss of a network connection to a MySQL server. The use-after-free defect was introduced by relying on incorrect Oracle mysql_stmt_close documentation and code examples.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.044','id'=>'CPANSA-DBD-mysql-2017-02','references'=>['https://github.com/perl5-dbi/DBD-mysql/issues/120' ],'reported'=>'2017-04-13' },{'affected_versions'=>'<4.044','cves'=>['CVE-2017-10789' ],'description'=>'The DBD::mysql module through 4.043 for Perl uses the mysql_ssl=1 setting to mean that SSL is optional (even though this setting\'s documentation has a "your communication with the server will be encrypted" statement), which allows man-in-the-middle attackers to spoof servers via a cleartext-downgrade attack, a related issue to CVE-2015-3152.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.044','id'=>'CPANSA-DBD-mysql-2017-01','references'=>['https://github.com/perl5-dbi/DBD-mysql/pull/114' ],'reported'=>'2017-03-23' },{'affected_versions'=>'>=2.9003, <4.039','cves'=>['CVE-2016-1249' ],'description'=>'Out-of-bounds read.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'<2.9003, >=4.039','id'=>'CPANSA-DBD-mysql-2016-03','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe' ],'reported'=>'2016-11-16' },{'affected_versions'=>'<4.037','cves'=>['CVE-2016-1246' ],'description'=>'Buffer overflow in the DBD::mysql module before 4.037 for Perl allows context-dependent attackers to cause a denial of service (crash) via vectors related to an error message.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.037','id'=>'CPANSA-DBD-mysql-2016-02','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/7c164a0c86cec6ee95df1d141e67b0e85dfdefd2','http://blogs.perl.org/users/mike_b/2016/10/security-release---buffer-overflow-in-dbdmysql-perl-library.html' ],'reported'=>'2016-10-02' },{'affected_versions'=>'<4.034','cves'=>['CVE-2015-8949' ],'description'=>'Use-after-free vulnerability in the my_login function in DBD::mysql before 4.033_01 allows attackers to have unspecified impact by leveraging a call to mysql_errno after a failure of my_login.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.034','id'=>'CPANSA-DBD-mysql-2016-01','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/cf0aa7751f6ef8445e9310a64b14dc81460ca156' ],'reported'=>'2016-08-19' },{'affected_versions'=>'<4.041','cves'=>['CVE-2016-1251' ],'description'=>'There is a vulnerability of type use-after-free affecting DBD::mysql (aka DBD-mysql or the Database Interface (DBI) MySQL driver for Perl) 3.x and 4.x before 4.041 when used with mysql_server_prepare=1.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.041','id'=>'CPANSA-DBD-mysql-2015-01','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/3619c170461a3107a258d1fd2d00ed4832adb1b1' ],'reported'=>'2015-12-27' },{'affected_versions'=>'<4.028','cves'=>['CVE-2014-9906' ],'description'=>'Use-after-free vulnerability in DBD::mysql before 4.029 allows attackers to cause a denial of service (program crash) or possibly execute arbitrary code via vectors related to a lost server connection.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.028','id'=>'CPANSA-DBD-mysql-2014-01','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/a56ae87a4c1c1fead7d09c3653905841ccccf1cc','https://rt.cpan.org/Public/Bug/Display.html?id=97625' ],'reported'=>'2014-07-30' }],'main_module'=>'DBD::mysql','versions'=>[{'date'=>'2000-04-15T20:17:36','version'=>'v1.2212.' },{'date'=>'2001-05-06T21:47:46','version'=>'2.0900' },{'date'=>'2001-05-25T21:24:45','version'=>'2.0901' },{'date'=>'2001-07-09T21:10:17','version'=>'2.0902' },{'date'=>'2001-10-28T22:53:19','version'=>'2.0903' },{'date'=>'2001-10-31T04:01:07','version'=>'2.1000' },{'date'=>'2001-11-04T17:55:04','version'=>'2.1001' },{'date'=>'2001-11-04T18:22:30','version'=>'2.1002' },{'date'=>'2001-11-05T20:14:34','version'=>'2.1003' },{'date'=>'2001-11-13T01:24:26','version'=>'2.1004' },{'date'=>'2001-12-13T09:07:53','version'=>'2.1005' },{'date'=>'2001-12-27T18:10:04','version'=>'2.1007' },{'date'=>'2001-12-27T18:10:21','version'=>'2.1006' },{'date'=>'2001-12-28T17:06:05','version'=>'2.1008' },{'date'=>'2002-01-01T20:02:26','version'=>'2.1009' },{'date'=>'2002-01-07T21:33:21','version'=>'2.1010' },{'date'=>'2002-02-12T11:09:53','version'=>'2.1011' },{'date'=>'2002-04-12T07:21:06','version'=>'2.1012' },{'date'=>'2002-04-15T07:49:36','version'=>'2.1013' },{'date'=>'2002-04-17T21:24:26','version'=>'2.1014' },{'date'=>'2002-04-29T20:53:41','version'=>'2.1015' },{'date'=>'2002-05-01T20:07:05','version'=>'2.1016' },{'date'=>'2002-05-02T20:59:04','version'=>'2.1017' },{'date'=>'2002-08-13T17:52:25','version'=>'2.1018' },{'date'=>'2002-09-16T18:42:20','version'=>'2.1019' },{'date'=>'2002-09-23T20:42:50','version'=>'2.1020' },{'date'=>'2002-12-17T20:46:14','version'=>'2.1021' },{'date'=>'2003-01-03T02:46:24','version'=>'2.1022' },{'date'=>'2003-01-19T21:19:03','version'=>'2.1023' },{'date'=>'2003-01-20T12:08:27','version'=>'2.1024' },{'date'=>'2003-02-07T21:09:44','version'=>'2.1025' },{'date'=>'2003-03-03T20:46:27','version'=>'2.1026' },{'date'=>'2003-05-31T18:08:15','version'=>'2.1027' },{'date'=>'2003-06-25T16:12:36','version'=>'2.1028' },{'date'=>'2003-06-27T04:32:05','version'=>'2.9002' },{'date'=>'2003-09-12T17:04:42','version'=>'2.9003_1' },{'date'=>'2003-10-27T03:39:04','version'=>'2.9003' },{'date'=>'2004-07-01T03:24:14','version'=>'2.9004_2' },{'date'=>'2004-07-14T03:07:34','version'=>'2.9004' },{'date'=>'2004-10-20T17:27:25','version'=>'2.9005_1' },{'date'=>'2004-10-28T00:39:25','version'=>'2.9005_3' },{'date'=>'2005-03-29T02:43:14','version'=>'2.9005' },{'date'=>'2005-04-04T04:27:00','version'=>'2.9006' },{'date'=>'2005-04-27T00:13:49','version'=>'2.9015_3' },{'date'=>'2005-04-27T00:14:06','version'=>'2.9007' },{'date'=>'2005-06-06T01:39:20','version'=>'2.9008' },{'date'=>'2005-07-01T01:48:20','version'=>'3.0000' },{'date'=>'2005-07-03T21:56:11','version'=>'3.0000_0' },{'date'=>'2005-07-04T15:53:40','version'=>'3.0001_0' },{'date'=>'2005-07-04T16:16:00','version'=>'3.0001_1' },{'date'=>'2005-07-07T01:14:17','version'=>'3.0001' },{'date'=>'2005-07-07T01:22:39','version'=>'3.0001_2' },{'date'=>'2005-07-08T05:37:13','version'=>'3.0001_3' },{'date'=>'2005-07-11T16:49:47','version'=>'3.0002' },{'date'=>'2005-08-04T02:50:35','version'=>'3.0002_1' },{'date'=>'2005-09-26T23:22:57','version'=>'3.0002_2' },{'date'=>'2005-09-28T18:58:55','version'=>'3.0002_3' },{'date'=>'2005-11-06T21:47:29','version'=>'3.0002_4' },{'date'=>'2006-02-01T23:20:01','version'=>'3.0002_5' },{'date'=>'2006-05-04T17:49:06','version'=>'3.0003' },{'date'=>'2006-05-04T17:49:23','version'=>'3.0003_1' },{'date'=>'2006-05-21T17:28:22','version'=>'3.0004' },{'date'=>'2006-05-21T17:28:33','version'=>'3.0004_1' },{'date'=>'2006-06-10T01:21:49','version'=>'3.0005_1' },{'date'=>'2006-06-10T01:22:01','version'=>'3.0005' },{'date'=>'2006-06-11T17:05:25','version'=>'3.0006' },{'date'=>'2006-06-11T17:05:36','version'=>'3.0006_1' },{'date'=>'2006-09-08T23:12:02','version'=>'3.0007' },{'date'=>'2006-09-08T23:13:45','version'=>'3.0007_1' },{'date'=>'2006-10-07T12:59:23','version'=>'3.0007_2' },{'date'=>'2006-10-16T13:42:13','version'=>'3.0008' },{'date'=>'2006-10-16T13:42:24','version'=>'3.0008_1' },{'date'=>'2006-12-24T14:11:04','version'=>'4.00' },{'date'=>'2007-01-08T01:11:12','version'=>'4.001' },{'date'=>'2007-03-02T03:32:59','version'=>'4.002' },{'date'=>'2007-03-02T14:13:37','version'=>'4.003' },{'date'=>'2007-03-22T22:31:22','version'=>'4.004' },{'date'=>'2007-06-08T15:33:34','version'=>'4.005' },{'date'=>'2007-12-26T22:50:48','version'=>'4.006' },{'date'=>'2008-05-11T15:56:07','version'=>'4.007' },{'date'=>'2008-08-15T14:06:50','version'=>'4.008' },{'date'=>'2008-10-22T01:05:54','version'=>'4.009' },{'date'=>'2008-10-24T14:00:41','version'=>'4.010' },{'date'=>'2009-04-14T02:40:31','version'=>'4.011' },{'date'=>'2009-06-19T02:08:06','version'=>'4.012' },{'date'=>'2009-09-16T18:37:29','version'=>'4.013' },{'date'=>'2010-04-15T03:17:58','version'=>'4.014' },{'date'=>'2010-07-09T19:48:58','version'=>'4.015' },{'date'=>'2010-07-10T16:50:49','version'=>'4.016' },{'date'=>'2010-08-12T05:50:17','version'=>'4.017' },{'date'=>'2010-10-26T16:59:27','version'=>'4.018' },{'date'=>'2011-05-09T01:28:25','version'=>'4.019' },{'date'=>'2011-08-20T18:45:49','version'=>'4.020' },{'date'=>'2012-04-28T14:18:16','version'=>'4.021' },{'date'=>'2012-08-30T02:00:19','version'=>'4.022' },{'date'=>'2013-04-12T21:48:10','version'=>'4.023' },{'date'=>'2013-09-17T16:04:11','version'=>'4.024' },{'date'=>'2013-11-04T18:29:18','version'=>'4.025' },{'date'=>'2014-01-16T01:33:03','version'=>'4.026' },{'date'=>'2014-03-19T14:25:36','version'=>'4.027' },{'date'=>'2014-08-01T19:59:28','version'=>'4.028' },{'date'=>'2014-12-09T02:39:44','version'=>'4.029' },{'date'=>'2015-01-28T03:53:42','version'=>'4.030_01' },{'date'=>'2015-03-02T20:44:31','version'=>'4.030_02' },{'date'=>'2015-03-06T20:12:05','version'=>'4.031' },{'date'=>'2015-04-16T22:28:43','version'=>'4.032_01' },{'date'=>'2015-07-21T12:15:24','version'=>'4.032' },{'date'=>'2015-10-25T19:59:17','version'=>'4.032_03' },{'date'=>'2015-10-27T03:37:29','version'=>'4.033' },{'date'=>'2015-12-15T07:16:36','version'=>'4.033_01' },{'date'=>'2015-12-18T07:00:41','version'=>'4.033_02' },{'date'=>'2016-07-04T19:32:50','version'=>'4.033_03' },{'date'=>'2016-07-06T06:32:05','version'=>'4.034' },{'date'=>'2016-07-09T05:50:13','version'=>'4.035' },{'date'=>'2016-08-01T06:29:25','version'=>'4.035_01' },{'date'=>'2016-08-11T08:11:18','version'=>'4.035_02' },{'date'=>'2016-08-19T15:52:10','version'=>'4.035_03' },{'date'=>'2016-08-23T05:59:26','version'=>'4.036' },{'date'=>'2016-10-03T07:00:29','version'=>'4.037' },{'date'=>'2016-10-14T20:56:49','version'=>'4.037_01' },{'date'=>'2016-10-19T19:37:55','version'=>'4.037_02' },{'date'=>'2016-10-20T02:33:04','version'=>'4.038' },{'date'=>'2016-10-30T08:45:31','version'=>'4.038_01' },{'date'=>'2016-11-16T03:57:57','version'=>'4.039' },{'date'=>'2016-11-19T19:56:51','version'=>'4.040' },{'date'=>'2016-11-28T20:40:41','version'=>'4.041' },{'date'=>'2016-12-13T06:59:09','version'=>'4.041_01' },{'date'=>'2017-02-28T20:57:20','version'=>'4.041_02' },{'date'=>'2017-03-08T20:32:52','version'=>'4.042' },{'date'=>'2017-06-29T21:12:09','version'=>'4.043' },{'date'=>'2018-01-23T01:53:30','version'=>'4.044' },{'date'=>'2018-02-07T21:43:00','version'=>'4.044' },{'date'=>'2018-02-08T20:30:55','version'=>'4.045' },{'date'=>'2018-02-08T20:48:11','version'=>'4.046' },{'date'=>'2018-03-09T20:27:44','version'=>'4.046_01' },{'date'=>'2018-09-09T03:02:20','version'=>'4.047' },{'date'=>'2018-09-15T12:46:51','version'=>'4.048' },{'date'=>'2018-11-17T18:58:09','version'=>'4.049' },{'date'=>'2019-01-09T09:07:15','version'=>'4.050' }]},'DBD-mysqlPP'=>{'advisories'=>[{'affected_versions'=>'<0.93','description'=>'SQL injection.
  ','distribution'=>'DBD-mysqlPP','fixed_versions'=>'>=0.03','id'=>'CPANSA-DBD-mysqlPP-2011-01','references'=>['https://metacpan.org/changes/distribution/DBD-mysqlPP','https://jvn.jp/en/jp/JVN51216285/index.html' ],'reported'=>'2011-10-14','severity'=>'high' }],'main_module'=>'DBD::mysqlPP','versions'=>[{'date'=>'2002-04-04T07:20:36','version'=>'0.02' },{'date'=>'2002-04-15T10:26:39','version'=>'0.03' },{'date'=>'2003-01-24T11:14:14','version'=>'0.04' },{'date'=>'2011-10-21T23:07:07','version'=>'0.05' },{'date'=>'2011-10-26T22:17:22','version'=>'0.06' },{'date'=>'2011-11-17T22:24:50','version'=>'0.07' }]},'DBI'=>{'advisories'=>[{'affected_versions'=>'<1.632','description'=>'DBD::File drivers open files from folders other than specifically passed using the f_dir attribute.
  ','distribution'=>'DBI','fixed_versions'=>'>=1.632','id'=>'CPANSA-DBI-2014-01','references'=>['https://metacpan.org/changes/distribution/DBI','https://rt.cpan.org/Public/Bug/Display.html?id=99508' ],'reported'=>'2014-10-15','severity'=>'high' },{'affected_versions'=>'<1.47','cves'=>['CVE-2005-0077' ],'description'=>'Allows local users to overwrite arbitrary files via a symlink attack on a temporary PID file.
  ','distribution'=>'DBI','fixed_versions'=>'>=1.47','id'=>'CPANSA-DBI-2005-01','references'=>['https://metacpan.org/changes/distribution/DBI' ],'reported'=>'2005-05-02' }],'main_module'=>'DBI','versions'=>[{'date'=>'1995-10-27T08:14:00','version'=>'0.64' },{'date'=>'1996-02-15T22:07:00','version'=>'0.67' },{'date'=>'1996-04-22T10:22:00','version'=>'0.68' },{'date'=>'1996-05-07T19:46:00','version'=>'0.69' },{'date'=>'1996-06-16T21:08:00','version'=>'0.70' },{'date'=>'1996-07-10T00:49:00','version'=>'0.71' },{'date'=>'1996-09-23T16:33:00','version'=>'0.72' },{'date'=>'1996-10-15T00:58:00','version'=>'0.73' },{'date'=>'1997-01-14T16:59:00','version'=>'0.74' },{'date'=>'1997-01-27T21:59:00','version'=>'0.75' },{'date'=>'1997-02-03T18:54:00','version'=>'0.76' },{'date'=>'1997-02-21T14:27:00','version'=>'0.77' },{'date'=>'1997-03-28T14:36:00','version'=>'0.78' },{'date'=>'1997-04-07T18:28:00','version'=>'0.79' },{'date'=>'1997-05-07T11:45:00','version'=>'0.80' },{'date'=>'1997-05-07T14:05:00','version'=>'0.81' },{'date'=>'1997-05-23T15:56:00','version'=>'0.82' },{'date'=>'1997-06-11T21:40:00','version'=>'0.83' },{'date'=>'1997-06-20T15:36:00','version'=>'0.84' },{'date'=>'1997-06-25T10:25:00','version'=>'0.85' },{'date'=>'1997-07-16T16:38:00','version'=>'0.001' },{'date'=>'1997-07-18T11:27:00','version'=>'0.87' },{'date'=>'1997-07-22T21:27:00','version'=>'0.88' },{'date'=>'1997-07-25T13:46:55','version'=>'0.89' },{'date'=>'1997-09-05T19:38:52','version'=>'0.90' },{'date'=>'1997-12-10T17:15:14','version'=>'0.91' },{'date'=>'1998-02-05T20:45:45','version'=>'0.92' },{'date'=>'1998-02-13T15:21:52','version'=>'0.93' },{'date'=>'1998-08-10T03:23:46','version'=>'0.94' },{'date'=>'1998-08-11T13:21:19','version'=>'0.95' },{'date'=>'1998-08-14T20:38:42','version'=>'1.00' },{'date'=>'1998-09-02T14:59:47','version'=>'1.01' },{'date'=>'1998-09-04T12:29:52','version'=>'1.02' },{'date'=>'1999-01-18T21:52:15','version'=>'1.06' },{'date'=>'1999-05-13T01:49:11','version'=>'1.08' },{'date'=>'1999-06-02T13:44:40','version'=>'1.08' },{'date'=>'1999-06-09T20:57:59','version'=>'1.09' },{'date'=>'1999-06-13T23:52:03','version'=>'1.10' },{'date'=>'1999-06-17T13:22:36','version'=>'1.11' },{'date'=>'1999-06-29T23:07:41','version'=>'1.12' },{'date'=>'1999-07-12T03:28:41','version'=>'1.13' },{'date'=>'2000-06-11T02:39:59','version'=>'1.03_80' },{'date'=>'2000-06-14T20:30:57','version'=>'1.14' },{'date'=>'2001-03-30T15:03:31','version'=>'1.15' },{'date'=>'2001-05-29T23:25:57','version'=>'1.16' },{'date'=>'2001-06-04T17:12:30','version'=>'1.17' },{'date'=>'2001-06-04T19:00:37','version'=>'1.18' },{'date'=>'2001-07-20T22:29:24','version'=>'1.19' },{'date'=>'2001-08-24T23:32:10','version'=>'1.20' },{'date'=>'2002-01-10T15:25:45','version'=>'1.201' },{'date'=>'2002-02-07T03:30:16','version'=>'1.21' },{'date'=>'2002-03-13T14:18:00','version'=>'1.21' },{'date'=>'2002-05-22T13:42:15','version'=>'1.22' },{'date'=>'2002-05-25T17:38:03','version'=>'1.23' },{'date'=>'2002-06-05T03:32:38','version'=>'1.24' },{'date'=>'2002-06-05T22:42:04','version'=>'1.25' },{'date'=>'2002-06-13T12:30:47','version'=>'1.26' },{'date'=>'2002-06-13T15:19:06','version'=>'1.27' },{'date'=>'2002-06-14T13:13:53','version'=>'1.28' },{'date'=>'2002-06-26T09:34:24','version'=>'1.28' },{'date'=>'2002-07-15T11:24:40','version'=>'1.29' },{'date'=>'2002-07-18T14:27:25','version'=>'1.30' },{'date'=>'2002-11-30T00:49:54','version'=>'1.31' },{'date'=>'2002-12-01T23:01:26','version'=>'1.32' },{'date'=>'2002-12-20T16:23:29','version'=>'1.32' },{'date'=>'2003-02-26T18:01:24','version'=>'1.32_90' },{'date'=>'2003-02-27T00:25:32','version'=>'1.33' },{'date'=>'2003-02-28T17:53:35','version'=>'1.34' },{'date'=>'2003-03-07T22:02:20','version'=>'1.35' },{'date'=>'2003-05-14T11:13:39','version'=>'1.36' },{'date'=>'2003-05-15T18:02:26','version'=>'1.37' },{'date'=>'2003-08-25T20:36:26','version'=>'1.38' },{'date'=>'2003-11-27T23:46:40','version'=>'1.39' },{'date'=>'2004-01-08T14:04:59','version'=>'1.39' },{'date'=>'2004-02-23T14:54:21','version'=>'1.41' },{'date'=>'2004-03-12T16:40:08','version'=>'1.41' },{'date'=>'2004-07-05T10:02:05','version'=>'1.43' },{'date'=>'2004-10-05T21:27:23','version'=>'1.44' },{'date'=>'2004-10-06T13:49:20','version'=>'1.45' },{'date'=>'2004-11-16T12:38:32','version'=>'1.46' },{'date'=>'2005-02-02T11:28:46','version'=>'1.47' },{'date'=>'2005-03-14T17:03:33','version'=>'1.48' },{'date'=>'2005-11-29T19:59:40','version'=>'1.49' },{'date'=>'2005-12-14T16:55:16','version'=>'1.50' },{'date'=>'2006-04-19T15:56:38','version'=>'1.45' },{'date'=>'2006-06-06T12:08:36','version'=>'1.51' },{'date'=>'2006-08-08T21:13:32','version'=>'1.52' },{'date'=>'2006-11-02T00:38:01','version'=>'1.53' },{'date'=>'2007-02-23T17:15:23','version'=>'1.54' },{'date'=>'2007-05-04T14:56:38','version'=>'1.55' },{'date'=>'2007-05-10T14:04:04','version'=>'1.56' },{'date'=>'2007-05-13T22:00:58','version'=>'1.56' },{'date'=>'2007-06-13T16:45:34','version'=>'1.57' },{'date'=>'2007-06-15T17:06:42','version'=>'1.57' },{'date'=>'2007-06-18T15:15:31','version'=>'1.57' },{'date'=>'2007-06-25T22:11:47','version'=>'1.58' },{'date'=>'2007-08-22T17:02:10','version'=>'1.59' },{'date'=>'2007-08-23T12:22:26','version'=>'1.59' },{'date'=>'2007-08-23T13:59:53','version'=>'1.59' },{'date'=>'2007-08-24T09:19:29','version'=>'1.59' },{'date'=>'2007-10-16T13:12:55','version'=>'1.601' },{'date'=>'2007-10-21T22:12:52','version'=>'1.601' },{'date'=>'2008-02-09T22:06:13','version'=>'1.602' },{'date'=>'2008-03-22T00:11:03','version'=>'1.603' },{'date'=>'2008-03-24T14:11:41','version'=>'1.604' },{'date'=>'2008-06-16T19:19:43','version'=>'1.605' },{'date'=>'2008-07-22T21:01:09','version'=>'1.606' },{'date'=>'2008-07-22T21:50:54','version'=>'1.607' },{'date'=>'2009-05-02T22:58:48','version'=>'1.608' },{'date'=>'2009-05-05T12:05:19','version'=>'1.608' },{'date'=>'2009-06-05T22:57:34','version'=>'1.609' },{'date'=>'2009-06-08T10:29:18','version'=>'1.609' },{'date'=>'2010-03-02T21:26:39','version'=>'1.611' },{'date'=>'2010-04-22T11:06:31','version'=>'1.611' },{'date'=>'2010-04-27T15:13:32','version'=>'1.611' },{'date'=>'2010-04-29T19:54:44','version'=>'1.611' },{'date'=>'2010-05-28T10:29:17','version'=>'1.612' },{'date'=>'2010-06-15T22:47:23','version'=>'1.612' },{'date'=>'2010-06-16T19:18:05','version'=>'1.612' },{'date'=>'2010-07-02T14:26:03','version'=>'1.612' },{'date'=>'2010-07-15T15:00:53','version'=>'1.612' },{'date'=>'2010-07-16T19:36:42','version'=>'1.612' },{'date'=>'2010-07-22T17:34:16','version'=>'1.613' },{'date'=>'2010-07-25T15:50:15','version'=>'1.613' },{'date'=>'2010-07-30T14:17:33','version'=>'1.614' },{'date'=>'2010-08-16T16:34:58','version'=>'1.614' },{'date'=>'2010-08-30T20:11:00','version'=>'1.614' },{'date'=>'2010-08-30T20:26:37','version'=>'1.614' },{'date'=>'2010-08-30T20:56:09','version'=>'1.614' },{'date'=>'2010-09-02T15:44:21','version'=>'1.614' },{'date'=>'2010-09-09T10:24:11','version'=>'1.614' },{'date'=>'2010-09-16T16:23:50','version'=>'1.614' },{'date'=>'2010-09-17T09:48:02','version'=>'1.614' },{'date'=>'2010-09-21T10:14:29','version'=>'1.615' },{'date'=>'2010-09-22T12:28:20','version'=>'1.615' },{'date'=>'2010-12-18T21:51:52','version'=>'1.616' },{'date'=>'2010-12-21T23:26:46','version'=>'1.616' },{'date'=>'2010-12-29T14:39:48','version'=>'1.616' },{'date'=>'2010-12-30T10:26:51','version'=>'1.616' },{'date'=>'2012-01-02T17:12:53','version'=>'1.617' },{'date'=>'2012-01-28T09:34:18','version'=>'1.617' },{'date'=>'2012-01-30T10:06:49','version'=>'1.617' },{'date'=>'2012-02-07T22:54:02','version'=>'1.618' },{'date'=>'2012-02-13T18:24:33','version'=>'1.618' },{'date'=>'2012-02-23T11:05:45','version'=>'1.618' },{'date'=>'2012-02-25T14:24:39','version'=>'1.618' },{'date'=>'2012-04-18T11:57:55','version'=>'1.619' },{'date'=>'2012-04-20T20:21:54','version'=>'1.619' },{'date'=>'2012-04-23T22:09:14','version'=>'1.619' },{'date'=>'2012-04-25T12:46:54','version'=>'1.620' },{'date'=>'2012-05-21T13:06:09','version'=>'1.621' },{'date'=>'2012-05-22T22:17:06','version'=>'1.621' },{'date'=>'2012-06-06T16:51:00','version'=>'1.622' },{'date'=>'2012-07-13T15:24:35','version'=>'1.623' },{'date'=>'2012-10-30T13:01:14','version'=>'1.623' },{'date'=>'2012-11-19T23:27:04','version'=>'1.623' },{'date'=>'2012-12-13T16:26:23','version'=>'1.623' },{'date'=>'2012-12-21T17:22:01','version'=>'1.623' },{'date'=>'2013-01-02T10:09:42','version'=>'1.623' },{'date'=>'2013-03-22T20:41:50','version'=>'1.624' },{'date'=>'2013-03-28T21:59:38','version'=>'1.625' },{'date'=>'2013-05-15T11:28:03','version'=>'1.626' },{'date'=>'2013-05-16T20:30:50','version'=>'1.627' },{'date'=>'2013-06-24T21:56:27','version'=>'1.628' },{'date'=>'2013-06-24T22:12:23','version'=>'1.628' },{'date'=>'2013-06-30T19:08:08','version'=>'1.628' },{'date'=>'2013-07-02T11:27:23','version'=>'1.628' },{'date'=>'2013-07-22T13:22:40','version'=>'1.628' },{'date'=>'2013-10-11T12:28:12','version'=>'1.629' },{'date'=>'2013-10-13T16:02:52','version'=>'1.629' },{'date'=>'2013-10-15T12:24:53','version'=>'1.629' },{'date'=>'2013-10-22T11:58:53','version'=>'1.629_50' },{'date'=>'2013-10-28T12:51:39','version'=>'1.630' },{'date'=>'2014-01-13T13:51:01','version'=>'1.631' },{'date'=>'2014-01-16T11:34:34','version'=>'1.631' },{'date'=>'2014-01-20T11:12:44','version'=>'1.631' },{'date'=>'2014-10-23T14:08:22','version'=>'1.631' },{'date'=>'2014-11-05T11:15:07','version'=>'1.632' },{'date'=>'2015-01-08T14:31:52','version'=>'1.632' },{'date'=>'2015-01-11T13:26:05','version'=>'1.633' },{'date'=>'2015-07-18T13:16:07','version'=>'1.633' },{'date'=>'2015-07-19T14:34:22','version'=>'1.633_91' },{'date'=>'2015-07-22T15:27:59','version'=>'1.633_92' },{'date'=>'2015-08-02T16:52:48','version'=>'1.633_93' },{'date'=>'2015-08-03T14:52:56','version'=>'1.634' },{'date'=>'2016-04-23T15:28:02','version'=>'1.634' },{'date'=>'2016-04-24T11:57:03','version'=>'1.635' },{'date'=>'2016-04-24T22:20:56','version'=>'1.636' },{'date'=>'2017-08-14T10:10:55','version'=>'1.637' },{'date'=>'2017-08-16T09:02:40','version'=>'1.637' },{'date'=>'2017-12-28T14:40:44','version'=>'1.639' },{'date'=>'2018-01-28T20:50:53','version'=>'1.640' },{'date'=>'2018-03-19T18:06:08','version'=>'1.641' },{'date'=>'2018-10-28T15:08:54','version'=>'1.641_90' },{'date'=>'2018-10-29T10:43:41','version'=>'1.642' }]},'DBIx-Custom'=>{'advisories'=>[{'affected_versions'=>'<0.1641','description'=>'SQL injection when passing special column names.
  ','distribution'=>'DBIx-Custom','fixed_versions'=>'>=0.1641','id'=>'CPANSA-DBIx-Custom-2011-01','references'=>['https://metacpan.org/changes/distribution/DBIx-Custom','https://github.com/yuki-kimoto/DBIx-Custom/commit/5b00b9f9a966e7abecabd91710c8fa893784d919' ],'reported'=>'2011-01-27','severity'=>'high' }],'main_module'=>'DBIx::Custom','versions'=>[{'date'=>'2009-11-08T04:18:19','version'=>'0.0101' },{'date'=>'2009-11-09T10:46:44','version'=>'0.0201' },{'date'=>'2009-11-12T14:12:47','version'=>'0.0301' },{'date'=>'2009-11-15T11:43:40','version'=>'0.0401' },{'date'=>'2009-11-16T11:10:52','version'=>'0.0501' },{'date'=>'2009-11-17T12:37:33','version'=>'0.0502' },{'date'=>'2009-11-19T12:05:50','version'=>'0.0601' },{'date'=>'2009-11-19T13:37:39','version'=>'0.0602' },{'date'=>'2009-11-20T12:08:31','version'=>'0.0603' },{'date'=>'2009-11-23T13:39:53','version'=>'0.0604' },{'date'=>'2009-11-23T14:45:46','version'=>'0.0605' },{'date'=>'2009-11-25T13:57:52','version'=>'0.0701' },{'date'=>'2009-12-01T07:30:25','version'=>'0.0702' },{'date'=>'2009-12-02T13:59:36','version'=>'0.0801' },{'date'=>'2009-12-09T14:27:53','version'=>'0.0901' },{'date'=>'2009-12-22T13:40:07','version'=>'0.0902' },{'date'=>'2010-01-18T12:42:57','version'=>'0.0903' },{'date'=>'2010-01-21T14:29:12','version'=>'0.0904' },{'date'=>'2010-01-22T12:51:23','version'=>'0.0905' },{'date'=>'2010-01-24T09:49:30','version'=>'0.0906' },{'date'=>'2010-01-30T00:15:17','version'=>'0.1001' },{'date'=>'2010-01-30T03:51:04','version'=>'0.1101' },{'date'=>'2010-05-01T13:02:19','version'=>'0.1301' },{'date'=>'2010-05-01T23:29:22','version'=>'0.1401' },{'date'=>'2010-05-02T06:04:57','version'=>'0.1402' },{'date'=>'2010-05-26T15:13:04','version'=>'0.1501' },{'date'=>'2010-05-27T14:00:04','version'=>'0.1502' },{'date'=>'2010-05-28T13:28:16','version'=>'0.1503' },{'date'=>'2010-06-25T12:11:33','version'=>'0.1602' },{'date'=>'2010-07-14T13:55:33','version'=>'0.1603' },{'date'=>'2010-08-03T14:43:14','version'=>'0.1604' },{'date'=>'2010-08-05T15:17:49','version'=>'0.1605' },{'date'=>'2010-08-05T15:24:36','version'=>'0.1606' },{'date'=>'2010-08-06T14:57:35','version'=>'0.1607' },{'date'=>'2010-08-07T05:49:19','version'=>'0.1608' },{'date'=>'2010-08-08T04:45:12','version'=>'0.1609' },{'date'=>'2010-08-08T12:44:43','version'=>'0.1610' },{'date'=>'2010-08-09T12:08:31','version'=>'0.1611' },{'date'=>'2010-08-10T11:19:41','version'=>'0.1612' },{'date'=>'2010-08-10T12:35:17','version'=>'0.1613' },{'date'=>'2010-08-12T15:01:01','version'=>'0.1614' },{'date'=>'2010-08-15T04:00:44','version'=>'0.1615' },{'date'=>'2010-08-24T10:18:06','version'=>'0.1616' },{'date'=>'2010-09-07T12:12:04','version'=>'0.1617' },{'date'=>'2010-10-17T05:44:56','version'=>'0.1618' },{'date'=>'2010-10-20T15:01:35','version'=>'0.1619' },{'date'=>'2010-10-21T14:38:05','version'=>'0.1620' },{'date'=>'2010-11-10T06:54:46','version'=>'0.1621' },{'date'=>'2010-12-20T14:58:38','version'=>'0.1622' },{'date'=>'2010-12-21T16:10:25','version'=>'0.1623' },{'date'=>'2010-12-22T08:41:09','version'=>'0.1624' },{'date'=>'2011-01-01T16:08:48','version'=>'0.1625' },{'date'=>'2011-01-02T04:21:11','version'=>'0.1626' },{'date'=>'2011-01-04T15:18:21','version'=>'0.1627' },{'date'=>'2011-01-12T07:29:29','version'=>'0.1628' },{'date'=>'2011-01-12T15:35:11','version'=>'0.1629' },{'date'=>'2011-01-13T15:41:25','version'=>'0.1630' },{'date'=>'2011-01-17T15:53:44','version'=>'0.1631' },{'date'=>'2011-01-18T14:43:16','version'=>'0.1632' },{'date'=>'2011-01-18T15:22:37','version'=>'0.1633' },{'date'=>'2011-01-19T14:52:48','version'=>'0.1634' },{'date'=>'2011-01-21T14:04:02','version'=>'0.1635' },{'date'=>'2011-01-22T13:02:55','version'=>'0.1636' },{'date'=>'2011-01-24T12:58:40','version'=>'0.1637' },{'date'=>'2011-01-25T12:32:26','version'=>'0.1638' },{'date'=>'2011-01-26T09:23:22','version'=>'0.1639' },{'date'=>'2011-01-26T13:59:10','version'=>'0.1640' },{'date'=>'2011-01-27T05:19:14','version'=>'0.1641' },{'date'=>'2011-01-28T12:18:42','version'=>'0.1642' },{'date'=>'2011-02-09T08:54:11','version'=>'0.1643' },{'date'=>'2011-02-11T14:07:25','version'=>'0.1644' },{'date'=>'2011-02-14T15:24:30','version'=>'0.1645' },{'date'=>'2011-02-18T17:48:52','version'=>'0.1646' },{'date'=>'2011-02-19T00:30:41','version'=>'0.1647' },{'date'=>'2011-02-21T16:13:29','version'=>'0.1648' },{'date'=>'2011-02-22T14:53:08','version'=>'0.1649' },{'date'=>'2011-02-24T05:45:44','version'=>'0.1650' },{'date'=>'2011-02-24T14:35:20','version'=>'0.1651' },{'date'=>'2011-02-25T14:39:56','version'=>'0.1652' },{'date'=>'2011-02-28T13:18:03','version'=>'0.1653' },{'date'=>'2011-03-06T14:32:11','version'=>'0.1654' },{'date'=>'2011-03-08T14:59:08','version'=>'0.1655' },{'date'=>'2011-03-09T13:44:35','version'=>'0.1656' },{'date'=>'2011-03-10T15:44:50','version'=>'0.1657' },{'date'=>'2011-03-11T16:23:11','version'=>'0.1658' },{'date'=>'2011-03-12T08:20:07','version'=>'0.1659' },{'date'=>'2011-03-14T11:16:27','version'=>'0.1660' },{'date'=>'2011-03-15T16:32:52','version'=>'0.1661' },{'date'=>'2011-03-19T14:40:50','version'=>'0.1662' },{'date'=>'2011-03-21T03:53:25','version'=>'0.1663' },{'date'=>'2011-03-24T14:45:52','version'=>'0.1664' },{'date'=>'2011-03-25T14:25:43','version'=>'0.1665' },{'date'=>'2011-03-29T17:26:27','version'=>'0.1666' },{'date'=>'2011-03-30T08:03:39','version'=>'0.1667' },{'date'=>'2011-03-30T15:04:03','version'=>'0.1668' },{'date'=>'2011-03-30T15:25:45','version'=>'0.1669' },{'date'=>'2011-04-01T15:29:33','version'=>'0.1670' },{'date'=>'2011-04-02T16:31:44','version'=>'0.1671' },{'date'=>'2011-04-04T13:37:34','version'=>'0.1672' },{'date'=>'2011-04-05T11:45:54','version'=>'0.1673' },{'date'=>'2011-04-05T11:59:11','version'=>'0.1674' },{'date'=>'2011-04-11T13:47:34','version'=>'0.1675' },{'date'=>'2011-04-11T14:55:38','version'=>'0.1676' },{'date'=>'2011-04-12T15:17:24','version'=>'0.1677' },{'date'=>'2011-04-18T13:36:31','version'=>'0.1678' },{'date'=>'2011-04-19T11:07:27','version'=>'0.1679' },{'date'=>'2011-04-25T14:05:23','version'=>'0.1680' },{'date'=>'2011-04-26T14:07:02','version'=>'0.1681' },{'date'=>'2011-05-23T14:40:41','version'=>'0.1682' },{'date'=>'2011-06-06T11:52:44','version'=>'0.1683' },{'date'=>'2011-06-07T13:07:20','version'=>'0.1684' },{'date'=>'2011-06-08T10:32:35','version'=>'0.1685' },{'date'=>'2011-06-08T12:24:07','version'=>'0.1686' },{'date'=>'2011-06-09T13:59:44','version'=>'0.1687' },{'date'=>'2011-06-10T13:26:20','version'=>'0.1688' },{'date'=>'2011-06-12T03:22:26','version'=>'0.1689' },{'date'=>'2011-06-12T12:01:43','version'=>'0.1690' },{'date'=>'2011-06-13T13:31:21','version'=>'0.1691' },{'date'=>'2011-06-14T13:27:31','version'=>'0.1692' },{'date'=>'2011-06-15T08:51:43','version'=>'0.1693' },{'date'=>'2011-06-17T14:38:23','version'=>'0.1694' },{'date'=>'2011-06-20T13:08:47','version'=>'0.1695' },{'date'=>'2011-06-21T13:12:38','version'=>'0.1696' },{'date'=>'2011-06-24T13:42:00','version'=>'0.1697' },{'date'=>'2011-06-27T13:23:13','version'=>'0.1698' },{'date'=>'2011-06-28T14:39:21','version'=>'0.1699' },{'date'=>'2011-07-01T11:04:37','version'=>'0.1700' },{'date'=>'2011-07-11T13:19:20','version'=>'0.1701' },{'date'=>'2011-07-26T14:09:43','version'=>'0.1702' },{'date'=>'2011-07-28T04:59:20','version'=>'0.1703' },{'date'=>'2011-07-29T13:45:24','version'=>'0.1704' },{'date'=>'2011-07-29T14:35:38','version'=>'0.1705' },{'date'=>'2011-07-30T04:25:21','version'=>'0.1706' },{'date'=>'2011-07-30T05:16:05','version'=>'0.1707' },{'date'=>'2011-07-30T14:32:34','version'=>'0.1708' },{'date'=>'2011-08-01T12:48:52','version'=>'0.1709' },{'date'=>'2011-08-02T13:30:15','version'=>'0.1710' },{'date'=>'2011-08-09T14:11:24','version'=>'0.1711' },{'date'=>'2011-08-10T16:16:52','version'=>'0.1712' },{'date'=>'2011-08-12T13:45:58','version'=>'0.1713' },{'date'=>'2011-08-13T13:38:02','version'=>'0.1714' },{'date'=>'2011-08-14T03:47:28','version'=>'0.1715' },{'date'=>'2011-08-15T14:00:28','version'=>'0.1716' },{'date'=>'2011-08-16T04:03:16','version'=>'0.1717' },{'date'=>'2011-08-20T09:40:46','version'=>'0.1718' },{'date'=>'2011-08-22T13:43:21','version'=>'0.1720' },{'date'=>'2011-08-26T14:11:53','version'=>'0.1721' },{'date'=>'2011-09-02T15:12:10','version'=>'0.1722' },{'date'=>'2011-09-12T12:24:14','version'=>'0.1723' },{'date'=>'2011-09-16T15:15:54','version'=>'0.1724' },{'date'=>'2011-09-27T11:48:33','version'=>'0.1725' },{'date'=>'2011-09-30T11:21:45','version'=>'0.1726' },{'date'=>'2011-10-03T10:43:32','version'=>'0.1727' },{'date'=>'2011-10-05T04:10:35','version'=>'0.1728' },{'date'=>'2011-10-05T08:12:55','version'=>'0.1729' },{'date'=>'2011-10-10T11:35:23','version'=>'0.1730' },{'date'=>'2011-10-11T14:30:46','version'=>'0.1731' },{'date'=>'2011-10-20T11:56:08','version'=>'0.1732' },{'date'=>'2011-10-21T22:47:50','version'=>'0.1733' },{'date'=>'2011-10-22T22:02:37','version'=>'0.1734' },{'date'=>'2011-10-23T00:11:48','version'=>'0.1735' },{'date'=>'2011-10-23T13:08:15','version'=>'0.1736' },{'date'=>'2011-10-24T14:07:44','version'=>'0.1737' },{'date'=>'2011-10-25T14:31:15','version'=>'0.1738' },{'date'=>'2011-10-26T01:14:58','version'=>'0.1739' },{'date'=>'2011-10-27T12:59:00','version'=>'0.1740' },{'date'=>'2011-10-28T11:49:57','version'=>'0.1741' },{'date'=>'2011-10-31T15:37:07','version'=>'0.1742' },{'date'=>'2011-11-01T12:02:38','version'=>'0.1743' },{'date'=>'2011-11-03T13:38:04','version'=>'0.1744' },{'date'=>'2011-11-04T14:16:11','version'=>'0.1745' },{'date'=>'2011-11-07T12:19:53','version'=>'0.1746' },{'date'=>'2011-11-11T11:59:27','version'=>'0.1747' },{'date'=>'2011-11-16T00:36:45','version'=>'0.20_01' },{'date'=>'2011-11-16T08:50:11','version'=>'0.2100' },{'date'=>'2011-11-21T11:05:36','version'=>'0.2101' },{'date'=>'2011-11-25T14:34:26','version'=>'0.2102' },{'date'=>'2011-11-28T10:38:56','version'=>'0.2103' },{'date'=>'2011-11-29T13:48:49','version'=>'0.2104' },{'date'=>'2012-01-14T13:39:10','version'=>'0.2105' },{'date'=>'2012-01-20T15:16:34','version'=>'0.2106' },{'date'=>'2012-01-25T08:56:44','version'=>'0.2107' },{'date'=>'2012-01-29T14:30:53','version'=>'0.2108' },{'date'=>'2012-02-07T13:31:49','version'=>'0.2109' },{'date'=>'2012-02-10T14:51:17','version'=>'0.2110' },{'date'=>'2012-02-11T14:45:41','version'=>'0.2111' },{'date'=>'2012-02-28T14:33:03','version'=>'0.22' },{'date'=>'2012-03-01T00:07:11','version'=>'0.23' },{'date'=>'2012-03-02T14:57:03','version'=>'0.24' },{'date'=>'2012-03-19T11:58:43','version'=>'0.25' },{'date'=>'2012-07-11T08:20:53','version'=>'0.26' },{'date'=>'2012-09-17T13:15:26','version'=>'0.27' },{'date'=>'2013-03-04T11:25:17','version'=>'0.28' },{'date'=>'2014-02-03T09:21:29','version'=>'0.29' },{'date'=>'2014-02-04T00:17:32','version'=>'0.30' },{'date'=>'2015-01-13T01:36:24','version'=>'0.31' },{'date'=>'2015-01-13T05:24:10','version'=>'0.32' },{'date'=>'2015-01-13T07:52:20','version'=>'0.33' },{'date'=>'2015-01-15T02:04:26','version'=>'0.34' },{'date'=>'2015-05-23T05:44:25','version'=>'0.35' },{'date'=>'2015-05-25T02:52:16','version'=>'0.36' },{'date'=>'2016-05-21T07:00:46','version'=>'0.37' },{'date'=>'2017-03-16T07:48:58','version'=>'0.38' },{'date'=>'2017-03-29T02:29:03','version'=>'0.39' },{'date'=>'2017-03-30T01:41:11','version'=>'0.40' },{'date'=>'2017-11-06T15:17:26','version'=>'0.41' }]},'Dancer'=>{'advisories'=>[{'affected_versions'=>'<1.3114','cves'=>['CVE-2012-5572' ],'description'=>'CRLF injection vulnerability in the cookie method allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via a cookie name.
  ','distribution'=>'Dancer','fixed_versions'=>'>=1.3114','id'=>'CPANSA-Dancer-2014-01','references'=>['https://metacpan.org/changes/distribution/Dancer','https://github.com/PerlDancer/Dancer/commit/46ef9124f3149f697455061499ac7cee40930349' ],'reported'=>'2014-05-30' },{'affected_versions'=>'<1.3051','cves'=>['CVE-2011-1589' ],'description'=>'Directory traversal vulnerability (Mojolicious report, but Dancer was vulnerable as well).
  ','distribution'=>'Dancer','fixed_versions'=>'>=1.3051','id'=>'CPANSA-Dancer-2011-01','references'=>['https://metacpan.org/changes/distribution/Dancer','https://github.com/PerlDancer/Dancer/commit/91d0bf6a36705b0971b18f7d38fa2f3df8c7b994' ],'reported'=>'2011-04-05' }],'main_module'=>'Dancer','versions'=>[{'date'=>'2009-07-27T13:18:07','version'=>'20090727.1315' },{'date'=>'2009-07-27T14:14:13','version'=>'0_0.99' },{'date'=>'2009-08-01T13:48:20','version'=>'0.9901' },{'date'=>'2009-08-04T10:01:54','version'=>'0.9902' },{'date'=>'2009-08-07T12:29:03','version'=>'0.9003' },{'date'=>'2009-09-19T15:30:19','version'=>'0.9904' },{'date'=>'2009-09-23T21:33:51','version'=>'0.9905' },{'date'=>'2009-11-20T11:14:20','version'=>'1.000' },{'date'=>'2010-01-06T13:53:28','version'=>'1.100' },{'date'=>'2010-01-11T09:46:45','version'=>'1.110' },{'date'=>'2010-01-15T16:03:35','version'=>'1.120' },{'date'=>'2010-01-15T17:53:08','version'=>'1.121' },{'date'=>'2010-01-20T07:48:38','version'=>'1.122' },{'date'=>'2010-01-29T17:29:24','version'=>'1.130' },{'date'=>'2010-02-09T07:55:18','version'=>'1.140' },{'date'=>'2010-02-17T15:09:48','version'=>'1.150' },{'date'=>'2010-03-07T17:50:01','version'=>'1.160' },{'date'=>'2010-03-24T11:19:00','version'=>'1.170' },{'date'=>'2010-03-24T13:44:04','version'=>'1.171' },{'date'=>'2010-03-28T15:09:59','version'=>'1.172' },{'date'=>'2010-04-01T14:13:30','version'=>'1.173' },{'date'=>'2010-04-04T11:03:53','version'=>'1.173_01' },{'date'=>'2010-04-08T13:49:39','version'=>'1.174' },{'date'=>'2010-04-11T10:49:39','version'=>'1.175' },{'date'=>'2010-04-19T08:43:22','version'=>'1.175_01' },{'date'=>'2010-04-22T20:29:56','version'=>'1.176' },{'date'=>'2010-05-05T12:21:26','version'=>'1.178_01' },{'date'=>'2010-05-16T10:28:47','version'=>'1.1800' },{'date'=>'2010-05-19T14:17:57','version'=>'1.1801' },{'date'=>'2010-05-19T17:32:52','version'=>'1.1802' },{'date'=>'2010-05-23T20:45:17','version'=>'1.1803' },{'date'=>'2010-06-18T11:59:20','version'=>'1.1804' },{'date'=>'2010-06-22T06:41:58','version'=>'1.1805' },{'date'=>'2010-07-07T06:15:55','version'=>'1.1806_01' },{'date'=>'2010-08-14T16:37:45','version'=>'1.1806_02' },{'date'=>'2010-08-23T17:47:12','version'=>'1.1807' },{'date'=>'2010-08-24T06:23:38','version'=>'1.1808' },{'date'=>'2010-08-25T05:41:15','version'=>'1.1809' },{'date'=>'2010-09-01T06:19:20','version'=>'1.1810' },{'date'=>'2010-09-03T09:23:14','version'=>'1.1811' },{'date'=>'2010-09-21T12:19:35','version'=>'1.1812' },{'date'=>'2010-09-24T14:25:44','version'=>'1.1901' },{'date'=>'2010-10-14T09:25:03','version'=>'1.1999_01' },{'date'=>'2010-10-28T15:41:17','version'=>'1.1999_02' },{'date'=>'2010-11-02T14:14:32','version'=>'1.1902' },{'date'=>'2010-11-02T14:25:04','version'=>'1.1902' },{'date'=>'2010-11-03T17:07:29','version'=>'1.1903' },{'date'=>'2010-11-04T11:16:17','version'=>'1.1904' },{'date'=>'2010-11-11T07:43:21','version'=>'1.1999_03' },{'date'=>'2010-11-14T08:08:56','version'=>'1.1999_04' },{'date'=>'2010-11-18T15:54:33','version'=>'1.200' },{'date'=>'2010-11-18T16:52:47','version'=>'1.2000' },{'date'=>'2010-11-29T22:05:38','version'=>'1.2000_01' },{'date'=>'2010-11-30T10:00:23','version'=>'1.2000_02' },{'date'=>'2010-11-30T19:59:09','version'=>'1.2001' },{'date'=>'2010-12-02T12:18:12','version'=>'1.2001_01' },{'date'=>'2010-12-03T20:28:56','version'=>'1.2002' },{'date'=>'2010-12-07T18:05:50','version'=>'1.2002_01' },{'date'=>'2010-12-08T21:38:17','version'=>'1.2002_02' },{'date'=>'2010-12-10T18:28:16','version'=>'1.2003' },{'date'=>'2010-12-22T17:57:55','version'=>'1.3000_01' },{'date'=>'2011-01-03T15:17:14','version'=>'1.3000_02' },{'date'=>'2011-01-27T10:00:22','version'=>'1.2004' },{'date'=>'2011-01-27T10:09:31','version'=>'1.3001' },{'date'=>'2011-02-02T15:42:28','version'=>'1.3002' },{'date'=>'2011-02-05T17:07:15','version'=>'1.2005' },{'date'=>'2011-02-06T13:12:28','version'=>'1.3003' },{'date'=>'2011-02-10T20:48:48','version'=>'1.3010' },{'date'=>'2011-02-12T12:50:18','version'=>'1.3010_01' },{'date'=>'2011-02-14T15:58:10','version'=>'1.3011' },{'date'=>'2011-03-01T19:00:52','version'=>'1.3012' },{'date'=>'2011-03-03T08:41:00','version'=>'1.3013' },{'date'=>'2011-03-04T12:56:36','version'=>'1.3014' },{'date'=>'2011-03-10T14:16:24','version'=>'1.3014_01' },{'date'=>'2011-03-13T13:17:43','version'=>'1.3019_01' },{'date'=>'2011-03-14T07:44:57','version'=>'1.3019_02' },{'date'=>'2011-03-21T13:44:17','version'=>'1.3020' },{'date'=>'2011-04-01T15:22:58','version'=>'1.3029_01' },{'date'=>'2011-04-08T20:07:26','version'=>'1.3029_02' },{'date'=>'2011-04-10T08:18:44','version'=>'1.3029_03' },{'date'=>'2011-04-13T08:26:50','version'=>'1.3030' },{'date'=>'2011-04-27T14:58:57','version'=>'1.3039_01' },{'date'=>'2011-05-01T14:55:49','version'=>'1.3040' },{'date'=>'2011-05-14T15:03:00','version'=>'1.3049_01' },{'date'=>'2011-05-20T10:57:10','version'=>'1.3050' },{'date'=>'2011-05-27T12:57:27','version'=>'1.3051' },{'date'=>'2011-05-27T13:07:51','version'=>'1.3059_01' },{'date'=>'2011-05-29T14:06:24','version'=>'1.3059_02' },{'date'=>'2011-06-11T14:02:50','version'=>'1.3059_03' },{'date'=>'2011-06-12T17:31:55','version'=>'1.3059_04' },{'date'=>'2011-06-15T10:35:07','version'=>'1.3060' },{'date'=>'2011-07-07T13:19:45','version'=>'1.3069_01' },{'date'=>'2011-07-10T16:14:53','version'=>'1.3069_02' },{'date'=>'2011-07-14T13:47:19','version'=>'1.3070' },{'date'=>'2011-07-26T16:21:51','version'=>'1.3071' },{'date'=>'2011-08-17T15:27:53','version'=>'1.3079_01' },{'date'=>'2011-08-23T09:55:46','version'=>'1.3072' },{'date'=>'2011-08-28T14:13:40','version'=>'1.3079_02' },{'date'=>'2011-09-10T15:10:29','version'=>'1.3079_03' },{'date'=>'2011-10-02T16:07:02','version'=>'1.3079_04' },{'date'=>'2011-10-18T14:43:22','version'=>'1.3079_05' },{'date'=>'2011-10-25T21:16:42','version'=>'1.3080' },{'date'=>'2011-11-27T06:51:43','version'=>'1.3089_01' },{'date'=>'2011-12-13T14:41:24','version'=>'1.3090' },{'date'=>'2011-12-17T11:09:48','version'=>'1.3091' },{'date'=>'2012-01-27T14:38:05','version'=>'1.3092' },{'date'=>'2012-02-29T14:34:55','version'=>'1.3093' },{'date'=>'2012-03-31T09:57:40','version'=>'1.3094' },{'date'=>'2012-04-01T19:22:56','version'=>'1.3095' },{'date'=>'2012-06-22T20:18:54','version'=>'1.3095_01' },{'date'=>'2012-07-03T07:27:28','version'=>'1.3095_02' },{'date'=>'2012-07-05T23:09:20','version'=>'1.3096' },{'date'=>'2012-07-08T18:36:14','version'=>'1.3097' },{'date'=>'2012-07-28T14:40:15','version'=>'1.3098' },{'date'=>'2012-08-11T13:54:49','version'=>'1.3099' },{'date'=>'2012-08-25T19:42:47','version'=>'1.3100' },{'date'=>'2012-10-06T13:24:53','version'=>'1.3110' },{'date'=>'2012-12-24T13:17:58','version'=>'1.9999_01' },{'date'=>'2012-12-24T13:48:35','version'=>'1.9999_02' },{'date'=>'2013-01-22T21:38:11','version'=>'2.0000_01' },{'date'=>'2013-02-22T15:33:14','version'=>'2.000001' },{'date'=>'2013-02-24T22:51:59','version'=>'1.3111' },{'date'=>'2013-03-30T16:33:05','version'=>'1.3111_01' },{'date'=>'2013-04-01T22:31:08','version'=>'1.3111_02' },{'date'=>'2013-04-11T01:04:37','version'=>'1.3112' },{'date'=>'2013-05-09T00:36:16','version'=>'1.3113' },{'date'=>'2013-06-02T16:49:58','version'=>'1.3114' },{'date'=>'2013-06-09T23:54:16','version'=>'1.3115' },{'date'=>'2013-07-04T01:35:27','version'=>'1.3116' },{'date'=>'2013-07-31T22:40:52','version'=>'1.3117' },{'date'=>'2013-09-01T16:45:13','version'=>'1.3118' },{'date'=>'2013-10-26T19:42:59','version'=>'1.3119' },{'date'=>'2013-12-24T16:23:20','version'=>'1.3120' },{'date'=>'2014-02-02T22:26:53','version'=>'1.3121' },{'date'=>'2014-04-10T23:16:40','version'=>'1.3122' },{'date'=>'2014-04-12T15:47:53','version'=>'1.3123' },{'date'=>'2014-05-10T16:15:17','version'=>'1.3124' },{'date'=>'2014-07-12T17:19:08','version'=>'1.3125' },{'date'=>'2014-07-15T02:01:21','version'=>'1.3126' },{'date'=>'2014-09-09T00:49:19','version'=>'1.3127' },{'date'=>'2014-09-09T11:47:21','version'=>'1.3128' },{'date'=>'2014-09-10T00:50:37','version'=>'1.3129' },{'date'=>'2014-09-16T01:21:25','version'=>'1.3130' },{'date'=>'2014-10-11T18:59:22','version'=>'1.3131_0' },{'date'=>'2014-10-13T23:25:36','version'=>'1.3131_1' },{'date'=>'2014-10-20T23:14:23','version'=>'1.3132' },{'date'=>'2014-11-26T22:20:35','version'=>'1.3133' },{'date'=>'2015-02-23T01:33:08','version'=>'1.3134' },{'date'=>'2015-04-23T01:54:25','version'=>'1.3135' },{'date'=>'2015-05-24T15:48:19','version'=>'1.3136' },{'date'=>'2015-06-05T20:05:21','version'=>'1.3137' },{'date'=>'2015-06-12T20:55:50','version'=>'1.3138' },{'date'=>'2015-06-25T20:13:45','version'=>'1.3139' },{'date'=>'2015-07-03T13:56:32','version'=>'1.3140' },{'date'=>'2015-09-07T15:15:26','version'=>'1.3141' },{'date'=>'2015-09-15T00:52:23','version'=>'1.3142' },{'date'=>'2015-10-26T21:15:31','version'=>'1.3143' },{'date'=>'2015-11-04T12:36:07','version'=>'1.3144' },{'date'=>'2015-11-06T22:12:42','version'=>'1.3200' },{'date'=>'2015-11-07T19:27:25','version'=>'1.3201' },{'date'=>'2015-11-07T21:52:17','version'=>'1.3202' },{'date'=>'2016-02-15T21:33:45','version'=>'1.3300' },{'date'=>'2016-02-16T22:42:44','version'=>'1.3301' },{'date'=>'2018-05-20T19:52:07','version'=>'1.3203' },{'date'=>'2018-05-23T13:43:34','version'=>'1.3204' },{'date'=>'2018-06-13T22:02:36','version'=>'1.3205' },{'date'=>'2018-06-15T22:11:45','version'=>'1.3400' },{'date'=>'2018-10-01T11:53:31','version'=>'1.3401' },{'date'=>'2018-10-10T10:44:29','version'=>'1.3402' },{'date'=>'2018-10-11T22:45:37','version'=>'1.3403' },{'date'=>'2018-10-12T20:33:54','version'=>'1.3500' }]},'Dancer2'=>{'advisories'=>[{'affected_versions'=>'<0.206000','description'=>'There is a potential RCE with regards to Storable. We have added session ID validation to the session engine so that session backends based on Storable can reject malformed session IDs that may lead to exploitation of the RCE.
  ','distribution'=>'Dancer2','fixed_versions'=>'>=0.206000','id'=>'CPANSA-Dancer2-2018-01','references'=>['https://metacpan.org/changes/distribution/Dancer2','http://lists.preshweb.co.uk/pipermail/dancer-users/2018-April/005952.html','https://github.com/PerlDancer/Dancer2/commit/3580f5d0874a9abf5483528f73bda9a7fd9ec7f1' ],'reported'=>'2018-01-30','severity'=>'critical' }],'main_module'=>'Dancer2','versions'=>[{'date'=>'2013-02-22T15:39:46','version'=>'0.01' },{'date'=>'2013-02-24T11:04:25','version'=>'0.02' },{'date'=>'2013-03-07T17:30:37','version'=>'0.03' },{'date'=>'2013-04-22T19:58:02','version'=>'0.04' },{'date'=>'2013-07-20T16:53:37','version'=>'0.05' },{'date'=>'2013-07-30T14:29:42','version'=>'0.06' },{'date'=>'2013-08-03T22:17:54','version'=>'0.07' },{'date'=>'2013-08-18T12:24:31','version'=>'0.08' },{'date'=>'2013-09-01T21:19:26','version'=>'0.09' },{'date'=>'2013-09-28T13:29:35','version'=>'0.10' },{'date'=>'2013-12-15T13:21:28','version'=>'0.11' },{'date'=>'2014-04-07T21:05:16','version'=>'0.12' },{'date'=>'2014-04-13T17:20:22','version'=>'0.13' },{'date'=>'2014-04-28T21:16:57','version'=>'0.140000' },{'date'=>'2014-05-01T08:50:43','version'=>'0.140001' },{'date'=>'2014-06-07T20:35:57','version'=>'0.140900_01' },{'date'=>'2014-06-08T20:29:28','version'=>'0.141000' },{'date'=>'2014-06-24T19:18:07','version'=>'0.142000' },{'date'=>'2014-07-05T19:43:17','version'=>'0.143000' },{'date'=>'2014-07-23T19:34:51','version'=>'0.149000_01' },{'date'=>'2014-08-10T11:53:37','version'=>'0.149000_02' },{'date'=>'2014-08-16T23:38:39','version'=>'0.150000' },{'date'=>'2014-10-08T19:51:49','version'=>'0.151000' },{'date'=>'2014-10-14T02:33:06','version'=>'0.152000' },{'date'=>'2014-10-23T21:48:36','version'=>'0.153000' },{'date'=>'2014-10-29T21:41:13','version'=>'0.153001' },{'date'=>'2014-10-30T08:29:15','version'=>'0.153002' },{'date'=>'2014-11-17T14:41:14','version'=>'0.154000' },{'date'=>'2014-11-28T00:21:55','version'=>'0.155000' },{'date'=>'2014-11-28T16:44:27','version'=>'0.155001' },{'date'=>'2014-12-02T22:02:03','version'=>'0.155002' },{'date'=>'2014-12-03T21:35:35','version'=>'0.155003' },{'date'=>'2014-12-04T10:57:08','version'=>'0.155004' },{'date'=>'2014-12-07T17:07:21','version'=>'0.156000' },{'date'=>'2014-12-08T22:08:30','version'=>'0.156001' },{'date'=>'2014-12-14T17:25:53','version'=>'0.157000' },{'date'=>'2014-12-21T19:42:24','version'=>'0.157001' },{'date'=>'2015-01-01T17:11:48','version'=>'0.158000' },{'date'=>'2015-02-24T03:54:24','version'=>'0.159000' },{'date'=>'2015-02-25T14:33:59','version'=>'0.159001' },{'date'=>'2015-03-03T18:25:28','version'=>'0.159002' },{'date'=>'2015-03-23T14:00:19','version'=>'0.159003' },{'date'=>'2015-04-26T22:15:22','version'=>'0.160000' },{'date'=>'2015-05-14T18:46:02','version'=>'0.160001' },{'date'=>'2015-06-04T11:07:02','version'=>'0.160002' },{'date'=>'2015-06-06T09:11:43','version'=>'0.160003' },{'date'=>'2015-07-08T13:04:02','version'=>'0.161000' },{'date'=>'2015-08-28T13:32:02','version'=>'0.161000_01' },{'date'=>'2015-09-06T11:13:10','version'=>'0.162000' },{'date'=>'2015-10-13T15:08:16','version'=>'0.162000_01' },{'date'=>'2015-10-15T11:00:10','version'=>'0.163000' },{'date'=>'2015-12-16T22:44:32','version'=>'0.164000' },{'date'=>'2015-12-17T08:23:24','version'=>'0.165000' },{'date'=>'2016-01-12T18:04:57','version'=>'0.166000' },{'date'=>'2016-01-22T06:57:11','version'=>'0.166001' },{'date'=>'2016-04-19T19:52:27','version'=>'0.166001_01' },{'date'=>'2016-04-29T14:45:41','version'=>'0.166001_02' },{'date'=>'2016-05-27T11:25:55','version'=>'0.166001_03' },{'date'=>'2016-05-27T12:57:04','version'=>'0.166001_04' },{'date'=>'2016-05-31T13:29:37','version'=>'0.200000' },{'date'=>'2016-06-16T14:00:23','version'=>'0.200001' },{'date'=>'2016-06-22T14:41:29','version'=>'0.200002' },{'date'=>'2016-07-05T19:36:46','version'=>'0.200003' },{'date'=>'2016-07-11T15:21:33','version'=>'0.200003' },{'date'=>'2016-07-22T04:41:26','version'=>'0.200004' },{'date'=>'2016-07-22T13:28:45','version'=>'0.201000' },{'date'=>'2016-08-13T18:53:07','version'=>'0.202000' },{'date'=>'2016-08-25T03:12:19','version'=>'0.203000' },{'date'=>'2016-09-04T02:01:29','version'=>'0.203001' },{'date'=>'2016-10-11T01:59:49','version'=>'0.204000' },{'date'=>'2016-10-17T13:32:25','version'=>'0.204001' },{'date'=>'2016-12-21T21:47:24','version'=>'0.204002' },{'date'=>'2017-01-25T21:23:22','version'=>'0.204003' },{'date'=>'2017-01-26T17:31:30','version'=>'0.204004' },{'date'=>'2017-03-10T21:40:43','version'=>'0.205000' },{'date'=>'2017-07-11T13:04:56','version'=>'0.205001' },{'date'=>'2017-10-17T21:10:03','version'=>'0.205002' },{'date'=>'2018-04-09T00:54:25','version'=>'0.206000_01' },{'date'=>'2018-04-10T01:50:18','version'=>'0.206000_02' },{'date'=>'2018-04-20T02:12:22','version'=>'0.206000' },{'date'=>'2018-11-14T22:26:15','version'=>'0.207000' }]},'Data-Dumper'=>{'advisories'=>[{'affected_versions'=>'<2.154','cves'=>['CVE-2014-4330' ],'description'=>'Infinite recursion.
  ','distribution'=>'Data-Dumper','fixed_versions'=>'>=2.154','id'=>'CPANSA-Data-Dumper-2014-01','references'=>['https://metacpan.org/changes/distribution/Data-Dumper' ],'reported'=>'2014-09-30' }],'main_module'=>'Data::Dumper','versions'=>[{'date'=>'1995-11-19T22:29:08','version'=>'1.21' },{'date'=>'1995-11-23T05:45:27','version'=>'1.22' },{'date'=>'1995-12-04T03:12:16','version'=>'1.23' },{'date'=>'1996-04-09T15:54:26','version'=>'2.00' },{'date'=>'1996-04-10T04:25:17','version'=>'2.01' },{'date'=>'1996-04-13T07:14:35','version'=>'2.02' },{'date'=>'1996-08-26T14:36:59','version'=>'2.03' },{'date'=>'1996-08-28T20:11:49','version'=>'2.04' },{'date'=>'1996-12-02T13:42:49','version'=>'2.05' },{'date'=>'1996-12-02T23:07:56','version'=>'2.06' },{'date'=>'1996-12-07T17:28:27','version'=>'2.07' },{'date'=>'1997-12-07T21:27:09','version'=>'2.08' },{'date'=>'1998-01-15T20:36:46','version'=>'2.081' },{'date'=>'1998-03-06T21:08:49','version'=>'2.081' },{'date'=>'1998-07-17T05:23:08','version'=>'2.09' },{'date'=>'1998-07-21T12:08:19','version'=>'2.09' },{'date'=>'1998-10-31T12:10:30','version'=>'2.10' },{'date'=>'1999-05-01T02:01:03','version'=>'2.101' },{'date'=>'1999-06-02T01:30:55','version'=>'2.101' },{'date'=>'2003-07-20T16:59:48','version'=>'2.12_01' },{'date'=>'2003-07-31T19:12:44','version'=>'2.12_02' },{'date'=>'2003-08-25T11:49:41','version'=>'2.121' },{'date'=>'2009-06-06T14:45:36','version'=>'2.121_20' },{'date'=>'2009-06-09T15:49:12','version'=>'2.122' },{'date'=>'2009-06-11T08:07:01','version'=>'2.123' },{'date'=>'2009-06-13T15:22:32','version'=>'2.124' },{'date'=>'2009-08-08T10:33:01','version'=>'2.125' },{'date'=>'2010-04-15T19:55:01','version'=>'2.126' },{'date'=>'2010-09-06T14:28:10','version'=>'2.126_01' },{'date'=>'2010-09-10T07:08:41','version'=>'2.127' },{'date'=>'2010-09-10T07:11:52','version'=>'2.128' },{'date'=>'2011-05-20T15:53:12','version'=>'2.130_03' },{'date'=>'2011-05-27T14:19:03','version'=>'2.131' },{'date'=>'2011-12-19T08:23:05','version'=>'2.135_01' },{'date'=>'2011-12-29T17:09:49','version'=>'2.135_02' },{'date'=>'2012-08-07T06:59:51','version'=>'2.135_07' },{'date'=>'2012-10-04T07:35:07','version'=>'2.136' },{'date'=>'2012-12-12T06:30:48','version'=>'2.139' },{'date'=>'2013-02-26T06:57:29','version'=>'2.143' },{'date'=>'2013-03-15T09:46:49','version'=>'2.145' },{'date'=>'2014-03-07T09:28:44','version'=>'2.151' },{'date'=>'2014-09-18T15:47:37','version'=>'2.154' },{'date'=>'2016-07-03T19:17:57','version'=>'2.160' },{'date'=>'2016-07-11T20:13:06','version'=>'2.161' },{'date'=>'2017-07-31T15:31:28','version'=>'2.167_01' },{'date'=>'2017-08-04T08:05:22','version'=>'2.167_02' },{'date'=>'2018-09-19T14:41:58','version'=>'2.172' },{'date'=>'2018-11-10T10:10:30','version'=>'2.173' }]},'Dezi'=>{'advisories'=>[{'affected_versions'=>'<0.002002','description'=>'Bypassing authentication on the /index URL app with non-idempotent requests to /search URL.
  ','distribution'=>'Dezi','fixed_versions'=>'>=0.002002','id'=>'CPANSA-Dezi-2012-01','references'=>['https://metacpan.org/changes/distribution/Dezi','https://github.com/karpet/Dezi/commit/f1ad292b4dd988d1a38202c804bb7a2a3bcca3c8' ],'reported'=>'2012-09-13' }],'main_module'=>'Dezi','versions'=>[{'date'=>'2011-06-22T04:53:57','version'=>'0.001000' },{'date'=>'2011-08-03T02:42:22','version'=>'0.001001' },{'date'=>'2011-09-30T03:35:08','version'=>'0.001002' },{'date'=>'2011-10-23T02:12:02','version'=>'0.001003' },{'date'=>'2012-03-17T02:40:15','version'=>'0.001004' },{'date'=>'2012-07-11T03:20:40','version'=>'0.001005' },{'date'=>'2012-08-18T02:43:23','version'=>'0.001006' },{'date'=>'2012-08-22T03:58:33','version'=>'0.001007' },{'date'=>'2012-09-04T02:05:34','version'=>'0.001008' },{'date'=>'2012-09-12T03:51:13','version'=>'0.002000' },{'date'=>'2012-09-13T01:50:59','version'=>'0.002001' },{'date'=>'2012-09-13T14:10:02','version'=>'0.002002' },{'date'=>'2012-10-16T00:57:46','version'=>'0.002003' },{'date'=>'2012-10-18T03:15:21','version'=>'0.002004' },{'date'=>'2012-12-19T05:25:13','version'=>'0.002005' },{'date'=>'2013-02-03T02:49:07','version'=>'0.002006' },{'date'=>'2013-02-05T15:02:54','version'=>'0.002007' },{'date'=>'2013-02-09T05:37:41','version'=>'0.002008' },{'date'=>'2013-02-13T02:30:33','version'=>'0.002009' },{'date'=>'2013-02-13T04:31:49','version'=>'0.002010' },{'date'=>'2013-11-13T17:08:03','version'=>'0.002011' },{'date'=>'2014-02-27T18:08:30','version'=>'0.002012' },{'date'=>'2014-06-05T06:59:12','version'=>'0.002998_01' },{'date'=>'2014-06-08T04:59:17','version'=>'0.003000' },{'date'=>'2014-07-30T20:40:24','version'=>'0.004000' },{'date'=>'2014-09-02T02:45:00','version'=>'0.004001' },{'date'=>'2015-04-30T22:01:11','version'=>'0.004002' },{'date'=>'2018-05-16T02:24:24','version'=>'0.004003' }]},'Email-Address'=>{'advisories'=>[{'affected_versions'=>'<1.905','cves'=>['CVE-2014-0477' ],'description'=>'Inefficient regular expression, which allows remote attackers to cause a denial of service (CPU consumption) via an empty quoted string in an RFC 2822 address.
  ','distribution'=>'Email-Address','fixed_versions'=>'>=1.905','id'=>'CPANSA-Email-Address-2014-01','references'=>['https://metacpan.org/changes/distribution/Email-Address' ],'reported'=>'2014-07-03' }],'main_module'=>'Email::Address','versions'=>[{'date'=>'2004-05-27T03:19:56','version'=>'1.1' },{'date'=>'2004-06-02T16:35:30','version'=>'1.2' },{'date'=>'2004-08-16T21:39:58','version'=>'1.3' },{'date'=>'2004-10-05T18:10:42','version'=>'1.5' },{'date'=>'2004-10-05T18:20:42','version'=>'1.6' },{'date'=>'2004-10-13T10:21:17','version'=>'1.7' },{'date'=>'2004-10-22T16:37:27','version'=>'1.80' },{'date'=>'2006-07-11T15:04:28','version'=>'1.85' },{'date'=>'2006-07-22T00:42:17','version'=>'1.86' },{'date'=>'2006-08-10T16:48:44','version'=>'1.870' },{'date'=>'2006-10-12T19:35:04','version'=>'1.861' },{'date'=>'2006-10-12T22:16:28','version'=>'1.871' },{'date'=>'2006-11-11T16:01:38','version'=>'1.880' },{'date'=>'2006-11-19T21:19:02','version'=>'1.881' },{'date'=>'2006-11-22T01:26:44','version'=>'1.882' },{'date'=>'2006-11-25T13:53:46','version'=>'1.883' },{'date'=>'2006-12-05T03:41:39','version'=>'1.884' },{'date'=>'2007-03-01T01:08:16','version'=>'1.885' },{'date'=>'2007-03-01T20:18:53','version'=>'1.886' },{'date'=>'2007-04-01T19:15:49','version'=>'1.887' },{'date'=>'2007-06-23T01:27:24','version'=>'1.888' },{'date'=>'2007-12-19T22:14:37','version'=>'1.889' },{'date'=>'2010-08-22T19:03:33','version'=>'1.890' },{'date'=>'2010-08-31T00:56:53','version'=>'1.891' },{'date'=>'2010-09-03T23:45:13','version'=>'1.892' },{'date'=>'2012-01-03T03:55:12','version'=>'1.893' },{'date'=>'2012-01-14T16:17:56','version'=>'1.894' },{'date'=>'2012-01-15T18:41:33','version'=>'1.895' },{'date'=>'2012-08-01T03:07:33','version'=>'1.896' },{'date'=>'2012-12-17T15:16:33','version'=>'1.897' },{'date'=>'2013-02-07T21:41:48','version'=>'1.898' },{'date'=>'2013-08-02T14:54:13','version'=>'1.899' },{'date'=>'2013-08-08T18:46:07','version'=>'1.900' },{'date'=>'2014-01-29T03:43:28','version'=>'1.901' },{'date'=>'2014-04-17T15:19:31','version'=>'1.902' },{'date'=>'2014-04-18T01:07:10','version'=>'1.903' },{'date'=>'2014-06-14T04:22:22','version'=>'1.904' },{'date'=>'2014-06-18T02:55:59','version'=>'1.905' },{'date'=>'2015-02-03T21:49:39','version'=>'1.906' },{'date'=>'2015-02-03T22:48:46','version'=>'1.907' },{'date'=>'2015-09-20T02:55:12','version'=>'1.908' },{'date'=>'2018-03-05T03:26:56','version'=>'1.909' },{'date'=>'2018-12-18T02:29:23','version'=>'1.910' },{'date'=>'2018-12-22T16:31:37','version'=>'1.911' },{'date'=>'2018-12-31T19:51:36','version'=>'1.912' }]},'Encode'=>{'advisories'=>[{'affected_versions'=>'<2.85','cves'=>['CVE-2016-1238' ],'description'=>'Loading optional modules from . (current directory).
  ','distribution'=>'Encode','fixed_versions'=>'>=2.85','id'=>'CPANSA-Encode-2016-01','references'=>['https://metacpan.org/changes/distribution/Encode','https://github.com/dankogai/p5-encode/pull/58/commits/12be15d64ce089154c4367dc1842cd0dc0993ec6' ],'reported'=>'2016-07-27' }],'main_module'=>'Encode','versions'=>[{'date'=>'2002-03-20T08:30:40','version'=>'0.93' },{'date'=>'2002-03-20T20:15:52','version'=>'0.94' },{'date'=>'2002-03-21T16:07:21','version'=>'0.95' },{'date'=>'2002-03-22T22:33:15','version'=>'0.96' },{'date'=>'2002-03-23T20:36:05','version'=>'0.97' },{'date'=>'2002-03-24T16:07:09','version'=>'0.98' },{'date'=>'2002-03-25T19:45:16','version'=>'0.99' },{'date'=>'2002-03-28T23:39:49','version'=>'1.00' },{'date'=>'2002-03-29T21:43:17','version'=>'1.01' },{'date'=>'2002-03-31T21:40:25','version'=>'1.10' },{'date'=>'2002-03-31T22:27:07','version'=>'1.11' },{'date'=>'2002-04-04T20:02:40','version'=>'1.20' },{'date'=>'2002-04-07T15:36:48','version'=>'1.26' },{'date'=>'2002-04-07T18:49:41','version'=>'1.27' },{'date'=>'2002-04-07T19:05:34','version'=>'1.28' },{'date'=>'2002-04-08T02:49:31','version'=>'1.30' },{'date'=>'2002-04-08T18:51:14','version'=>'1.31' },{'date'=>'2002-04-09T20:26:37','version'=>'1.32' },{'date'=>'2002-04-10T22:44:19','version'=>'1.33' },{'date'=>'2002-04-14T22:49:10','version'=>'1.40' },{'date'=>'2002-04-16T23:47:16','version'=>'1.41' },{'date'=>'2002-04-19T06:18:26','version'=>'1.50' },{'date'=>'2002-04-20T10:08:39','version'=>'1.51' },{'date'=>'2002-04-20T23:55:45','version'=>'1.52' },{'date'=>'2002-04-22T09:56:04','version'=>'1.56' },{'date'=>'2002-04-22T20:37:12','version'=>'1.57' },{'date'=>'2002-04-23T00:22:06','version'=>'1.58' },{'date'=>'2002-04-24T20:23:42','version'=>'1.60' },{'date'=>'2002-04-26T03:19:40','version'=>'1.61' },{'date'=>'2002-04-27T11:43:39','version'=>'1.62' },{'date'=>'2002-04-27T19:52:51','version'=>'1.63' },{'date'=>'2002-04-29T07:20:38','version'=>'1.64' },{'date'=>'2002-04-30T16:40:07','version'=>'1.65' },{'date'=>'2002-05-01T05:51:35','version'=>'1.66' },{'date'=>'2002-05-02T07:43:35','version'=>'1.67' },{'date'=>'2002-05-03T12:29:47','version'=>'1.68' },{'date'=>'2002-05-04T16:50:40','version'=>'1.69' },{'date'=>'2002-05-06T10:36:39','version'=>'1.70' },{'date'=>'2002-05-07T16:30:42','version'=>'1.71' },{'date'=>'2002-05-20T16:04:48','version'=>'1.72' },{'date'=>'2002-05-28T18:41:36','version'=>'1.74' },{'date'=>'2002-06-01T18:17:49','version'=>'1.75' },{'date'=>'2002-08-25T15:18:49','version'=>'1.76' },{'date'=>'2002-10-06T03:59:19','version'=>'1.77' },{'date'=>'2002-10-20T15:55:16','version'=>'1.78' },{'date'=>'2002-10-21T06:11:36','version'=>'1.79' },{'date'=>'2002-10-21T20:42:56','version'=>'1.80' },{'date'=>'2002-11-08T18:42:11','version'=>'1.81' },{'date'=>'2002-11-14T23:17:11','version'=>'1.82' },{'date'=>'2002-11-18T18:06:47','version'=>'1.83' },{'date'=>'2003-01-10T12:09:05','version'=>'1.84' },{'date'=>'2003-01-21T22:23:28','version'=>'1.85' },{'date'=>'2003-01-22T03:36:42','version'=>'1.86' },{'date'=>'2003-02-06T02:01:00','version'=>'1.87' },{'date'=>'2003-02-20T14:46:12','version'=>'1.88' },{'date'=>'2003-02-28T01:45:53','version'=>'1.89' },{'date'=>'2003-03-09T17:54:26','version'=>'1.90' },{'date'=>'2003-03-09T20:12:08','version'=>'1.91' },{'date'=>'2003-03-31T03:51:31','version'=>'1.92' },{'date'=>'2003-04-24T17:50:54','version'=>'1.93' },{'date'=>'2003-05-10T18:31:48','version'=>'1.94' },{'date'=>'2003-05-21T09:22:43','version'=>'1.95' },{'date'=>'2003-06-18T09:41:21','version'=>'1.96' },{'date'=>'2003-07-08T22:01:28','version'=>'1.97' },{'date'=>'2003-08-25T11:47:32','version'=>'1.98' },{'date'=>'2003-12-29T02:52:28','version'=>'1.99' },{'date'=>'2004-05-16T21:05:06','version'=>'2.00' },{'date'=>'2004-05-25T16:31:35','version'=>'2.01' },{'date'=>'2004-08-31T11:01:51','version'=>'2.02' },{'date'=>'2004-10-06T06:50:47','version'=>'2.03' },{'date'=>'2004-10-16T21:26:58','version'=>'2.04' },{'date'=>'2004-10-19T05:03:32','version'=>'2.05' },{'date'=>'2004-10-22T06:29:14','version'=>'2.06' },{'date'=>'2004-10-22T19:43:19','version'=>'2.07' },{'date'=>'2004-10-24T13:04:29','version'=>'2.08' },{'date'=>'2004-12-03T19:21:42','version'=>'2.09' },{'date'=>'2005-05-16T18:54:53','version'=>'2.10' },{'date'=>'2005-08-05T11:26:06','version'=>'2.11' },{'date'=>'2005-09-08T14:23:38','version'=>'2.12' },{'date'=>'2006-01-15T15:12:01','version'=>'2.13' },{'date'=>'2006-01-15T15:57:41','version'=>'2.14' },{'date'=>'2006-04-06T16:01:30','version'=>'2.15' },{'date'=>'2006-05-03T18:38:44','version'=>'2.16' },{'date'=>'2006-05-09T17:14:04','version'=>'2.17' },{'date'=>'2006-06-03T20:34:08','version'=>'2.18' },{'date'=>'2007-04-06T13:05:52','version'=>'2.19' },{'date'=>'2007-04-22T15:17:34','version'=>'2.20' },{'date'=>'2007-05-12T06:50:09','version'=>'2.21' },{'date'=>'2007-05-29T07:43:07','version'=>'2.22' },{'date'=>'2007-05-29T18:21:25','version'=>'2.23' },{'date'=>'2008-03-12T10:12:18','version'=>'2.24' },{'date'=>'2008-05-07T21:06:08','version'=>'2.25' },{'date'=>'2008-07-01T21:03:33','version'=>'2.26' },{'date'=>'2009-01-21T23:01:50','version'=>'2.27' },{'date'=>'2009-02-01T13:16:44','version'=>'2.29' },{'date'=>'2009-02-15T17:48:01','version'=>'2.30' },{'date'=>'2009-02-16T06:25:32','version'=>'2.31' },{'date'=>'2009-03-07T07:45:00','version'=>'2.32' },{'date'=>'2009-03-25T08:01:10','version'=>'2.33' },{'date'=>'2009-07-08T13:53:25','version'=>'2.34' },{'date'=>'2009-07-13T02:32:45','version'=>'2.35' },{'date'=>'2009-09-06T09:20:21','version'=>'2.36' },{'date'=>'2009-09-06T14:37:23','version'=>'2.37' },{'date'=>'2009-11-16T14:34:43','version'=>'2.38' },{'date'=>'2009-11-26T09:31:02','version'=>'2.39' },{'date'=>'2010-09-18T18:47:17','version'=>'2.40' },{'date'=>'2010-12-23T11:12:33','version'=>'2.41' },{'date'=>'2010-12-31T22:52:35','version'=>'2.42' },{'date'=>'2011-05-21T23:21:24','version'=>'2.43' },{'date'=>'2011-08-09T08:01:30','version'=>'2.44' },{'date'=>'2012-08-05T23:15:11','version'=>'2.45' },{'date'=>'2012-08-12T05:52:45','version'=>'2.46' },{'date'=>'2012-08-15T05:40:21','version'=>'2.47' },{'date'=>'2013-02-18T02:43:35','version'=>'2.48' },{'date'=>'2013-03-05T03:19:15','version'=>'2.49' },{'date'=>'2013-04-26T18:36:59','version'=>'2.50' },{'date'=>'2013-04-29T22:21:31','version'=>'2.51' },{'date'=>'2013-08-14T02:33:46','version'=>'2.52' },{'date'=>'2013-08-29T15:27:02','version'=>'2.53' },{'date'=>'2013-08-29T16:50:08','version'=>'2.54' },{'date'=>'2013-09-14T07:58:54','version'=>'2.55' },{'date'=>'2013-12-22T04:12:07','version'=>'2.56' },{'date'=>'2014-01-03T04:55:36','version'=>'2.57' },{'date'=>'2014-03-28T02:41:54','version'=>'2.58' },{'date'=>'2014-04-06T17:41:19','version'=>'2.59' },{'date'=>'2014-04-29T16:34:10','version'=>'2.60' },{'date'=>'2014-05-31T09:55:56','version'=>'2.61' },{'date'=>'2014-05-31T12:20:28','version'=>'2.62' },{'date'=>'2014-10-19T07:13:44','version'=>'2.63' },{'date'=>'2014-10-29T15:42:04','version'=>'2.64' },{'date'=>'2014-11-27T14:12:57','version'=>'2.65' },{'date'=>'2014-12-02T23:37:28','version'=>'2.66' },{'date'=>'2014-12-04T20:28:33','version'=>'2.67' },{'date'=>'2015-01-22T10:29:46','version'=>'2.68' },{'date'=>'2015-02-05T10:43:34','version'=>'2.69' },{'date'=>'2015-02-05T10:56:52','version'=>'2.70' },{'date'=>'2015-03-12T00:14:19','version'=>'2.71' },{'date'=>'2015-03-14T02:51:25','version'=>'2.72' },{'date'=>'2015-04-15T23:27:13','version'=>'2.73' },{'date'=>'2015-06-25T00:59:20','version'=>'2.74' },{'date'=>'2015-06-30T10:10:03','version'=>'2.75' },{'date'=>'2015-07-31T02:26:51','version'=>'2.76' },{'date'=>'2015-09-15T14:03:35','version'=>'2.77' },{'date'=>'2015-09-24T02:29:52','version'=>'2.78' },{'date'=>'2016-01-22T07:08:25','version'=>'2.79' },{'date'=>'2016-01-25T15:04:42','version'=>'2.80' },{'date'=>'2016-02-06T19:34:58','version'=>'2.81' },{'date'=>'2016-02-06T20:21:37','version'=>'2.82' },{'date'=>'2016-03-24T08:00:30','version'=>'2.83' },{'date'=>'2016-04-11T07:24:26','version'=>'2.84' },{'date'=>'2016-08-04T03:37:23','version'=>'2.85' },{'date'=>'2016-08-10T18:25:39','version'=>'2.86' },{'date'=>'2016-10-28T05:15:33','version'=>'2.87' },{'date'=>'2016-11-29T23:38:19','version'=>'2.88' },{'date'=>'2017-04-21T05:24:59','version'=>'2.89' },{'date'=>'2017-06-10T17:46:11','version'=>'2.90' },{'date'=>'2017-06-22T08:18:22','version'=>'2.91' },{'date'=>'2017-07-18T07:23:39','version'=>'2.92' },{'date'=>'2017-10-06T22:33:35','version'=>'2.93' },{'date'=>'2018-01-09T06:04:38','version'=>'2.94' },{'date'=>'2018-02-08T00:41:02','version'=>'2.95' },{'date'=>'2018-02-11T05:41:37','version'=>'2.96' },{'date'=>'2018-02-21T12:30:05','version'=>'2.97' },{'date'=>'2018-04-22T09:14:59','version'=>'2.98' },{'date'=>'2019-01-21T03:28:35','version'=>'2.99' },{'date'=>'2019-01-31T04:42:29','version'=>'2.100' },{'date'=>'2019-01-31T05:05:06','version'=>'3.00' }]},'ExtUtils-MakeMaker'=>{'advisories'=>[{'affected_versions'=>'<7.22','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'ExtUtils-MakeMaker','fixed_versions'=>'>=7.22','id'=>'CPANSA-ExtUtils-MakeMaker-2016-01','references'=>['https://metacpan.org/changes/distribution/ExtUtils-MakeMaker','https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker/commit/3e9df17d11c40f2561c23ec79693c8c390e0ae88' ],'reported'=>'2016-08-07' }],'main_module'=>'ExtUtils::MakeMaker','versions'=>[{'date'=>'2001-07-06T08:23:56','version'=>'5.47_01' },{'date'=>'2002-01-16T20:19:18','version'=>'5.48_01' },{'date'=>'2002-01-18T04:56:33','version'=>'5.48_03' },{'date'=>'2002-01-22T00:33:31','version'=>'5.48_04' },{'date'=>'2002-02-04T08:46:04','version'=>'5.49_01' },{'date'=>'2002-03-05T04:53:40','version'=>'5.50_01' },{'date'=>'2002-03-25T07:53:14','version'=>'5.51_01' },{'date'=>'2002-03-26T05:56:07','version'=>'5.52_01' },{'date'=>'2002-03-31T03:55:52','version'=>'5.54_01' },{'date'=>'2002-04-05T05:01:52','version'=>'5.55_01' },{'date'=>'2002-04-06T08:29:20','version'=>'5.55_02' },{'date'=>'2002-04-07T03:04:18','version'=>'5.55_03' },{'date'=>'2002-04-11T05:32:04','version'=>'5.90_01' },{'date'=>'2002-04-24T04:21:44','version'=>'5.91_01' },{'date'=>'2002-04-30T03:43:53','version'=>'5.92_01' },{'date'=>'2002-05-06T06:02:08','version'=>'5.93_01' },{'date'=>'2002-05-17T19:04:41','version'=>'5.94_01' },{'date'=>'2002-05-17T21:24:13','version'=>'5.94_02' },{'date'=>'2002-05-18T18:43:02','version'=>'5.95_01' },{'date'=>'2002-05-23T21:01:02','version'=>'5.96_01' },{'date'=>'2002-05-26T01:25:25','version'=>'6.00' },{'date'=>'2002-05-30T19:02:20','version'=>'6.01' },{'date'=>'2002-06-16T05:41:28','version'=>'6.02' },{'date'=>'2002-06-19T21:24:32','version'=>'6.03' },{'date'=>'2002-08-27T01:42:36','version'=>'6.04' },{'date'=>'2002-08-27T23:24:30','version'=>'6.05' },{'date'=>'2002-12-19T08:42:01','version'=>'6.06_01' },{'date'=>'2002-12-24T04:54:53','version'=>'6.06_02' },{'date'=>'2003-03-30T03:49:59','version'=>'6.06_03' },{'date'=>'2003-03-31T04:37:55','version'=>'6.06_04' },{'date'=>'2003-03-31T10:50:00','version'=>'6.06_05' },{'date'=>'2003-04-07T02:46:10','version'=>'6.10_01' },{'date'=>'2003-04-07T08:33:23','version'=>'6.10_02' },{'date'=>'2003-04-11T07:27:36','version'=>'6.10_03' },{'date'=>'2003-05-23T09:05:27','version'=>'6.10_04' },{'date'=>'2003-06-07T01:32:29','version'=>'6.10_05' },{'date'=>'2003-06-07T08:00:14','version'=>'6.10_06' },{'date'=>'2003-07-05T23:40:34','version'=>'6.10_07' },{'date'=>'2003-07-22T01:23:46','version'=>'6.10_08' },{'date'=>'2003-07-28T04:00:19','version'=>'6.11' },{'date'=>'2003-07-30T05:28:47','version'=>'6.12' },{'date'=>'2003-07-31T23:51:40','version'=>'6.13' },{'date'=>'2003-08-03T23:27:51','version'=>'6.14' },{'date'=>'2003-08-03T23:46:11','version'=>'6.15' },{'date'=>'2003-08-18T08:43:08','version'=>'6.16' },{'date'=>'2003-09-15T22:23:01','version'=>'6.17' },{'date'=>'2003-11-04T04:12:53','version'=>'6.18' },{'date'=>'2003-11-04T07:03:30','version'=>'6.19' },{'date'=>'2003-11-06T10:37:47','version'=>'6.20' },{'date'=>'2003-11-11T08:26:17','version'=>'6.21' },{'date'=>'2004-04-03T21:33:45','version'=>'6.21_03' },{'date'=>'2004-11-24T04:06:20','version'=>'6.22' },{'date'=>'2004-11-26T21:15:45','version'=>'6.23' },{'date'=>'2004-11-30T20:42:14','version'=>'6.24' },{'date'=>'2004-12-09T06:00:53','version'=>'6.24_01' },{'date'=>'2004-12-15T12:05:50','version'=>'6.25' },{'date'=>'2004-12-18T02:34:56','version'=>'6.25_01' },{'date'=>'2004-12-20T08:36:56','version'=>'6.25_02' },{'date'=>'2004-12-21T04:17:27','version'=>'6.25_03' },{'date'=>'2004-12-21T05:58:10','version'=>'6.25_04' },{'date'=>'2004-12-22T13:05:53','version'=>'6.25_05' },{'date'=>'2004-12-26T22:26:26','version'=>'6.25_06' },{'date'=>'2004-12-31T08:53:31','version'=>'6.25_07' },{'date'=>'2005-02-08T14:21:17','version'=>'6.25_08' },{'date'=>'2005-03-12T18:29:26','version'=>'6.25_09' },{'date'=>'2005-03-14T00:17:26','version'=>'6.25_10' },{'date'=>'2005-03-15T10:05:07','version'=>'6.25_11' },{'date'=>'2005-03-19T00:19:47','version'=>'6.25_12' },{'date'=>'2005-03-22T22:50:34','version'=>'6.26' },{'date'=>'2005-03-29T05:48:40','version'=>'6.26_01' },{'date'=>'2005-04-04T23:55:46','version'=>'6.27' },{'date'=>'2005-04-12T23:23:53','version'=>'6.28' },{'date'=>'2005-05-19T21:22:00','version'=>'6.29' },{'date'=>'2005-05-20T23:14:45','version'=>'6.30' },{'date'=>'2005-08-17T06:59:11','version'=>'6.30_01' },{'date'=>'2006-09-01T19:07:28','version'=>'6.30_02' },{'date'=>'2006-09-01T21:06:57','version'=>'6.30_03' },{'date'=>'2006-09-11T20:20:27','version'=>'6.30_04' },{'date'=>'2006-10-10T01:04:44','version'=>'6.31' },{'date'=>'2007-02-21T16:02:09','version'=>'6.32' },{'date'=>'2007-06-29T22:18:15','version'=>'6.33' },{'date'=>'2007-06-30T16:10:15','version'=>'6.34' },{'date'=>'2007-07-02T03:56:25','version'=>'6.35' },{'date'=>'2007-07-03T08:10:57','version'=>'6.36' },{'date'=>'2007-11-26T01:10:14','version'=>'6.37_01' },{'date'=>'2007-11-26T07:35:50','version'=>'6.37_02' },{'date'=>'2007-11-26T22:18:55','version'=>'6.37_03' },{'date'=>'2007-11-29T00:04:35','version'=>'6.38' },{'date'=>'2007-12-06T11:08:15','version'=>'6.40' },{'date'=>'2007-12-08T01:02:26','version'=>'6.42' },{'date'=>'2008-01-02T00:09:23','version'=>'6.43_01' },{'date'=>'2008-02-29T00:08:42','version'=>'6.44' },{'date'=>'2008-09-06T10:22:44','version'=>'6.45_01' },{'date'=>'2008-09-07T21:18:05','version'=>'6.45_02' },{'date'=>'2008-09-27T21:37:54','version'=>'6.46' },{'date'=>'2008-10-14T16:41:49','version'=>'6.47_01' },{'date'=>'2008-10-16T23:18:52','version'=>'6.47_02' },{'date'=>'2008-10-20T18:20:40','version'=>'6.48' },{'date'=>'2009-02-20T01:11:08','version'=>'6.49_01' },{'date'=>'2009-03-22T19:30:00','version'=>'6.50' },{'date'=>'2009-04-10T21:33:29','version'=>'6.51_01' },{'date'=>'2009-04-14T04:22:58','version'=>'6.51_02' },{'date'=>'2009-05-24T05:41:35','version'=>'6.51_03' },{'date'=>'2009-05-24T21:07:28','version'=>'6.51_04' },{'date'=>'2009-05-30T18:41:35','version'=>'6.52' },{'date'=>'2009-06-08T02:05:24','version'=>'6.53_01' },{'date'=>'2009-06-08T02:28:24','version'=>'6.53_02' },{'date'=>'2009-07-02T21:55:25','version'=>'6.53_03' },{'date'=>'2009-07-07T23:53:09','version'=>'6.54' },{'date'=>'2009-07-14T23:02:39','version'=>'6.55_01' },{'date'=>'2009-08-05T07:40:59','version'=>'6.55_02' },{'date'=>'2009-12-05T07:09:23','version'=>'6.55_03' },{'date'=>'2009-12-17T22:06:47','version'=>'6.56' },{'date'=>'2010-08-24T08:38:36','version'=>'6.57_01' },{'date'=>'2010-09-07T23:43:49','version'=>'6.57_02' },{'date'=>'2010-09-08T22:33:36','version'=>'6.57_03' },{'date'=>'2010-09-09T23:52:37','version'=>'6.57_04' },{'date'=>'2010-09-11T20:25:23','version'=>'6.57_05' },{'date'=>'2010-10-06T10:53:43','version'=>'6.57_06' },{'date'=>'2011-03-25T03:41:39','version'=>'6.57_07' },{'date'=>'2011-03-27T11:00:41','version'=>'6.57_08' },{'date'=>'2011-03-28T00:15:59','version'=>'6.57_09' },{'date'=>'2011-04-04T05:33:46','version'=>'6.57_10' },{'date'=>'2011-05-20T00:34:23','version'=>'6.57_11' },{'date'=>'2011-07-06T21:22:27','version'=>'6.58' },{'date'=>'2011-08-03T20:25:34','version'=>'6.58_01' },{'date'=>'2011-08-05T13:07:58','version'=>'6.59' },{'date'=>'2011-09-25T05:23:43','version'=>'6.61_01' },{'date'=>'2011-10-23T23:48:06','version'=>'6.62' },{'date'=>'2011-10-24T00:40:49','version'=>'6.63_01' },{'date'=>'2011-11-02T00:07:43','version'=>'6.63_02' },{'date'=>'2012-11-02T03:58:40','version'=>'6.63_03' },{'date'=>'2012-11-22T21:25:35','version'=>'6.63_04' },{'date'=>'2012-12-17T02:35:20','version'=>'6.64' },{'date'=>'2013-03-18T23:21:28','version'=>'6.65_01' },{'date'=>'2013-04-14T09:59:15','version'=>'6.65_02' },{'date'=>'2013-04-15T12:50:31','version'=>'6.65_03' },{'date'=>'2013-04-19T17:52:08','version'=>'6.66' },{'date'=>'2013-04-25T20:08:31','version'=>'6.67_01' },{'date'=>'2013-06-02T17:31:16','version'=>'6.67_02' },{'date'=>'2013-06-05T21:09:00','version'=>'6.67_03' },{'date'=>'2013-06-10T19:25:22','version'=>'6.67_04' },{'date'=>'2013-06-13T20:55:25','version'=>'6.67_05' },{'date'=>'2013-06-14T22:35:24','version'=>'6.68' },{'date'=>'2013-06-20T12:00:00','version'=>'6.69_01' },{'date'=>'2013-07-02T12:16:23','version'=>'6.69_02' },{'date'=>'2013-07-09T21:47:07','version'=>'6.69_03' },{'date'=>'2013-07-10T10:50:08','version'=>'6.69_04' },{'date'=>'2013-07-11T21:20:53','version'=>'6.69_05' },{'date'=>'2013-07-12T13:51:50','version'=>'6.69_06' },{'date'=>'2013-07-16T14:34:32','version'=>'6.69_07' },{'date'=>'2013-07-16T23:40:44','version'=>'6.69_08' },{'date'=>'2013-07-21T08:26:44','version'=>'6.69_09' },{'date'=>'2013-07-23T21:42:47','version'=>'6.70' },{'date'=>'2013-07-24T08:33:58','version'=>'6.71_01' },{'date'=>'2013-07-24T17:42:20','version'=>'6.72' },{'date'=>'2013-07-24T22:53:41','version'=>'6.73_01' },{'date'=>'2013-07-26T12:34:19','version'=>'6.73_02' },{'date'=>'2013-07-30T21:12:02','version'=>'6.73_03' },{'date'=>'2013-08-01T21:41:12','version'=>'6.73_04' },{'date'=>'2013-08-05T16:45:38','version'=>'6.73_05' },{'date'=>'2013-08-05T23:52:18','version'=>'6.73_06' },{'date'=>'2013-08-07T15:09:12','version'=>'6.73_07' },{'date'=>'2013-08-09T18:52:24','version'=>'6.73_08' },{'date'=>'2013-08-09T19:00:18','version'=>'6.73_09' },{'date'=>'2013-08-16T15:43:35','version'=>'6.73_10' },{'date'=>'2013-08-17T21:57:55','version'=>'6.73_11' },{'date'=>'2013-08-23T09:52:43','version'=>'6.73_12' },{'date'=>'2013-08-27T11:45:55','version'=>'6.74' },{'date'=>'2013-08-29T14:09:22','version'=>'6.75_01' },{'date'=>'2013-09-01T20:52:29','version'=>'6.75_02' },{'date'=>'2013-09-02T23:26:56','version'=>'6.75_03' },{'date'=>'2013-09-05T11:10:20','version'=>'6.75_04' },{'date'=>'2013-09-06T12:40:59','version'=>'6.76' },{'date'=>'2013-09-10T14:22:45','version'=>'6.77_01' },{'date'=>'2013-09-12T20:23:49','version'=>'6.77_02' },{'date'=>'2013-09-16T11:23:59','version'=>'6.77_03' },{'date'=>'2013-09-18T18:25:33','version'=>'6.77_04' },{'date'=>'2013-09-19T13:12:32','version'=>'6.77_05' },{'date'=>'2013-09-19T14:43:24','version'=>'6.77_06' },{'date'=>'2013-09-21T08:48:44','version'=>'6.77_07' },{'date'=>'2013-09-22T17:46:50','version'=>'6.77_08' },{'date'=>'2013-09-23T12:47:39','version'=>'6.78' },{'date'=>'2013-10-01T14:01:33','version'=>'6.79_01' },{'date'=>'2013-10-11T12:01:23','version'=>'6.79_02' },{'date'=>'2013-10-11T13:00:29','version'=>'6.79_03' },{'date'=>'2013-10-11T17:59:30','version'=>'6.79_04' },{'date'=>'2013-10-15T15:08:06','version'=>'6.80' },{'date'=>'2013-10-16T08:04:29','version'=>'6.81_01' },{'date'=>'2013-10-17T11:24:19','version'=>'6.81_02' },{'date'=>'2013-10-24T19:54:34','version'=>'6.81_03' },{'date'=>'2013-11-01T19:56:13','version'=>'6.81_04' },{'date'=>'2013-11-02T21:44:06','version'=>'6.81_05' },{'date'=>'2013-11-04T19:24:38','version'=>'6.82' },{'date'=>'2013-11-05T11:45:54','version'=>'6.83_01' },{'date'=>'2013-11-12T11:15:21','version'=>'6.83_02' },{'date'=>'2013-11-15T09:49:39','version'=>'6.83_03' },{'date'=>'2013-11-17T11:44:01','version'=>'6.83_04' },{'date'=>'2013-11-25T22:52:46','version'=>'6.83_05' },{'date'=>'2013-11-29T21:55:40','version'=>'6.83_06' },{'date'=>'2013-11-30T15:27:01','version'=>'6.84' },{'date'=>'2013-12-16T13:18:35','version'=>'6.85_01' },{'date'=>'2013-12-17T10:17:50','version'=>'6.85_02' },{'date'=>'2013-12-23T14:59:36','version'=>'6.85_03' },{'date'=>'2013-12-23T15:02:38','version'=>'6.85_04' },{'date'=>'2013-12-29T11:28:14','version'=>'6.85_05' },{'date'=>'2013-12-30T23:18:09','version'=>'6.85_06' },{'date'=>'2014-01-01T19:00:36','version'=>'6.85_07' },{'date'=>'2014-01-04T12:21:05','version'=>'6.86' },{'date'=>'2014-01-12T10:34:38','version'=>'6.87_01' },{'date'=>'2014-01-18T13:30:15','version'=>'6.87_02' },{'date'=>'2014-01-19T17:53:19','version'=>'6.87_03' },{'date'=>'2014-01-26T19:33:34','version'=>'6.87_04' },{'date'=>'2014-01-28T14:00:44','version'=>'6.87_05' },{'date'=>'2014-01-31T20:59:13','version'=>'6.88' },{'date'=>'2014-02-17T16:23:55','version'=>'6.89_01' },{'date'=>'2014-02-20T20:49:24','version'=>'6.90' },{'date'=>'2014-03-06T13:52:24','version'=>'6.91_01' },{'date'=>'2014-03-13T16:34:37','version'=>'6.92' },{'date'=>'2014-03-24T16:57:01','version'=>'6.93_01' },{'date'=>'2014-03-25T20:38:21','version'=>'6.94' },{'date'=>'2014-04-02T20:52:53','version'=>'6.95_01' },{'date'=>'2014-04-07T14:29:26','version'=>'6.95_02' },{'date'=>'2014-04-11T21:09:21','version'=>'6.96' },{'date'=>'2014-04-24T13:29:12','version'=>'6.97_01' },{'date'=>'2014-04-28T10:55:44','version'=>'6.97_02' },{'date'=>'2014-04-29T20:41:00','version'=>'6.98' },{'date'=>'2014-06-03T21:19:42','version'=>'6.99_01' },{'date'=>'2014-06-05T11:18:25','version'=>'6.99_02' },{'date'=>'2014-07-04T10:15:23','version'=>'6.99_03' },{'date'=>'2014-07-12T11:54:35','version'=>'6.99_04' },{'date'=>'2014-07-22T11:42:12','version'=>'6.99_05' },{'date'=>'2014-07-28T14:07:14','version'=>'6.99_06' },{'date'=>'2014-07-30T16:44:02','version'=>'6.99_07' },{'date'=>'2014-08-18T13:19:18','version'=>'6.99_08' },{'date'=>'2014-08-28T10:13:30','version'=>'6.99_09' },{'date'=>'2014-09-04T14:04:55','version'=>'6.99_10' },{'date'=>'2014-09-08T13:39:46','version'=>'6.99_11' },{'date'=>'2014-09-11T14:32:19','version'=>'6.99_12' },{'date'=>'2014-09-15T19:11:34','version'=>'6.99_13' },{'date'=>'2014-09-19T14:06:14','version'=>'6.99_14' },{'date'=>'2014-09-21T12:23:58','version'=>'6.99_15' },{'date'=>'2014-10-02T18:50:08','version'=>'6.99_16' },{'date'=>'2014-10-12T18:41:24','version'=>'6.99_17' },{'date'=>'2014-10-20T09:14:39','version'=>'6.99_18' },{'date'=>'2014-10-22T19:48:56','version'=>'7.00' },{'date'=>'2014-10-25T12:49:55','version'=>'7.01_01' },{'date'=>'2014-10-25T16:49:40','version'=>'7.01_02' },{'date'=>'2014-10-30T19:48:04','version'=>'7.01_03' },{'date'=>'2014-10-31T10:13:56','version'=>'7.01_04' },{'date'=>'2014-11-03T12:53:43','version'=>'7.01_05' },{'date'=>'2014-11-03T20:55:23','version'=>'7.01_06' },{'date'=>'2014-11-04T19:40:07','version'=>'7.01_07' },{'date'=>'2014-11-04T20:29:00','version'=>'7.01_08' },{'date'=>'2014-11-06T21:59:55','version'=>'7.01_09' },{'date'=>'2014-11-08T10:39:16','version'=>'7.02' },{'date'=>'2014-11-18T21:47:11','version'=>'7.03_01' },{'date'=>'2014-11-24T13:26:46','version'=>'7.03_02' },{'date'=>'2014-11-25T16:43:06','version'=>'7.03_03' },{'date'=>'2014-11-27T14:42:51','version'=>'7.03_04' },{'date'=>'2014-11-28T18:32:48','version'=>'7.03_05' },{'date'=>'2014-12-01T15:37:46','version'=>'7.03_06' },{'date'=>'2014-12-02T12:56:02','version'=>'7.04' },{'date'=>'2014-12-06T16:58:07','version'=>'7.05_01' },{'date'=>'2014-12-15T20:13:08','version'=>'7.05_02' },{'date'=>'2014-12-24T12:12:00','version'=>'7.05_03' },{'date'=>'2014-12-24T14:49:46','version'=>'7.05_04' },{'date'=>'2014-12-31T23:21:05','version'=>'7.05_05' },{'date'=>'2015-01-08T19:09:29','version'=>'7.05_06' },{'date'=>'2015-01-09T16:23:43','version'=>'7.05_07' },{'date'=>'2015-01-20T10:13:21','version'=>'7.05_08' },{'date'=>'2015-01-23T10:51:30','version'=>'7.05_09' },{'date'=>'2015-01-26T15:19:01','version'=>'7.05_10' },{'date'=>'2015-01-31T16:40:19','version'=>'7.05_11' },{'date'=>'2015-02-07T15:19:11','version'=>'7.05_12' },{'date'=>'2015-02-18T22:49:29','version'=>'7.05_13' },{'date'=>'2015-02-20T17:32:55','version'=>'7.05_14' },{'date'=>'2015-03-05T19:44:02','version'=>'7.05_15' },{'date'=>'2015-03-09T11:35:12','version'=>'7.05_16' },{'date'=>'2015-03-24T12:27:52','version'=>'7.05_17' },{'date'=>'2015-03-27T12:20:03','version'=>'7.05_18' },{'date'=>'2015-03-27T16:59:34','version'=>'7.05_19' },{'date'=>'2015-04-04T15:53:36','version'=>'7.05_20' },{'date'=>'2015-06-13T14:19:26','version'=>'7.05_21' },{'date'=>'2015-06-14T13:44:56','version'=>'7.05_22' },{'date'=>'2015-06-24T19:51:24','version'=>'7.05_23' },{'date'=>'2015-07-01T18:30:38','version'=>'7.05_24' },{'date'=>'2015-07-07T17:18:36','version'=>'7.05_25' },{'date'=>'2015-08-04T19:41:25','version'=>'7.05_26' },{'date'=>'2015-08-05T09:35:40','version'=>'7.05_27' },{'date'=>'2015-08-19T18:10:20','version'=>'7.05_28' },{'date'=>'2015-08-24T15:26:22','version'=>'7.05_29' },{'date'=>'2015-08-31T18:06:48','version'=>'7.06' },{'date'=>'2015-09-02T11:55:33','version'=>'7.07_01' },{'date'=>'2015-09-08T19:59:05','version'=>'7.08' },{'date'=>'2015-09-10T18:55:41','version'=>'7.10' },{'date'=>'2015-11-12T12:35:03','version'=>'7.11_01' },{'date'=>'2015-11-21T20:23:22','version'=>'7.11_02' },{'date'=>'2015-11-25T15:40:06','version'=>'7.11_03' },{'date'=>'2016-02-15T11:40:55','version'=>'7.11_04' },{'date'=>'2016-03-19T10:07:11','version'=>'7.11_05' },{'date'=>'2016-03-29T18:44:47','version'=>'7.11_06' },{'date'=>'2016-04-19T11:41:10','version'=>'7.12' },{'date'=>'2016-04-23T16:35:56','version'=>'7.13_01' },{'date'=>'2016-04-24T13:20:40','version'=>'7.14' },{'date'=>'2016-04-27T18:27:25','version'=>'7.15_01' },{'date'=>'2016-04-28T12:15:28','version'=>'7.15_02' },{'date'=>'2016-05-01T13:29:10','version'=>'7.15_03' },{'date'=>'2016-05-07T10:28:49','version'=>'7.16' },{'date'=>'2016-05-09T19:14:54','version'=>'7.17_01' },{'date'=>'2016-05-09T23:07:33','version'=>'7.17_02' },{'date'=>'2016-05-11T18:22:21','version'=>'7.17_03' },{'date'=>'2016-05-23T15:39:08','version'=>'7.18' },{'date'=>'2016-06-02T14:01:28','version'=>'7.19_01' },{'date'=>'2016-06-13T09:11:52','version'=>'7.19_02' },{'date'=>'2016-06-13T13:44:33','version'=>'7.19_03' },{'date'=>'2016-06-14T11:35:43','version'=>'7.19_04' },{'date'=>'2016-06-20T14:40:57','version'=>'7.19_05' },{'date'=>'2016-06-27T12:04:29','version'=>'7.19_06' },{'date'=>'2016-07-03T14:30:23','version'=>'7.19_07' },{'date'=>'2016-07-28T12:26:56','version'=>'7.19_08' },{'date'=>'2016-08-05T08:57:09','version'=>'7.20' },{'date'=>'2016-08-07T09:54:04','version'=>'7.21_01' },{'date'=>'2016-08-08T08:42:10','version'=>'7.22' },{'date'=>'2016-08-19T09:24:06','version'=>'7.23_01' },{'date'=>'2016-08-20T12:35:27','version'=>'7.24' },{'date'=>'2017-02-03T15:21:22','version'=>'7.25_01' },{'date'=>'2017-05-11T11:19:49','version'=>'7.25_02' },{'date'=>'2017-05-11T17:09:16','version'=>'7.25_03' },{'date'=>'2017-05-12T12:25:54','version'=>'7.25_04' },{'date'=>'2017-05-15T09:41:49','version'=>'7.25_05' },{'date'=>'2017-05-23T19:31:28','version'=>'7.25_06' },{'date'=>'2017-05-27T20:21:06','version'=>'7.26' },{'date'=>'2017-05-28T10:50:55','version'=>'7.27_01' },{'date'=>'2017-05-30T08:56:32','version'=>'7.27_02' },{'date'=>'2017-05-30T21:26:23','version'=>'7.28' },{'date'=>'2017-05-31T08:32:44','version'=>'7.29_01' },{'date'=>'2017-06-11T11:17:55','version'=>'7.29_02' },{'date'=>'2017-06-12T12:31:08','version'=>'7.30' },{'date'=>'2017-06-14T15:10:23','version'=>'7.31_01' },{'date'=>'2017-06-26T13:14:10','version'=>'7.31_02' },{'date'=>'2017-07-10T09:02:35','version'=>'7.31_03' },{'date'=>'2017-10-05T12:19:00','version'=>'7.31_04' },{'date'=>'2017-11-25T09:37:04','version'=>'7.31_05' },{'date'=>'2018-01-16T13:28:46','version'=>'7.31_06' },{'date'=>'2018-01-16T16:24:23','version'=>'7.31_07' },{'date'=>'2018-02-12T12:32:45','version'=>'7.31_08' },{'date'=>'2018-02-16T20:25:44','version'=>'7.32' },{'date'=>'2018-02-20T10:44:19','version'=>'7.33_01' },{'date'=>'2018-02-24T14:05:00','version'=>'7.33_02' },{'date'=>'2018-02-24T20:21:42','version'=>'7.33_03' },{'date'=>'2018-03-19T10:51:54','version'=>'7.34' },{'date'=>'2018-04-19T12:46:01','version'=>'7.35_01' },{'date'=>'2018-04-24T11:01:35','version'=>'7.35_02' },{'date'=>'2018-04-27T13:59:23','version'=>'7.35_03' },{'date'=>'2018-07-09T09:50:43','version'=>'7.35_04' },{'date'=>'2018-07-10T09:18:31','version'=>'7.35_05' },{'date'=>'2018-07-19T19:49:08','version'=>'7.35_06' },{'date'=>'2018-11-23T11:59:44','version'=>'7.35_07' },{'date'=>'2018-12-06T10:56:33','version'=>'7.35_08' },{'date'=>'2019-02-18T10:27:00','version'=>'7.35_09' },{'date'=>'2019-02-20T10:06:48','version'=>'7.35_10' }]},'FCGI'=>{'advisories'=>[{'affected_versions'=>'<0.74','cves'=>['CVE-2011-2766' ],'description'=>'Leaking information across requests when using the deprecated and undocumented old FCGI interface.
  ','distribution'=>'FCGI','fixed_versions'=>'>=0.74','id'=>'CPANSA-FCGI-2011-01','references'=>['https://metacpan.org/changes/distribution/FCGI','https://github.com/perl-catalyst/FCGI/commit/297693dc8362d25bb25e473899c72508a0f71d2e' ],'reported'=>'2011-09-24' }],'main_module'=>'FCGI','versions'=>[{'date'=>'1996-09-25T17:48:57','version'=>'0.25' },{'date'=>'1996-10-15T21:51:06','version'=>'0.26' },{'date'=>'1997-02-20T08:55:44','version'=>'0.27' },{'date'=>'1997-02-25T07:14:13','version'=>'0.28' },{'date'=>'1997-06-10T18:16:17','version'=>'0.29' },{'date'=>'1997-06-24T17:17:05','version'=>'0.30' },{'date'=>'1997-07-24T11:05:43','version'=>'0.31' },{'date'=>'1998-06-17T10:24:17','version'=>'0.34' },{'date'=>'1998-06-22T15:38:51','version'=>'0.35' },{'date'=>'1998-06-24T19:42:57','version'=>'0.36' },{'date'=>'1998-06-27T16:08:39','version'=>'0.37' },{'date'=>'1998-07-15T15:24:00','version'=>'0.40' },{'date'=>'1998-07-29T16:05:51','version'=>'0.41' },{'date'=>'1998-08-28T15:30:49','version'=>'0.42' },{'date'=>'1998-12-22T22:34:14','version'=>'0.43' },{'date'=>'1998-12-23T11:28:39','version'=>'0.44' },{'date'=>'1999-03-08T17:04:02','version'=>'0.45' },{'date'=>'1999-07-30T08:26:31','version'=>'0.46' },{'date'=>'1999-07-31T21:58:01','version'=>'0.47' },{'date'=>'1999-08-27T13:41:54','version'=>'0.48' },{'date'=>'2000-04-09T18:58:32','version'=>'0.49' },{'date'=>'2000-04-10T07:04:43','version'=>'0.50' },{'date'=>'2000-04-12T12:27:09','version'=>'0.51' },{'date'=>'2000-04-12T14:10:02','version'=>'0.52' },{'date'=>'2000-07-10T10:01:51','version'=>'0.53' },{'date'=>'2000-10-08T19:52:29','version'=>'0.54' },{'date'=>'2000-10-18T21:22:46','version'=>'0.55' },{'date'=>'2000-11-03T15:44:28','version'=>'0.56' },{'date'=>'2000-11-12T15:15:01','version'=>'0.57' },{'date'=>'2000-11-14T23:20:24','version'=>'0.58' },{'date'=>'2000-12-31T22:05:44','version'=>'0.59' },{'date'=>'2001-06-08T15:19:08','version'=>'0.60' },{'date'=>'2001-09-20T12:34:13','version'=>'0.61' },{'date'=>'2001-09-21T16:19:42','version'=>'0.62' },{'date'=>'2001-09-24T20:43:48','version'=>'0.63' },{'date'=>'2001-09-25T08:26:24','version'=>'0.64' },{'date'=>'2002-02-19T14:16:27','version'=>'0.65' },{'date'=>'2002-09-05T16:23:07','version'=>'0.66' },{'date'=>'2002-12-23T10:21:36','version'=>'0.67' },{'date'=>'2009-12-20T21:05:48','version'=>'0.67_01' },{'date'=>'2010-01-06T10:07:05','version'=>'0.68' },{'date'=>'2010-01-10T01:35:11','version'=>'0.68_01' },{'date'=>'2010-01-13T19:25:40','version'=>'0.68_02' },{'date'=>'2010-02-15T23:08:12','version'=>'0.69' },{'date'=>'2010-03-22T14:35:03','version'=>'0.70' },{'date'=>'2010-04-01T00:55:33','version'=>'0.71' },{'date'=>'2010-08-24T21:32:56','version'=>'0.71_01' },{'date'=>'2011-04-28T08:50:09','version'=>'0.71_02' },{'date'=>'2011-04-28T09:05:42','version'=>'0.71_03' },{'date'=>'2011-05-19T09:06:02','version'=>'0.72' },{'date'=>'2011-05-28T01:35:17','version'=>'0.73' },{'date'=>'2011-09-24T08:31:47','version'=>'0.74' },{'date'=>'2014-07-17T00:19:02','version'=>'0.75' },{'date'=>'2014-08-05T01:29:06','version'=>'0.76' },{'date'=>'2014-08-05T15:53:28','version'=>'0.77' },{'date'=>'2016-03-07T00:08:23','version'=>'0.78' }]},'Fake-Encode'=>{'advisories'=>[{'affected_versions'=>'<0.08','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'Fake-Encode','fixed_versions'=>'>=0.08','id'=>'CPANSA-Fake-Encode-2017-01','references'=>['https://metacpan.org/changes/distribution/Fake-Encode' ],'reported'=>'2017-01-23' }],'main_module'=>'Fake::Encode','versions'=>[{'date'=>'2016-05-31T14:11:49','version'=>'0.01' },{'date'=>'2017-01-23T12:34:23','version'=>'0.02' },{'date'=>'2017-01-25T15:52:13','version'=>'0.03' },{'date'=>'2017-01-26T15:17:01','version'=>'0.04' },{'date'=>'2017-03-06T16:01:40','version'=>'0.05' },{'date'=>'2017-09-08T17:54:14','version'=>'0.06' },{'date'=>'2017-09-09T15:27:50','version'=>'0.07' },{'date'=>'2018-02-03T14:50:49','version'=>'0.08' },{'date'=>'2018-02-19T12:21:04','version'=>'0.09' }]},'Fake-Our'=>{'advisories'=>[{'affected_versions'=>'<0.06','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'Fake-Our','fixed_versions'=>'>=0.06','id'=>'CPANSA-Fake-Our-2017-01','references'=>['https://metacpan.org/changes/distribution/Fake-Our' ],'reported'=>'2017-01-23' }],'main_module'=>'Fake::Our','versions'=>[{'date'=>'2014-02-09T05:36:09','version'=>'0.01' },{'date'=>'2014-08-06T17:33:15','version'=>'0.02' },{'date'=>'2014-08-09T02:35:25','version'=>'0.03' },{'date'=>'2014-08-10T15:33:58','version'=>'0.04' },{'date'=>'2015-06-21T04:09:47','version'=>'0.05' },{'date'=>'2017-01-23T12:34:34','version'=>'0.06' },{'date'=>'2017-01-26T15:21:45','version'=>'0.07' },{'date'=>'2017-01-27T15:18:56','version'=>'0.08' },{'date'=>'2017-01-28T15:07:50','version'=>'0.09' },{'date'=>'2017-03-06T16:01:51','version'=>'0.10' },{'date'=>'2018-02-03T11:05:49','version'=>'0.11' },{'date'=>'2018-02-16T17:54:00','version'=>'0.12' },{'date'=>'2018-02-17T01:35:58','version'=>'0.13' },{'date'=>'2018-02-18T15:32:17','version'=>'0.14' }]},'File-DataClass'=>{'advisories'=>[{'affected_versions'=>'<0.72.1','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'File-DataClass','fixed_versions'=>'>=0.72.1','id'=>'CPANSA-File-DataClass-2017-01','references'=>['https://metacpan.org/changes/distribution/File-DataClass' ],'reported'=>'2017-04-01' }],'main_module'=>'File::DataClass','versions'=>[{'date'=>'2010-09-29T16:37:04','version'=>'0.1.228' },{'date'=>'2010-10-06T14:20:31','version'=>'0.2.234' },{'date'=>'2011-01-26T18:14:50','version'=>'0.3.238' },{'date'=>'2011-02-27T23:09:38','version'=>'0.3.239' },{'date'=>'2011-04-12T19:44:59','version'=>'0.3.259' },{'date'=>'2011-05-15T17:45:09','version'=>'0.4.268' },{'date'=>'2011-05-30T01:47:40','version'=>'0.5.271' },{'date'=>'2011-07-11T13:39:10','version'=>'0.6.286' },{'date'=>'2011-11-30T00:05:18','version'=>'0.7.321' },{'date'=>'2011-12-02T04:40:20','version'=>'0.7.325' },{'date'=>'2011-12-02T22:39:25','version'=>'0.7.326' },{'date'=>'2011-12-03T18:43:58','version'=>'0.7.328' },{'date'=>'2012-02-22T18:28:29','version'=>'0.7.330' },{'date'=>'2012-02-23T11:00:24','version'=>'0.7.331' },{'date'=>'2012-02-24T10:52:18','version'=>'0.7.332' },{'date'=>'2012-03-12T17:34:58','version'=>'0.7.335' },{'date'=>'2012-03-20T18:24:26','version'=>'0.7.336' },{'date'=>'2012-03-21T22:43:50','version'=>'0.7.338' },{'date'=>'2012-03-22T13:48:59','version'=>'0.7.339' },{'date'=>'2012-03-24T00:37:31','version'=>'0.7.343' },{'date'=>'2012-03-28T23:58:41','version'=>'0.8.351' },{'date'=>'2012-03-29T22:05:21','version'=>'0.8.355' },{'date'=>'2012-04-03T00:26:12','version'=>'0.8.357' },{'date'=>'2012-04-04T15:19:03','version'=>'0.8.360' },{'date'=>'2012-04-17T18:57:01','version'=>'0.9.368' },{'date'=>'2012-05-19T21:05:56','version'=>'0.10.380' },{'date'=>'2012-07-10T00:34:23','version'=>'0.11.401' },{'date'=>'2012-09-02T13:43:37','version'=>'0.12.406' },{'date'=>'2012-09-06T14:02:06','version'=>'0.12.409' },{'date'=>'2012-11-07T07:49:39','version'=>'0.13.416' },{'date'=>'2012-11-13T20:16:27','version'=>'0.13.418' },{'date'=>'2012-12-12T23:25:16','version'=>'0.13.420' },{'date'=>'2012-12-14T17:58:08','version'=>'0.13.421' },{'date'=>'2012-12-19T22:23:08','version'=>'0.13.422' },{'date'=>'2012-12-21T20:48:41','version'=>'0.13.424' },{'date'=>'2012-12-30T03:05:28','version'=>'0.13.427' },{'date'=>'2013-01-07T00:52:48','version'=>'0.14.429' },{'date'=>'2013-04-01T01:14:44','version'=>'0.15.431' },{'date'=>'2013-04-02T14:21:13','version'=>'0.15.434' },{'date'=>'2013-04-14T16:15:55','version'=>'v0.16.438' },{'date'=>'2013-04-15T20:42:56','version'=>'v0.16.442' },{'date'=>'2013-04-24T03:47:54','version'=>'v0.16.445' },{'date'=>'2013-04-29T17:12:37','version'=>'v0.17.450' },{'date'=>'2013-04-30T22:15:36','version'=>'v0.18.6' },{'date'=>'2013-05-02T14:14:57','version'=>'v0.19.1' },{'date'=>'2013-05-07T23:33:06','version'=>'v0.20.6' },{'date'=>'2013-05-10T14:58:03','version'=>'v0.20.7' },{'date'=>'2013-05-14T13:32:28','version'=>'v0.20.8' },{'date'=>'2013-05-15T20:03:34','version'=>'v0.20.9' },{'date'=>'2013-05-16T00:11:50','version'=>'v0.20.10' },{'date'=>'2013-05-17T16:07:41','version'=>'v0.20.12' },{'date'=>'2013-06-08T13:26:40','version'=>'v0.20.13' },{'date'=>'2013-07-28T17:41:14','version'=>'v0.22.1' },{'date'=>'2013-07-29T11:39:49','version'=>'v0.22.2' },{'date'=>'2013-07-29T11:46:28','version'=>'v0.22.3' },{'date'=>'2013-07-29T18:37:14','version'=>'v0.22.4' },{'date'=>'2013-07-30T10:19:23','version'=>'v0.22.5' },{'date'=>'2013-07-30T16:25:59','version'=>'v0.22.7' },{'date'=>'2013-07-31T09:54:30','version'=>'v0.22.8' },{'date'=>'2013-08-02T19:06:49','version'=>'v0.22.9' },{'date'=>'2013-08-06T17:19:31','version'=>'v0.23.1' },{'date'=>'2013-08-07T13:14:13','version'=>'v0.23.2' },{'date'=>'2013-08-13T18:01:24','version'=>'0.24.1' },{'date'=>'2013-08-16T22:49:23','version'=>'0.24.3' },{'date'=>'2013-09-03T13:11:17','version'=>'0.25.1' },{'date'=>'2013-09-26T16:04:18','version'=>'0.26.1' },{'date'=>'2013-11-22T09:42:00','version'=>'0.27.1' },{'date'=>'2014-01-01T15:02:23','version'=>'0.28.1' },{'date'=>'2014-01-01T17:03:18','version'=>'0.29.1' },{'date'=>'2014-01-02T02:33:28','version'=>'0.30.1' },{'date'=>'2014-01-13T18:41:29','version'=>'0.31.1' },{'date'=>'2014-01-24T20:56:21','version'=>'0.33.1' },{'date'=>'2014-04-04T10:52:59','version'=>'0.34.1' },{'date'=>'2014-05-01T14:40:32','version'=>'0.35.1' },{'date'=>'2014-05-13T10:03:54','version'=>'0.36.1' },{'date'=>'2014-05-13T21:08:07','version'=>'0.37.1' },{'date'=>'2014-05-15T00:11:43','version'=>'0.38.1' },{'date'=>'2014-05-16T08:19:01','version'=>'0.39.1' },{'date'=>'2014-05-22T09:37:34','version'=>'0.40.1' },{'date'=>'2014-05-22T14:10:49','version'=>'0.40.2' },{'date'=>'2014-05-28T10:28:42','version'=>'0.41.1' },{'date'=>'2014-07-03T23:27:53','version'=>'0.42.1' },{'date'=>'2014-07-04T09:25:10','version'=>'0.42.2' },{'date'=>'2014-07-04T12:19:02','version'=>'0.43.1' },{'date'=>'2014-07-16T12:39:03','version'=>'0.44.1' },{'date'=>'2014-08-18T23:00:05','version'=>'0.45.1' },{'date'=>'2014-08-26T12:43:14','version'=>'0.45.5' },{'date'=>'2014-08-26T16:41:35','version'=>'0.46.1' },{'date'=>'2014-08-27T16:17:50','version'=>'0.47.1' },{'date'=>'2014-09-03T22:25:51','version'=>'0.48.1' },{'date'=>'2014-10-02T17:39:13','version'=>'0.48.3' },{'date'=>'2014-10-02T19:59:28','version'=>'0.49.1' },{'date'=>'2014-11-07T18:51:52','version'=>'0.50.1' },{'date'=>'2014-11-08T21:45:45','version'=>'0.50.2' },{'date'=>'2014-11-09T13:19:50','version'=>'0.50.3' },{'date'=>'2014-11-09T15:52:41','version'=>'0.51.1' },{'date'=>'2014-11-10T12:44:49','version'=>'0.52.1' },{'date'=>'2014-12-19T11:49:49','version'=>'0.53.1' },{'date'=>'2014-12-19T22:54:41','version'=>'0.54.1' },{'date'=>'2015-02-05T00:04:33','version'=>'0.55.1' },{'date'=>'2015-03-19T14:59:03','version'=>'0.56.1' },{'date'=>'2015-04-04T20:00:58','version'=>'0.57.1' },{'date'=>'2015-04-04T20:16:31','version'=>'0.58.1' },{'date'=>'2015-04-05T17:58:31','version'=>'0.59.1' },{'date'=>'2015-04-08T23:10:28','version'=>'0.60.1' },{'date'=>'2015-05-11T12:15:05','version'=>'0.61.1' },{'date'=>'2015-05-24T11:52:28','version'=>'0.62.1' },{'date'=>'2015-06-21T21:42:17','version'=>'0.63.1' },{'date'=>'2015-08-29T08:58:54','version'=>'0.66.1' },{'date'=>'2016-02-01T00:18:43','version'=>'0.67.1' },{'date'=>'2016-02-01T14:33:11','version'=>'0.68.1' },{'date'=>'2016-07-05T00:36:52','version'=>'0.69.1' },{'date'=>'2016-07-29T15:24:24','version'=>'0.70.1' },{'date'=>'2016-07-29T18:59:13','version'=>'0.71.1' },{'date'=>'2017-04-02T08:23:47','version'=>'0.72.1' },{'date'=>'2017-06-02T00:03:17','version'=>'0.73.1' }]},'File-Path'=>{'advisories'=>[{'affected_versions'=>'<2.13','cves'=>['CVE-2017-6512' ],'description'=>'Race condition in the rmtree and remove_tree functions allows attackers to set the mode on arbitrary files via vectors involving directory-permission loosening logic.
  ','distribution'=>'Fake-Encode','fixed_versions'=>'>=2.13','id'=>'CPANSA-File-Path-2017-01','references'=>['https://metacpan.org/changes/distribution/File-Path','https://github.com/jkeenan/File-Path/commit/e5ef95276ee8ad471c66ee574a5d42552b3a6af2' ],'reported'=>'2017-05-02' }],'main_module'=>'File::Path','versions'=>[{'date'=>'2007-05-17T13:46:15','version'=>'1.99_01' },{'date'=>'2007-05-27T09:29:48','version'=>'1.99_02' },{'date'=>'2007-06-27T19:23:09','version'=>'2.00_05' },{'date'=>'2007-07-04T21:37:13','version'=>'2.00_06' },{'date'=>'2007-07-09T19:37:02','version'=>'2.00_07' },{'date'=>'2007-08-01T00:10:43','version'=>'2.00_08' },{'date'=>'2007-08-20T18:15:55','version'=>'2.00_09' },{'date'=>'2007-09-04T17:20:45','version'=>'2.00_10' },{'date'=>'2007-09-08T12:53:07','version'=>'2.00_11' },{'date'=>'2007-09-29T10:29:32','version'=>'2.01' },{'date'=>'2007-10-24T10:36:09','version'=>'2.02' },{'date'=>'2007-11-04T18:36:19','version'=>'2.03' },{'date'=>'2007-11-24T09:53:23','version'=>'2.04' },{'date'=>'2008-05-07T08:25:05','version'=>'2.05' },{'date'=>'2008-05-08T09:36:50','version'=>'2.06' },{'date'=>'2008-05-10T21:02:47','version'=>'2.06_01' },{'date'=>'2008-05-12T10:07:46','version'=>'2.06_02' },{'date'=>'2008-05-12T21:43:43','version'=>'2.06_03' },{'date'=>'2008-05-13T14:40:30','version'=>'2.06_04' },{'date'=>'2008-10-01T20:41:37','version'=>'2.06_05' },{'date'=>'2008-10-05T21:59:58','version'=>'2.06_06' },{'date'=>'2008-10-29T17:55:36','version'=>'2.06_07' },{'date'=>'2008-11-05T00:12:29','version'=>'2.06_08' },{'date'=>'2008-11-09T13:11:17','version'=>'2.07' },{'date'=>'2009-06-21T13:23:32','version'=>'2.07_03' },{'date'=>'2009-10-04T10:31:05','version'=>'2.08' },{'date'=>'2013-01-16T21:36:05','version'=>'2.09' },{'date'=>'2015-06-24T17:03:22','version'=>'2.10_001' },{'date'=>'2015-06-26T17:28:20','version'=>'2.10_002' },{'date'=>'2015-07-08T16:59:11','version'=>'2.10_003' },{'date'=>'2015-07-10T11:34:44','version'=>'2.10_004' },{'date'=>'2015-07-17T15:03:07','version'=>'2.10_005' },{'date'=>'2015-07-18T02:28:14','version'=>'2.11' },{'date'=>'2015-07-24T23:01:36','version'=>'2.11_001' },{'date'=>'2015-07-25T09:56:18','version'=>'2.11_002' },{'date'=>'2015-08-03T18:07:05','version'=>'2.11_003' },{'date'=>'2015-10-01T19:34:07','version'=>'2.11_004' },{'date'=>'2015-10-09T12:11:52','version'=>'2.12' },{'date'=>'2016-09-18T13:35:39','version'=>'2.12_001' },{'date'=>'2017-03-12T22:09:35','version'=>'2.12_002' },{'date'=>'2017-04-07T13:59:30','version'=>'2.12_003' },{'date'=>'2017-04-18T18:37:56','version'=>'2.12_004' },{'date'=>'2017-04-21T12:03:20','version'=>'2.12_005' },{'date'=>'2017-04-21T21:58:56','version'=>'2.12_006' },{'date'=>'2017-04-22T20:09:24','version'=>'2.12_007' },{'date'=>'2017-05-07T17:48:35','version'=>'2.12_008' },{'date'=>'2017-05-31T23:44:51','version'=>'2.13' },{'date'=>'2017-06-07T21:34:52','version'=>'2.14' },{'date'=>'2017-07-30T02:40:36','version'=>'2.15' },{'date'=>'2018-08-31T13:04:13','version'=>'2.16' }]},'GBrowse'=>{'advisories'=>[{'affected_versions'=>'<2.56','description'=>'An attacker is able to delete other users\' accounts.  No httponly cookie flag.  Cross-site scripting vulnerability in generation of citation text.
  ','distribution'=>'GBrowse','fixed_versions'=>'>=2.56','id'=>'CPANSA-GBrowser-2017-01','references'=>['https://metacpan.org/changes/distribution/GBrowse' ],'reported'=>'2017-01-15' },{'affected_versions'=>'<1.62','description'=>'Cross-site scripting.
  ','distribution'=>'GBrowse','fixed_versions'=>'>=1.62','id'=>'CPANSA-GBrowser-2004-01','references'=>['https://metacpan.org/changes/distribution/GBrowse' ],'reported'=>'2004-04-05' },{'affected_versions'=>'<1.54','description'=>'Path traversal.
  ','distribution'=>'GBrowse','fixed_versions'=>'>=1.54','id'=>'CPANSA-GBrowser-2003-01','references'=>['https://metacpan.org/changes/distribution/GBrowse' ],'reported'=>'2003-08-23' }],'main_module'=>'CGI::Toggle','versions'=>[{'date'=>'2008-12-29T15:38:27','version'=>'1.981' },{'date'=>'2008-12-29T17:21:12','version'=>'1.982' },{'date'=>'2009-01-06T07:42:56','version'=>'1.983' },{'date'=>'2009-01-06T09:17:54','version'=>'1.984' },{'date'=>'2009-01-10T12:37:42','version'=>'1.985' },{'date'=>'2009-01-12T16:58:20','version'=>'1.986' },{'date'=>'2009-01-22T19:49:50','version'=>'1.987' },{'date'=>'2009-01-30T00:12:57','version'=>'1.988' },{'date'=>'2009-03-10T19:24:17','version'=>'1.989' },{'date'=>'2009-04-03T19:29:22','version'=>'1.99' },{'date'=>'2009-05-04T05:30:31','version'=>'1.991' },{'date'=>'2009-05-05T23:40:00','version'=>'1.992' },{'date'=>'2009-05-07T14:11:11','version'=>'1.993' },{'date'=>'2009-05-30T22:07:17','version'=>'1.994' },{'date'=>'2009-06-08T21:27:08','version'=>'1.995' },{'date'=>'2009-07-06T14:12:57','version'=>'1.996' },{'date'=>'2009-07-30T16:40:54','version'=>'1.997' },{'date'=>'2009-08-19T19:19:44','version'=>'1.9971' },{'date'=>'2009-12-09T21:39:37','version'=>'1.998' },{'date'=>'2009-12-15T15:59:37','version'=>'1.9982' },{'date'=>'2009-12-18T19:25:25','version'=>'1.9983' },{'date'=>'2009-12-22T21:20:40','version'=>'1.9984' },{'date'=>'2009-12-23T21:56:31','version'=>'1.999' },{'date'=>'2010-01-28T02:58:41','version'=>'2.00' },{'date'=>'2010-02-09T18:13:33','version'=>'2.01' },{'date'=>'2010-03-10T05:56:50','version'=>'2.02' },{'date'=>'2010-03-25T16:06:21','version'=>'2.03' },{'date'=>'2010-04-18T21:44:27','version'=>'2.04' },{'date'=>'2010-05-13T03:30:32','version'=>'2.05' },{'date'=>'2010-05-13T21:17:05','version'=>'2.06' },{'date'=>'2010-05-17T14:49:41','version'=>'2.07' },{'date'=>'2010-05-21T02:52:47','version'=>'2.08' },{'date'=>'2010-06-10T20:17:32','version'=>'2.09' },{'date'=>'2010-06-15T14:20:30','version'=>'2.10' },{'date'=>'2010-06-30T19:15:37','version'=>'2.11' },{'date'=>'2010-06-30T19:30:03','version'=>'2.12' },{'date'=>'2010-07-05T20:17:39','version'=>'2.13' },{'date'=>'2010-08-27T15:06:04','version'=>'2.14' },{'date'=>'2010-09-13T22:17:44','version'=>'2.15' },{'date'=>'2010-11-01T16:24:01','version'=>'2.16' },{'date'=>'2010-11-18T17:08:57','version'=>'2.17' },{'date'=>'2011-01-18T22:35:59','version'=>'2.20' },{'date'=>'2011-01-22T17:17:34','version'=>'2.21' },{'date'=>'2011-01-26T14:31:35','version'=>'2.22' },{'date'=>'2011-01-30T20:03:25','version'=>'2.23' },{'date'=>'2011-01-31T17:19:08','version'=>'2.24' },{'date'=>'2011-02-02T18:53:40','version'=>'2.25' },{'date'=>'2011-02-04T18:51:54','version'=>'2.26' },{'date'=>'2011-04-10T21:07:42','version'=>'2.27' },{'date'=>'2011-04-10T21:32:05','version'=>'2.28' },{'date'=>'2011-05-02T16:12:11','version'=>'2.29' },{'date'=>'2011-05-03T12:17:18','version'=>'2.30' },{'date'=>'2011-05-03T15:50:21','version'=>'2.31' },{'date'=>'2011-05-04T18:47:51','version'=>'2.32' },{'date'=>'2011-05-07T03:27:32','version'=>'2.33' },{'date'=>'2011-06-01T15:19:47','version'=>'2.34' },{'date'=>'2011-06-03T13:41:28','version'=>'2.35' },{'date'=>'2011-06-04T14:58:14','version'=>'2.36' },{'date'=>'2011-06-06T21:24:59','version'=>'2.37' },{'date'=>'2011-06-09T16:00:48','version'=>'2.38' },{'date'=>'2011-06-29T17:45:00','version'=>'2.39' },{'date'=>'2011-09-30T16:56:29','version'=>'2.40' },{'date'=>'2011-10-07T13:31:48','version'=>'2.41' },{'date'=>'2011-10-12T19:33:22','version'=>'2.42' },{'date'=>'2011-10-24T16:43:23','version'=>'2.43' },{'date'=>'2011-12-08T23:09:26','version'=>'2.44' },{'date'=>'2012-01-03T21:35:41','version'=>'2.45' },{'date'=>'2012-02-10T17:28:20','version'=>'2.46' },{'date'=>'2012-02-16T12:40:04','version'=>'2.47' },{'date'=>'2012-02-24T21:06:10','version'=>'2.48' },{'date'=>'2012-04-17T23:48:26','version'=>'2.49' },{'date'=>'2012-09-04T16:22:21','version'=>'2.50' },{'date'=>'2012-09-18T03:01:31','version'=>'2.51' },{'date'=>'2012-09-26T02:54:36','version'=>'2.52' },{'date'=>'2012-12-10T11:23:34','version'=>'2.53' },{'date'=>'2012-12-11T15:49:03','version'=>'2.54' },{'date'=>'2013-07-10T14:51:25','version'=>'2.55' },{'date'=>'2017-01-15T21:29:11','version'=>'2.56' }]},'HTML-Perlinfo'=>{'advisories'=>[{'affected_versions'=>'<1.52','description'=>'Possibility of denial-of-service attack.
  ','distribution'=>'HTML-Perlinfo','fixed_versions'=>'>=1.52','id'=>'CPANSA-HTML-Perlinfo-2008-01','references'=>['https://metacpan.org/changes/release/ACCARDO/HTML-Perlinfo-1.52' ],'reported'=>'2008-07-04' }],'main_module'=>'HTML::Perlinfo','versions'=>[{'date'=>'2005-08-18T21:39:08','version'=>'1.00' },{'date'=>'2005-09-19T20:41:07','version'=>'1.05' },{'date'=>'2006-01-14T05:25:20','version'=>'1.25' },{'date'=>'2006-08-13T03:42:36','version'=>'1.40' },{'date'=>'2006-08-13T09:29:45','version'=>'1.41' },{'date'=>'2006-08-15T01:04:34','version'=>'1.42' },{'date'=>'2006-08-25T07:51:28','version'=>'1.43' },{'date'=>'2006-09-10T23:20:13','version'=>'1.44' },{'date'=>'2006-09-24T02:22:48','version'=>'1.45' },{'date'=>'2006-09-27T20:08:12','version'=>'1.46' },{'date'=>'2006-10-02T19:30:30','version'=>'1.47' },{'date'=>'2008-03-16T03:15:04','version'=>'1.48' },{'date'=>'2008-04-26T04:17:07','version'=>'1.49' },{'date'=>'2008-04-30T20:44:40','version'=>'1.50' },{'date'=>'2008-06-08T21:07:29','version'=>'1.51' },{'date'=>'2008-07-03T23:57:26','version'=>'1.52' },{'date'=>'2008-07-21T22:24:22','version'=>'1.53' },{'date'=>'2008-07-27T23:52:36','version'=>'1.54' },{'date'=>'2009-04-08T01:09:54','version'=>'1.55' },{'date'=>'2009-04-08T19:06:59','version'=>'1.56' },{'date'=>'2009-04-16T15:57:34','version'=>'1.57' },{'date'=>'2009-04-17T02:41:48','version'=>'1.58' },{'date'=>'2009-04-22T03:29:45','version'=>'1.59' },{'date'=>'2009-05-02T20:48:38','version'=>'1.60' },{'date'=>'2009-05-02T22:21:42','version'=>'1.60' },{'date'=>'2009-05-03T23:02:35','version'=>'1.61' },{'date'=>'2011-06-13T19:28:39','version'=>'1.62' },{'date'=>'2014-08-19T21:37:30','version'=>'1.63' },{'date'=>'2014-08-19T22:29:15','version'=>'1.64' },{'date'=>'2015-06-06T23:25:41','version'=>'1.65' },{'date'=>'2015-06-08T18:20:03','version'=>'1.66' },{'date'=>'2015-06-08T20:22:33','version'=>'1.67' },{'date'=>'2015-06-12T02:03:18','version'=>'1.68' },{'date'=>'2016-11-29T19:21:00','version'=>'1.69' }]},'HTML-Scrubber'=>{'advisories'=>[{'affected_versions'=>'<0.15','description'=>'Cross-site scripting vulnerability.
  ','distribution'=>'HTML-Scrubber','fixed_versions'=>'>=0.15','id'=>'CPANSA-HTML-Scrubber-2015-01','references'=>['https://jvn.jp/en/jp/JVN53973084/index.html' ],'reported'=>'2015-10-10' }],'main_module'=>'HTML::Scrubber','versions'=>[{'date'=>'2003-04-18T14:10:19','version'=>'0.02' },{'date'=>'2003-07-21T14:57:02','version'=>'0.03' },{'date'=>'2003-10-30T02:31:36','version'=>'0.04' },{'date'=>'2003-10-31T07:27:00','version'=>'0.05' },{'date'=>'2003-11-02T11:10:49','version'=>'0.06' },{'date'=>'2004-03-18T14:35:12','version'=>'0.07' },{'date'=>'2004-04-01T22:12:20','version'=>'0.08' },{'date'=>'2011-04-01T15:36:18','version'=>'0.09' },{'date'=>'2013-09-27T14:06:41','version'=>'0.10' },{'date'=>'2013-10-11T14:13:11','version'=>'0.11' },{'date'=>'2015-03-14T18:25:35','version'=>'0.12' },{'date'=>'2015-03-19T16:31:12','version'=>'0.13' },{'date'=>'2015-04-02T16:20:48','version'=>'0.14' },{'date'=>'2015-10-10T14:02:08','version'=>'0.15' },{'date'=>'2017-06-25T19:31:24','version'=>'0.16' },{'date'=>'2017-06-27T13:04:46','version'=>'0.17' }]},'HTTP-Body'=>{'advisories'=>[{'affected_versions'=>'>=1.08, <1.19','description'=>'HTTP::Body::Multipart in the HTTP-Body 1.08, 1.17, and earlier module for Perl uses the part of the uploaded file\'s name after the first "." character as the suffix of a temporary file, which makes it easier for remote attackers to conduct attacks by leveraging subsequent behavior that may assume the suffix is well-formed.
  ','distribution'=>'HTTP-Body','id'=>'CPANSA-HTTP-Body-2013-01','references'=>['https://security-tracker.debian.org/tracker/CVE-2013-4407','https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=721634' ],'reported'=>'2013-09-02','severity'=>'moderate' }],'main_module'=>'HTTP::Body','versions'=>[{'date'=>'2005-10-06T23:31:10','version'=>'0.01' },{'date'=>'2005-10-07T19:39:00','version'=>'0.2' },{'date'=>'2005-10-28T00:04:21','version'=>'0.03' },{'date'=>'2005-11-09T06:02:28','version'=>'0.4' },{'date'=>'2005-11-17T04:03:44','version'=>'0.5' },{'date'=>'2006-01-06T11:55:08','version'=>'0.6' },{'date'=>'2007-03-23T17:02:39','version'=>'0.7' },{'date'=>'2007-03-24T01:48:23','version'=>'0.8' },{'date'=>'2007-03-27T17:55:21','version'=>'0.9' },{'date'=>'2008-02-23T16:03:17','version'=>'1.00' },{'date'=>'2008-02-23T16:16:09','version'=>'1.01' },{'date'=>'2008-02-27T22:08:06','version'=>'1.02' },{'date'=>'2008-04-07T14:20:46','version'=>'1.03' },{'date'=>'2008-06-23T19:41:56','version'=>'1.04' },{'date'=>'2008-12-01T22:14:51','version'=>'1.05' },{'date'=>'2010-01-09T18:23:07','version'=>'1.06' },{'date'=>'2010-01-24T19:42:49','version'=>'1.07' },{'date'=>'2010-08-19T19:02:08','version'=>'1.08' },{'date'=>'2010-08-19T23:11:46','version'=>'1.09' },{'date'=>'2010-10-08T14:52:40','version'=>'1.10' },{'date'=>'2010-10-26T14:38:59','version'=>'1.11' },{'date'=>'2011-03-20T00:58:03','version'=>'1.12' },{'date'=>'2011-11-04T18:44:06','version'=>'1.14' },{'date'=>'2011-12-05T03:02:21','version'=>'1.15' },{'date'=>'2012-10-03T15:19:24','version'=>'1.16' },{'date'=>'2012-10-03T22:04:49','version'=>'1.17' },{'date'=>'2013-12-06T15:06:26','version'=>'1.18' },{'date'=>'2013-12-06T15:07:56','version'=>'1.19' },{'date'=>'2015-01-28T15:21:00','version'=>'1.20' },{'date'=>'2015-01-29T03:50:10','version'=>'1.21' },{'date'=>'2015-01-29T03:53:01','version'=>'1.22' }]},'HTTP-Session2'=>{'advisories'=>[{'affected_versions'=>'<1.10','description'=>'HTTP::Session2 1.10 does not validate session id, this causes RCE depending on the session store you use.
  ','distribution'=>'HTTP-Session2','fixed_versions'=>'>=1.10','id'=>'CPANSA-HTTP-Session2-2018-01','references'=>['https://metacpan.org/changes/distribution/HTTP-Session2','https://github.com/tokuhirom/HTTP-Session2/commit/813838f6d08034b6a265a70e53b59b941b5d3e6d' ],'reported'=>'2018-01-26','severity'=>'critical' }],'main_module'=>'HTTP::Session2','versions'=>[{'date'=>'2013-10-28T03:20:09','version'=>'0.01' },{'date'=>'2013-10-30T00:17:21','version'=>'0.02' },{'date'=>'2013-10-31T01:21:27','version'=>'0.03' },{'date'=>'2013-11-01T01:10:52','version'=>'0.04' },{'date'=>'2014-03-18T18:53:09','version'=>'0.05' },{'date'=>'2014-07-28T04:10:11','version'=>'1.00' },{'date'=>'2014-07-28T11:44:05','version'=>'1.01' },{'date'=>'2014-07-31T21:17:23','version'=>'1.02' },{'date'=>'2014-08-01T11:04:00','version'=>'1.03' },{'date'=>'2014-08-01T11:10:56','version'=>'1.04' },{'date'=>'2014-08-01T11:20:46','version'=>'1.05' },{'date'=>'2014-08-01T14:04:04','version'=>'1.06' },{'date'=>'2014-08-01T14:08:11','version'=>'1.07' },{'date'=>'2014-08-03T07:23:00','version'=>'1.08' },{'date'=>'2014-09-01T02:26:38','version'=>'1.09' },{'date'=>'2018-01-26T05:02:08','version'=>'1.10' }]},'HTTP-Tiny'=>{'advisories'=>[{'affected_versions'=>'<0.059','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'HTTP-Tiny','fixed_versions'=>'>=0.059','id'=>'CPANSA-HTTP-Tiny-2016-01','references'=>['https://metacpan.org/changes/distribution/HTTP-Tiny','https://github.com/chansen/p5-http-tiny/commit/b239c95ea7a256cfee9b8848f1bd4d1df6e66444' ],'reported'=>'2016-07-29' }],'main_module'=>'HTTP::Tiny','versions'=>[{'date'=>'2010-12-11T12:59:31','version'=>'0.001' },{'date'=>'2010-12-14T02:59:37','version'=>'0.002' },{'date'=>'2010-12-15T17:30:49','version'=>'0.003' },{'date'=>'2010-12-16T03:53:33','version'=>'0.004' },{'date'=>'2011-01-08T11:32:21','version'=>'0.005' },{'date'=>'2011-01-10T12:27:39','version'=>'0.006' },{'date'=>'2011-01-12T09:56:28','version'=>'0.007' },{'date'=>'2011-01-14T11:34:51','version'=>'0.008' },{'date'=>'2011-01-17T21:29:27','version'=>'0.009' },{'date'=>'2011-02-04T07:45:53','version'=>'0.010' },{'date'=>'2011-03-20T00:49:53','version'=>'0.011' },{'date'=>'2011-03-31T19:49:33','version'=>'0.012' },{'date'=>'2011-07-18T03:15:12','version'=>'0.013' },{'date'=>'2011-10-20T17:55:01','version'=>'0.014' },{'date'=>'2011-10-26T20:42:15','version'=>'0.015' },{'date'=>'2011-10-27T03:06:06','version'=>'0.016' },{'date'=>'2012-02-23T02:58:42','version'=>'0.017' },{'date'=>'2012-04-18T13:41:15','version'=>'0.018' },{'date'=>'2012-05-14T11:15:52','version'=>'0.019' },{'date'=>'2012-05-14T19:25:57','version'=>'0.020' },{'date'=>'2012-05-16T02:39:55','version'=>'0.021' },{'date'=>'2012-06-02T03:32:21','version'=>'0.022' },{'date'=>'2012-09-19T16:06:37','version'=>'0.023' },{'date'=>'2012-10-10T00:45:59','version'=>'0.024' },{'date'=>'2012-12-26T17:11:23','version'=>'0.025' },{'date'=>'2013-03-05T03:54:12','version'=>'0.026' },{'date'=>'2013-03-05T17:04:07','version'=>'0.027' },{'date'=>'2013-03-05T19:13:42','version'=>'0.028' },{'date'=>'2013-04-17T17:51:23','version'=>'0.029' },{'date'=>'2013-06-13T15:47:33','version'=>'0.030' },{'date'=>'2013-06-17T03:18:45','version'=>'0.031' },{'date'=>'2013-06-20T15:42:26','version'=>'0.032' },{'date'=>'2013-06-21T10:27:45','version'=>'0.033' },{'date'=>'2013-06-26T23:03:50','version'=>'0.034' },{'date'=>'2013-09-10T16:30:04','version'=>'0.035' },{'date'=>'2013-09-25T16:11:04','version'=>'0.036' },{'date'=>'2013-10-28T17:50:02','version'=>'0.037' },{'date'=>'2013-11-18T17:57:17','version'=>'0.038' },{'date'=>'2013-11-28T00:49:36','version'=>'0.039' },{'date'=>'2014-02-17T18:05:10','version'=>'0.040' },{'date'=>'2014-02-17T18:09:12','version'=>'0.041' },{'date'=>'2014-02-18T16:24:50','version'=>'0.042' },{'date'=>'2014-02-21T01:42:05','version'=>'0.043' },{'date'=>'2014-07-17T03:47:41','version'=>'0.044' },{'date'=>'2014-07-20T23:24:33','version'=>'0.045' },{'date'=>'2014-07-21T14:33:53','version'=>'0.046' },{'date'=>'2014-07-29T18:13:01','version'=>'0.047' },{'date'=>'2014-08-21T17:20:45','version'=>'0.048' },{'date'=>'2014-09-02T15:21:17','version'=>'0.049' },{'date'=>'2014-09-23T19:32:00','version'=>'0.050' },{'date'=>'2014-11-18T03:59:56','version'=>'0.051' },{'date'=>'2014-12-11T20:25:19','version'=>'0.052' },{'date'=>'2014-12-12T04:43:37','version'=>'0.053' },{'date'=>'2015-01-27T12:18:58','version'=>'0.054' },{'date'=>'2015-05-07T22:15:24','version'=>'0.055' },{'date'=>'2015-05-19T10:01:27','version'=>'0.056' },{'date'=>'2016-04-18T14:19:09','version'=>'0.057' },{'date'=>'2016-05-03T17:49:33','version'=>'0.058' },{'date'=>'2016-07-29T20:12:12','version'=>'0.059' },{'date'=>'2016-08-05T16:12:02','version'=>'0.061' },{'date'=>'2016-08-08T16:20:33','version'=>'0.063' },{'date'=>'2016-08-17T01:43:01','version'=>'0.064' },{'date'=>'2016-09-10T02:43:48','version'=>'0.065' },{'date'=>'2016-09-14T15:45:04','version'=>'0.067' },{'date'=>'2016-09-23T20:15:05','version'=>'0.068' },{'date'=>'2016-10-05T15:37:11','version'=>'0.069' },{'date'=>'2016-10-10T03:25:33','version'=>'0.070' },{'date'=>'2018-07-24T15:35:02','version'=>'0.073' },{'date'=>'2018-07-30T19:37:29','version'=>'0.074' },{'date'=>'2018-08-01T11:10:11','version'=>'0.075' },{'date'=>'2018-08-06T01:09:54','version'=>'0.076' }]},'Imager'=>{'advisories'=>[{'affected_versions'=>'<1.006','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'Imager','fixed_versions'=>'>=1.006','id'=>'CPANSA-Imager-2016-01','references'=>['https://metacpan.org/changes/distribution/Imager' ],'reported'=>'2017-08-26' },{'affected_versions'=>'<0.64','cves'=>['CVE-2008-1928' ],'description'=>'Buffer overflow in the floating point sample path for image based fills.
  ','distribution'=>'Imager','fixed_versions'=>'>=0.64','id'=>'CPANSA-Imager-2008-01','references'=>['https://rt.cpan.org/Ticket/Display.html?id=68910','https://metacpan.org/changes/distribution/Imager' ],'reported'=>'2008-04-23' },{'affected_versions'=>'<0.57','cves'=>['CVE-2007-2459','CVE-2007-2413' ],'description'=>'A specially crafted compressed BMP file can cause a buffer overflow in malloced memory.
  ','distribution'=>'Imager','fixed_versions'=>'>=0.57','id'=>'CPANSA-Imager-2007-01','references'=>['https://rt.cpan.org/Public/Bug/Display.html?id=26811','https://metacpan.org/changes/distribution/Imager' ],'reported'=>'2008-04-30' }],'main_module'=>'Imager','versions'=>[{'date'=>'1999-07-19T14:26:37','version'=>'0.21' },{'date'=>'2000-01-03T20:14:03','version'=>'0.27' },{'date'=>'2000-01-04T11:16:56','version'=>'0.28' },{'date'=>'2000-01-05T10:48:05','version'=>'0.29' },{'date'=>'2000-01-16T12:52:22','version'=>'0.31' },{'date'=>'2000-03-04T13:28:32','version'=>'0.32' },{'date'=>'2001-01-29T00:50:14','version'=>'0.35' },{'date'=>'2001-01-29T15:06:27','version'=>'0.36' },{'date'=>'2001-01-31T05:02:15','version'=>'0.37' },{'date'=>'2001-05-21T16:21:08','version'=>'0.38' },{'date'=>'2001-11-02T21:39:20','version'=>'0.39' },{'date'=>'2002-04-11T15:09:57','version'=>'0.40' },{'date'=>'2002-04-12T12:07:29','version'=>'0.41' },{'date'=>'2004-01-04T12:47:37','version'=>'0.42' },{'date'=>'2004-02-17T07:53:52','version'=>'0.43' },{'date'=>'2004-12-07T23:58:16','version'=>'0.43_03' },{'date'=>'2004-12-15T13:02:40','version'=>'0.44' },{'date'=>'2005-05-24T07:08:15','version'=>'0.44_01' },{'date'=>'2005-05-30T04:41:43','version'=>'0.45' },{'date'=>'2005-12-12T04:07:30','version'=>'0.45_02' },{'date'=>'2005-12-20T00:13:31','version'=>'0.46' },{'date'=>'2005-12-30T06:05:50','version'=>'0.47' },{'date'=>'2006-02-21T06:09:30','version'=>'0.47_01' },{'date'=>'2006-03-03T05:06:46','version'=>'0.48' },{'date'=>'2006-03-07T01:04:03','version'=>'0.49' },{'date'=>'2006-03-28T04:31:56','version'=>'0.49_01' },{'date'=>'2006-03-29T00:31:03','version'=>'0.50' },{'date'=>'2006-04-23T14:29:42','version'=>'0.51' },{'date'=>'2006-06-28T13:38:48','version'=>'0.51_01' },{'date'=>'2006-07-04T14:03:23','version'=>'0.51_02' },{'date'=>'2006-07-19T00:58:22','version'=>'0.51_03' },{'date'=>'2006-07-25T05:09:08','version'=>'0.52' },{'date'=>'2006-07-27T01:01:57','version'=>'0.53' },{'date'=>'2006-09-14T07:58:27','version'=>'0.54' },{'date'=>'2006-12-16T22:31:19','version'=>'0.55' },{'date'=>'2007-04-01T12:30:34','version'=>'0.56' },{'date'=>'2007-04-30T08:49:39','version'=>'0.57' },{'date'=>'2007-05-11T11:00:18','version'=>'0.57_01' },{'date'=>'2007-05-16T12:49:23','version'=>'0.58' },{'date'=>'2007-06-14T07:33:05','version'=>'0.59' },{'date'=>'2007-08-30T07:51:36','version'=>'0.60' },{'date'=>'2007-11-05T07:53:45','version'=>'0.61' },{'date'=>'2007-11-28T10:06:27','version'=>'0.61_02' },{'date'=>'2007-12-10T08:31:12','version'=>'0.62' },{'date'=>'2008-04-07T08:49:14','version'=>'0.63' },{'date'=>'2008-04-23T04:10:18','version'=>'0.64' },{'date'=>'2008-05-20T06:34:48','version'=>'0.65' },{'date'=>'2008-12-12T11:57:40','version'=>'0.67' },{'date'=>'2009-09-02T07:05:11','version'=>'0.67_01' },{'date'=>'2009-09-07T05:14:24','version'=>'0.68' },{'date'=>'2009-09-08T09:23:38','version'=>'0.69' },{'date'=>'2009-09-21T03:36:15','version'=>'0.70' },{'date'=>'2009-11-16T04:15:54','version'=>'0.71' },{'date'=>'2009-11-30T07:17:33','version'=>'0.71_01' },{'date'=>'2009-12-01T09:06:53','version'=>'0.71_02' },{'date'=>'2009-12-04T14:21:49','version'=>'0.71_03' },{'date'=>'2009-12-10T00:44:51','version'=>'0.72' },{'date'=>'2010-03-15T07:24:59','version'=>'0.73' },{'date'=>'2010-05-06T14:29:21','version'=>'0.74' },{'date'=>'2010-06-20T10:47:23','version'=>'0.75' },{'date'=>'2010-08-06T10:49:44','version'=>'0.75_01' },{'date'=>'2010-08-07T01:48:37','version'=>'0.75_02' },{'date'=>'2010-08-09T12:49:36','version'=>'0.75_03' },{'date'=>'2010-08-11T09:33:24','version'=>'0.77' },{'date'=>'2010-09-13T10:48:57','version'=>'0.77_01' },{'date'=>'2010-09-27T04:59:03','version'=>'0.77_02' },{'date'=>'2010-10-04T09:00:26','version'=>'0.78' },{'date'=>'2010-12-11T01:09:12','version'=>'0.79' },{'date'=>'2011-01-17T07:43:35','version'=>'0.80' },{'date'=>'2011-02-14T08:22:57','version'=>'0.81' },{'date'=>'2011-03-14T12:18:07','version'=>'0.82' },{'date'=>'2011-05-17T11:15:02','version'=>'0.82_01' },{'date'=>'2011-05-20T14:07:44','version'=>'0.83' },{'date'=>'2011-06-20T12:54:05','version'=>'0.84' },{'date'=>'2011-08-08T12:39:58','version'=>'0.84_01' },{'date'=>'2011-08-22T09:28:25','version'=>'0.84_02' },{'date'=>'2011-08-29T09:19:04','version'=>'0.85' },{'date'=>'2011-10-10T07:22:51','version'=>'0.85_01' },{'date'=>'2011-10-24T10:14:57','version'=>'0.85_02' },{'date'=>'2011-10-31T10:37:15','version'=>'0.86' },{'date'=>'2012-01-03T05:27:14','version'=>'0.87' },{'date'=>'2012-02-22T05:13:09','version'=>'0.88' },{'date'=>'2012-03-18T01:45:35','version'=>'0.89' },{'date'=>'2012-04-30T09:09:02','version'=>'0.90' },{'date'=>'2012-06-04T12:27:17','version'=>'0.91' },{'date'=>'2012-08-14T09:53:38','version'=>'0.92' },{'date'=>'2012-08-18T01:41:22','version'=>'0.92_01' },{'date'=>'2012-10-15T10:15:07','version'=>'0.93' },{'date'=>'2012-11-12T10:44:54','version'=>'0.93_01' },{'date'=>'2012-11-25T00:13:16','version'=>'0.93_02' },{'date'=>'2012-12-14T22:59:55','version'=>'0.94' },{'date'=>'2013-03-02T08:34:07','version'=>'0.94_01' },{'date'=>'2013-04-05T06:19:32','version'=>'0.94_02' },{'date'=>'2013-04-19T12:13:27','version'=>'0.95' },{'date'=>'2013-05-19T04:27:19','version'=>'0.96' },{'date'=>'2013-07-01T13:21:32','version'=>'0.96_01' },{'date'=>'2013-07-09T13:46:48','version'=>'0.96_02' },{'date'=>'2013-07-15T09:52:06','version'=>'0.97' },{'date'=>'2014-01-02T22:22:03','version'=>'0.98' },{'date'=>'2014-06-25T11:36:29','version'=>'0.99' },{'date'=>'2014-06-29T05:06:45','version'=>'0.99_01' },{'date'=>'2014-07-21T09:16:17','version'=>'0.99_02' },{'date'=>'2014-07-29T09:13:55','version'=>'1.000' },{'date'=>'2015-01-02T03:34:59','version'=>'1.001' },{'date'=>'2015-04-03T01:31:26','version'=>'1.002' },{'date'=>'2015-05-12T08:11:18','version'=>'1.003' },{'date'=>'2015-11-08T09:45:59','version'=>'1.004' },{'date'=>'2016-03-16T08:35:26','version'=>'1.004_001' },{'date'=>'2016-03-20T01:27:53','version'=>'1.004_002' },{'date'=>'2016-03-23T09:34:13','version'=>'1.004_003' },{'date'=>'2016-04-15T05:58:07','version'=>'1.004_004' },{'date'=>'2016-04-16T00:01:33','version'=>'1.005' },{'date'=>'2017-08-26T04:27:06','version'=>'1.006' },{'date'=>'2018-11-24T01:47:34','version'=>'1.007' },{'date'=>'2018-12-31T10:04:02','version'=>'1.008' },{'date'=>'2019-01-11T09:10:13','version'=>'1.009' },{'date'=>'2019-02-13T08:14:07','version'=>'1.010' },{'date'=>'2019-03-07T03:20:03','version'=>'1.011' }]},'LWP-Protocol-Net-Curl'=>{'advisories'=>[{'affected_versions'=>'<0.009','description'=>'Misconfiguration with libcurl v7.28.1 causes a HTTPS validation issues.
  ','distribution'=>'LWP-Protocol-Net-Curl','fixed_versions'=>'>=0.009','id'=>'CPANSA-LWP-Protocol-Net-Curl-2012-01','references'=>['https://metacpan.org/changes/distribution/LWP-Protocol-Net-Curl','https://github.com/creaktive/LWP-Protocol-Net-Curl/commit/dc8b183c6520a2b6bcde685de635675ee4a7e019' ],'reported'=>'2012-11-28' }],'main_module'=>'LWP::Protocol::Net::Curl','versions'=>[{'date'=>'2012-10-24T18:49:20','version'=>'0.001' },{'date'=>'2012-10-26T20:05:13','version'=>'0.002' },{'date'=>'2012-10-29T18:55:46','version'=>'0.003' },{'date'=>'2012-10-31T13:01:46','version'=>'0.004' },{'date'=>'2012-11-01T15:17:14','version'=>'0.005' },{'date'=>'2012-11-12T12:23:09','version'=>'0.006' },{'date'=>'2012-11-13T14:33:10','version'=>'0.007' },{'date'=>'2012-11-25T22:38:58','version'=>'0.008' },{'date'=>'2012-11-28T19:03:10','version'=>'0.009' },{'date'=>'2012-12-07T00:13:55','version'=>'0.010' },{'date'=>'2012-12-18T12:05:00','version'=>'0.011' },{'date'=>'2013-02-08T11:00:04','version'=>'0.012' },{'date'=>'2013-02-11T01:56:30','version'=>'0.013' },{'date'=>'2013-02-16T12:51:03','version'=>'0.014' },{'date'=>'2013-05-13T21:41:47','version'=>'0.015' },{'date'=>'2013-05-18T22:12:03','version'=>'0.016' },{'date'=>'2013-07-13T12:22:34','version'=>'0.017' },{'date'=>'2013-08-17T11:34:49','version'=>'0.018' },{'date'=>'2013-10-11T12:33:53','version'=>'0.019' },{'date'=>'2013-10-13T09:02:17','version'=>'0.020' },{'date'=>'2014-01-21T17:46:37','version'=>'0.021' },{'date'=>'2014-07-09T15:04:06','version'=>'0.022' },{'date'=>'2014-12-23T17:06:56','version'=>'0.023' }]},'Lemonldap-NG-Portal'=>{'advisories'=>[{'affected_versions'=>'<0.87','description'=>'When running on Apache with thread support setMacros and setGroups were not launched with the good datas.
  ','distribution'=>'Lemonldap-NG-Portal','fixed_versions'=>'>=0.87','id'=>'CPANSA-Lemonldap-NG-Portal-2009-01','references'=>['https://metacpan.org/changes/distribution/Lemonldap-NG-Portal' ],'reported'=>'2009-02-08' }],'main_module'=>'Lemonldap::NG::Portal','versions'=>[{'date'=>'2005-06-29T18:44:50','version'=>'0.01' },{'date'=>'2005-07-02T08:49:37','version'=>'0.02' },{'date'=>'2006-10-07T13:24:36','version'=>'0.1' },{'date'=>'2006-10-14T13:26:07','version'=>'0.11' },{'date'=>'2006-10-14T14:11:06','version'=>'0.111' },{'date'=>'2006-10-17T13:58:53','version'=>'0.2' },{'date'=>'2006-11-02T15:23:31','version'=>'0.4' },{'date'=>'2006-11-03T07:25:06','version'=>'0.41' },{'date'=>'2006-12-07T21:02:36','version'=>'0.42' },{'date'=>'2006-12-19T18:26:07','version'=>'0.5' },{'date'=>'2006-12-31T13:03:32','version'=>'0.51' },{'date'=>'2007-01-13T19:47:36','version'=>'0.6' },{'date'=>'2007-02-28T22:29:18','version'=>'0.62' },{'date'=>'2007-03-04T18:23:52','version'=>'0.63' },{'date'=>'2007-03-09T20:18:23','version'=>'0.64' },{'date'=>'2007-03-29T19:52:31','version'=>'0.7' },{'date'=>'2007-04-01T20:26:10','version'=>'0.71' },{'date'=>'2007-04-14T20:46:13','version'=>'0.72' },{'date'=>'2007-04-20T06:51:13','version'=>'0.73' },{'date'=>'2007-06-13T13:54:26','version'=>'0.74' },{'date'=>'2007-07-22T20:35:13','version'=>'0.76' },{'date'=>'2007-07-31T05:11:34','version'=>'0.77' },{'date'=>'2007-10-15T06:03:56','version'=>'0.8' },{'date'=>'2008-02-28T07:13:04','version'=>'0.81' },{'date'=>'2008-04-11T14:53:38','version'=>'0.82' },{'date'=>'2008-06-06T05:50:06','version'=>'0.83' },{'date'=>'2008-06-06T12:46:10','version'=>'0.84' },{'date'=>'2008-08-25T19:53:48','version'=>'0.85' },{'date'=>'2008-12-25T08:26:49','version'=>'0.86' },{'date'=>'2009-02-08T07:13:05','version'=>'0.87' },{'date'=>'2009-06-29T10:14:46','version'=>'0.88' },{'date'=>'2009-07-05T11:40:59','version'=>'0.89' },{'date'=>'2009-10-11T08:26:21','version'=>'0.90' },{'date'=>'2010-10-13T21:02:21','version'=>'0.99' },{'date'=>'2010-10-22T05:36:29','version'=>'0.99.1' },{'date'=>'2010-10-22T05:45:04','version'=>'0.991' },{'date'=>'2010-10-24T06:33:29','version'=>'0.992' },{'date'=>'2010-11-26T13:38:59','version'=>'1.0.0' },{'date'=>'2011-02-28T13:42:23','version'=>'1.0.2' },{'date'=>'2011-03-07T11:17:03','version'=>'v1.0.3' },{'date'=>'2011-03-23T14:54:26','version'=>'1.0.4' },{'date'=>'2011-04-15T14:51:44','version'=>'1.0.5' },{'date'=>'2011-05-30T08:40:46','version'=>'1.0.6' },{'date'=>'2011-07-08T09:33:35','version'=>'1.1.0' },{'date'=>'2011-07-29T13:43:35','version'=>'1.1.1' },{'date'=>'2011-10-07T12:58:06','version'=>'1.1.2' },{'date'=>'2012-06-18T10:13:31','version'=>'1.2.0' },{'date'=>'2012-07-06T09:18:54','version'=>'1.2.1' },{'date'=>'2012-09-17T14:04:26','version'=>'1.2.2' },{'date'=>'2013-01-25T21:51:54','version'=>'1.2.2_01' },{'date'=>'2013-02-08T17:11:38','version'=>'1.2.3' },{'date'=>'2013-04-23T13:19:57','version'=>'1.2.4' },{'date'=>'2013-08-26T10:39:11','version'=>'1.2.5' },{'date'=>'2013-11-02T16:31:10','version'=>'v1.3.0' },{'date'=>'2013-11-10T18:00:31','version'=>'v1.3.0_01' },{'date'=>'2013-11-11T14:01:21','version'=>'v1.3.1' },{'date'=>'2014-02-05T09:31:50','version'=>'1.3.2' },{'date'=>'2014-03-07T13:55:23','version'=>'1.3.3' },{'date'=>'2014-06-30T12:54:16','version'=>'v1.4.0' },{'date'=>'2014-07-25T09:55:37','version'=>'v1.4.1' },{'date'=>'2014-11-05T15:15:30','version'=>'v1.4.2' },{'date'=>'2014-12-19T10:31:47','version'=>'v1.4.3' },{'date'=>'2015-04-15T10:05:31','version'=>'v1.4.4' },{'date'=>'2015-05-22T16:54:10','version'=>'v1.4.5' },{'date'=>'2015-10-09T09:21:04','version'=>'v1.4.6' },{'date'=>'2016-03-02T09:50:24','version'=>'v1.9.0' },{'date'=>'2016-03-22T14:25:24','version'=>'v1.4.7' },{'date'=>'2016-04-05T16:02:49','version'=>'v1.9.1' },{'date'=>'2016-04-27T15:23:10','version'=>'v1.4.8' },{'date'=>'2016-05-01T19:25:36','version'=>'v1.9.2' },{'date'=>'2016-06-03T14:14:52','version'=>'v1.4.9' },{'date'=>'2016-06-07T15:48:38','version'=>'v1.9.3' },{'date'=>'2016-06-14T18:36:34','version'=>'v1.9.4' },{'date'=>'2016-07-13T09:08:18','version'=>'v1.4.10' },{'date'=>'2016-07-13T12:58:54','version'=>'v1.9.5' },{'date'=>'2016-10-10T13:34:33','version'=>'v1.4.11' },{'date'=>'2016-10-16T12:23:25','version'=>'v1.9.6' },{'date'=>'2016-12-14T19:57:55','version'=>'v1.9.7' },{'date'=>'2017-02-28T21:11:18','version'=>'v1.9.99_2.0alpha1' },{'date'=>'2017-03-02T14:55:34','version'=>'v1.9.8' },{'date'=>'2017-03-07T05:48:09','version'=>'v1.9.99_02' },{'date'=>'2017-03-07T06:00:28','version'=>'v1.9.99_03' },{'date'=>'2017-03-15T05:34:48','version'=>'v1.9.991_01' },{'date'=>'2017-03-17T07:21:31','version'=>'v1.9.9' },{'date'=>'2017-05-19T18:48:42','version'=>'v1.9.10' },{'date'=>'2017-09-01T10:32:34','version'=>'v1.9.11' },{'date'=>'2017-09-12T08:40:27','version'=>'v1.9.12' },{'date'=>'2017-09-29T14:00:36','version'=>'v1.9.13' },{'date'=>'2017-11-24T19:59:18','version'=>'v1.9.14' },{'date'=>'2018-01-23T12:50:53','version'=>'v1.9.15' },{'date'=>'2018-03-16T10:34:13','version'=>'v1.9.16' },{'date'=>'2018-06-16T09:27:27','version'=>'v1.9.17' },{'date'=>'2018-10-05T09:40:26','version'=>'v1.9.18' },{'date'=>'2018-11-30T10:49:52','version'=>'v2.0.0' },{'date'=>'2019-02-12T17:13:39','version'=>'v2.0.2' }]},'MHonArc'=>{'advisories'=>[{'affected_versions'=>'<2.6.17','cves'=>['CVE-2010-4524' ],'description'=>'Improper escaping of certain HTML sequences (XSS).
  ','distribution'=>'MHonArc','fixed_versions'=>'>=2.6.17','id'=>'CPANSA-MHonArc-2011-01','references'=>['https://metacpan.org/changes/distribution/MHonArc' ],'reported'=>'2011-01-09' },{'affected_versions'=>'<2.6.17','cves'=>['CVE-2010-1677' ],'description'=>'DoS when processing html messages with deep tag nesting.
  ','distribution'=>'MHonArc','fixed_versions'=>'>=2.6.17','id'=>'CPANSA-MHonArc-2011-02','references'=>['https://metacpan.org/changes/distribution/MHonArc' ],'reported'=>'2011-01-09' }],'main_module'=>'MHonArc::Char','versions'=>[{'date'=>'1997-12-11T20:44:41','version'=>'2.1' },{'date'=>'1998-03-04T01:06:00','version'=>'v2.2.0' },{'date'=>'1998-10-11T02:56:10','version'=>'v2.3.0' },{'date'=>'1998-10-25T19:27:37','version'=>'v2.3.1' },{'date'=>'1998-11-01T20:02:48','version'=>'v2.3.2' },{'date'=>'1998-11-08T21:59:21','version'=>'v2.3.3' },{'date'=>'1999-06-26T07:57:53','version'=>'v2.4.0' },{'date'=>'1999-07-26T19:30:51','version'=>'v2.4.1' },{'date'=>'1999-08-12T07:16:14','version'=>'v2.4.2' },{'date'=>'1999-08-16T06:25:39','version'=>'v2.4.3' },{'date'=>'1999-10-01T19:43:07','version'=>'v2.4.4' },{'date'=>'2000-02-15T03:44:03','version'=>'v2.4.5' },{'date'=>'2000-04-24T08:35:56','version'=>'v2.4.6' },{'date'=>'2000-10-29T04:18:32','version'=>'v2.4.7' },{'date'=>'2000-10-30T06:29:47','version'=>'v2.4.7' },{'date'=>'2001-04-14T21:48:01','version'=>'v2.4.8' },{'date'=>'2001-06-11T03:09:13','version'=>'v2.4.9' },{'date'=>'2001-08-26T19:46:53','version'=>'v2.5.0' },{'date'=>'2001-09-07T15:24:19','version'=>'v2.5.0' },{'date'=>'2001-10-17T16:03:13','version'=>'v2.5.0' },{'date'=>'2001-11-14T05:09:59','version'=>'v2.5.1' },{'date'=>'2001-11-25T06:46:19','version'=>'v2.5.2' },{'date'=>'2002-04-18T07:23:29','version'=>'v2.5.3' },{'date'=>'2002-05-03T05:06:16','version'=>'v2.5.4' },{'date'=>'2002-05-28T05:43:00','version'=>'v2.5.5' },{'date'=>'2002-06-18T18:07:38','version'=>'v2.5.6' },{'date'=>'2002-06-21T22:59:36','version'=>'v2.5.7' },{'date'=>'2002-06-29T03:22:26','version'=>'v2.5.8' },{'date'=>'2002-07-20T02:39:53','version'=>'v2.5.9' },{'date'=>'2002-07-29T00:10:32','version'=>'v2.5.10' },{'date'=>'2002-08-04T04:25:22','version'=>'v2.5.11' },{'date'=>'2002-09-04T04:32:14','version'=>'v2.5.12' },{'date'=>'2002-10-21T17:13:35','version'=>'v2.5.13' },{'date'=>'2002-12-22T01:07:40','version'=>'v2.5.14' },{'date'=>'2003-02-10T05:23:02','version'=>'v2.6.0' },{'date'=>'2003-02-23T00:39:05','version'=>'v2.6.1' },{'date'=>'2003-03-12T01:55:48','version'=>'v2.6.2' },{'date'=>'2003-04-06T02:11:59','version'=>'v2.6.3' },{'date'=>'2003-06-22T21:54:52','version'=>'v2.6.4' },{'date'=>'2003-07-20T04:51:56','version'=>'v2.6.5' },{'date'=>'2003-07-21T17:20:07','version'=>'v2.6.6' },{'date'=>'2003-08-07T23:49:43','version'=>'v2.6.7' },{'date'=>'2003-08-13T04:47:02','version'=>'v2.6.8' },{'date'=>'2004-05-17T06:24:46','version'=>'v2.6.9' },{'date'=>'2004-05-17T06:25:16','version'=>'v2.6.10' },{'date'=>'2005-05-20T17:15:40','version'=>'v2.6.11' },{'date'=>'2005-06-09T02:30:11','version'=>'v2.6.12' },{'date'=>'2005-07-06T05:15:55','version'=>'v2.6.13' },{'date'=>'2005-07-23T07:15:49','version'=>'2.6.14' },{'date'=>'2005-07-27T03:46:13','version'=>'2.6.15' },{'date'=>'2006-06-10T03:21:01','version'=>'2.6.16' },{'date'=>'2011-01-09T10:04:06','version'=>'2.6.17' },{'date'=>'2011-01-09T16:35:39','version'=>'2.6.18' },{'date'=>'2014-04-22T03:33:53','version'=>'2.6.19' }]},'Module-Signature'=>{'advisories'=>[{'affected_versions'=>'<0.72','cves'=>['CVE-2013-2145' ],'description'=>'The cpansign verify functionality in the Module::Signature module before 0.72 for Perl allows attackers to bypass the signature check and execute arbitrary code via a SIGNATURE file with a "special unknown cipher" that references an untrusted module in Digest/.
  ','distribution'=>'Module-Signature','fixed_versions'=>'>=0.72','id'=>'CPANSA-Module-Signature-2013-01','references'=>['https://metacpan.org/changes/distribution/Module-Signature' ],'reported'=>'2013-08-19' }],'main_module'=>'Module::Signature','versions'=>[{'date'=>'2002-08-13T14:04:00','version'=>'0.02' },{'date'=>'2002-08-13T15:48:18','version'=>'0.03' },{'date'=>'2002-08-14T08:03:45','version'=>'0.04' },{'date'=>'2002-08-14T09:28:41','version'=>'0.05' },{'date'=>'2002-10-10T15:22:33','version'=>'0.06' },{'date'=>'2002-10-11T04:16:01','version'=>'0.07' },{'date'=>'2002-10-11T19:32:19','version'=>'0.08' },{'date'=>'2002-10-12T10:33:29','version'=>'0.09' },{'date'=>'2002-10-12T11:10:21','version'=>'0.10' },{'date'=>'2002-10-12T19:23:48','version'=>'0.11' },{'date'=>'2002-10-12T22:55:54','version'=>'0.12' },{'date'=>'2002-10-13T05:22:45','version'=>'0.13' },{'date'=>'2002-10-17T06:14:07','version'=>'0.14' },{'date'=>'2002-10-17T22:01:57','version'=>'0.15' },{'date'=>'2002-10-28T23:37:00','version'=>'0.16' },{'date'=>'2002-10-30T07:05:06','version'=>'0.17' },{'date'=>'2002-11-04T15:08:41','version'=>'0.18' },{'date'=>'2002-11-04T15:13:45','version'=>'0.19' },{'date'=>'2002-11-04T15:24:41','version'=>'0.20' },{'date'=>'2002-11-22T10:28:48','version'=>'0.21' },{'date'=>'2003-05-15T18:44:28','version'=>'0.23' },{'date'=>'2003-07-08T02:49:57','version'=>'0.24' },{'date'=>'2003-07-16T06:31:58','version'=>'0.25' },{'date'=>'2003-07-17T14:03:19','version'=>'0.26' },{'date'=>'2003-07-28T14:31:54','version'=>'0.27' },{'date'=>'2003-07-29T15:30:55','version'=>'0.28' },{'date'=>'2003-08-08T02:54:01','version'=>'0.29' },{'date'=>'2003-08-10T13:35:38','version'=>'0.30' },{'date'=>'2003-08-10T17:17:19','version'=>'0.31' },{'date'=>'2003-08-11T09:15:13','version'=>'0.32' },{'date'=>'2003-08-12T04:11:59','version'=>'0.33' },{'date'=>'2003-08-18T15:32:45','version'=>'0.34' },{'date'=>'2003-08-27T07:08:31','version'=>'0.35' },{'date'=>'2003-10-28T04:22:56','version'=>'0.36' },{'date'=>'2003-11-06T10:55:07','version'=>'0.37' },{'date'=>'2004-01-01T10:14:15','version'=>'0.38' },{'date'=>'2004-06-17T15:17:14','version'=>'0.39' },{'date'=>'2004-07-01T12:18:17','version'=>'0.40' },{'date'=>'2004-07-04T08:19:11','version'=>'0.41' },{'date'=>'2004-11-20T06:19:22','version'=>'0.42' },{'date'=>'2004-12-16T06:45:55','version'=>'0.43' },{'date'=>'2004-12-16T07:17:30','version'=>'0.44' },{'date'=>'2005-08-09T04:23:46','version'=>'0.45' },{'date'=>'2005-08-21T08:16:22','version'=>'0.50' },{'date'=>'2006-01-01T18:41:57','version'=>'0.51' },{'date'=>'2006-01-18T16:32:37','version'=>'0.52' },{'date'=>'2006-01-31T05:02:24','version'=>'0.53' },{'date'=>'2006-05-11T17:12:46','version'=>'0.54' },{'date'=>'2006-07-30T01:15:07','version'=>'0.55' },{'date'=>'2009-11-16T14:59:35','version'=>'0.60' },{'date'=>'2009-11-18T16:58:07','version'=>'0.61' },{'date'=>'2010-03-23T21:21:37','version'=>'0.62' },{'date'=>'2010-03-28T02:49:21','version'=>'0.62' },{'date'=>'2010-05-08T22:55:43','version'=>'0.62' },{'date'=>'2010-09-03T19:55:36','version'=>'0.65' },{'date'=>'2010-09-06T20:58:24','version'=>'0.66' },{'date'=>'2011-04-17T15:09:22','version'=>'0.67' },{'date'=>'2011-05-13T09:55:20','version'=>'0.68' },{'date'=>'2012-11-02T15:20:28','version'=>'0.69' },{'date'=>'2012-11-28T17:49:21','version'=>'0.70' },{'date'=>'2013-06-04T10:29:18','version'=>'0.71' },{'date'=>'2013-06-05T15:21:34','version'=>'0.72' },{'date'=>'2013-06-05T20:57:10','version'=>'0.73' },{'date'=>'2015-04-06T18:39:32','version'=>'0.74' },{'date'=>'2015-04-06T20:58:34','version'=>'0.75' },{'date'=>'2015-04-08T10:13:11','version'=>'0.76' },{'date'=>'2015-04-08T11:47:26','version'=>'0.77' },{'date'=>'2015-04-09T09:00:30','version'=>'0.78' },{'date'=>'2015-05-18T15:18:02','version'=>'0.79' },{'date'=>'2016-06-07T06:36:30','version'=>'0.80' },{'date'=>'2016-09-05T06:41:06','version'=>'0.81' },{'date'=>'2018-08-26T15:19:13','version'=>'0.81' },{'date'=>'2018-08-29T08:35:25','version'=>'0.83' }]},'MojoMojo'=>{'advisories'=>[{'affected_versions'=>'<0.999033','description'=>'Anonymous users can delete attachments.
  ','distribution'=>'MojoMojo','fixed_versions'=>'>=0.999033','id'=>'CPANSA-MojoMojo-2009-01','references'=>['https://metacpan.org/changes/distribution/MojoMojo','https://github.com/mojomojo/mojomojo/commit/a9b9fd4f4f037627d30f3cbaa10abe42a3439637' ],'reported'=>'2009-08-14' }],'main_module'=>'MojoMojo','versions'=>[{'date'=>'2007-08-29T14:32:52','version'=>'0.05' },{'date'=>'2007-09-12T21:46:24','version'=>'0.05' },{'date'=>'2007-09-13T11:28:37','version'=>'0.05' },{'date'=>'2007-09-18T07:33:43','version'=>'0.999004' },{'date'=>'2007-09-18T08:02:02','version'=>'0.999005' },{'date'=>'2007-09-19T20:59:39','version'=>'0.999006' },{'date'=>'2007-09-23T23:30:59','version'=>'0.999007' },{'date'=>'2007-11-12T22:25:35','version'=>'0.999008' },{'date'=>'2008-01-20T23:15:07','version'=>'0.999010' },{'date'=>'2008-01-23T23:00:05','version'=>'0.999011' },{'date'=>'2008-02-05T23:20:47','version'=>'0.999012' },{'date'=>'2008-03-05T00:34:49','version'=>'0.999013' },{'date'=>'2008-05-02T18:11:49','version'=>'0.999014' },{'date'=>'2008-05-03T16:10:08','version'=>'0.999015' },{'date'=>'2008-06-29T13:03:39','version'=>'0.999016' },{'date'=>'2008-07-09T14:26:56','version'=>'0.999017' },{'date'=>'2008-07-16T19:26:46','version'=>'0.999018' },{'date'=>'2008-07-19T21:33:36','version'=>'0.999018' },{'date'=>'2008-07-29T16:25:08','version'=>'0.999018' },{'date'=>'2008-11-01T01:04:37','version'=>'0.999021' },{'date'=>'2008-11-15T09:09:37','version'=>'0.999022' },{'date'=>'2008-11-23T16:45:05','version'=>'0.999023' },{'date'=>'2008-12-31T17:53:50','version'=>'0.999024' },{'date'=>'2009-01-04T22:51:40','version'=>'0.999025' },{'date'=>'2009-01-07T23:28:15','version'=>'0.999026' },{'date'=>'2009-01-30T23:29:25','version'=>'0.999027' },{'date'=>'2009-04-23T10:06:20','version'=>'0.999028' },{'date'=>'2009-05-09T23:21:10','version'=>'0.999029' },{'date'=>'2009-07-18T19:39:14','version'=>'0.999030' },{'date'=>'2009-07-26T19:39:37','version'=>'0.999031' },{'date'=>'2009-08-02T21:28:51','version'=>'0.999032' },{'date'=>'2009-08-14T12:50:18','version'=>'0.999033' },{'date'=>'2009-09-04T18:27:34','version'=>'0.999040' },{'date'=>'2009-10-26T16:07:25','version'=>'0.999041' },{'date'=>'2009-12-02T08:22:24','version'=>'0.999042' },{'date'=>'2010-05-11T22:58:19','version'=>'1.00' },{'date'=>'2010-05-27T07:44:39','version'=>'1.01' },{'date'=>'2010-08-30T21:24:41','version'=>'1.02' },{'date'=>'2011-01-13T12:48:10','version'=>'1.03' },{'date'=>'2011-03-12T23:37:45','version'=>'1.04' },{'date'=>'2011-09-14T10:09:05','version'=>'1.05' },{'date'=>'2012-08-07T10:39:42','version'=>'1.06' },{'date'=>'2012-11-12T23:30:00','version'=>'1.07' },{'date'=>'2013-01-06T07:46:41','version'=>'1.08' },{'date'=>'2013-01-25T16:06:42','version'=>'1.09' },{'date'=>'2013-05-12T22:59:03','version'=>'1.10' },{'date'=>'2014-12-25T17:13:24','version'=>'1.11' },{'date'=>'2017-05-13T13:47:52','version'=>'1.12' }]},'Mojolicious'=>{'advisories'=>[{'affected_versions'=>'>7.83, <7.92','description'=>'This release reverts the addition of stream classes (added in 7.83), which have unfortunately resulted in many Mojolicious applications becoming unstable. While there are no known exploits yet, we\'ve chosen to err on the side of cautiousness and will classify this as a security issue.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2018-04','references'=>['https://github.com/mojolicious/mojo/commit/61f6cbf22c7bf8eb4787bd1014d91ee2416c73e7' ],'reported'=>'2018-08-09','severity'=>'critical' },{'affected_versions'=>'<7.80','description'=>'Mojo::UserAgent was not checking peer SSL certificates by default.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2018-03','references'=>['https://github.com/mojolicious/mojo/pull/1226','https://github.com/mojolicious/mojo/commit/d3cbbad890673612fdbdea63fdd522b516f6104c' ],'reported'=>'2018-05-19','severity'=>'high' },{'affected_versions'=>'<7.78','description'=>'GET requests with embedded backslashes can be used to access local files on Windows hosts
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2018-02','references'=>['https://github.com/mojolicious/mojo/pull/1217','https://github.com/mojolicious/mojo/commit/23ebe051d9378f0f122e3c908845fc0c2cae0106' ],'reported'=>'2018-05-11','severity'=>'critical' },{'affected_versions'=>'<7.66','description'=>'Mojo::UserAgent::CookieJar leaks old cookies because of the missing host_only flag on empty domain.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2018-01','references'=>['https://github.com/mojolicious/mojo/pull/1192','https://github.com/mojolicious/mojo/issues/1185','https://github.com/mojolicious/mojo/commit/c16a56a9d6575ddc53d15e76d58f0ebcb0eeb149' ],'reported'=>'2018-02-13','severity'=>'minor' },{'affected_versions'=>'<5.76','description'=>'Directory traversal on Windows
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2015-01','references'=>['https://github.com/mojolicious/mojo/issues/738','https://github.com/mojolicious/mojo/commit/9ffa38fca73a9ddee91cbc70e0696268d500edde' ],'reported'=>'2015-02-02','severity'=>'critical' },{'affected_versions'=>'<5.48','description'=>'Context sensitivity of method param could lead to parameter injection attacks.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2014-01','references'=>['https://github.com/mojolicious/mojo/commit/a815d4797145f872ef6e9f1270841eda1d410afb' ],'reported'=>'2014-10-07','severity'=>'high' },{'affected_versions'=>'<1.16','description'=>'Directory traversal vulnerability in Path.pm in Mojolicious before 1.16 allows remote attackers to read arbitrary files via a %2f..%2f (encoded slash dot dot slash) in a URI.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2011-02','references'=>['https://github.com/mojolicious/mojo/commit/b09854988c5b5b6a2ba53cc8661c4b2677da3818','https://www.cvedetails.com/cve/CVE-2011-1589/' ],'reported'=>'2011-04-05','severity'=>'critical' },{'affected_versions'=>'<1.12','description'=>'Mojolicious is vulnerable to cross-site scripting, caused by improper validation of user-supplied input by link_to helper. A remote attacker could exploit this vulnerability using a specially-crafted URL to execute script in a victim\'s Web browser within the security context of the hosting Web site, once the URL is clicked. An attacker could use this vulnerability to steal the victim\'s cookie-based authentication credentials.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2011-01','references'=>['https://exchange.xforce.ibmcloud.com/vulnerabilities/67257','https://www.debian.org/security/2011/dsa-2239','https://github.com/mojolicious/mojo/commit/f6801ef7be8c78092e38f870b19fae3da0899d60' ],'reported'=>'2011-03-10','severity'=>'high' }],'main_module'=>'Mojolicious','versions'=>[{'date'=>'2010-02-11T02:04:14','version'=>'0.999920' },{'date'=>'2010-02-11T02:55:03','version'=>'0.999921' },{'date'=>'2010-02-26T18:50:34','version'=>'0.999922' },{'date'=>'2010-03-08T20:03:52','version'=>'0.999923' },{'date'=>'2010-03-20T22:56:55','version'=>'0.999924' },{'date'=>'2010-06-07T22:33:12','version'=>'0.999925' },{'date'=>'2010-06-11T10:33:01','version'=>'0.999926' },{'date'=>'2010-08-15T13:48:19','version'=>'0.999927' },{'date'=>'2010-08-17T17:41:47','version'=>'0.999928' },{'date'=>'2010-08-17T17:54:45','version'=>'0.999929' },{'date'=>'2010-10-19T13:57:49','version'=>'0.999930' },{'date'=>'2010-10-26T04:44:54','version'=>'0.999931' },{'date'=>'2010-10-30T00:54:42','version'=>'0.999932' },{'date'=>'2010-10-30T19:46:09','version'=>'0.999933' },{'date'=>'2010-11-01T00:33:14','version'=>'0.999934' },{'date'=>'2010-11-03T20:34:11','version'=>'0.999935' },{'date'=>'2010-11-04T23:48:46','version'=>'0.999936' },{'date'=>'2010-11-09T20:13:52','version'=>'0.999937' },{'date'=>'2010-11-09T21:24:17','version'=>'0.999938' },{'date'=>'2010-11-15T17:56:49','version'=>'0.999939' },{'date'=>'2010-11-15T23:18:40','version'=>'0.999940' },{'date'=>'2010-11-19T14:22:51','version'=>'0.999941' },{'date'=>'2010-12-01T18:57:50','version'=>'0.999950' },{'date'=>'2010-12-26T14:55:33','version'=>'1.0' },{'date'=>'2011-01-06T12:00:46','version'=>'1.01' },{'date'=>'2011-02-14T03:22:27','version'=>'1.1' },{'date'=>'2011-02-18T17:07:03','version'=>'1.11' },{'date'=>'2011-03-10T10:05:32','version'=>'1.12' },{'date'=>'2011-03-14T11:58:23','version'=>'1.13' },{'date'=>'2011-03-17T13:24:28','version'=>'1.14' },{'date'=>'2011-03-18T18:31:34','version'=>'1.15' },{'date'=>'2011-04-15T09:07:17','version'=>'1.16' },{'date'=>'2011-04-18T21:49:07','version'=>'1.17' },{'date'=>'2011-04-19T21:03:20','version'=>'1.18' },{'date'=>'2011-04-19T22:17:44','version'=>'1.19' },{'date'=>'2011-04-20T10:39:46','version'=>'1.20' },{'date'=>'2011-04-20T15:29:17','version'=>'1.21' },{'date'=>'2011-05-02T07:00:00','version'=>'1.22' },{'date'=>'2011-05-08T17:00:10','version'=>'1.31' },{'date'=>'2011-05-11T13:29:59','version'=>'1.32' },{'date'=>'2011-05-20T12:32:57','version'=>'1.33' },{'date'=>'2011-05-22T13:20:40','version'=>'1.34' },{'date'=>'2011-06-02T09:03:36','version'=>'1.4' },{'date'=>'2011-06-03T10:12:43','version'=>'1.41' },{'date'=>'2011-06-09T14:12:56','version'=>'1.42' },{'date'=>'2011-06-13T14:05:24','version'=>'1.43' },{'date'=>'2011-06-18T18:14:22','version'=>'1.44' },{'date'=>'2011-06-20T00:25:16','version'=>'1.45' },{'date'=>'2011-06-21T04:56:47','version'=>'1.46' },{'date'=>'2011-06-22T13:03:42','version'=>'1.47' },{'date'=>'2011-06-24T12:01:47','version'=>'1.48' },{'date'=>'2011-06-30T15:18:18','version'=>'1.49' },{'date'=>'2011-07-01T10:26:00','version'=>'1.50' },{'date'=>'2011-07-01T13:59:47','version'=>'1.51' },{'date'=>'2011-07-01T17:48:50','version'=>'1.52' },{'date'=>'2011-07-02T11:48:49','version'=>'1.53' },{'date'=>'2011-07-03T18:04:37','version'=>'1.54' },{'date'=>'2011-07-04T21:23:51','version'=>'1.55' },{'date'=>'2011-07-05T20:49:36','version'=>'1.56' },{'date'=>'2011-07-07T02:00:07','version'=>'1.57' },{'date'=>'2011-07-07T19:52:59','version'=>'1.58' },{'date'=>'2011-07-08T04:58:56','version'=>'1.59' },{'date'=>'2011-07-08T20:44:55','version'=>'1.60' },{'date'=>'2011-07-09T19:36:58','version'=>'1.61' },{'date'=>'2011-07-10T00:40:32','version'=>'1.62' },{'date'=>'2011-07-10T03:19:49','version'=>'1.63' },{'date'=>'2011-07-10T05:51:47','version'=>'1.64' },{'date'=>'2011-07-25T18:13:25','version'=>'1.65' },{'date'=>'2011-07-26T23:14:38','version'=>'1.66' },{'date'=>'2011-07-27T13:57:06','version'=>'1.67' },{'date'=>'2011-07-29T18:39:20','version'=>'1.68' },{'date'=>'2011-08-03T14:32:24','version'=>'1.69' },{'date'=>'2011-08-04T15:34:41','version'=>'1.70' },{'date'=>'2011-08-05T04:01:50','version'=>'1.71' },{'date'=>'2011-08-05T20:07:50','version'=>'1.72' },{'date'=>'2011-08-09T10:07:19','version'=>'1.73' },{'date'=>'2011-08-09T12:09:49','version'=>'1.74' },{'date'=>'2011-08-12T13:14:07','version'=>'1.75' },{'date'=>'2011-08-12T14:54:00','version'=>'1.76' },{'date'=>'2011-08-14T20:48:58','version'=>'1.77' },{'date'=>'2011-08-16T13:22:48','version'=>'1.78' },{'date'=>'2011-08-17T17:43:58','version'=>'1.79' },{'date'=>'2011-08-17T19:08:11','version'=>'1.80' },{'date'=>'2011-08-19T02:48:39','version'=>'1.81' },{'date'=>'2011-08-19T04:55:49','version'=>'1.82' },{'date'=>'2011-08-19T05:21:15','version'=>'1.83' },{'date'=>'2011-08-19T18:08:30','version'=>'1.84' },{'date'=>'2011-08-20T00:19:42','version'=>'1.85' },{'date'=>'2011-08-21T18:59:13','version'=>'1.86' },{'date'=>'2011-08-23T00:49:19','version'=>'1.87' },{'date'=>'2011-08-23T19:20:37','version'=>'1.88' },{'date'=>'2011-08-23T21:15:42','version'=>'1.89' },{'date'=>'2011-08-24T19:01:47','version'=>'1.90' },{'date'=>'2011-08-25T05:54:05','version'=>'1.91' },{'date'=>'2011-08-26T00:47:54','version'=>'1.92' },{'date'=>'2011-08-27T09:11:59','version'=>'1.93' },{'date'=>'2011-08-27T10:52:14','version'=>'1.94' },{'date'=>'2011-09-01T20:50:35','version'=>'1.95' },{'date'=>'2011-09-01T22:42:14','version'=>'1.96' },{'date'=>'2011-09-03T10:32:15','version'=>'1.97' },{'date'=>'2011-09-14T18:21:20','version'=>'1.98' },{'date'=>'2011-09-29T08:27:22','version'=>'1.99' },{'date'=>'2011-10-17T16:25:55','version'=>'2.0' },{'date'=>'2011-10-19T12:49:44','version'=>'2.01' },{'date'=>'2011-10-19T23:41:41','version'=>'2.02' },{'date'=>'2011-10-20T12:24:36','version'=>'2.03' },{'date'=>'2011-10-21T15:37:59','version'=>'2.04' },{'date'=>'2011-10-22T16:36:22','version'=>'2.05' },{'date'=>'2011-10-22T21:44:31','version'=>'2.06' },{'date'=>'2011-10-23T00:39:23','version'=>'2.07' },{'date'=>'2011-10-23T01:30:44','version'=>'2.08' },{'date'=>'2011-10-23T02:13:30','version'=>'2.09' },{'date'=>'2011-10-25T02:22:41','version'=>'2.10' },{'date'=>'2011-10-25T18:47:46','version'=>'2.11' },{'date'=>'2011-10-27T01:54:39','version'=>'2.12' },{'date'=>'2011-10-27T19:15:21','version'=>'2.13' },{'date'=>'2011-10-28T20:28:23','version'=>'2.14' },{'date'=>'2011-10-29T04:29:30','version'=>'2.15' },{'date'=>'2011-10-29T20:52:07','version'=>'2.16' },{'date'=>'2011-10-30T00:55:35','version'=>'2.17' },{'date'=>'2011-10-30T18:03:30','version'=>'2.18' },{'date'=>'2011-10-31T09:07:02','version'=>'2.19' },{'date'=>'2011-11-01T00:40:20','version'=>'2.20' },{'date'=>'2011-11-02T01:29:01','version'=>'2.21' },{'date'=>'2011-11-03T15:21:43','version'=>'2.22' },{'date'=>'2011-11-04T18:45:33','version'=>'2.23' },{'date'=>'2011-11-05T16:16:00','version'=>'2.24' },{'date'=>'2011-11-08T21:13:48','version'=>'2.25' },{'date'=>'2011-11-10T16:53:32','version'=>'2.26' },{'date'=>'2011-11-16T20:59:52','version'=>'2.27' },{'date'=>'2011-11-17T23:44:36','version'=>'2.28' },{'date'=>'2011-11-19T20:10:28','version'=>'2.29' },{'date'=>'2011-11-20T00:19:04','version'=>'2.30' },{'date'=>'2011-11-20T22:25:03','version'=>'2.31' },{'date'=>'2011-11-24T10:31:31','version'=>'2.32' },{'date'=>'2011-11-28T12:32:13','version'=>'2.33' },{'date'=>'2011-11-28T14:02:31','version'=>'2.34' },{'date'=>'2011-12-01T14:19:35','version'=>'2.35' },{'date'=>'2011-12-05T10:52:35','version'=>'2.36' },{'date'=>'2011-12-10T18:18:16','version'=>'2.37' },{'date'=>'2011-12-17T12:03:38','version'=>'2.38' },{'date'=>'2011-12-22T12:31:43','version'=>'2.39' },{'date'=>'2011-12-24T13:04:21','version'=>'2.40' },{'date'=>'2011-12-28T16:09:18','version'=>'2.41' },{'date'=>'2012-01-02T17:15:52','version'=>'2.42' },{'date'=>'2012-01-08T03:43:27','version'=>'2.43' },{'date'=>'2012-01-17T23:21:12','version'=>'2.44' },{'date'=>'2012-01-18T15:23:03','version'=>'2.45' },{'date'=>'2012-01-25T18:20:48','version'=>'2.46' },{'date'=>'2012-02-06T16:28:27','version'=>'2.47' },{'date'=>'2012-02-09T07:04:28','version'=>'2.48' },{'date'=>'2012-02-13T19:45:00','version'=>'2.49' },{'date'=>'2012-02-18T01:18:38','version'=>'2.50' },{'date'=>'2012-02-19T12:32:58','version'=>'2.51' },{'date'=>'2012-02-24T15:01:33','version'=>'2.52' },{'date'=>'2012-02-25T05:53:29','version'=>'2.53' },{'date'=>'2012-02-27T15:31:19','version'=>'2.54' },{'date'=>'2012-02-27T19:26:41','version'=>'2.55' },{'date'=>'2012-03-01T21:07:06','version'=>'2.56' },{'date'=>'2012-03-03T22:01:50','version'=>'2.57' },{'date'=>'2012-03-09T18:38:46','version'=>'2.58' },{'date'=>'2012-03-09T19:02:23','version'=>'2.59' },{'date'=>'2012-03-13T16:50:25','version'=>'2.60' },{'date'=>'2012-03-14T00:41:48','version'=>'2.61' },{'date'=>'2012-03-17T09:05:12','version'=>'2.62' },{'date'=>'2012-03-20T18:39:51','version'=>'2.63' },{'date'=>'2012-03-21T01:23:59','version'=>'2.64' },{'date'=>'2012-03-22T22:06:10','version'=>'2.65' },{'date'=>'2012-03-23T16:16:55','version'=>'2.66' },{'date'=>'2012-03-24T14:29:35','version'=>'2.67' },{'date'=>'2012-03-24T14:59:52','version'=>'2.68' },{'date'=>'2012-03-27T12:53:44','version'=>'2.69' },{'date'=>'2012-03-30T21:24:44','version'=>'2.70' },{'date'=>'2012-04-03T01:46:31','version'=>'2.71' },{'date'=>'2012-04-03T13:16:07','version'=>'2.72' },{'date'=>'2012-04-03T17:10:05','version'=>'2.73' },{'date'=>'2012-04-03T22:33:05','version'=>'2.74' },{'date'=>'2012-04-05T01:57:10','version'=>'2.75' },{'date'=>'2012-04-05T03:52:05','version'=>'2.76' },{'date'=>'2012-04-09T12:36:15','version'=>'2.77' },{'date'=>'2012-04-09T18:54:51','version'=>'2.78' },{'date'=>'2012-04-10T10:58:23','version'=>'2.79' },{'date'=>'2012-04-10T14:25:57','version'=>'2.80' },{'date'=>'2012-04-15T18:49:31','version'=>'2.81' },{'date'=>'2012-04-16T21:09:32','version'=>'2.82' },{'date'=>'2012-04-18T18:51:37','version'=>'2.83' },{'date'=>'2012-04-18T21:29:14','version'=>'2.84' },{'date'=>'2012-04-19T15:37:54','version'=>'2.85' },{'date'=>'2012-04-23T12:21:14','version'=>'2.86' },{'date'=>'2012-04-23T14:19:09','version'=>'2.87' },{'date'=>'2012-04-24T02:15:58','version'=>'2.88' },{'date'=>'2012-04-24T20:08:49','version'=>'2.89' },{'date'=>'2012-04-25T11:35:38','version'=>'2.90' },{'date'=>'2012-04-26T19:20:37','version'=>'2.91' },{'date'=>'2012-04-30T16:50:01','version'=>'2.92' },{'date'=>'2012-05-05T22:00:26','version'=>'2.93' },{'date'=>'2012-05-10T03:49:57','version'=>'2.94' },{'date'=>'2012-05-10T20:08:54','version'=>'2.95' },{'date'=>'2012-05-21T08:26:37','version'=>'2.96' },{'date'=>'2012-05-28T12:11:13','version'=>'2.97' },{'date'=>'2012-05-30T18:21:26','version'=>'2.98' },{'date'=>'2012-06-26T06:45:51','version'=>'3.0' },{'date'=>'2012-07-01T10:00:07','version'=>'3.01' },{'date'=>'2012-07-03T19:21:54','version'=>'3.02' },{'date'=>'2012-07-06T21:17:36','version'=>'3.03' },{'date'=>'2012-07-07T11:29:24','version'=>'3.04' },{'date'=>'2012-07-07T21:49:48','version'=>'3.05' },{'date'=>'2012-07-11T17:27:01','version'=>'3.06' },{'date'=>'2012-07-13T00:25:44','version'=>'3.07' },{'date'=>'2012-07-13T21:53:56','version'=>'3.08' },{'date'=>'2012-07-16T19:46:15','version'=>'3.09' },{'date'=>'2012-07-16T20:00:50','version'=>'3.10' },{'date'=>'2012-07-19T01:44:35','version'=>'3.11' },{'date'=>'2012-07-20T12:30:03','version'=>'3.12' },{'date'=>'2012-07-24T17:03:04','version'=>'3.13' },{'date'=>'2012-07-27T11:05:47','version'=>'3.14' },{'date'=>'2012-07-28T11:32:31','version'=>'3.15' },{'date'=>'2012-07-31T18:55:11','version'=>'3.16' },{'date'=>'2012-08-01T00:38:50','version'=>'3.17' },{'date'=>'2012-08-01T19:15:21','version'=>'3.18' },{'date'=>'2012-08-02T15:40:34','version'=>'3.19' },{'date'=>'2012-08-03T23:32:38','version'=>'3.20' },{'date'=>'2012-08-05T22:32:21','version'=>'3.21' },{'date'=>'2012-08-06T19:53:03','version'=>'3.22' },{'date'=>'2012-08-07T03:37:26','version'=>'3.23' },{'date'=>'2012-08-07T20:56:45','version'=>'3.24' },{'date'=>'2012-08-08T00:31:31','version'=>'3.25' },{'date'=>'2012-08-08T04:04:18','version'=>'3.26' },{'date'=>'2012-08-08T21:18:27','version'=>'3.27' },{'date'=>'2012-08-10T12:18:38','version'=>'3.28' },{'date'=>'2012-08-13T13:42:56','version'=>'3.29' },{'date'=>'2012-08-13T16:14:35','version'=>'3.30' },{'date'=>'2012-08-15T09:37:25','version'=>'3.31' },{'date'=>'2012-08-20T12:37:26','version'=>'3.32' },{'date'=>'2012-08-23T18:34:00','version'=>'3.33' },{'date'=>'2012-08-24T01:17:41','version'=>'3.34' },{'date'=>'2012-08-27T22:52:31','version'=>'3.35' },{'date'=>'2012-08-30T00:59:43','version'=>'3.36' },{'date'=>'2012-09-04T20:50:40','version'=>'3.37' },{'date'=>'2012-09-07T00:05:53','version'=>'3.38' },{'date'=>'2012-09-10T11:58:00','version'=>'3.39' },{'date'=>'2012-09-11T18:03:47','version'=>'3.40' },{'date'=>'2012-09-13T18:22:49','version'=>'3.41' },{'date'=>'2012-09-16T17:29:48','version'=>'3.42' },{'date'=>'2012-09-22T19:40:59','version'=>'3.43' },{'date'=>'2012-09-29T11:20:17','version'=>'3.44' },{'date'=>'2012-10-09T20:39:26','version'=>'3.45' },{'date'=>'2012-10-10T20:55:33','version'=>'3.46' },{'date'=>'2012-10-12T23:10:49','version'=>'3.47' },{'date'=>'2012-10-16T22:51:05','version'=>'3.48' },{'date'=>'2012-10-19T16:34:25','version'=>'3.49' },{'date'=>'2012-10-20T01:34:34','version'=>'3.50' },{'date'=>'2012-10-23T20:23:54','version'=>'3.51' },{'date'=>'2012-10-26T14:41:25','version'=>'3.52' },{'date'=>'2012-10-31T02:41:01','version'=>'3.53' },{'date'=>'2012-11-01T04:36:00','version'=>'3.54' },{'date'=>'2012-11-08T11:20:15','version'=>'3.55' },{'date'=>'2012-11-09T20:09:37','version'=>'3.56' },{'date'=>'2012-11-12T19:47:57','version'=>'3.57' },{'date'=>'2012-11-19T16:05:13','version'=>'3.58' },{'date'=>'2012-11-20T19:53:03','version'=>'3.59' },{'date'=>'2012-11-22T05:12:27','version'=>'3.60' },{'date'=>'2012-11-25T04:19:47','version'=>'3.61' },{'date'=>'2012-11-26T00:57:00','version'=>'3.62' },{'date'=>'2012-11-28T10:17:51','version'=>'3.63' },{'date'=>'2012-12-01T16:39:26','version'=>'3.64' },{'date'=>'2012-12-08T22:47:54','version'=>'3.65' },{'date'=>'2012-12-14T01:03:29','version'=>'3.66' },{'date'=>'2012-12-14T23:48:00','version'=>'3.67' },{'date'=>'2012-12-16T00:55:55','version'=>'3.68' },{'date'=>'2012-12-20T22:47:53','version'=>'3.69' },{'date'=>'2012-12-23T22:18:59','version'=>'3.70' },{'date'=>'2013-01-02T11:57:12','version'=>'3.71' },{'date'=>'2013-01-04T22:16:16','version'=>'3.72' },{'date'=>'2013-01-06T22:46:48','version'=>'3.73' },{'date'=>'2013-01-07T18:47:06','version'=>'3.74' },{'date'=>'2013-01-08T16:15:03','version'=>'3.75' },{'date'=>'2013-01-10T00:00:19','version'=>'3.76' },{'date'=>'2013-01-12T00:36:11','version'=>'3.77' },{'date'=>'2013-01-12T23:47:49','version'=>'3.78' },{'date'=>'2013-01-13T00:50:13','version'=>'3.79' },{'date'=>'2013-01-15T05:02:52','version'=>'3.80' },{'date'=>'2013-01-17T21:32:48','version'=>'3.81' },{'date'=>'2013-01-18T15:50:23','version'=>'3.82' },{'date'=>'2013-01-27T15:28:40','version'=>'3.83' },{'date'=>'2013-01-30T00:32:12','version'=>'3.84' },{'date'=>'2013-02-13T00:56:23','version'=>'3.85' },{'date'=>'2013-02-22T02:01:13','version'=>'3.86' },{'date'=>'2013-02-23T19:36:00','version'=>'3.87' },{'date'=>'2013-03-03T21:53:52','version'=>'3.88' },{'date'=>'2013-03-04T16:12:24','version'=>'3.89' },{'date'=>'2013-03-14T20:08:14','version'=>'3.90' },{'date'=>'2013-03-17T22:59:42','version'=>'3.91' },{'date'=>'2013-04-03T19:48:34','version'=>'3.92' },{'date'=>'2013-04-05T21:46:38','version'=>'3.93' },{'date'=>'2013-04-08T21:48:55','version'=>'3.94' },{'date'=>'2013-04-12T03:49:59','version'=>'3.95' },{'date'=>'2013-04-22T21:34:16','version'=>'3.96' },{'date'=>'2013-04-25T21:49:41','version'=>'3.97' },{'date'=>'2013-05-15T20:02:05','version'=>'4.0' },{'date'=>'2013-05-19T17:24:38','version'=>'4.01' },{'date'=>'2013-05-20T16:55:00','version'=>'4.02' },{'date'=>'2013-05-21T05:24:56','version'=>'4.03' },{'date'=>'2013-05-23T21:25:32','version'=>'4.04' },{'date'=>'2013-05-24T02:59:59','version'=>'4.05' },{'date'=>'2013-05-24T14:23:41','version'=>'4.06' },{'date'=>'2013-05-25T18:07:30','version'=>'4.07' },{'date'=>'2013-05-30T21:45:51','version'=>'4.08' },{'date'=>'2013-05-31T02:24:29','version'=>'4.09' },{'date'=>'2013-06-01T02:09:07','version'=>'4.10' },{'date'=>'2013-06-03T04:34:37','version'=>'4.11' },{'date'=>'2013-06-07T01:51:09','version'=>'4.12' },{'date'=>'2013-06-09T00:25:21','version'=>'4.13' },{'date'=>'2013-06-10T00:23:12','version'=>'4.14' },{'date'=>'2013-06-18T08:02:11','version'=>'4.15' },{'date'=>'2013-06-19T01:27:29','version'=>'4.16' },{'date'=>'2013-07-04T16:14:27','version'=>'4.17' },{'date'=>'2013-07-08T09:17:43','version'=>'4.18' },{'date'=>'2013-07-21T21:47:46','version'=>'4.19' },{'date'=>'2013-07-28T12:53:38','version'=>'4.20' },{'date'=>'2013-07-28T20:17:31','version'=>'4.21' },{'date'=>'2013-07-29T19:13:38','version'=>'4.22' },{'date'=>'2013-07-31T20:35:17','version'=>'4.23' },{'date'=>'2013-08-08T21:10:52','version'=>'4.24' },{'date'=>'2013-08-17T20:16:56','version'=>'4.25' },{'date'=>'2013-08-18T15:06:51','version'=>'4.26' },{'date'=>'2013-08-26T15:29:36','version'=>'4.27' },{'date'=>'2013-08-29T16:11:59','version'=>'4.28' },{'date'=>'2013-08-31T02:01:44','version'=>'4.29' },{'date'=>'2013-09-01T21:48:28','version'=>'4.30' },{'date'=>'2013-09-04T20:09:26','version'=>'4.31' },{'date'=>'2013-09-06T21:19:59','version'=>'4.32' },{'date'=>'2013-09-07T20:38:03','version'=>'4.33' },{'date'=>'2013-09-08T20:58:54','version'=>'4.34' },{'date'=>'2013-09-10T21:40:13','version'=>'4.35' },{'date'=>'2013-09-12T21:31:22','version'=>'4.36' },{'date'=>'2013-09-13T01:32:54','version'=>'4.37' },{'date'=>'2013-09-16T22:01:40','version'=>'4.38' },{'date'=>'2013-09-17T04:53:49','version'=>'4.39' },{'date'=>'2013-09-21T01:15:17','version'=>'4.40' },{'date'=>'2013-09-21T17:25:38','version'=>'4.41' },{'date'=>'2013-09-30T07:46:05','version'=>'4.42' },{'date'=>'2013-10-02T19:16:26','version'=>'4.43' },{'date'=>'2013-10-04T21:18:14','version'=>'4.44' },{'date'=>'2013-10-06T15:46:08','version'=>'4.45' },{'date'=>'2013-10-12T17:11:54','version'=>'4.46' },{'date'=>'2013-10-14T23:51:30','version'=>'4.47' },{'date'=>'2013-10-16T05:28:45','version'=>'4.48' },{'date'=>'2013-10-17T16:53:59','version'=>'4.49' },{'date'=>'2013-10-23T01:18:55','version'=>'4.50' },{'date'=>'2013-10-28T17:20:46','version'=>'4.51' },{'date'=>'2013-10-29T06:27:25','version'=>'4.52' },{'date'=>'2013-10-30T00:21:27','version'=>'4.53' },{'date'=>'2013-11-07T00:45:35','version'=>'4.54' },{'date'=>'2013-11-07T02:38:24','version'=>'4.55' },{'date'=>'2013-11-10T02:56:56','version'=>'4.56' },{'date'=>'2013-11-11T20:30:04','version'=>'4.57' },{'date'=>'2013-11-19T20:46:01','version'=>'4.58' },{'date'=>'2013-12-04T21:35:49','version'=>'4.59' },{'date'=>'2013-12-11T16:33:35','version'=>'4.60' },{'date'=>'2013-12-16T16:59:25','version'=>'4.61' },{'date'=>'2013-12-17T20:35:36','version'=>'4.62' },{'date'=>'2013-12-19T22:59:01','version'=>'4.63' },{'date'=>'2014-01-01T16:20:28','version'=>'4.64' },{'date'=>'2014-01-02T22:36:45','version'=>'4.65' },{'date'=>'2014-01-04T21:48:06','version'=>'4.66' },{'date'=>'2014-01-11T17:20:18','version'=>'4.67' },{'date'=>'2014-01-21T22:24:03','version'=>'4.68' },{'date'=>'2014-01-24T04:06:26','version'=>'4.69' },{'date'=>'2014-01-26T22:08:54','version'=>'4.70' },{'date'=>'2014-01-28T03:10:15','version'=>'4.71' },{'date'=>'2014-01-29T21:29:25','version'=>'4.72' },{'date'=>'2014-02-01T05:20:38','version'=>'4.73' },{'date'=>'2014-02-02T04:30:05','version'=>'4.74' },{'date'=>'2014-02-02T06:54:56','version'=>'4.75' },{'date'=>'2014-02-04T22:41:32','version'=>'4.76' },{'date'=>'2014-02-06T23:19:13','version'=>'4.77' },{'date'=>'2014-02-08T23:02:08','version'=>'4.78' },{'date'=>'2014-02-11T02:49:44','version'=>'4.79' },{'date'=>'2014-02-13T04:30:43','version'=>'4.80' },{'date'=>'2014-02-15T03:27:30','version'=>'4.81' },{'date'=>'2014-02-19T04:11:47','version'=>'4.82' },{'date'=>'2014-02-19T06:20:46','version'=>'4.83' },{'date'=>'2014-02-22T22:59:02','version'=>'4.84' },{'date'=>'2014-02-26T22:48:41','version'=>'4.85' },{'date'=>'2014-03-03T05:45:32','version'=>'4.86' },{'date'=>'2014-03-04T07:14:15','version'=>'4.87' },{'date'=>'2014-03-09T22:42:42','version'=>'4.88' },{'date'=>'2014-03-13T21:30:57','version'=>'4.89' },{'date'=>'2014-03-16T21:22:35','version'=>'4.90' },{'date'=>'2014-03-29T00:05:17','version'=>'4.91' },{'date'=>'2014-04-08T20:41:54','version'=>'4.92' },{'date'=>'2014-04-13T02:17:03','version'=>'4.93' },{'date'=>'2014-04-19T23:39:22','version'=>'4.94' },{'date'=>'2014-04-27T03:27:43','version'=>'4.95' },{'date'=>'2014-04-27T20:04:36','version'=>'4.96' },{'date'=>'2014-04-29T22:12:52','version'=>'4.97' },{'date'=>'2014-05-09T01:57:34','version'=>'4.98' },{'date'=>'2014-05-12T00:46:43','version'=>'4.99' },{'date'=>'2014-05-29T20:15:51','version'=>'5.0' },{'date'=>'2014-05-30T14:51:14','version'=>'5.01' },{'date'=>'2014-05-31T21:51:34','version'=>'5.02' },{'date'=>'2014-06-02T22:07:46','version'=>'5.03' },{'date'=>'2014-06-03T21:11:50','version'=>'5.04' },{'date'=>'2014-06-08T21:50:53','version'=>'5.05' },{'date'=>'2014-06-12T02:08:01','version'=>'5.06' },{'date'=>'2014-06-13T19:28:04','version'=>'5.07' },{'date'=>'2014-06-16T23:44:48','version'=>'5.08' },{'date'=>'2014-06-24T15:02:21','version'=>'5.09' },{'date'=>'2014-06-28T23:25:12','version'=>'5.10' },{'date'=>'2014-07-03T04:01:24','version'=>'5.11' },{'date'=>'2014-07-03T23:06:55','version'=>'5.12' },{'date'=>'2014-07-13T00:44:29','version'=>'5.13' },{'date'=>'2014-07-14T22:01:49','version'=>'5.14' },{'date'=>'2014-07-17T17:58:05','version'=>'5.15' },{'date'=>'2014-07-21T16:01:56','version'=>'5.16' },{'date'=>'2014-07-24T12:40:41','version'=>'5.17' },{'date'=>'2014-07-25T20:25:29','version'=>'5.18' },{'date'=>'2014-07-26T21:03:13','version'=>'5.19' },{'date'=>'2014-07-26T23:36:18','version'=>'5.20' },{'date'=>'2014-07-27T18:48:25','version'=>'5.21' },{'date'=>'2014-07-30T16:42:35','version'=>'5.22' },{'date'=>'2014-07-31T21:32:03','version'=>'5.23' },{'date'=>'2014-08-02T21:56:32','version'=>'5.24' },{'date'=>'2014-08-07T01:29:20','version'=>'5.25' },{'date'=>'2014-08-09T21:26:37','version'=>'5.26' },{'date'=>'2014-08-11T14:26:47','version'=>'5.27' },{'date'=>'2014-08-13T00:32:33','version'=>'5.28' },{'date'=>'2014-08-16T12:40:15','version'=>'5.29' },{'date'=>'2014-08-17T21:49:15','version'=>'5.30' },{'date'=>'2014-08-19T17:40:27','version'=>'5.31' },{'date'=>'2014-08-21T18:19:53','version'=>'5.32' },{'date'=>'2014-08-23T22:25:32','version'=>'5.33' },{'date'=>'2014-08-29T21:53:02','version'=>'5.34' },{'date'=>'2014-08-30T21:57:50','version'=>'5.35' },{'date'=>'2014-09-02T00:20:21','version'=>'5.36' },{'date'=>'2014-09-03T20:55:45','version'=>'5.37' },{'date'=>'2014-09-05T21:57:34','version'=>'5.38' },{'date'=>'2014-09-07T03:18:45','version'=>'5.39' },{'date'=>'2014-09-12T01:06:33','version'=>'5.40' },{'date'=>'2014-09-13T21:24:03','version'=>'5.41' },{'date'=>'2014-09-17T21:54:39','version'=>'5.42' },{'date'=>'2014-09-22T00:14:24','version'=>'5.43' },{'date'=>'2014-09-23T00:49:52','version'=>'5.44' },{'date'=>'2014-09-27T03:21:55','version'=>'5.46' },{'date'=>'2014-09-27T03:24:38','version'=>'5.45' },{'date'=>'2014-09-28T03:31:15','version'=>'5.47' },{'date'=>'2014-10-07T23:08:14','version'=>'5.48' },{'date'=>'2014-10-10T21:12:14','version'=>'5.49' },{'date'=>'2014-10-15T22:00:04','version'=>'5.50' },{'date'=>'2014-10-17T21:48:17','version'=>'5.51' },{'date'=>'2014-10-18T20:49:34','version'=>'5.52' },{'date'=>'2014-10-20T23:34:37','version'=>'5.53' },{'date'=>'2014-10-23T22:51:06','version'=>'5.54' },{'date'=>'2014-10-29T00:58:34','version'=>'5.55' },{'date'=>'2014-10-30T00:23:25','version'=>'5.56' },{'date'=>'2014-11-02T22:52:07','version'=>'5.57' },{'date'=>'2014-11-07T00:04:47','version'=>'5.58' },{'date'=>'2014-11-08T00:26:41','version'=>'5.59' },{'date'=>'2014-11-12T01:31:36','version'=>'5.60' },{'date'=>'2014-11-15T00:46:43','version'=>'5.61' },{'date'=>'2014-11-18T18:24:54','version'=>'5.62' },{'date'=>'2014-11-22T03:52:56','version'=>'5.63' },{'date'=>'2014-11-23T02:12:00','version'=>'5.64' },{'date'=>'2014-11-25T03:23:01','version'=>'5.65' },{'date'=>'2014-11-27T03:13:19','version'=>'5.66' },{'date'=>'2014-11-27T06:19:49','version'=>'5.67' },{'date'=>'2014-12-03T04:36:04','version'=>'5.68' },{'date'=>'2014-12-13T02:19:36','version'=>'5.69' },{'date'=>'2014-12-18T00:12:31','version'=>'5.70' },{'date'=>'2015-01-01T22:44:58','version'=>'5.71' },{'date'=>'2015-01-11T20:02:04','version'=>'5.72' },{'date'=>'2015-01-23T16:29:22','version'=>'5.73' },{'date'=>'2015-01-24T13:32:51','version'=>'5.74' },{'date'=>'2015-01-27T04:08:19','version'=>'5.75' },{'date'=>'2015-02-02T19:36:16','version'=>'5.76' },{'date'=>'2015-02-03T02:37:04','version'=>'5.77' },{'date'=>'2015-02-13T00:21:48','version'=>'5.78' },{'date'=>'2015-02-13T05:32:50','version'=>'5.79' },{'date'=>'2015-02-18T05:24:00','version'=>'5.80' },{'date'=>'2015-02-21T03:30:18','version'=>'5.81' },{'date'=>'2015-02-23T03:05:04','version'=>'5.82' },{'date'=>'2015-02-26T22:17:01','version'=>'6.0' },{'date'=>'2015-03-03T16:12:16','version'=>'6.01' },{'date'=>'2015-03-10T02:53:22','version'=>'6.02' },{'date'=>'2015-03-16T04:43:10','version'=>'6.03' },{'date'=>'2015-03-23T04:42:27','version'=>'6.04' },{'date'=>'2015-03-25T05:08:15','version'=>'6.05' },{'date'=>'2015-04-07T00:55:21','version'=>'6.06' },{'date'=>'2015-04-07T17:38:01','version'=>'6.07' },{'date'=>'2015-04-09T22:03:46','version'=>'6.08' },{'date'=>'2015-04-26T05:10:45','version'=>'6.09' },{'date'=>'2015-04-27T02:01:03','version'=>'6.10' },{'date'=>'2015-05-16T22:14:01','version'=>'6.11' },{'date'=>'2015-06-18T21:48:20','version'=>'6.12' },{'date'=>'2015-08-20T06:09:39','version'=>'6.16' },{'date'=>'2015-08-22T19:38:51','version'=>'6.17' },{'date'=>'2015-09-02T17:26:36','version'=>'6.18' },{'date'=>'2015-09-12T23:37:29','version'=>'6.19' },{'date'=>'2015-09-16T22:50:30','version'=>'6.20' },{'date'=>'2015-09-23T01:05:04','version'=>'6.21' },{'date'=>'2015-09-27T01:03:32','version'=>'6.22' },{'date'=>'2015-10-07T18:17:26','version'=>'6.23' },{'date'=>'2015-10-13T22:54:46','version'=>'6.24' },{'date'=>'2015-10-22T02:49:47','version'=>'6.25' },{'date'=>'2015-10-29T00:29:07','version'=>'6.26' },{'date'=>'2015-10-30T00:07:08','version'=>'6.27' },{'date'=>'2015-11-02T15:17:16','version'=>'6.28' },{'date'=>'2015-11-12T02:59:43','version'=>'6.30' },{'date'=>'2015-11-14T19:38:51','version'=>'6.31' },{'date'=>'2015-11-18T18:16:15','version'=>'6.32' },{'date'=>'2015-11-22T16:47:00','version'=>'6.33' },{'date'=>'2016-01-13T20:08:22','version'=>'6.40' },{'date'=>'2016-01-24T22:01:52','version'=>'6.42' },{'date'=>'2016-02-01T16:15:40','version'=>'6.43' },{'date'=>'2016-02-05T22:42:51','version'=>'6.44' },{'date'=>'2016-02-09T23:29:35','version'=>'6.45' },{'date'=>'2016-02-14T00:51:10','version'=>'6.46' },{'date'=>'2016-02-19T23:09:15','version'=>'6.47' },{'date'=>'2016-02-24T17:07:45','version'=>'6.48' },{'date'=>'2016-02-26T22:47:33','version'=>'6.49' },{'date'=>'2016-02-27T00:12:03','version'=>'6.50' },{'date'=>'2016-02-29T23:03:44','version'=>'6.51' },{'date'=>'2016-03-02T22:24:28','version'=>'6.52' },{'date'=>'2016-03-04T00:58:55','version'=>'6.53' },{'date'=>'2016-03-07T15:09:42','version'=>'6.54' },{'date'=>'2016-03-08T20:42:43','version'=>'6.55' },{'date'=>'2016-03-16T02:42:45','version'=>'6.56' },{'date'=>'2016-03-23T04:23:41','version'=>'6.57' },{'date'=>'2016-04-10T17:11:22','version'=>'6.58' },{'date'=>'2016-04-22T18:45:19','version'=>'6.59' },{'date'=>'2016-04-26T13:16:04','version'=>'6.60' },{'date'=>'2016-05-02T17:31:34','version'=>'6.61' },{'date'=>'2016-05-14T21:05:47','version'=>'6.62' },{'date'=>'2016-06-03T21:10:48','version'=>'6.63' },{'date'=>'2016-06-09T16:41:51','version'=>'6.64' },{'date'=>'2016-06-14T16:15:21','version'=>'6.65' },{'date'=>'2016-06-16T22:35:28','version'=>'6.66' },{'date'=>'2016-07-19T06:21:07','version'=>'7.0' },{'date'=>'2016-08-01T18:46:35','version'=>'7.01' },{'date'=>'2016-08-17T16:34:19','version'=>'7.02' },{'date'=>'2016-08-17T16:40:11','version'=>'7.03' },{'date'=>'2016-08-29T13:59:45','version'=>'7.04' },{'date'=>'2016-08-29T16:44:18','version'=>'7.05' },{'date'=>'2016-09-17T21:05:37','version'=>'7.06' },{'date'=>'2016-09-20T12:30:54','version'=>'7.07' },{'date'=>'2016-09-23T17:19:00','version'=>'7.08' },{'date'=>'2016-10-23T09:46:35','version'=>'7.09' },{'date'=>'2016-11-01T19:02:03','version'=>'7.10' },{'date'=>'2016-11-30T09:23:48','version'=>'7.11' },{'date'=>'2016-12-20T08:41:05','version'=>'7.12' },{'date'=>'2016-12-29T19:40:25','version'=>'7.13' },{'date'=>'2017-01-04T22:58:20','version'=>'7.14' },{'date'=>'2017-01-10T11:42:59','version'=>'7.15' },{'date'=>'2017-01-10T23:52:50','version'=>'7.16' },{'date'=>'2017-01-11T08:35:01','version'=>'7.17' },{'date'=>'2017-01-11T22:05:10','version'=>'7.18' },{'date'=>'2017-01-15T16:05:23','version'=>'7.19' },{'date'=>'2017-01-18T09:38:55','version'=>'7.20' },{'date'=>'2017-01-22T14:29:35','version'=>'7.21' },{'date'=>'2017-01-25T23:09:32','version'=>'7.22' },{'date'=>'2017-01-29T21:43:19','version'=>'7.23' },{'date'=>'2017-02-05T21:09:47','version'=>'7.24' },{'date'=>'2017-02-09T22:51:35','version'=>'7.25' },{'date'=>'2017-02-15T23:08:52','version'=>'7.26' },{'date'=>'2017-02-27T17:02:21','version'=>'7.27' },{'date'=>'2017-03-07T21:36:36','version'=>'7.28' },{'date'=>'2017-03-14T23:27:54','version'=>'7.29' },{'date'=>'2017-04-06T12:04:02','version'=>'7.30' },{'date'=>'2017-04-24T07:50:54','version'=>'7.31' },{'date'=>'2017-05-30T17:08:40','version'=>'7.32' },{'date'=>'2017-06-05T22:14:35','version'=>'7.33' },{'date'=>'2017-07-02T22:04:01','version'=>'7.34' },{'date'=>'2017-07-05T07:50:23','version'=>'7.35' },{'date'=>'2017-07-10T07:48:45','version'=>'7.36' },{'date'=>'2017-07-24T07:55:46','version'=>'7.37' },{'date'=>'2017-08-01T21:56:47','version'=>'7.38' },{'date'=>'2017-08-03T08:50:10','version'=>'7.39' },{'date'=>'2017-08-14T08:32:54','version'=>'7.40' },{'date'=>'2017-08-16T08:19:30','version'=>'7.41' },{'date'=>'2017-08-17T11:15:42','version'=>'7.42' },{'date'=>'2017-08-18T08:26:45','version'=>'7.43' },{'date'=>'2017-09-03T16:04:13','version'=>'7.44' },{'date'=>'2017-09-07T08:41:40','version'=>'7.45' },{'date'=>'2017-09-12T12:27:00','version'=>'7.46' },{'date'=>'2017-10-12T08:26:53','version'=>'7.47' },{'date'=>'2017-10-21T13:33:01','version'=>'7.48' },{'date'=>'2017-10-30T13:18:49','version'=>'7.49' },{'date'=>'2017-10-30T18:18:13','version'=>'7.50' },{'date'=>'2017-10-31T19:14:43','version'=>'7.51' },{'date'=>'2017-11-02T22:29:23','version'=>'7.52' },{'date'=>'2017-11-04T15:24:07','version'=>'7.53' },{'date'=>'2017-11-04T22:50:30','version'=>'7.54' },{'date'=>'2017-11-07T10:58:56','version'=>'7.55' },{'date'=>'2017-11-16T13:33:27','version'=>'7.56' },{'date'=>'2017-11-18T16:10:38','version'=>'7.57' },{'date'=>'2017-12-03T22:14:41','version'=>'7.58' },{'date'=>'2017-12-17T17:58:55','version'=>'7.59' },{'date'=>'2018-01-03T14:00:44','version'=>'7.60' },{'date'=>'2018-01-15T15:35:28','version'=>'7.61' },{'date'=>'2018-02-03T19:53:39','version'=>'7.62' },{'date'=>'2018-02-06T20:52:51','version'=>'7.63' },{'date'=>'2018-02-07T10:17:57','version'=>'7.64' },{'date'=>'2018-02-11T21:55:33','version'=>'7.65' },{'date'=>'2018-02-14T08:55:35','version'=>'7.66' },{'date'=>'2018-02-19T23:11:52','version'=>'7.67' },{'date'=>'2018-02-23T18:44:15','version'=>'7.68' },{'date'=>'2018-02-24T21:58:41','version'=>'7.69' },{'date'=>'2018-02-28T23:47:08','version'=>'7.70' },{'date'=>'2018-03-16T16:41:58','version'=>'7.71' },{'date'=>'2018-04-02T21:01:43','version'=>'7.72' },{'date'=>'2018-04-06T14:10:03','version'=>'7.73' },{'date'=>'2018-04-07T22:15:16','version'=>'7.74' },{'date'=>'2018-04-10T16:04:41','version'=>'7.75' },{'date'=>'2018-04-24T16:55:32','version'=>'7.76' },{'date'=>'2018-05-01T17:18:20','version'=>'7.77' },{'date'=>'2018-05-11T16:36:16','version'=>'7.78' },{'date'=>'2018-05-14T22:13:04','version'=>'7.79' },{'date'=>'2018-05-20T22:46:20','version'=>'7.80' },{'date'=>'2018-05-21T22:39:30','version'=>'7.81' },{'date'=>'2018-05-27T21:59:59','version'=>'7.82' },{'date'=>'2018-06-03T21:10:42','version'=>'7.83' },{'date'=>'2018-06-06T14:04:49','version'=>'7.84' },{'date'=>'2018-06-19T15:57:43','version'=>'7.85' },{'date'=>'2018-07-03T11:30:46','version'=>'7.86' },{'date'=>'2018-07-04T10:20:11','version'=>'7.87' },{'date'=>'2018-07-13T11:00:52','version'=>'7.88' },{'date'=>'2018-08-07T09:38:35','version'=>'7.89' },{'date'=>'2018-08-08T22:19:36','version'=>'7.90' },{'date'=>'2018-08-09T08:39:58','version'=>'7.91' },{'date'=>'2018-08-09T16:52:45','version'=>'7.92' },{'date'=>'2018-08-12T14:23:08','version'=>'7.93' },{'date'=>'2018-08-31T12:53:17','version'=>'7.94' },{'date'=>'2018-09-14T22:17:06','version'=>'8.0' },{'date'=>'2018-09-25T16:14:07','version'=>'8.01' },{'date'=>'2018-10-01T21:34:50','version'=>'8.02' },{'date'=>'2018-10-16T22:41:46','version'=>'8.03' },{'date'=>'2018-10-21T20:23:27','version'=>'8.04' },{'date'=>'2018-11-01T17:15:20','version'=>'8.05' },{'date'=>'2018-11-08T23:31:57','version'=>'8.06' },{'date'=>'2018-11-18T22:09:07','version'=>'8.07' },{'date'=>'2018-12-01T18:26:15','version'=>'8.08' },{'date'=>'2018-12-04T20:59:01','version'=>'8.09' },{'date'=>'2018-12-20T10:28:28','version'=>'8.10' },{'date'=>'2019-01-02T18:04:35','version'=>'8.11' },{'date'=>'2019-02-01T16:34:38','version'=>'8.12' }]},'Mojolicious-Plugin-OAuth2'=>{'advisories'=>[{'affected_versions'=>'<1.3','description'=>'Param injection in case of several parameters of the same name are present.
  ','distribution'=>'Mojolicious-Plugin-OAuth2','fixed_versions'=>'>=1.3','id'=>'CPANSA-Mojolicious-Plugin-OAuth2-2014-01','references'=>['https://metacpan.org/changes/distribution/Mojolicious-Plugin-OAuth2','https://github.com/marcusramberg/Mojolicious-Plugin-OAuth2/commit/68315d329059b427e13d486c0e10733f728709aa' ],'reported'=>'2014-10-07' }],'main_module'=>'Mojolicious::Plugin::OAuth2','versions'=>[{'date'=>'2011-01-08T11:03:42','version'=>'0.01' },{'date'=>'2011-01-09T18:00:14','version'=>'0.02' },{'date'=>'2011-04-03T16:00:38','version'=>'0.1' },{'date'=>'2011-08-01T16:56:18','version'=>'0.2' },{'date'=>'2011-09-04T19:42:29','version'=>'0.3' },{'date'=>'2011-09-07T16:59:50','version'=>'0.4' },{'date'=>'2011-10-19T11:55:32','version'=>'0.5' },{'date'=>'2012-03-09T21:15:39','version'=>'0.6' },{'date'=>'2012-05-30T11:49:29','version'=>'0.7' },{'date'=>'2012-08-23T20:18:41','version'=>'0.8' },{'date'=>'2013-05-20T05:55:18','version'=>'0.9' },{'date'=>'2013-11-06T13:24:52','version'=>'1.0' },{'date'=>'2014-03-13T08:18:10','version'=>'1.1' },{'date'=>'2014-09-06T13:49:59','version'=>'1.2' },{'date'=>'2014-10-07T05:49:16','version'=>'1.3' },{'date'=>'2015-03-01T20:09:19','version'=>'1.4' },{'date'=>'2015-03-02T07:32:59','version'=>'1.5' },{'date'=>'2015-03-18T16:40:18','version'=>'1.51' },{'date'=>'2015-04-06T20:46:39','version'=>'1.52' },{'date'=>'2015-09-08T07:27:41','version'=>'1.53' },{'date'=>'2018-08-30T10:48:55','version'=>'1.54' },{'date'=>'2018-09-08T18:30:54','version'=>'1.55' },{'date'=>'2018-09-23T22:04:16','version'=>'1.56' },{'date'=>'2018-09-24T08:55:14','version'=>'1.57' }]},'Net-DNS'=>{'advisories'=>[{'affected_versions'=>'<0.63','cves'=>['CVE-2007-6341' ],'description'=>'Allows remote attackers to cause a denial of service (program "croak") via a crafted DNS response.
  ','distribution'=>'Net-DNS','fixed_versions'=>'>=0.63','id'=>'CPANSA-Net-DNS-2008-01','references'=>['https://metacpan.org/changes/distribution/Net-DNS' ],'reported'=>'2008-02-08' }],'main_module'=>'Net::DNS','versions'=>[{'date'=>'1997-02-04T10:03:21','version'=>'0.02' },{'date'=>'1997-02-05T05:54:07','version'=>'0.02' },{'date'=>'1997-02-10T16:24:12','version'=>'0.03' },{'date'=>'1997-02-13T23:50:40','version'=>'0.04' },{'date'=>'1997-03-28T06:22:18','version'=>'0.05' },{'date'=>'1997-04-03T06:54:12','version'=>'0.06' },{'date'=>'1997-04-19T18:07:46','version'=>'0.07' },{'date'=>'1997-05-13T15:27:34','version'=>'0.08' },{'date'=>'1997-05-29T22:16:14','version'=>'0.09' },{'date'=>'1997-06-13T04:35:29','version'=>'0.10' },{'date'=>'1997-07-06T18:10:05','version'=>'0.11' },{'date'=>'1997-10-02T05:53:19','version'=>'0.12' },{'date'=>'2002-02-01T21:32:42','version'=>'0.14' },{'date'=>'2002-04-11T23:04:19','version'=>'0.19' },{'date'=>'2002-05-15T00:39:48','version'=>'0.20' },{'date'=>'2002-06-03T21:44:48','version'=>'0.21' },{'date'=>'2002-06-06T21:48:08','version'=>'0.22' },{'date'=>'2002-06-11T22:49:07','version'=>'0.23' },{'date'=>'2002-07-06T20:17:50','version'=>'0.24' },{'date'=>'2002-08-01T10:37:46','version'=>'0.25' },{'date'=>'2002-08-05T20:11:20','version'=>'0.26' },{'date'=>'2002-08-15T15:55:56','version'=>'0.27' },{'date'=>'2002-08-21T00:18:55','version'=>'0.28' },{'date'=>'2002-10-02T06:09:09','version'=>'0.29' },{'date'=>'2002-11-07T13:19:03','version'=>'0.30' },{'date'=>'2002-11-18T04:32:09','version'=>'0.31' },{'date'=>'2003-01-05T21:37:55','version'=>'0.32' },{'date'=>'2003-01-08T18:31:53','version'=>'0.33' },{'date'=>'2003-03-06T19:19:53','version'=>'0.34' },{'date'=>'2003-05-22T02:33:15','version'=>'0.34_02' },{'date'=>'2003-05-23T01:24:00','version'=>'0.34_03' },{'date'=>'2003-05-26T07:13:38','version'=>'0.35' },{'date'=>'2003-05-28T22:24:43','version'=>'0.36' },{'date'=>'2003-05-28T22:41:56','version'=>'0.37' },{'date'=>'2003-06-05T23:55:14','version'=>'0.38' },{'date'=>'2003-06-23T00:19:28','version'=>'0.38_01' },{'date'=>'2003-07-29T09:34:12','version'=>'0.38_02' },{'date'=>'2003-08-07T22:35:45','version'=>'0.39' },{'date'=>'2003-08-12T04:10:01','version'=>'0.39_01' },{'date'=>'2003-08-28T15:17:51','version'=>'0.39_02' },{'date'=>'2003-09-01T22:18:39','version'=>'0.40' },{'date'=>'2003-09-26T22:54:49','version'=>'0.40_01' },{'date'=>'2003-10-03T15:57:27','version'=>'0.41' },{'date'=>'2003-10-26T05:42:29','version'=>'0.42' },{'date'=>'2003-12-01T04:39:24','version'=>'0.42_01' },{'date'=>'2003-12-11T08:53:09','version'=>'0.42_02' },{'date'=>'2003-12-12T00:28:17','version'=>'0.43' },{'date'=>'2003-12-13T01:55:07','version'=>'0.44' },{'date'=>'2004-01-03T06:49:06','version'=>'0.44_01' },{'date'=>'2004-01-04T04:51:25','version'=>'0.44_02' },{'date'=>'2004-01-08T05:56:11','version'=>'0.45' },{'date'=>'2004-02-10T00:53:47','version'=>'0.45_01' },{'date'=>'2004-02-21T12:53:34','version'=>'0.46' },{'date'=>'2004-04-01T07:39:00','version'=>'0.47' },{'date'=>'2004-05-06T19:18:31','version'=>'0.47_01' },{'date'=>'2004-08-13T01:11:57','version'=>'0.48' },{'date'=>'2005-03-07T14:31:55','version'=>'0.48_01' },{'date'=>'2005-03-14T20:47:20','version'=>'0.48_02' },{'date'=>'2005-03-22T15:54:51','version'=>'0.48_03' },{'date'=>'2005-03-29T13:12:16','version'=>'0.49' },{'date'=>'2005-05-24T08:07:55','version'=>'0.49_01' },{'date'=>'2005-05-28T07:07:52','version'=>'0.49_02' },{'date'=>'2005-06-01T20:51:43','version'=>'0.49_03' },{'date'=>'2005-06-08T14:15:32','version'=>'0.50' },{'date'=>'2005-06-10T11:00:29','version'=>'0.51' },{'date'=>'2005-06-14T11:42:54','version'=>'0.49_01' },{'date'=>'2005-06-22T14:32:45','version'=>'0.49_01' },{'date'=>'2005-07-01T21:50:47','version'=>'0.52' },{'date'=>'2005-07-22T12:23:21','version'=>'0.53' },{'date'=>'2005-07-31T14:40:15','version'=>'0.53_01' },{'date'=>'2005-10-18T14:39:03','version'=>'0.53_02' },{'date'=>'2005-12-07T13:15:30','version'=>'0.54' },{'date'=>'2005-12-14T10:29:42','version'=>'0.55' },{'date'=>'2006-02-20T15:34:25','version'=>'0.56' },{'date'=>'2006-02-24T16:21:14','version'=>'0.57' },{'date'=>'2006-07-04T11:42:41','version'=>'0.58' },{'date'=>'2006-09-18T19:31:10','version'=>'0.59' },{'date'=>'2007-06-22T07:31:18','version'=>'0.60' },{'date'=>'2007-08-01T12:26:55','version'=>'0.61' },{'date'=>'2007-12-28T19:32:25','version'=>'0.62' },{'date'=>'2008-02-08T15:49:50','version'=>'0.63' },{'date'=>'2008-12-30T18:11:35','version'=>'0.64' },{'date'=>'2009-01-26T18:19:23','version'=>'0.65' },{'date'=>'2009-12-30T13:58:25','version'=>'0.66' },{'date'=>'2011-10-25T12:14:24','version'=>'0.66_01' },{'date'=>'2011-10-27T14:23:38','version'=>'0.66_02' },{'date'=>'2011-10-28T14:31:06','version'=>'0.66_03' },{'date'=>'2011-10-28T15:00:15','version'=>'0.66_04' },{'date'=>'2011-10-31T14:36:02','version'=>'0.66_06' },{'date'=>'2011-10-31T19:34:01','version'=>'0.66_07' },{'date'=>'2011-11-02T21:52:59','version'=>'0.66_08' },{'date'=>'2011-11-07T09:07:56','version'=>'0.67' },{'date'=>'2012-01-23T13:41:03','version'=>'0.67_01' },{'date'=>'2012-01-26T10:44:13','version'=>'0.67_03' },{'date'=>'2012-01-27T08:47:28','version'=>'0.67_04' },{'date'=>'2012-01-31T21:54:27','version'=>'0.68' },{'date'=>'2012-01-31T22:11:31','version'=>'0.68' },{'date'=>'2012-10-29T15:35:55','version'=>'0.68_01' },{'date'=>'2012-10-31T10:25:57','version'=>'0.68_02' },{'date'=>'2012-10-31T20:33:53','version'=>'0.68_03' },{'date'=>'2012-11-12T07:15:13','version'=>'0.68_04' },{'date'=>'2012-11-12T10:22:31','version'=>'0.68_05' },{'date'=>'2012-11-19T12:57:25','version'=>'0.68_06' },{'date'=>'2012-11-21T23:12:34','version'=>'0.68_07' },{'date'=>'2012-11-23T22:12:01','version'=>'0.68_08' },{'date'=>'2012-12-04T07:18:08','version'=>'0.68_09' },{'date'=>'2012-12-05T12:07:43','version'=>'0.69' },{'date'=>'2012-12-05T14:05:12','version'=>'0.69_1' },{'date'=>'2012-12-06T11:10:17','version'=>'0.70' },{'date'=>'2012-12-12T16:04:03','version'=>'0.70_1' },{'date'=>'2012-12-15T11:18:56','version'=>'0.71' },{'date'=>'2012-12-24T21:14:23','version'=>'0.71_01' },{'date'=>'2012-12-28T15:03:57','version'=>'0.72' },{'date'=>'2013-11-13T15:18:55','version'=>'0.72_01' },{'date'=>'2013-11-14T16:13:33','version'=>'0.72_02' },{'date'=>'2013-11-18T10:49:23','version'=>'0.72_03' },{'date'=>'2013-11-19T21:52:50','version'=>'0.72_04' },{'date'=>'2013-11-29T13:35:08','version'=>'0.73' },{'date'=>'2013-12-24T15:21:50','version'=>'0.73_1' },{'date'=>'2014-01-02T20:32:27','version'=>'0.73_2' },{'date'=>'2014-01-05T20:31:16','version'=>'0.73_3' },{'date'=>'2014-01-12T10:25:24','version'=>'0.73_4' },{'date'=>'2014-01-13T15:59:49','version'=>'0.73_5' },{'date'=>'2014-01-16T10:23:47','version'=>'0.74' },{'date'=>'2014-03-03T21:33:39','version'=>'0.74_1' },{'date'=>'2014-03-10T08:36:19','version'=>'0.74_2' },{'date'=>'2014-04-03T21:00:45','version'=>'0.74_3' },{'date'=>'2014-04-30T14:05:59','version'=>'0.74_4' },{'date'=>'2014-05-05T06:05:46','version'=>'0.74_5' },{'date'=>'2014-05-06T09:22:01','version'=>'0.74_6' },{'date'=>'2014-05-08T09:54:21','version'=>'0.75' },{'date'=>'2014-05-22T20:56:00','version'=>'0.75_1' },{'date'=>'2014-05-23T22:26:56','version'=>'0.76' },{'date'=>'2014-05-29T11:26:07','version'=>'0.76_1' },{'date'=>'2014-06-05T16:04:39','version'=>'0.76_2' },{'date'=>'2014-06-13T08:31:32','version'=>'0.76_3' },{'date'=>'2014-06-13T21:57:13','version'=>'0.77' },{'date'=>'2014-07-02T09:53:03','version'=>'0.77_1' },{'date'=>'2014-07-09T07:09:44','version'=>'0.77_2' },{'date'=>'2014-07-10T14:13:33','version'=>'0.78' },{'date'=>'2014-07-30T21:41:25','version'=>'0.78_1' },{'date'=>'2014-08-12T22:13:54','version'=>'0.78_2' },{'date'=>'2014-08-15T14:40:22','version'=>'0.78_3' },{'date'=>'2014-08-19T13:24:46','version'=>'0.78_5' },{'date'=>'2014-08-22T22:29:13','version'=>'0.79' },{'date'=>'2014-09-11T11:42:35','version'=>'0.79_1' },{'date'=>'2014-09-15T14:51:32','version'=>'0.79_2' },{'date'=>'2014-09-22T11:51:22','version'=>'0.80' },{'date'=>'2014-10-20T08:19:15','version'=>'0.80_1' },{'date'=>'2014-10-24T08:21:15','version'=>'0.80_2' },{'date'=>'2014-10-29T13:44:16','version'=>'0.81' },{'date'=>'2015-01-05T10:22:06','version'=>'0.81_01' },{'date'=>'2015-01-20T14:12:38','version'=>'0.82' },{'date'=>'2015-02-11T14:26:36','version'=>'0.82_01' },{'date'=>'2015-02-18T11:05:47','version'=>'0.82_02' },{'date'=>'2015-02-26T15:48:06','version'=>'0.83' },{'date'=>'2015-05-27T10:04:50','version'=>'1.00_01' },{'date'=>'2015-06-11T17:23:10','version'=>'1.00_02' },{'date'=>'2015-06-15T10:02:08','version'=>'1.00_03' },{'date'=>'2015-06-23T13:57:29','version'=>'1.00_04' },{'date'=>'2015-06-26T09:37:11','version'=>'1.00_05' },{'date'=>'2015-06-29T17:15:06','version'=>'1.00_06' },{'date'=>'2015-07-01T13:51:22','version'=>'1.00_07' },{'date'=>'2015-07-02T08:17:44','version'=>'1.00_08' },{'date'=>'2015-07-06T17:28:32','version'=>'1.01' },{'date'=>'2015-08-26T20:44:25','version'=>'1.01_01' },{'date'=>'2015-09-03T06:21:58','version'=>'1.01_02' },{'date'=>'2015-09-04T20:39:37','version'=>'1.01_03' },{'date'=>'2015-09-08T08:26:06','version'=>'1.01_04' },{'date'=>'2015-09-11T11:49:24','version'=>'1.01_05' },{'date'=>'2015-09-15T18:51:53','version'=>'1.01_06' },{'date'=>'2015-09-16T10:25:09','version'=>'1.02' },{'date'=>'2015-09-22T13:39:43','version'=>'1.02_01' },{'date'=>'2015-10-05T08:30:03','version'=>'1.02_02' },{'date'=>'2015-10-06T20:39:36','version'=>'1.02_03' },{'date'=>'2015-10-08T21:24:29','version'=>'1.02_04' },{'date'=>'2015-10-13T07:30:39','version'=>'1.02_05' },{'date'=>'2015-10-14T12:44:57','version'=>'1.02_06' },{'date'=>'2015-10-20T09:59:26','version'=>'1.02_07' },{'date'=>'2015-10-23T08:32:04','version'=>'1.02_08' },{'date'=>'2015-10-27T16:07:21','version'=>'1.02_09' },{'date'=>'2015-11-02T06:00:09','version'=>'1.02_10' },{'date'=>'2015-11-08T13:49:33','version'=>'1.03' },{'date'=>'2015-12-01T21:21:55','version'=>'1.03_01' },{'date'=>'2015-12-02T14:27:42','version'=>'1.03_02' },{'date'=>'2015-12-02T20:49:07','version'=>'1.03_03' },{'date'=>'2015-12-08T20:41:10','version'=>'1.04' },{'date'=>'2016-02-01T16:26:27','version'=>'1.04_01' },{'date'=>'2016-02-02T08:03:42','version'=>'1.04_02' },{'date'=>'2016-02-05T12:19:57','version'=>'1.04_03' },{'date'=>'2016-02-29T12:32:53','version'=>'1.04_04' },{'date'=>'2016-03-07T21:11:01','version'=>'1.05' },{'date'=>'2016-03-21T13:15:38','version'=>'1.05_01' },{'date'=>'2016-03-24T18:45:15','version'=>'1.05_02' },{'date'=>'2016-04-04T21:53:54','version'=>'1.05_03' },{'date'=>'2016-04-15T10:11:03','version'=>'1.05_04' },{'date'=>'2016-04-17T12:05:46','version'=>'1.05_05' },{'date'=>'2016-05-11T08:58:51','version'=>'1.05_06' },{'date'=>'2016-05-22T07:54:41','version'=>'1.05_07' },{'date'=>'2016-05-27T19:12:44','version'=>'1.06' },{'date'=>'2016-06-22T08:54:06','version'=>'1.06_01' },{'date'=>'2016-08-24T11:36:13','version'=>'1.06_02' },{'date'=>'2016-08-25T15:01:31','version'=>'1.06_03' },{'date'=>'2016-09-17T08:19:30','version'=>'1.06_04' },{'date'=>'2016-11-12T03:24:33','version'=>'1.06_05' },{'date'=>'2016-12-23T14:48:42','version'=>'1.06_06' },{'date'=>'2016-12-29T17:16:20','version'=>'1.07' },{'date'=>'2017-01-18T21:51:05','version'=>'1.07_01' },{'date'=>'2017-01-27T10:44:03','version'=>'1.07_02' },{'date'=>'2017-02-09T10:28:55','version'=>'1.07_03' },{'date'=>'2017-02-13T10:08:41','version'=>'1.07_04' },{'date'=>'2017-02-20T11:12:45','version'=>'1.08' },{'date'=>'2017-03-06T09:33:06','version'=>'1.08_02' },{'date'=>'2017-03-13T10:02:22','version'=>'1.08_03' },{'date'=>'2017-03-22T09:48:52','version'=>'1.08_04' },{'date'=>'2017-03-24T07:00:36','version'=>'1.09' },{'date'=>'2017-04-19T13:10:57','version'=>'1.09_01' },{'date'=>'2017-05-05T22:21:10','version'=>'1.10' },{'date'=>'2017-05-31T09:07:40','version'=>'1.10_01' },{'date'=>'2017-06-03T20:26:47','version'=>'1.10_02' },{'date'=>'2017-06-12T12:03:07','version'=>'1.10_03' },{'date'=>'2017-06-26T12:52:57','version'=>'1.11' },{'date'=>'2017-07-07T21:50:10','version'=>'1.11_01' },{'date'=>'2017-07-28T16:17:01','version'=>'1.11_02' },{'date'=>'2017-08-15T10:33:15','version'=>'1.11_03' },{'date'=>'2017-08-17T12:48:08','version'=>'1.11_04' },{'date'=>'2017-08-18T13:15:31','version'=>'1.12' },{'date'=>'2017-09-12T09:28:26','version'=>'1.12_01' },{'date'=>'2017-10-06T09:07:45','version'=>'1.12_02' },{'date'=>'2017-10-10T14:42:38','version'=>'1.12_03' },{'date'=>'2017-10-18T09:49:20','version'=>'1.13' },{'date'=>'2017-11-30T11:11:55','version'=>'1.13_01' },{'date'=>'2017-12-07T10:17:12','version'=>'1.13_02' },{'date'=>'2017-12-15T12:34:59','version'=>'1.14' },{'date'=>'2018-01-31T10:11:39','version'=>'1.14_01' },{'date'=>'2018-02-01T14:14:07','version'=>'1.14_02' },{'date'=>'2018-02-09T11:42:14','version'=>'1.15' },{'date'=>'2018-06-11T09:20:56','version'=>'1.15_01' },{'date'=>'2018-06-14T10:46:39','version'=>'1.15_02' },{'date'=>'2018-07-03T09:05:15','version'=>'1.15_03' },{'date'=>'2018-07-06T10:03:02','version'=>'1.15_04' },{'date'=>'2018-07-16T04:56:07','version'=>'1.16' },{'date'=>'2018-07-20T16:22:38','version'=>'1.16_01' },{'date'=>'2018-07-24T15:35:14','version'=>'1.16_02' },{'date'=>'2018-07-25T07:10:24','version'=>'1.17' },{'date'=>'2018-09-11T10:24:34','version'=>'1.17_01' },{'date'=>'2018-09-11T15:32:52','version'=>'1.17_02' },{'date'=>'2018-09-12T06:15:44','version'=>'1.17_03' },{'date'=>'2018-09-21T14:49:48','version'=>'1.18' },{'date'=>'2018-11-08T06:39:55','version'=>'1.18_01' },{'date'=>'2018-11-15T06:02:14','version'=>'1.19' },{'date'=>'2018-12-31T12:23:28','version'=>'1.19_01' },{'date'=>'2019-01-28T09:48:25','version'=>'1.19_02' }]},'Net-OpenID-Consumer'=>{'advisories'=>[{'affected_versions'=>'<1.12','description'=>'A potential timing attack when checking signatures.
  ','distribution'=>'Net-OpenID-Consumer','fixed_versions'=>'>=1.12','id'=>'CPANSA-Net-OpenID-Consumer-2010-01','references'=>['https://metacpan.org/changes/distribution/Net-OpenID-Consumer','https://github.com/wrog/Net-OpenID-Consumer/commit/4e82c7e4b6ad4bc40571c5cfcaa58f9365b147a5','http://lists.openid.net/pipermail/openid-security/2010-July/001156.html' ],'reported'=>'2010-11-06' },{'affected_versions'=>'<0.06','description'=>'Incorrect comparison of system openssl status when doing DSA checks.
  ','distribution'=>'Net-OpenID-Consumer','fixed_versions'=>'>=0.06','id'=>'CPANSA-Net-OpenID-Consumer-2015-05','references'=>['https://metacpan.org/changes/distribution/Net-OpenID-Consumer' ],'reported'=>'2015-05-26' }],'main_module'=>'Net::OpenID::Consumer','versions'=>[{'date'=>'2005-05-23T03:02:59','version'=>'0.02' },{'date'=>'2005-05-23T08:05:35','version'=>'0.03' },{'date'=>'2005-05-25T05:08:25','version'=>'0.04' },{'date'=>'2005-05-25T06:14:44','version'=>'0.05' },{'date'=>'2005-05-26T06:18:39','version'=>'0.06' },{'date'=>'2005-05-26T06:56:30','version'=>'0.07' },{'date'=>'2005-05-26T07:18:01','version'=>'0.08' },{'date'=>'2005-06-23T23:50:47','version'=>'0.09' },{'date'=>'2005-06-27T04:43:01','version'=>'0.10' },{'date'=>'2005-06-27T21:59:47','version'=>'0.11' },{'date'=>'2005-07-13T17:57:27','version'=>'0.12' },{'date'=>'2007-04-16T17:58:45','version'=>'0.13' },{'date'=>'2007-08-03T22:07:20','version'=>'0.14' },{'date'=>'2008-10-13T02:30:05','version'=>'1.01' },{'date'=>'2008-10-14T04:39:07','version'=>'1.02' },{'date'=>'2008-11-30T02:02:17','version'=>'1.03' },{'date'=>'2010-02-18T15:32:06','version'=>'1.04' },{'date'=>'2010-02-18T16:01:19','version'=>'1.05' },{'date'=>'2010-03-16T17:38:56','version'=>'1.06' },{'date'=>'2010-11-06T02:24:29','version'=>'1.030099_001' },{'date'=>'2010-11-07T11:21:33','version'=>'1.030099_002' },{'date'=>'2010-11-08T22:35:52','version'=>'1.030099_003' },{'date'=>'2010-12-17T21:57:03','version'=>'1.030099_004' },{'date'=>'2011-01-01T01:55:09','version'=>'1.030099_005' },{'date'=>'2011-10-23T01:35:49','version'=>'1.030099_006' },{'date'=>'2011-10-25T23:10:00','version'=>'1.100099_001' },{'date'=>'2011-11-02T10:38:05','version'=>'1.100099_002' },{'date'=>'2011-11-04T23:01:32','version'=>'1.11' },{'date'=>'2011-11-07T17:16:08','version'=>'1.12' },{'date'=>'2011-11-15T03:28:36','version'=>'1.13' },{'date'=>'2013-04-01T13:17:57','version'=>'1.14' },{'date'=>'2013-09-06T23:47:04','version'=>'1.15' },{'date'=>'2014-09-15T21:38:12','version'=>'1.16' },{'date'=>'2016-01-15T11:45:55','version'=>'1.17' },{'date'=>'2016-02-08T01:40:13','version'=>'1.18' }]},'Otogiri'=>{'advisories'=>[{'affected_versions'=>'<0.13','description'=>'A depenpendant module SQL::Maker without strict mode is vulnerable to SQL injection.
  ','distribution'=>'Otogiri','fixed_versions'=>'>=0.13','id'=>'CPANSA-Otogiri-2014-01','references'=>['https://github.com/ytnobody/Otogiri/commit/fac1592b3d153a6871ff1aed8016a6888cff9095','https://metacpan.org/changes/distribution/Otogiri' ],'reported'=>'2014-07-03' }],'main_module'=>'Otogiri','versions'=>[{'date'=>'2013-10-30T06:45:51','version'=>'0.01' },{'date'=>'2013-11-08T08:36:50','version'=>'0.02' },{'date'=>'2013-11-09T05:00:47','version'=>'0.03' },{'date'=>'2013-12-27T00:15:23','version'=>'0.04' },{'date'=>'2013-12-28T15:54:15','version'=>'0.05' },{'date'=>'2014-01-14T09:13:18','version'=>'0.06' },{'date'=>'2014-02-25T06:25:50','version'=>'0.07' },{'date'=>'2014-03-18T04:14:12','version'=>'0.08' },{'date'=>'2014-03-18T05:07:37','version'=>'0.09' },{'date'=>'2014-05-13T12:58:21','version'=>'0.10' },{'date'=>'2014-05-30T10:11:18','version'=>'0.11' },{'date'=>'2014-06-05T08:30:13','version'=>'0.12' },{'date'=>'2014-07-03T12:40:28','version'=>'0.13' },{'date'=>'2014-12-18T08:37:33','version'=>'0.14' },{'date'=>'2015-01-11T04:56:15','version'=>'0.15' },{'date'=>'2015-11-13T07:18:18','version'=>'0.16' },{'date'=>'2016-02-02T05:58:26','version'=>'0.17' },{'date'=>'2017-05-19T01:37:05','version'=>'0.18' }]},'PAR'=>{'advisories'=>[{'affected_versions'=>'<1.003','cves'=>['CVE-2011-4114' ],'description'=>'PAR packed files are extracted to unsafe and predictable temporary directories (this bug was originally reported against PAR::Packer, but it applies to PAR as well).
  ','distribution'=>'PAR','fixed_versions'=>'>=1.003','id'=>'CPANSA-PAR-2011-01','references'=>['https://metacpan.org/changes/distribution/PAR','https://rt.cpan.org/Public/Bug/Display.html?id=69560' ],'reported'=>'2011-07-18' }],'main_module'=>'PAR','versions'=>[{'date'=>'2002-10-18T20:38:24','version'=>'0.01' },{'date'=>'2002-10-18T21:07:35','version'=>'0.02' },{'date'=>'2002-10-18T22:18:06','version'=>'0.03' },{'date'=>'2002-10-19T02:46:52','version'=>'0.04' },{'date'=>'2002-10-19T14:33:26','version'=>'0.05' },{'date'=>'2002-10-19T15:31:54','version'=>'0.06' },{'date'=>'2002-10-19T17:38:40','version'=>'0.10' },{'date'=>'2002-10-19T22:30:34','version'=>'0.11' },{'date'=>'2002-10-20T13:00:43','version'=>'0.12' },{'date'=>'2002-10-21T17:29:03','version'=>'0.13' },{'date'=>'2002-10-27T10:38:32','version'=>'0.14' },{'date'=>'2002-10-27T17:52:07','version'=>'0.15' },{'date'=>'2002-11-02T02:20:38','version'=>'0.20' },{'date'=>'2002-11-02T21:26:48','version'=>'0.21' },{'date'=>'2002-11-03T13:05:06','version'=>'0.22' },{'date'=>'2002-11-05T14:36:58','version'=>'0.30' },{'date'=>'2002-11-05T22:23:36','version'=>'0.40' },{'date'=>'2002-11-06T12:25:00','version'=>'0.41' },{'date'=>'2002-11-07T00:48:34','version'=>'0.42' },{'date'=>'2002-11-07T14:41:31','version'=>'0.43' },{'date'=>'2002-11-08T15:01:18','version'=>'0.44' },{'date'=>'2002-11-08T21:01:12','version'=>'0.45' },{'date'=>'2002-11-09T23:02:45','version'=>'0.46' },{'date'=>'2002-11-10T06:56:37','version'=>'0.47' },{'date'=>'2002-11-13T11:32:10','version'=>'0.48' },{'date'=>'2002-11-23T14:45:40','version'=>'0.49' },{'date'=>'2002-12-03T01:00:23','version'=>'0.50' },{'date'=>'2002-12-11T14:30:53','version'=>'0.51' },{'date'=>'2002-12-17T04:06:52','version'=>'0.60' },{'date'=>'2002-12-17T11:49:44','version'=>'0.61' },{'date'=>'2003-01-09T11:16:42','version'=>'0.62' },{'date'=>'2003-02-06T00:38:33','version'=>'0.63' },{'date'=>'2003-03-01T15:54:25','version'=>'0.64' },{'date'=>'2003-03-09T14:31:52','version'=>'0.65' },{'date'=>'2003-03-19T15:54:32','version'=>'0.66' },{'date'=>'2003-03-31T19:58:56','version'=>'0.66' },{'date'=>'2003-05-16T17:35:22','version'=>'0.67_89' },{'date'=>'2003-05-25T19:09:58','version'=>'0.68' },{'date'=>'2003-05-31T13:12:53','version'=>'0.69' },{'date'=>'2003-07-08T15:39:11','version'=>'0.69' },{'date'=>'2003-07-16T08:20:09','version'=>'0.69_91' },{'date'=>'2003-07-27T14:13:18','version'=>'0.69_93' },{'date'=>'2003-07-29T08:21:31','version'=>'0.70' },{'date'=>'2003-07-30T13:57:01','version'=>'0.71' },{'date'=>'2003-08-02T13:11:15','version'=>'0.72' },{'date'=>'2003-08-06T09:16:17','version'=>'0.73' },{'date'=>'2003-08-25T13:39:35','version'=>'0.74' },{'date'=>'2003-09-21T10:58:00','version'=>'0.75' },{'date'=>'2003-10-23T04:45:55','version'=>'0.75_99' },{'date'=>'2003-10-28T12:21:23','version'=>'0.76' },{'date'=>'2003-12-11T23:00:26','version'=>'0.76_98' },{'date'=>'2003-12-28T02:31:29','version'=>'0.76_99' },{'date'=>'2003-12-31T15:33:24','version'=>'0.77' },{'date'=>'2004-01-03T17:36:11','version'=>'0.77_98' },{'date'=>'2004-01-04T20:30:15','version'=>'0.77_99' },{'date'=>'2004-01-06T21:26:43','version'=>'0.78' },{'date'=>'2004-01-08T11:35:51','version'=>'0.79' },{'date'=>'2004-02-15T23:25:34','version'=>'0.79_97' },{'date'=>'2004-02-27T15:58:33','version'=>'0.79_98' },{'date'=>'2004-02-27T23:54:39','version'=>'0.79_98' },{'date'=>'2004-03-03T14:49:47','version'=>'0.79_99' },{'date'=>'2004-03-16T17:04:25','version'=>'0.80' },{'date'=>'2004-03-28T14:43:14','version'=>'0.80_99' },{'date'=>'2004-05-22T19:13:38','version'=>'0.81' },{'date'=>'2004-05-24T14:59:45','version'=>'0.82' },{'date'=>'2004-05-29T16:02:03','version'=>'0.83' },{'date'=>'2004-07-02T10:59:55','version'=>'0.85' },{'date'=>'2004-08-30T22:49:15','version'=>'0.85_01' },{'date'=>'2004-12-11T03:49:09','version'=>'0.86' },{'date'=>'2005-01-30T19:04:55','version'=>'0.87' },{'date'=>'2005-06-07T09:13:43','version'=>'0.88' },{'date'=>'2005-06-10T15:49:20','version'=>'0.89' },{'date'=>'2005-11-25T23:01:00','version'=>'0.90' },{'date'=>'2006-02-15T09:33:05','version'=>'0.91' },{'date'=>'2006-03-04T20:16:36','version'=>'0.91' },{'date'=>'2006-05-19T13:37:12','version'=>'0.93' },{'date'=>'2006-06-02T10:25:51','version'=>'0.93' },{'date'=>'2006-06-20T20:44:56','version'=>'0.93' },{'date'=>'2006-07-22T19:59:13','version'=>'0.942' },{'date'=>'2006-08-05T11:28:06','version'=>'0.950' },{'date'=>'2006-08-11T15:51:56','version'=>'0.950' },{'date'=>'2006-08-12T12:35:34','version'=>'0.950' },{'date'=>'2006-08-22T14:14:35','version'=>'0.952' },{'date'=>'2006-09-26T20:18:06','version'=>'0.954' },{'date'=>'2006-10-03T12:35:05','version'=>'0.955' },{'date'=>'2006-10-03T12:58:55','version'=>'0.956' },{'date'=>'2006-10-24T16:42:26','version'=>'0.957' },{'date'=>'2006-11-11T14:33:23','version'=>'0.958' },{'date'=>'2006-11-12T11:48:37','version'=>'0.959' },{'date'=>'2006-11-21T12:02:35','version'=>'0.960' },{'date'=>'2006-12-01T14:19:55','version'=>'0.969_01' },{'date'=>'2006-12-03T17:25:33','version'=>'0.970' },{'date'=>'2007-01-10T17:58:01','version'=>'0.970_01' },{'date'=>'2007-01-12T11:02:02','version'=>'0.971' },{'date'=>'2007-01-16T15:23:38','version'=>'0.972' },{'date'=>'2007-02-03T11:40:25','version'=>'0.973' },{'date'=>'2007-07-29T11:17:27','version'=>'0.976' },{'date'=>'2007-12-20T21:17:26','version'=>'0.977' },{'date'=>'2008-05-13T12:44:22','version'=>'0.979' },{'date'=>'2008-05-22T11:41:38','version'=>'0.980' },{'date'=>'2008-08-09T22:17:14','version'=>'0.980' },{'date'=>'2008-08-10T21:39:41','version'=>'0.980' },{'date'=>'2008-09-12T15:02:23','version'=>'0.983' },{'date'=>'2009-01-25T22:31:20','version'=>'0.984' },{'date'=>'2009-02-02T01:40:36','version'=>'0.985_01' },{'date'=>'2009-02-19T16:04:27','version'=>'0.986' },{'date'=>'2009-02-20T14:30:08','version'=>'0.987_01' },{'date'=>'2009-03-02T14:47:14','version'=>'0.988' },{'date'=>'2009-03-02T14:56:44','version'=>'0.989_01' },{'date'=>'2009-03-10T15:11:05','version'=>'0.991' },{'date'=>'2009-04-05T11:32:48','version'=>'0.992' },{'date'=>'2009-07-19T16:37:30','version'=>'0.993' },{'date'=>'2009-07-23T13:08:07','version'=>'0.994' },{'date'=>'2010-04-10T14:05:52','version'=>'1.000' },{'date'=>'2010-07-25T09:32:33','version'=>'1.001' },{'date'=>'2010-07-25T10:07:06','version'=>'1.002' },{'date'=>'2011-11-28T16:53:29','version'=>'1.003' },{'date'=>'2011-11-30T22:31:25','version'=>'1.004' },{'date'=>'2011-12-02T13:53:02','version'=>'1.005' },{'date'=>'2012-10-14T22:45:17','version'=>'1.006' },{'date'=>'2012-10-22T21:50:20','version'=>'1.007' },{'date'=>'2015-01-24T14:11:44','version'=>'1.008' },{'date'=>'2015-04-22T15:26:50','version'=>'1.009' },{'date'=>'2015-07-13T10:56:21','version'=>'1.010' },{'date'=>'2016-09-18T11:33:22','version'=>'1.011' },{'date'=>'2016-11-25T16:06:43','version'=>'1.012' },{'date'=>'2016-11-27T16:51:00','version'=>'1.013' },{'date'=>'2016-12-18T16:36:08','version'=>'1.014' },{'date'=>'2017-04-13T15:29:12','version'=>'1.015' }]},'PAR-Packer'=>{'advisories'=>[{'affected_versions'=>'<1.011','cves'=>['CVE-2011-4114' ],'description'=>'PAR packed files are extracted to unsafe and predictable temporary directories.
  ','distribution'=>'PAR-Packer','fixed_versions'=>'>=1.011','id'=>'CPANSA-PAR-Packer-2011-01','references'=>['https://metacpan.org/changes/distribution/PAR-Packer','https://rt.cpan.org/Public/Bug/Display.html?id=69560' ],'reported'=>'2011-07-18' }],'main_module'=>'PAR::Packer','versions'=>[{'date'=>'2006-12-01T14:20:06','version'=>'0.969_01' },{'date'=>'2006-12-03T17:36:32','version'=>'0.970' },{'date'=>'2007-02-03T12:27:07','version'=>'0.973' },{'date'=>'2007-05-07T18:21:52','version'=>'0.975' },{'date'=>'2007-07-29T11:50:15','version'=>'0.976' },{'date'=>'2007-12-20T21:39:30','version'=>'0.977' },{'date'=>'2008-02-29T18:37:56','version'=>'0.978' },{'date'=>'2008-05-13T15:45:56','version'=>'0.979' },{'date'=>'2008-05-14T10:27:09','version'=>'0.980' },{'date'=>'2008-07-29T15:44:11','version'=>'0.982' },{'date'=>'2009-03-10T15:55:06','version'=>'0.980' },{'date'=>'2009-03-21T11:20:02','version'=>'0.991' },{'date'=>'2009-07-19T16:47:51','version'=>'0.992_01' },{'date'=>'2009-07-23T13:18:32','version'=>'0.992_02' },{'date'=>'2009-07-24T18:30:24','version'=>'0.992_03' },{'date'=>'2009-09-11T07:38:47','version'=>'0.992_04' },{'date'=>'2009-11-13T09:01:15','version'=>'0.992_05' },{'date'=>'2009-11-20T13:59:38','version'=>'0.992_06' },{'date'=>'2009-11-22T13:08:12','version'=>'1.000' },{'date'=>'2009-11-24T11:16:58','version'=>'1.001' },{'date'=>'2009-12-17T20:55:25','version'=>'1.002' },{'date'=>'2010-04-10T17:57:57','version'=>'1.003' },{'date'=>'2010-04-20T12:10:24','version'=>'1.004' },{'date'=>'2010-06-05T15:54:54','version'=>'1.005' },{'date'=>'2010-06-26T11:23:34','version'=>'1.006' },{'date'=>'2010-09-09T16:42:00','version'=>'1.007' },{'date'=>'2010-11-21T17:11:43','version'=>'1.008' },{'date'=>'2011-03-26T13:36:55','version'=>'1.009' },{'date'=>'2011-07-13T14:10:05','version'=>'1.010' },{'date'=>'2011-12-01T21:08:37','version'=>'1.011' },{'date'=>'2011-12-02T17:53:42','version'=>'1.012' },{'date'=>'2012-02-22T09:58:04','version'=>'1.013' },{'date'=>'2012-12-21T15:55:13','version'=>'1.014' },{'date'=>'2013-10-09T12:06:04','version'=>'1.015' },{'date'=>'2013-11-30T19:03:48','version'=>'1.016' },{'date'=>'2013-12-03T23:53:51','version'=>'1.017' },{'date'=>'2014-05-18T16:52:34','version'=>'1.018' },{'date'=>'2014-07-07T14:25:15','version'=>'1.019' },{'date'=>'2014-08-24T13:27:57','version'=>'1.020' },{'date'=>'2014-09-14T13:49:37','version'=>'1.021' },{'date'=>'2014-09-19T10:07:30','version'=>'1.022' },{'date'=>'2014-11-02T14:32:42','version'=>'1.023' },{'date'=>'2014-11-07T09:04:07','version'=>'1.024' },{'date'=>'2015-01-24T16:52:17','version'=>'1.025' },{'date'=>'2015-07-19T13:14:40','version'=>'1.026' },{'date'=>'2015-11-18T16:58:33','version'=>'1.027' },{'date'=>'2015-11-19T09:05:09','version'=>'1.027' },{'date'=>'2016-01-12T16:24:46','version'=>'1.029' },{'date'=>'2016-02-02T14:54:21','version'=>'1.029_01' },{'date'=>'2016-02-11T14:08:57','version'=>'1.029_02' },{'date'=>'2016-02-25T08:41:55','version'=>'1.029_03' },{'date'=>'2016-02-29T08:36:46','version'=>'1.029_04' },{'date'=>'2016-03-29T08:29:59','version'=>'1.030' },{'date'=>'2016-04-10T17:15:52','version'=>'1.031' },{'date'=>'2016-04-29T17:01:57','version'=>'1.031_01' },{'date'=>'2016-05-07T09:59:28','version'=>'1.032' },{'date'=>'2016-05-19T09:50:49','version'=>'1.033' },{'date'=>'2016-07-17T12:38:31','version'=>'1.034' },{'date'=>'2016-07-23T12:04:14','version'=>'1.035' },{'date'=>'2016-12-04T17:13:20','version'=>'1.035_001' },{'date'=>'2016-12-19T19:35:16','version'=>'1.035_002' },{'date'=>'2016-12-30T11:06:25','version'=>'1.036' },{'date'=>'2017-03-22T19:29:19','version'=>'1.036_001' },{'date'=>'2017-05-14T11:54:43','version'=>'1.036_002' },{'date'=>'2017-05-28T11:33:53','version'=>'1.037' },{'date'=>'2017-09-27T19:40:44','version'=>'1.038' },{'date'=>'2017-09-28T05:13:05','version'=>'1.039' },{'date'=>'2017-10-10T17:00:14','version'=>'1.039_001' },{'date'=>'2017-10-13T12:05:52','version'=>'1.039_002' },{'date'=>'2017-10-16T20:46:49','version'=>'1.039_003' },{'date'=>'2017-10-17T17:07:49','version'=>'1.039_004' },{'date'=>'2017-10-21T16:09:18','version'=>'1.040' },{'date'=>'2017-11-08T17:07:11','version'=>'1.041' },{'date'=>'2018-04-02T21:46:01','version'=>'1.042' },{'date'=>'2018-04-03T11:26:08','version'=>'1.043' },{'date'=>'2018-06-06T22:03:32','version'=>'1.044' },{'date'=>'2018-06-12T19:04:22','version'=>'1.045' },{'date'=>'2018-08-17T22:20:28','version'=>'1.046' },{'date'=>'2018-08-19T09:17:57','version'=>'1.047' },{'date'=>'2019-03-04T09:42:35','version'=>'1.047_001' },{'date'=>'2019-03-04T15:33:14','version'=>'1.047_002' },{'date'=>'2019-03-06T17:39:18','version'=>'1.047_003' }]},'PathTools'=>{'advisories'=>[{'affected_versions'=>'<3.65','cves'=>['CVE-2016-1238' ],'description'=>'Does not properly remove . (period) characters from the end of the includes directory array, which might allow local users to gain privileges via a Trojan horse module under the current working directory.
  ','distribution'=>'PathTools','fixed_versions'=>'>=3.65','id'=>'CPANSA-PathTools-2016-02','references'=>['https://metacpan.org/changes/distribution/PathTools' ],'reported'=>'2016-02-08' },{'affected_versions'=>'<3.62','cves'=>['CVE-2015-8607' ],'description'=>'Does not properly preserve the taint attribute of data, which might allow context-dependent attackers to bypass the taint protection mechanism via a crafted string.
  ','distribution'=>'PathTools','fixed_versions'=>'>=3.62','id'=>'CPANSA-PathTools-2016-01','references'=>['https://metacpan.org/changes/distribution/PathTools' ],'reported'=>'2016-01-11' }],'main_module'=>'Cwd','versions'=>[{'date'=>'2004-09-03T03:40:00','version'=>'3.00' },{'date'=>'2004-09-07T03:39:26','version'=>'3.01' },{'date'=>'2004-11-19T04:26:35','version'=>'3.01_01' },{'date'=>'2004-11-29T04:20:10','version'=>'3.01_02' },{'date'=>'2004-11-30T02:34:46','version'=>'3.01_03' },{'date'=>'2005-01-10T01:33:05','version'=>'3.02' },{'date'=>'2005-01-22T03:59:59','version'=>'3.03' },{'date'=>'2005-02-07T00:28:43','version'=>'3.04' },{'date'=>'2005-02-28T13:27:37','version'=>'3.05' },{'date'=>'2005-04-14T02:06:10','version'=>'3.06' },{'date'=>'2005-05-06T12:50:38','version'=>'3.07' },{'date'=>'2005-05-28T15:13:27','version'=>'3.08' },{'date'=>'2005-06-15T23:45:19','version'=>'3.09' },{'date'=>'2005-08-26T03:29:11','version'=>'3.10' },{'date'=>'2005-08-28T01:16:38','version'=>'3.11' },{'date'=>'2005-10-04T03:14:00','version'=>'3.12' },{'date'=>'2005-11-16T05:58:53','version'=>'3.13' },{'date'=>'2005-11-18T00:15:37','version'=>'3.14' },{'date'=>'2005-12-10T04:51:57','version'=>'3.14_01' },{'date'=>'2005-12-14T05:11:27','version'=>'3.14_02' },{'date'=>'2005-12-27T20:32:26','version'=>'3.15' },{'date'=>'2006-01-31T02:52:07','version'=>'3.16' },{'date'=>'2006-03-03T22:55:18','version'=>'3.17' },{'date'=>'2006-04-28T03:04:00','version'=>'3.18' },{'date'=>'2006-07-12T03:43:15','version'=>'3.19' },{'date'=>'2006-10-05T02:18:51','version'=>'3.21' },{'date'=>'2006-10-10T02:53:23','version'=>'3.22' },{'date'=>'2006-10-11T17:13:59','version'=>'3.23' },{'date'=>'2006-11-20T04:53:56','version'=>'3.24' },{'date'=>'2007-05-22T02:08:53','version'=>'3.25' },{'date'=>'2007-10-14T02:15:40','version'=>'3.25_01' },{'date'=>'2007-12-25T02:34:28','version'=>'3.2501' },{'date'=>'2008-01-14T12:02:28','version'=>'3.26' },{'date'=>'2008-01-15T23:27:33','version'=>'3.26_01' },{'date'=>'2008-01-17T02:21:47','version'=>'3.27' },{'date'=>'2008-02-12T03:46:01','version'=>'3.2701' },{'date'=>'2008-07-26T02:19:45','version'=>'3.28_01' },{'date'=>'2008-10-27T19:27:37','version'=>'3.28_02' },{'date'=>'2008-10-27T21:16:35','version'=>'3.28_03' },{'date'=>'2008-10-29T20:11:52','version'=>'3.29' },{'date'=>'2009-05-07T18:27:46','version'=>'3.29_01' },{'date'=>'2009-05-10T08:59:46','version'=>'3.30' },{'date'=>'2009-09-21T12:46:15','version'=>'3.30_01' },{'date'=>'2009-09-29T06:22:30','version'=>'3.30_02' },{'date'=>'2009-11-01T14:22:36','version'=>'3.31' },{'date'=>'2010-07-23T08:10:31','version'=>'3.31_02' },{'date'=>'2010-09-17T13:24:05','version'=>'3.31_03' },{'date'=>'2010-09-19T15:53:14','version'=>'3.32' },{'date'=>'2010-09-20T07:54:00','version'=>'3.33' },{'date'=>'2011-12-20T07:42:29','version'=>'3.39_01' },{'date'=>'2013-01-16T06:35:08','version'=>'3.40' },{'date'=>'2014-05-01T18:34:31','version'=>'3.46_01' },{'date'=>'2014-05-23T17:00:38','version'=>'3.47' },{'date'=>'2015-07-11T22:18:08','version'=>'3.56_01' },{'date'=>'2015-07-16T15:33:27','version'=>'3.56_02' },{'date'=>'2015-11-09T22:09:25','version'=>'3.58_01' },{'date'=>'2015-11-13T23:46:00','version'=>'3.59' },{'date'=>'2015-11-19T02:32:50','version'=>'3.60' },{'date'=>'2016-01-11T13:49:31','version'=>'3.62' },{'date'=>'2018-02-18T20:27:27','version'=>'3.73' },{'date'=>'2018-02-19T08:41:14','version'=>'3.74' },{'date'=>'2018-08-29T19:53:19','version'=>'3.75' }]},'Perl-Version'=>{'advisories'=>[{'affected_versions'=>'<1.013','description'=>'Insecure dependency File::Slurp is used.
  ','distribution'=>'Perl-Version','fixed_versions'=>'>=1.013','id'=>'CPANSA-Perl-Version-2014-01','references'=>['https://metacpan.org/changes/distribution/Perl-Version','https://rt.cpan.org/Public/Bug/Display.html?id=92974' ],'reported'=>'2014-02-12' }],'main_module'=>'Perl::Version','versions'=>[{'date'=>'2007-02-07T19:41:42','version'=>'v0.0.1' },{'date'=>'2007-02-23T18:03:11','version'=>'v0.0.3' },{'date'=>'2007-02-24T18:03:42','version'=>'v0.0.4' },{'date'=>'2007-02-25T12:41:13','version'=>'v0.0.5' },{'date'=>'2007-02-27T12:46:07','version'=>'v0.0.6' },{'date'=>'2007-02-28T01:27:59','version'=>'v0.0.7' },{'date'=>'2007-06-20T16:09:31','version'=>'0.0.8' },{'date'=>'2007-09-03T14:28:35','version'=>'v1.000' },{'date'=>'2007-09-07T15:42:58','version'=>'v1.001' },{'date'=>'2007-09-07T15:58:18','version'=>'v1.002' },{'date'=>'2007-11-08T12:14:27','version'=>'1.003' },{'date'=>'2007-11-08T12:24:59','version'=>'1.004' },{'date'=>'2008-04-03T14:56:16','version'=>'1.005' },{'date'=>'2008-04-07T19:14:56','version'=>'1.006' },{'date'=>'2008-04-07T19:27:24','version'=>'1.007' },{'date'=>'2009-03-07T16:40:03','version'=>'1.008' },{'date'=>'2009-03-09T16:22:08','version'=>'1.009' },{'date'=>'2010-09-19T15:37:48','version'=>'1.010' },{'date'=>'2011-02-21T21:32:17','version'=>'1.011' },{'date'=>'2014-02-12T20:58:43','version'=>'1.013' },{'date'=>'2014-02-14T16:08:42','version'=>'1.013_01' },{'date'=>'2014-02-18T16:42:57','version'=>'1.013_02' },{'date'=>'2015-11-21T06:05:48','version'=>'1.013_03' }]},'Plack-Middleware-Session'=>{'advisories'=>[{'affected_versions'=>'<=0.21','description'=>'Plack::Middleware::Session::Cookie 0.21 has a security vulnerability where it allows an attacker to execute arbitrary code on the server, when the middleware is enabled without a secret.
  ','distribution'=>'Plack-Middleware-Session','fixed_versions'=>'>0.21','id'=>'CPANSA-Plack-Middleware-Session-2014-01','references'=>['https://gist.github.com/miyagawa/2b8764af908a0dacd43d','https://metacpan.org/changes/distribution/Plack-Middleware-Session' ],'reported'=>'2014-08-11','severity'=>'critical' }],'main_module'=>'Plack::Middleware::Session','versions'=>[{'date'=>'2009-12-15T18:59:13','version'=>'0.01' },{'date'=>'2009-12-19T19:27:38','version'=>'0.02' },{'date'=>'2010-01-07T22:12:43','version'=>'0.03' },{'date'=>'2010-01-30T21:46:53','version'=>'0.09_01' },{'date'=>'2010-01-31T07:17:07','version'=>'0.09_02' },{'date'=>'2010-02-03T04:46:20','version'=>'0.09_03' },{'date'=>'2010-02-23T03:16:31','version'=>'0.10' },{'date'=>'2010-02-27T10:47:17','version'=>'0.11' },{'date'=>'2010-07-07T22:55:18','version'=>'0.12' },{'date'=>'2010-12-22T17:00:14','version'=>'0.13' },{'date'=>'2011-03-29T20:50:06','version'=>'0.14' },{'date'=>'2012-09-04T21:16:35','version'=>'0.15' },{'date'=>'2013-02-10T19:43:11','version'=>'0.16' },{'date'=>'2013-02-11T23:45:49','version'=>'0.17' },{'date'=>'2013-02-12T10:57:14','version'=>'0.17' },{'date'=>'2013-06-24T23:09:39','version'=>'0.20' },{'date'=>'2013-10-12T18:42:26','version'=>'0.21' },{'date'=>'2014-08-11T17:18:03','version'=>'0.22' },{'date'=>'2014-08-11T17:23:40','version'=>'0.23' },{'date'=>'2014-09-05T11:48:57','version'=>'0.24' },{'date'=>'2014-09-29T03:07:54','version'=>'0.25' },{'date'=>'2015-02-03T08:17:55','version'=>'0.26' },{'date'=>'2015-02-14T00:52:35','version'=>'0.27' },{'date'=>'2015-02-16T16:30:31','version'=>'0.28' },{'date'=>'2015-02-17T23:57:32','version'=>'0.29' },{'date'=>'2015-03-02T18:25:56','version'=>'0.30' },{'date'=>'2019-02-26T19:01:59','version'=>'0.31' },{'date'=>'2019-02-26T21:36:43','version'=>'0.32' }]},'RT-Authen-ExternalAuth'=>{'advisories'=>[{'affected_versions'=>'<0.27','cves'=>['CVE-2017-5361' ],'description'=>'Timing sidechannel vulnerability in password checking.
  ','distribution'=>'RT-Authen-ExternalAuth','fixed_versions'=>'>=0.27','id'=>'CPANSA-RT-Authen-ExternalAuth-2017-01','references'=>['https://metacpan.org/changes/distribution/RT-Authen-ExternalAuth' ],'reported'=>'2017-06-15' }],'main_module'=>'RT::Authen::ExternalAuth','versions'=>[{'date'=>'2008-03-13T16:16:36','version'=>'0.01' },{'date'=>'2008-03-17T13:34:40','version'=>'0.02' },{'date'=>'2008-03-31T14:55:18','version'=>'0.03' },{'date'=>'2008-04-03T14:20:36','version'=>'0.04' },{'date'=>'2008-04-09T08:57:51','version'=>'0.05' },{'date'=>'2008-10-17T13:22:11','version'=>'0.06_01' },{'date'=>'2008-10-17T16:41:34','version'=>'0.06_02' },{'date'=>'2008-10-31T12:08:54','version'=>'0.06_02' },{'date'=>'2008-11-01T18:23:27','version'=>'0.06_02' },{'date'=>'2008-11-06T21:16:42','version'=>'0.06_02' },{'date'=>'2008-12-22T22:08:06','version'=>'0.07_02' },{'date'=>'2009-01-20T21:09:48','version'=>'0.07_02' },{'date'=>'2009-01-24T13:52:42','version'=>'0.07_02' },{'date'=>'2011-02-19T00:43:35','version'=>'0.08_01' },{'date'=>'2011-04-15T19:46:43','version'=>'0.08_02' },{'date'=>'2011-05-06T21:08:52','version'=>'0.09' },{'date'=>'2012-01-23T17:51:41','version'=>'0.09_01' },{'date'=>'2012-01-26T18:48:51','version'=>'0.09_02' },{'date'=>'2012-01-27T23:07:12','version'=>'0.09_03' },{'date'=>'2012-02-17T16:34:10','version'=>'0.10' },{'date'=>'2012-02-23T16:31:54','version'=>'0.10_01' },{'date'=>'2012-07-25T08:57:21','version'=>'0.11' },{'date'=>'2012-07-25T18:36:36','version'=>'0.11' },{'date'=>'2012-10-26T19:59:54','version'=>'0.12' },{'date'=>'2013-01-31T19:22:43','version'=>'0.13' },{'date'=>'2013-05-22T21:28:15','version'=>'0.14' },{'date'=>'2013-05-23T00:20:43','version'=>'0.15' },{'date'=>'2013-06-27T19:24:37','version'=>'0.16' },{'date'=>'2013-07-10T19:43:08','version'=>'0.17' },{'date'=>'2014-03-07T22:19:49','version'=>'0.18' },{'date'=>'2014-04-04T17:21:04','version'=>'0.19' },{'date'=>'2014-04-09T19:34:29','version'=>'0.20' },{'date'=>'2014-07-02T02:20:30','version'=>'0.21' },{'date'=>'2014-08-14T04:04:28','version'=>'0.22_01' },{'date'=>'2014-08-14T17:28:53','version'=>'0.23' },{'date'=>'2014-09-30T22:04:16','version'=>'0.23_01' },{'date'=>'2014-10-09T16:24:49','version'=>'0.24' },{'date'=>'2014-10-16T20:59:29','version'=>'0.25' },{'date'=>'2016-08-02T16:14:34','version'=>'0.26' },{'date'=>'2017-06-15T18:44:24','version'=>'0.27' }]},'RT-Extension-MobileUI'=>{'advisories'=>[{'affected_versions'=>'<1.02','cves'=>['CVE-2012-2769' ],'description'=>'Multiple cross-site scripting (XSS) vulnerabilities in the topic administration page.
  ','distribution'=>'RT-Extension-MobileUI','fixed_versions'=>'>=1.02','id'=>'CPANSA-RT-Extension-MobileUI-2012-01','references'=>['https://metacpan.org/changes/distribution/RT-Extension-MobileUI' ],'reported'=>'2012-05-18' }],'main_module'=>'RT::Extension::MobileUI','versions'=>[{'date'=>'2010-08-05T20:58:09','version'=>'0.9' },{'date'=>'2010-08-06T15:38:53','version'=>'0.91' },{'date'=>'2010-08-06T15:58:11','version'=>'0.92' },{'date'=>'2010-08-06T17:55:08','version'=>'0.93' },{'date'=>'2010-08-09T13:36:43','version'=>'0.94' },{'date'=>'2010-08-09T13:44:33','version'=>'0.95' },{'date'=>'2010-08-26T21:28:07','version'=>'0.96' },{'date'=>'2010-09-06T18:11:56','version'=>'0.96' },{'date'=>'2010-10-28T15:50:29','version'=>'0.98' },{'date'=>'2010-10-29T14:08:08','version'=>'0.99' },{'date'=>'2010-11-19T18:11:43','version'=>'1.00' },{'date'=>'2010-12-08T16:36:01','version'=>'1.01' },{'date'=>'2012-07-25T08:57:33','version'=>'1.02' },{'date'=>'2012-07-25T18:36:52','version'=>'1.02' },{'date'=>'2012-08-27T16:42:55','version'=>'1.03' },{'date'=>'2013-06-12T19:09:14','version'=>'1.04' },{'date'=>'2013-08-13T18:06:54','version'=>'1.05' },{'date'=>'2014-04-23T20:25:25','version'=>'1.06' },{'date'=>'2014-04-23T20:26:56','version'=>'1.07' }]},'RTMP-Client'=>{'advisories'=>[{'affected_versions'=>'<0.04','description'=>'TBD
  ','distribution'=>'RTMP-Client','fixed_versions'=>'>=0.04','id'=>'CPANSA-RTMP-Client-2011-01','references'=>['https://metacpan.org/changes/distribution/RTMP-Client' ],'reported'=>'2011-12-01' }],'main_module'=>'RTMP::Client','versions'=>[{'date'=>'2011-07-26T08:17:20','version'=>'0.01' },{'date'=>'2011-07-27T02:09:05','version'=>'0.02' },{'date'=>'2011-07-27T02:17:06','version'=>'0.03' },{'date'=>'2011-12-01T08:59:19','version'=>'0.04' }]},'SOAP-Lite'=>{'advisories'=>[{'affected_versions'=>'<1.15','cves'=>['CVE-2015-8978' ],'description'=>'An example attack consists of defining 10 or more XML entities, each defined as consisting of 10 of the previous entity, with the document consisting of a single instance of the largest entity, which expands to one billion copies of the first entity. The amount of computer memory used for handling an external SOAP call would likely exceed that available to the process parsing the XML.
  ','distribution'=>'SOAP-Lite','fixed_versions'=>'>=1.15','id'=>'CPANSA-SOAP-Lite-2015-01','references'=>['https://metacpan.org/changes/distribution/SOAP-Lite','https://www.securityfocus.com/bid/94487','https://github.com/redhotpenguin/perl-soaplite/commit/6942fe0d281be1c32c5117605f9c4e8d44f51124' ],'reported'=>'2015-07-21' },{'affected_versions'=>'<0.55','cves'=>['CVE-2002-1742' ],'description'=>'Allows remote attackers to load arbitrary Perl functions by suppling a non-existent function in a script using a SOAP::Lite module, which causes the AUTOLOAD subroutine to trigger.
  ','distribution'=>'SOAP-Lite','fixed_versions'=>'>=0.55','id'=>'CPANSA-SOAP-Lite-2002-01','references'=>['https://metacpan.org/changes/distribution/SOAP-Lite' ],'reported'=>'2002-04-08','severity'=>'high' },{'affected_versions'=>'<0.38','description'=>'Security problem on server side (no more details).
  ','distribution'=>'SOAP-Lite','fixed_versions'=>'>=0.38','id'=>'CPANSA-SOAP-Lite-2000-01','references'=>['https://metacpan.org/changes/distribution/SOAP-Lite' ],'reported'=>'2000-10-05' }],'main_module'=>'SOAP::Lite','versions'=>[{'date'=>'2000-09-25T01:49:14','version'=>'0.36' },{'date'=>'2000-10-06T01:58:32','version'=>'0.38' },{'date'=>'2000-10-09T04:27:51','version'=>'0.39' },{'date'=>'2000-10-16T05:12:09','version'=>'0.40' },{'date'=>'2000-10-31T15:10:52','version'=>'0.41' },{'date'=>'2000-11-15T15:00:57','version'=>'0.42' },{'date'=>'2000-11-28T20:43:40','version'=>'0.43' },{'date'=>'2000-12-13T07:37:47','version'=>'0.44' },{'date'=>'2001-01-17T17:28:31','version'=>'0.45' },{'date'=>'2001-02-01T02:23:51','version'=>'0.46' },{'date'=>'2001-02-22T07:28:20','version'=>'0.47' },{'date'=>'2001-04-18T19:09:15','version'=>'0.50' },{'date'=>'2001-07-18T22:39:30','version'=>'0.51' },{'date'=>'2001-11-21T19:35:24','version'=>'0.52' },{'date'=>'2002-04-16T05:20:54','version'=>'0.55' },{'date'=>'2003-10-28T19:27:00','version'=>'0.60' },{'date'=>'2004-02-26T16:36:26','version'=>'0.60' },{'date'=>'2005-02-22T01:57:43','version'=>'0.65_3' },{'date'=>'2005-04-03T09:20:17','version'=>'0.65_4' },{'date'=>'2005-05-06T17:24:23','version'=>'0.65_5' },{'date'=>'2005-06-03T19:23:20','version'=>'0.65_6' },{'date'=>'2005-12-25T08:42:50','version'=>'0.66' },{'date'=>'2006-01-04T23:14:27','version'=>'0.66.1' },{'date'=>'2006-01-27T21:43:49','version'=>'0.67' },{'date'=>'2006-07-06T18:18:56','version'=>'0.68' },{'date'=>'2006-08-16T14:53:50','version'=>'0.69' },{'date'=>'2007-10-18T20:54:02','version'=>'0.70_01' },{'date'=>'2007-11-08T21:30:41','version'=>'0.70_02' },{'date'=>'2007-11-18T19:00:11','version'=>'0.70_03' },{'date'=>'2008-01-02T17:06:17','version'=>'0.70_04' },{'date'=>'2008-02-13T12:28:07','version'=>'0.70_05' },{'date'=>'2008-02-16T10:37:04','version'=>'0.70_06' },{'date'=>'2008-02-25T21:44:41','version'=>'0.70_07' },{'date'=>'2008-02-25T21:50:22','version'=>'0.70_08' },{'date'=>'2008-02-28T21:58:13','version'=>'0.71' },{'date'=>'2008-03-29T14:13:41','version'=>'0.71.01' },{'date'=>'2008-04-14T17:25:25','version'=>'0.71.02' },{'date'=>'2008-04-17T20:40:23','version'=>'v0.71.03' },{'date'=>'2008-04-22T06:03:55','version'=>'0.71.04' },{'date'=>'2008-05-05T21:50:36','version'=>'0.710.05' },{'date'=>'2008-06-05T18:47:08','version'=>'0.710.06' },{'date'=>'2008-06-13T20:27:05','version'=>'0.710.07' },{'date'=>'2008-07-13T20:41:11','version'=>'0.710.08' },{'date'=>'2009-09-29T21:20:02','version'=>'0.710.09' },{'date'=>'2009-09-30T18:40:30','version'=>'0.710.10' },{'date'=>'2010-03-18T20:24:42','version'=>'0.711' },{'date'=>'2010-06-03T15:41:39','version'=>'0.712' },{'date'=>'2011-08-16T17:53:28','version'=>'0.713' },{'date'=>'2011-08-18T19:51:02','version'=>'0.714' },{'date'=>'2012-07-15T09:37:20','version'=>'0.715' },{'date'=>'2013-05-11T06:44:04','version'=>'0.716' },{'date'=>'2013-07-17T06:17:00','version'=>'1.0' },{'date'=>'2013-07-29T08:26:07','version'=>'1.01' },{'date'=>'2013-07-30T02:20:34','version'=>'1.02' },{'date'=>'2013-08-04T17:49:18','version'=>'1.03' },{'date'=>'2013-08-10T03:46:49','version'=>'1.04' },{'date'=>'2013-08-19T05:31:17','version'=>'1.05' },{'date'=>'2013-08-22T04:20:29','version'=>'1.06' },{'date'=>'2013-11-08T03:09:10','version'=>'1.07' },{'date'=>'2013-11-08T17:41:10','version'=>'1.08' },{'date'=>'2014-01-14T21:41:07','version'=>'1.09' },{'date'=>'2014-01-23T18:53:42','version'=>'1.10' },{'date'=>'2014-02-22T05:18:14','version'=>'1.11' },{'date'=>'2014-11-27T07:08:11','version'=>'1.12' },{'date'=>'2014-12-30T15:58:06','version'=>'1.13' },{'date'=>'2015-03-25T05:04:34','version'=>'1.14' },{'date'=>'2015-07-21T18:12:21','version'=>'1.15' },{'date'=>'2015-07-23T07:34:59','version'=>'1.16' },{'date'=>'2015-07-31T05:59:50','version'=>'1.17' },{'date'=>'2015-08-26T04:31:24','version'=>'1.18' },{'date'=>'2015-08-26T15:38:01','version'=>'1.19' },{'date'=>'2016-06-09T21:34:36','version'=>'1.20' },{'date'=>'2017-08-16T05:18:24','version'=>'1.22' },{'date'=>'2017-12-19T02:30:48','version'=>'1.23' },{'date'=>'2017-12-19T18:36:52','version'=>'1.24' },{'date'=>'2017-12-29T18:39:43','version'=>'1.25' },{'date'=>'2017-12-30T22:19:12','version'=>'1.26' },{'date'=>'2018-05-14T20:36:08','version'=>'1.27' }]},'SVG-Sparkline'=>{'advisories'=>[{'affected_versions'=>'<1.12','description'=>'Invalid data input validation makes it possible to pass arbitrary strings to module loading eval.
  ','distribution'=>'SVG-Sparkline','fixed_versions'=>'>=1.12','id'=>'CPANSA-SVG-Sparkline-2017-01','references'=>['https://metacpan.org/changes/distribution/SVG-Sparkline','https://github.com/gwadej/svg-sparkline/commit/ca83d6eb56aa86f3ca735866ffa9aa97acc2e708' ],'reported'=>'2017-05-15' }],'main_module'=>'SVG::Sparkline','versions'=>[{'date'=>'2009-04-02T02:42:59','version'=>'0.1.0' },{'date'=>'2009-04-03T01:30:19','version'=>'0.1.1' },{'date'=>'2009-04-05T21:43:08','version'=>'0.2.0' },{'date'=>'2009-04-18T04:46:33','version'=>'0.2.5' },{'date'=>'2009-04-21T00:31:44','version'=>'0.2.6' },{'date'=>'2009-04-27T03:42:24','version'=>'0.2.7' },{'date'=>'2009-05-06T23:20:05','version'=>'0.3' },{'date'=>'2009-05-07T22:11:10','version'=>'0.31' },{'date'=>'2009-10-19T04:12:52','version'=>'0.32' },{'date'=>'2009-10-21T00:27:30','version'=>'0.33' },{'date'=>'2010-05-01T04:50:06','version'=>'0.34' },{'date'=>'2010-10-30T22:01:18','version'=>'0.35' },{'date'=>'2012-09-04T00:09:32','version'=>'0.36' },{'date'=>'2013-10-24T14:01:00','version'=>'1' },{'date'=>'2014-09-04T02:01:54','version'=>'1.1' },{'date'=>'2015-03-03T19:38:44','version'=>'1.11' },{'date'=>'2017-05-15T01:32:51','version'=>'1.12' }]},'SVN-Look'=>{'advisories'=>[{'affected_versions'=>'<0.40','description'=>'Two-arg open with a possibility of running arbitrary commands.
  ','distribution'=>'SVN-Look','fixed_versions'=>'>=0.40','id'=>'CPANSA-SVN-Look-2014-01','references'=>['https://metacpan.org/changes/distribution/SVN-Look','https://github.com/gnustavo/SVN-Look/commit/b413ac1c397dfc6b2d164fede693f7ff9a94c83c' ],'reported'=>'2014-05-31' }],'main_module'=>'SVN::Look','versions'=>[{'date'=>'2008-09-26T03:22:44','version'=>'0.08.360' },{'date'=>'2008-09-27T22:10:54','version'=>'0.09.366' },{'date'=>'2008-09-28T03:07:02','version'=>'0.10.369' },{'date'=>'2008-10-05T03:16:35','version'=>'0.11.388' },{'date'=>'2008-10-10T02:25:16','version'=>'0.12.409' },{'date'=>'2008-10-24T00:51:56','version'=>'0.12.442' },{'date'=>'2008-11-03T10:43:38','version'=>'0.12.455' },{'date'=>'2008-11-06T03:11:52','version'=>'0.13.463' },{'date'=>'2009-02-28T02:50:53','version'=>'0.14.5' },{'date'=>'2009-03-01T12:17:06','version'=>'0.14.7' },{'date'=>'2009-03-06T01:52:43','version'=>'0.14.9' },{'date'=>'2009-03-08T02:25:41','version'=>'0.14.10' },{'date'=>'2009-03-20T01:24:06','version'=>'0.14.12' },{'date'=>'2009-10-25T01:23:51','version'=>'0.15' },{'date'=>'2010-02-16T20:16:51','version'=>'0.16' },{'date'=>'2010-02-24T23:20:51','version'=>'0.17' },{'date'=>'2010-04-28T11:38:27','version'=>'0.18' },{'date'=>'2010-12-12T10:35:04','version'=>'0.19' },{'date'=>'2010-12-12T19:59:46','version'=>'0.20' },{'date'=>'2011-07-20T20:11:31','version'=>'0.21' },{'date'=>'2011-07-22T22:31:55','version'=>'0.22' },{'date'=>'2011-07-27T20:22:58','version'=>'0.23' },{'date'=>'2011-07-30T21:52:08','version'=>'0.24' },{'date'=>'2011-08-21T23:31:44','version'=>'0.25' },{'date'=>'2011-08-27T20:12:39','version'=>'0.26' },{'date'=>'2011-09-18T02:42:31','version'=>'0.27' },{'date'=>'2011-10-10T23:18:59','version'=>'0.28' },{'date'=>'2011-10-13T01:06:12','version'=>'0.29' },{'date'=>'2011-11-02T21:00:23','version'=>'0.30' },{'date'=>'2012-02-26T00:04:15','version'=>'0.31' },{'date'=>'2012-02-26T21:55:01','version'=>'0.32' },{'date'=>'2012-02-27T23:49:07','version'=>'0.33' },{'date'=>'2012-03-05T14:37:05','version'=>'0.34' },{'date'=>'2012-04-22T00:14:50','version'=>'0.35' },{'date'=>'2012-06-18T17:07:07','version'=>'0.36' },{'date'=>'2012-06-18T17:34:58','version'=>'0.37' },{'date'=>'2012-06-19T17:00:40','version'=>'0.38' },{'date'=>'2013-10-20T23:32:26','version'=>'0.39' },{'date'=>'2014-06-12T18:05:32','version'=>'0.40' },{'date'=>'2014-06-14T02:51:53','version'=>'0.41' }]},'Search-OpenSearch-Server'=>{'advisories'=>[{'affected_versions'=>'<0.17','description'=>'Arbitrary Perl methods could be called via HTTP like RPC.
  ','distribution'=>'Search-OpenSearch-Server','fixed_versions'=>'>=0.17','id'=>'CPANSA-Search-OpenSearch-Server-2012-01','references'=>['https://metacpan.org/changes/distribution/Search-OpenSearch-Server','https://github.com/karpet/search-opensearch-server/commit/69d53fde9d70fe12e1f592de482601c43c45a278' ],'reported'=>'2012-08-31' }],'main_module'=>'Search::OpenSearch::Server','versions'=>[{'date'=>'2010-05-28T03:07:46','version'=>'0.01' },{'date'=>'2010-05-29T01:11:09','version'=>'0.02' },{'date'=>'2010-06-23T01:22:53','version'=>'0.03' },{'date'=>'2010-06-26T21:08:31','version'=>'0.04' },{'date'=>'2011-01-08T04:05:22','version'=>'0.05' },{'date'=>'2011-09-26T18:12:08','version'=>'0.06' },{'date'=>'2011-09-26T18:16:12','version'=>'0.07' },{'date'=>'2011-09-30T03:15:51','version'=>'0.08' },{'date'=>'2011-10-23T01:42:30','version'=>'0.09' },{'date'=>'2012-05-01T02:22:52','version'=>'0.10' },{'date'=>'2012-07-15T03:32:57','version'=>'0.11' },{'date'=>'2012-07-27T02:42:45','version'=>'0.12' },{'date'=>'2012-08-07T01:48:25','version'=>'0.13' },{'date'=>'2012-08-10T03:10:13','version'=>'0.14' },{'date'=>'2012-08-21T02:34:37','version'=>'0.15' },{'date'=>'2012-08-21T17:47:00','version'=>'0.16' },{'date'=>'2012-09-04T01:54:00','version'=>'0.17' },{'date'=>'2012-09-12T03:42:03','version'=>'0.18' },{'date'=>'2012-09-13T14:06:58','version'=>'0.19' },{'date'=>'2012-09-20T02:21:37','version'=>'0.20' },{'date'=>'2012-10-15T04:32:38','version'=>'0.21' },{'date'=>'2012-11-08T03:20:16','version'=>'0.22' },{'date'=>'2012-11-21T19:01:22','version'=>'0.23' },{'date'=>'2012-11-26T19:37:12','version'=>'0.24' },{'date'=>'2012-12-18T19:11:36','version'=>'0.25' },{'date'=>'2013-01-04T19:08:19','version'=>'0.26' },{'date'=>'2013-06-14T02:28:09','version'=>'0.27' },{'date'=>'2014-03-02T22:22:17','version'=>'0.28' },{'date'=>'2014-04-23T18:20:52','version'=>'0.299_01' },{'date'=>'2014-04-24T02:56:24','version'=>'0.299_02' },{'date'=>'2014-06-05T07:29:19','version'=>'0.299_03' },{'date'=>'2014-06-08T04:57:40','version'=>'0.300' },{'date'=>'2015-08-14T20:04:12','version'=>'0.301' }]},'Storable'=>{'advisories'=>[{'affected_versions'=>'<3.05','description'=>'Malcrafted storable files or buffers.
  ','distribution'=>'Storable','fixed_versions'=>'>=3.05','id'=>'CPANSA-Storable-2017-01','references'=>['https://metacpan.org/changes/distribution/Storable','https://cxsecurity.com/issue/WLB-2007120031' ],'reported'=>'2017-01-29' }],'main_module'=>'Storable','versions'=>[{'date'=>'1995-10-02T10:50:02','version'=>'0.1' },{'date'=>'1997-01-13T11:42:25','version'=>'0.2' },{'date'=>'1997-01-13T17:18:01','version'=>'0.2' },{'date'=>'1997-01-14T15:12:36','version'=>'0.3' },{'date'=>'1997-01-15T18:25:57','version'=>'0.4' },{'date'=>'1997-01-22T14:47:23','version'=>'0.4' },{'date'=>'1997-02-27T15:02:37','version'=>'0.4' },{'date'=>'1997-02-27T15:38:18','version'=>'0.4' },{'date'=>'1997-03-25T10:32:00','version'=>'0.4' },{'date'=>'1997-05-16T09:24:59','version'=>'0.4' },{'date'=>'1997-06-03T09:38:38','version'=>'0.4' },{'date'=>'1997-06-10T16:47:47','version'=>'0.5' },{'date'=>'1997-11-05T10:05:11','version'=>'0.5' },{'date'=>'1998-01-13T16:59:38','version'=>'0.5' },{'date'=>'1998-01-20T08:32:03','version'=>'0.5' },{'date'=>'1998-03-06T20:52:28','version'=>'0.5' },{'date'=>'1998-03-25T14:10:24','version'=>'0.5' },{'date'=>'1998-04-08T11:20:48','version'=>'0.5' },{'date'=>'1998-04-09T16:17:05','version'=>'0.5' },{'date'=>'1998-04-24T15:29:23','version'=>'0.5' },{'date'=>'1998-04-30T13:13:58','version'=>'0.5' },{'date'=>'1998-05-12T07:15:48','version'=>'0.5' },{'date'=>'1998-06-04T16:19:02','version'=>'0.6' },{'date'=>'1998-06-12T09:54:35','version'=>'0.6' },{'date'=>'1998-06-22T09:00:32','version'=>'0.6' },{'date'=>'1998-07-03T13:53:55','version'=>'0.6' },{'date'=>'1998-07-21T12:10:39','version'=>'0.6' },{'date'=>'1999-01-31T18:01:47','version'=>'0.6' },{'date'=>'1999-07-12T13:05:25','version'=>'0.6' },{'date'=>'1999-09-02T12:47:03','version'=>'0.6' },{'date'=>'1999-09-14T20:27:23','version'=>'v0.6.5' },{'date'=>'1999-10-19T19:33:43','version'=>'v0.6.6' },{'date'=>'1999-10-20T17:10:19','version'=>'v0.6.7' },{'date'=>'2000-03-02T22:29:53','version'=>'v0.6.9' },{'date'=>'2000-03-29T18:00:09','version'=>'v0.6.10' },{'date'=>'2000-04-02T22:12:47','version'=>'v0.6.11' },{'date'=>'2000-08-03T22:12:31','version'=>'v0.7.0' },{'date'=>'2000-08-13T20:17:55','version'=>'v0.7.1' },{'date'=>'2000-08-14T07:27:17','version'=>'v0.7.2' },{'date'=>'2000-08-23T23:12:01','version'=>'v0.7.4' },{'date'=>'2000-09-01T19:44:37','version'=>'v1.0.0' },{'date'=>'2000-09-17T16:56:12','version'=>'v1.0.1' },{'date'=>'2000-09-28T21:50:42','version'=>'v1.0.2' },{'date'=>'2000-09-29T19:55:57','version'=>'v1.0.3' },{'date'=>'2000-10-23T18:12:41','version'=>'v1.0.4' },{'date'=>'2000-10-26T17:18:33','version'=>'v1.0.5' },{'date'=>'2000-11-05T17:30:34','version'=>'v1.0.6' },{'date'=>'2001-01-03T09:48:40','version'=>'v1.0.7' },{'date'=>'2001-02-17T12:43:23','version'=>'v1.0.10' },{'date'=>'2001-03-15T00:30:04','version'=>'v1.0.11' },{'date'=>'2001-07-01T11:30:39','version'=>'v1.0.12' },{'date'=>'2001-08-28T21:59:16','version'=>'v1.0.13' },{'date'=>'2001-12-01T13:48:14','version'=>'v1.0.14' },{'date'=>'2002-05-18T16:48:08','version'=>'2.00' },{'date'=>'2002-05-28T20:34:47','version'=>'2.02' },{'date'=>'2002-06-01T04:35:47','version'=>'2.03' },{'date'=>'2002-06-08T02:11:56','version'=>'2.04' },{'date'=>'2002-10-03T03:37:51','version'=>'2.05' },{'date'=>'2002-11-25T12:34:01','version'=>'2.06' },{'date'=>'2003-05-05T05:21:16','version'=>'2.07' },{'date'=>'2003-09-05T20:01:37','version'=>'2.08' },{'date'=>'2004-01-06T01:47:55','version'=>'2.09' },{'date'=>'2004-03-01T04:28:16','version'=>'2.10' },{'date'=>'2004-03-17T15:11:57','version'=>'2.11' },{'date'=>'2004-03-24T03:24:16','version'=>'2.12' },{'date'=>'2004-06-28T16:41:47','version'=>'2.13' },{'date'=>'2005-04-25T02:15:51','version'=>'2.14' },{'date'=>'2005-05-23T17:21:53','version'=>'2.15' },{'date'=>'2007-03-31T00:51:12','version'=>'2.16' },{'date'=>'2007-11-16T20:48:24','version'=>'2.17' },{'date'=>'2007-11-23T18:18:24','version'=>'2.18' },{'date'=>'2009-05-18T04:18:09','version'=>'2.20' },{'date'=>'2009-08-06T05:30:04','version'=>'2.21' },{'date'=>'2010-11-12T17:12:42','version'=>'2.23' },{'date'=>'2010-11-12T17:29:29','version'=>'2.24' },{'date'=>'2010-12-11T06:08:33','version'=>'2.25' },{'date'=>'2011-07-03T04:04:14','version'=>'2.29' },{'date'=>'2011-07-12T03:59:06','version'=>'2.30' },{'date'=>'2012-06-07T01:16:46','version'=>'2.35' },{'date'=>'2012-09-11T01:30:44','version'=>'2.38' },{'date'=>'2012-09-11T01:38:57','version'=>'2.39' },{'date'=>'2013-07-13T16:49:48','version'=>'2.45' },{'date'=>'2014-07-02T11:09:04','version'=>'2.51' },{'date'=>'2017-01-29T11:41:00','version'=>'3.05' },{'date'=>'2017-01-30T14:25:11','version'=>'3.05_01' },{'date'=>'2017-01-30T18:55:50','version'=>'3.05_02' },{'date'=>'2017-01-31T01:58:36','version'=>'3.05_03' },{'date'=>'2017-02-02T11:22:12','version'=>'3.05_04' },{'date'=>'2017-03-05T10:48:10','version'=>'3.05_06' },{'date'=>'2017-03-05T12:52:10','version'=>'3.05_07' },{'date'=>'2017-03-11T07:51:19','version'=>'3.05_09' },{'date'=>'2017-03-14T09:03:54','version'=>'3.05_10' },{'date'=>'2017-03-29T20:00:48','version'=>'3.05_11' },{'date'=>'2017-04-19T07:20:42','version'=>'3.05_12' },{'date'=>'2017-10-15T12:06:30','version'=>'3.05_14' },{'date'=>'2017-10-21T09:30:17','version'=>'3.05_15' },{'date'=>'2017-10-21T16:17:28','version'=>'3.05_16' },{'date'=>'2018-04-19T08:29:33','version'=>'3.06' },{'date'=>'2018-04-20T16:11:03','version'=>'3.05_17' },{'date'=>'2018-04-21T10:08:56','version'=>'3.08' },{'date'=>'2018-04-21T16:50:30','version'=>'3.09' },{'date'=>'2018-04-27T17:46:19','version'=>'3.11' },{'date'=>'2018-09-05T15:12:26','version'=>'3.11_01' },{'date'=>'2019-03-06T12:42:01','version'=>'3.12_03' }]},'Tk'=>{'advisories'=>[{'affected_versions'=>'<804.029','cves'=>['CVE-2006-4484' ],'description'=>'Buffer overflow in the LWZReadByte_ function in the GD extension in allows remote attackers to have an unknown impact via a GIF file with input_code_size greater than MAX_LWZ_BITS, which triggers an overflow when initializing the table array.
  ','distribution'=>'Tk','fixed_versions'=>'>=804.029','id'=>'CPANSA-Tk-2008-01','references'=>['https://metacpan.org/changes/distribution/Tk' ],'reported'=>'2008-10-01' }],'main_module'=>'Tk','versions'=>[{'date'=>'1995-08-22T23:03:30','version'=>0 },{'date'=>'1995-12-19T01:56:04','version'=>0 },{'date'=>'1996-08-29T00:19:01','version'=>0 },{'date'=>'1996-09-07T01:08:44','version'=>'400.200' },{'date'=>'1997-01-08T23:27:30','version'=>'400.201' },{'date'=>'1997-01-25T12:33:02','version'=>'400.202' },{'date'=>'1997-05-04T20:05:58','version'=>'402.000' },{'date'=>'1997-06-14T19:17:26','version'=>'402.001' },{'date'=>'1997-07-18T17:01:40','version'=>'402.002' },{'date'=>'1997-10-04T15:32:53','version'=>'402.003' },{'date'=>'1998-01-25T17:07:27','version'=>'402.004' },{'date'=>'1998-02-07T21:22:00','version'=>'402.003' },{'date'=>'1998-02-22T19:34:11','version'=>'800.000' },{'date'=>'1998-03-02T00:12:00','version'=>'800.0_01' },{'date'=>'1998-03-09T22:37:37','version'=>'800.0_02' },{'date'=>'1998-03-17T13:43:00','version'=>'402.003' },{'date'=>'1998-04-01T04:36:00','version'=>'402.003' },{'date'=>'1998-04-02T18:32:00','version'=>'402.003' },{'date'=>'1998-04-05T08:37:23','version'=>'800.003' },{'date'=>'1998-04-19T17:23:45','version'=>'800.004' },{'date'=>'1998-05-17T18:07:11','version'=>'800.005' },{'date'=>'1998-06-14T20:30:35','version'=>'800.006' },{'date'=>'1998-06-26T16:30:23','version'=>'800.007' },{'date'=>'1998-07-17T16:47:42','version'=>'800.008' },{'date'=>'1998-08-08T19:31:23','version'=>'800.010' },{'date'=>'1998-09-01T17:20:02','version'=>'800.011' },{'date'=>'1998-11-15T14:28:04','version'=>'800.012' },{'date'=>'1999-03-16T22:13:10','version'=>'800.013' },{'date'=>'1999-04-05T20:15:39','version'=>'800.014' },{'date'=>'1999-07-28T22:10:03','version'=>'800.015' },{'date'=>'2000-01-08T12:48:56','version'=>'800.017' },{'date'=>'2000-01-08T12:58:16','version'=>'800.0_16' },{'date'=>'2000-01-22T19:44:55','version'=>'800.018' },{'date'=>'2000-03-13T16:39:08','version'=>'800.019' },{'date'=>'2000-03-27T17:01:22','version'=>'800.020' },{'date'=>'2000-04-21T13:38:21','version'=>'800.021' },{'date'=>'2000-05-13T09:48:51','version'=>'800.022' },{'date'=>'2001-05-15T15:07:21','version'=>'800.023' },{'date'=>'2001-07-14T21:06:00','version'=>'800.012' },{'date'=>'2002-03-05T16:38:25','version'=>'800.024' },{'date'=>'2002-03-17T20:30:42','version'=>'800.024' },{'date'=>'2002-10-13T17:20:55','version'=>'804.0_24' },{'date'=>'2003-05-02T01:10:54','version'=>'v804.024.' },{'date'=>'2003-09-08T08:13:16','version'=>'800.025' },{'date'=>'2003-09-28T18:01:55','version'=>'804.025' },{'date'=>'2003-10-10T18:24:24','version'=>'804.025' },{'date'=>'2003-10-20T20:44:44','version'=>'804.025' },{'date'=>'2003-10-27T08:23:07','version'=>'804.025' },{'date'=>'2003-11-02T22:28:10','version'=>'804.025' },{'date'=>'2003-11-16T22:15:42','version'=>'804.025' },{'date'=>'2003-12-02T21:26:56','version'=>'804.025' },{'date'=>'2003-12-08T08:01:15','version'=>'804.025_' },{'date'=>'2003-12-11T08:03:20','version'=>'804.025' },{'date'=>'2003-12-14T20:22:05','version'=>'804.025' },{'date'=>'2003-12-19T17:42:32','version'=>'804.025' },{'date'=>'2003-12-21T21:09:10','version'=>'804.025_' },{'date'=>'2003-12-23T23:19:20','version'=>'804.025' },{'date'=>'2004-01-12T21:59:01','version'=>'804.025' },{'date'=>'2004-02-28T17:33:01','version'=>'804.025_' },{'date'=>'2004-03-07T20:33:56','version'=>'804.025_' },{'date'=>'2004-03-19T08:10:49','version'=>'804.026' },{'date'=>'2004-04-11T19:04:25','version'=>'804.026' },{'date'=>'2007-02-11T08:49:16','version'=>'804.027_500' },{'date'=>'2007-09-21T22:57:57','version'=>'804.027_501' },{'date'=>'2007-12-04T21:03:29','version'=>'804.027_502' },{'date'=>'2007-12-18T22:01:39','version'=>'804.028' },{'date'=>'2008-10-01T21:48:52','version'=>'804.0285' },{'date'=>'2008-11-04T22:27:51','version'=>'804.028501' },{'date'=>'2010-01-30T17:54:07','version'=>'804.028502' },{'date'=>'2010-05-13T00:00:04','version'=>'804.028503' },{'date'=>'2010-05-27T19:25:41','version'=>'804.029' },{'date'=>'2011-06-13T17:53:20','version'=>'804.0295' },{'date'=>'2011-10-14T19:22:48','version'=>'804.029501' },{'date'=>'2011-10-17T21:12:41','version'=>'804.029502' },{'date'=>'2011-10-20T21:08:12','version'=>'804.03' },{'date'=>'2013-05-17T22:16:24','version'=>'804.030500' },{'date'=>'2013-05-18T05:01:41','version'=>'804.030501' },{'date'=>'2013-05-21T07:30:50','version'=>'804.030502' },{'date'=>'2013-05-25T12:57:05','version'=>'804.031' },{'date'=>'2013-11-17T11:24:41','version'=>'804.031500' },{'date'=>'2013-11-18T20:19:08','version'=>'804.031501' },{'date'=>'2013-12-01T15:07:28','version'=>'804.031502' },{'date'=>'2013-12-07T13:00:14','version'=>'804.031503' },{'date'=>'2014-01-26T17:01:07','version'=>'804.032' },{'date'=>'2014-11-06T21:01:44','version'=>'804.032500' },{'date'=>'2015-01-31T10:28:08','version'=>'804.032501' },{'date'=>'2015-02-21T15:54:08','version'=>'804.033' },{'date'=>'2017-08-20T09:29:42','version'=>'804.033500' },{'date'=>'2017-08-26T15:26:56','version'=>'804.034' }]},'UI-Dialog'=>{'advisories'=>[{'affected_versions'=>'<1.11','description'=>'Allows remote attackers to execute arbitrary commands.
  ','distribution'=>'UI-Dialog','fixed_versions'=>'>=1.11','id'=>'CPANSA-UI-Dialog-2015-01','references'=>['https://metacpan.org/changes/distribution/UI-Dialog' ],'reported'=>'2015-10-10' },{'affected_versions'=>'<1.03','description'=>'CDialog and Whiptail backends usage of the temp files.
  ','distribution'=>'UI-Dialog','fixed_versions'=>'>=1.03','id'=>'CPANSA-UI-Dialog-2004-01','references'=>['https://metacpan.org/changes/distribution/UI-Dialog' ],'reported'=>'2004-02-18' }],'main_module'=>'UI::Dialog','versions'=>[{'date'=>'2004-01-04T10:51:34','version'=>'1.00' },{'date'=>'2004-01-13T00:08:39','version'=>'1.01' },{'date'=>'2004-02-15T11:03:37','version'=>'1.02' },{'date'=>'2004-02-18T16:52:59','version'=>'1.03' },{'date'=>'2004-02-22T18:34:25','version'=>'1.04' },{'date'=>'2004-03-18T02:12:03','version'=>'1.05' },{'date'=>'2004-03-18T16:01:50','version'=>'1.06' },{'date'=>'2004-07-21T19:59:51','version'=>'1.07' },{'date'=>'2004-10-05T00:46:22','version'=>'1.08' },{'date'=>'2013-08-10T09:39:07','version'=>'1.09' },{'date'=>'2013-08-10T17:09:57','version'=>'1.09' },{'date'=>'2013-08-19T17:22:00','version'=>'1.09' },{'date'=>'2016-01-19T19:05:07','version'=>'1.11' },{'date'=>'2016-01-22T06:42:45','version'=>'1.12' },{'date'=>'2016-01-30T21:24:56','version'=>'1.13' },{'date'=>'2016-02-03T02:10:12','version'=>'1.14' },{'date'=>'2016-02-09T00:11:17','version'=>'1.15' },{'date'=>'2016-02-10T02:57:43','version'=>'1.16' },{'date'=>'2016-02-12T05:25:14','version'=>'1.17' },{'date'=>'2016-02-13T02:56:26','version'=>'1.18' },{'date'=>'2016-02-21T23:33:48','version'=>'1.19' },{'date'=>'2016-03-07T02:15:26','version'=>'1.20' },{'date'=>'2016-04-02T22:17:32','version'=>'1.21' }]},'XML-LibXML'=>{'advisories'=>[{'affected_versions'=>'<2.0120','cves'=>['CVE-2015-3451' ],'description'=>'The _clone function does not properly set the expand_entities option, which allows remote attackers to conduct XML external entity (XXE) attacks via crafted XML data to the (1) new or (2) load_xml function.
  ','distribution'=>'XML-LibXML','fixed_versions'=>'>=2.0120','id'=>'CPANSA-XML-LibXML-2015-01','references'=>['https://metacpan.org/changes/distribution/XML-LibXML' ],'reported'=>'2015-04-23' }],'main_module'=>'XML::LibXML','versions'=>[{'date'=>'2001-05-18T11:31:21','version'=>'0.91' },{'date'=>'2001-06-03T07:47:14','version'=>'0.92' },{'date'=>'2001-06-09T16:52:26','version'=>'0.93' },{'date'=>'2001-06-10T08:54:23','version'=>'0.94' },{'date'=>'2001-06-21T10:07:56','version'=>'0.96' },{'date'=>'2001-06-29T20:39:47','version'=>'0.97' },{'date'=>'2001-07-20T16:08:25','version'=>'0.99' },{'date'=>'2001-08-07T10:13:29','version'=>'1.00' },{'date'=>'2001-11-14T11:39:59','version'=>'1.30' },{'date'=>'2001-11-25T17:25:52','version'=>'1.31' },{'date'=>'2002-03-13T14:24:12','version'=>'1.40' },{'date'=>'2002-05-11T21:07:22','version'=>'1.49' },{'date'=>'2002-05-20T11:33:20','version'=>'1.50' },{'date'=>'2002-05-31T16:53:50','version'=>'1.51' },{'date'=>'2002-06-12T10:16:35','version'=>'1.52' },{'date'=>'2002-09-14T21:02:38','version'=>'1.53' },{'date'=>'2002-10-26T15:21:51','version'=>'1.54_0' },{'date'=>'2002-11-08T10:03:05','version'=>'1.54_1' },{'date'=>'2002-11-08T18:15:20','version'=>'1.54_2' },{'date'=>'2002-11-15T20:14:58','version'=>'1.54_3' },{'date'=>'2003-05-22T23:44:39','version'=>'1.54_4' },{'date'=>'2003-05-30T18:46:39','version'=>'1.54' },{'date'=>'2003-08-19T21:15:43','version'=>'1.55' },{'date'=>'2003-08-25T13:39:01','version'=>'1.56' },{'date'=>'2004-02-29T16:56:42','version'=>'1.57' },{'date'=>'2004-03-31T19:49:55','version'=>'1.58' },{'date'=>'2004-04-04T11:42:03','version'=>'1.58_1' },{'date'=>'2006-08-02T10:59:49','version'=>'1.59' },{'date'=>'2006-08-26T18:11:05','version'=>'1.60' },{'date'=>'2006-09-24T15:43:20','version'=>'1.61' },{'date'=>'2006-09-25T07:21:39','version'=>'1.61' },{'date'=>'2006-09-25T07:42:26','version'=>'1.61' },{'date'=>'2006-09-25T11:38:04','version'=>'1.61' },{'date'=>'2006-11-18T09:57:51','version'=>'1.62' },{'date'=>'2006-11-25T09:10:37','version'=>'1.62' },{'date'=>'2007-04-16T11:46:21','version'=>'1.63' },{'date'=>'2007-09-09T21:51:03','version'=>'1.64' },{'date'=>'2007-09-25T16:37:46','version'=>'1.65' },{'date'=>'2008-01-29T21:10:45','version'=>'1.66' },{'date'=>'2008-11-04T14:26:16','version'=>'1.67' },{'date'=>'2008-11-05T13:32:59','version'=>'1.68' },{'date'=>'2008-11-11T21:00:56','version'=>'1.69' },{'date'=>'2009-01-23T22:30:52','version'=>'1.69_1' },{'date'=>'2009-02-06T19:12:24','version'=>'1.69_2' },{'date'=>'2009-10-07T12:31:25','version'=>'1.70' },{'date'=>'2011-06-14T17:01:30','version'=>'1.71' },{'date'=>'2011-06-16T16:40:11','version'=>'1.72' },{'date'=>'2011-06-18T08:35:40','version'=>'1.73' },{'date'=>'2011-06-23T12:27:53','version'=>'1.74' },{'date'=>'2011-06-24T16:02:54','version'=>'1.75' },{'date'=>'2011-06-30T18:20:41','version'=>'1.76' },{'date'=>'2011-07-01T19:31:51','version'=>'1.77' },{'date'=>'2011-07-06T17:27:49','version'=>'1.78' },{'date'=>'2011-07-08T17:06:33','version'=>'1.79' },{'date'=>'2011-07-12T20:39:51','version'=>'1.80' },{'date'=>'2011-07-16T15:36:21','version'=>'1.81' },{'date'=>'2011-07-20T20:49:05','version'=>'1.82' },{'date'=>'2011-07-23T11:34:22','version'=>'1.83' },{'date'=>'2011-07-23T20:17:26','version'=>'1.84' },{'date'=>'2011-08-24T14:08:28','version'=>'1.85' },{'date'=>'2011-08-25T08:46:56','version'=>'1.86' },{'date'=>'2011-08-27T11:07:44','version'=>'1.87' },{'date'=>'2011-09-21T10:01:23','version'=>'1.88' },{'date'=>'2011-12-24T07:47:30','version'=>'1.89' },{'date'=>'2012-01-08T19:01:33','version'=>'1.90' },{'date'=>'2012-02-21T12:02:10','version'=>'1.91' },{'date'=>'2012-02-21T17:03:56','version'=>'1.92' },{'date'=>'2012-02-27T09:18:12','version'=>'1.93' },{'date'=>'2012-03-03T20:10:26','version'=>'1.94' },{'date'=>'2012-03-06T08:42:27','version'=>'1.95' },{'date'=>'2012-03-16T19:05:40','version'=>'1.96' },{'date'=>'2012-04-30T17:35:11','version'=>'1.97' },{'date'=>'2012-05-13T18:06:03','version'=>'1.98' },{'date'=>'2012-05-31T07:25:35','version'=>'1.99' },{'date'=>'2012-06-19T20:07:27','version'=>'2.0000' },{'date'=>'2012-06-20T16:53:03','version'=>'2.0001' },{'date'=>'2012-07-08T15:12:36','version'=>'2.0002' },{'date'=>'2012-07-27T15:22:53','version'=>'2.0003' },{'date'=>'2012-08-07T20:06:48','version'=>'2.0004' },{'date'=>'2012-10-13T11:23:03','version'=>'2.0005' },{'date'=>'2012-10-13T20:34:57','version'=>'2.0006' },{'date'=>'2012-10-17T17:05:13','version'=>'2.0007' },{'date'=>'2012-10-22T10:13:20','version'=>'2.0008' },{'date'=>'2012-11-01T14:29:13','version'=>'2.0009' },{'date'=>'2012-11-01T18:16:34','version'=>'2.0010' },{'date'=>'2012-11-07T22:29:47','version'=>'2.0011' },{'date'=>'2012-11-09T04:42:04','version'=>'2.0012' },{'date'=>'2012-12-04T15:46:46','version'=>'2.0013' },{'date'=>'2012-12-05T09:13:26','version'=>'2.0014' },{'date'=>'2013-04-12T23:35:55','version'=>'2.0015' },{'date'=>'2013-04-13T19:39:51','version'=>'2.0016' },{'date'=>'2013-05-09T08:07:47','version'=>'2.0017' },{'date'=>'2013-05-13T10:44:19','version'=>'2.0018' },{'date'=>'2013-07-01T08:08:50','version'=>'2.0019' },{'date'=>'2013-08-14T05:27:26','version'=>'2.0100' },{'date'=>'2013-08-15T05:34:30','version'=>'2.0101' },{'date'=>'2013-08-19T12:18:31','version'=>'2.0102' },{'date'=>'2013-08-22T05:35:19','version'=>'2.0103' },{'date'=>'2013-08-30T09:38:04','version'=>'2.0104' },{'date'=>'2013-09-07T17:24:00','version'=>'2.0105' },{'date'=>'2013-09-17T16:14:51','version'=>'2.0106' },{'date'=>'2013-10-31T07:16:02','version'=>'2.0107' },{'date'=>'2013-12-17T09:10:53','version'=>'2.0108' },{'date'=>'2014-01-31T08:01:23','version'=>'2.0109' },{'date'=>'2014-02-01T14:14:02','version'=>'2.0110' },{'date'=>'2014-03-05T15:31:25','version'=>'2.0111' },{'date'=>'2014-03-13T18:19:10','version'=>'2.0112' },{'date'=>'2014-03-14T12:15:54','version'=>'2.0113' },{'date'=>'2014-04-03T13:01:06','version'=>'2.0114' },{'date'=>'2014-04-03T13:15:41','version'=>'2.0115' },{'date'=>'2014-04-12T08:10:37','version'=>'2.0116' },{'date'=>'2014-10-26T16:31:29','version'=>'2.0117' },{'date'=>'2015-02-05T10:57:03','version'=>'2.0118' },{'date'=>'2015-04-23T07:14:45','version'=>'2.0119' },{'date'=>'2015-05-01T09:50:18','version'=>'2.0120' },{'date'=>'2015-05-03T12:08:06','version'=>'2.0121' },{'date'=>'2015-09-01T09:02:29','version'=>'2.0122' },{'date'=>'2015-12-06T13:19:22','version'=>'2.0123' },{'date'=>'2016-02-27T11:21:08','version'=>'2.0124' },{'date'=>'2016-05-30T09:24:51','version'=>'2.0125' },{'date'=>'2016-06-24T16:21:00','version'=>'2.0126' },{'date'=>'2016-07-22T17:40:51','version'=>'2.0127' },{'date'=>'2016-07-24T09:15:48','version'=>'2.0128' },{'date'=>'2017-03-14T13:37:23','version'=>'2.0129' },{'date'=>'2017-10-18T08:45:49','version'=>'2.0130' },{'date'=>'2017-10-24T08:57:20','version'=>'2.0131' },{'date'=>'2017-10-28T17:58:34','version'=>'2.0132' },{'date'=>'2019-02-02T11:11:30','version'=>'2.0133' },{'date'=>'2019-02-10T15:02:55','version'=>'2.0134' }]},'libapreq2'=>{'advisories'=>[{'affected_versions'=>'<2.07','cves'=>['CVE-2006-0042' ],'description'=>'Unspecified vulnerability in apreq_parse_headers and apreq_parse_urlencoded functions in Apache2::Request (Libapreq2) allows remote attackers to cause a denial of service (CPU consumption) via unknown attack vectors that result in quadratic computational complexity.
  ','distribution'=>'libapreq2','fixed_versions'=>'>=2.07','id'=>'CPANSA-libapreq2-2006-01','references'=>['https://metacpan.org/changes/distribution/libapreq2' ],'reported'=>'2007-04-17' }],'main_module'=>'Apache2::Upload','versions'=>[{'date'=>'2003-11-11T01:28:48','version'=>'2.01_03' },{'date'=>'2003-11-16T04:16:12','version'=>'2.02_02' },{'date'=>'2004-06-12T14:52:49','version'=>'2.03_04' },{'date'=>'2004-08-30T16:13:45','version'=>'2.04_03' },{'date'=>'2005-05-04T23:38:05','version'=>'2.05' },{'date'=>'2005-07-20T17:10:48','version'=>'2.06' },{'date'=>'2006-02-12T18:10:47','version'=>'2.07' },{'date'=>'2006-08-09T04:54:07','version'=>'2.08' },{'date'=>'2009-03-13T22:47:11','version'=>'2.12' },{'date'=>'2010-12-02T18:41:57','version'=>'2.13' }]},'libwww-perl'=>{'advisories'=>[{'affected_versions'=>'<6.00','cves'=>['CVE-2011-0633' ],'description'=>'The Net::HTTPS module in libwww-perl (LWP) before 6.00, as used in WWW::Mechanize, LWP::UserAgent, and other products, when running in environments that do not set the If-SSL-Cert-Subject header, does not enable full validation of SSL certificates by default, which allows remote attackers to spoof servers via man-in-the-middle (MITM) attacks involving hostnames that are not properly validated.
  ','distribution'=>'libwww-perl','fixed_versions'=>'>=6.00','id'=>'CPANSA-libwww-perl-2011-01','references'=>['http://vttynotes.blogspot.com/2010/12/man-in-middle-fun-with-perl-lwp.html','http://vttynotes.blogspot.com/2011/03/quick-note-on-lwp-and-perl-security-cve.html' ],'reported'=>'2011-01-20' },{'affected_versions'=>'<5.835','cves'=>['CVE-2010-2253' ],'description'=>'lwp-download in libwww-perl before 5.835 does not reject downloads to filenames that begin with a . (dot) character, which allows remote servers to create or overwrite files via (1) a 3xx redirect to a URL with a crafted filename or (2) a Content-Disposition header that suggests a crafted filename, and possibly execute arbitrary code as a consequence of writing to a dotfile in a home directory.
  ','distribution'=>'libwww-perl','fixed_versions'=>'>=5.835','id'=>'CPANSA-libwww-perl-2010-01','references'=>['http://vttynotes.blogspot.com/2010/12/man-in-middle-fun-with-perl-lwp.html','http://vttynotes.blogspot.com/2011/03/quick-note-on-lwp-and-perl-security-cve.html' ],'reported'=>'2010-07-06' },{'affected_versions'=>'<5.51','description'=>'If LWP::UserAgent::env_proxy is called in a CGI environment, the case-insensitivity when looking for "http_proxy" permits "HTTP_PROXY" to be found, but this can be trivially set by the web client using the "Proxy:" header.
  ','distribution'=>'libwww-perl','fixed_versions'=>'>=5.51','id'=>'CPANSA-libwww-perl-2001-01','reported'=>'2001-03-14' }],'main_module'=>'LWP','versions'=>[{'date'=>'1995-09-16T13:51:35','version'=>'5' },{'date'=>'1995-11-06T14:29:13','version'=>'5' },{'date'=>'1996-05-09T22:43:16','version'=>'5' },{'date'=>'1996-05-26T14:01:51','version'=>'5.00' },{'date'=>'1996-08-02T16:38:58','version'=>'5.01' },{'date'=>'1996-09-11T16:19:57','version'=>'5.02' },{'date'=>'1996-09-30T22:58:37','version'=>'5.03' },{'date'=>'1996-10-22T10:39:33','version'=>'5.04' },{'date'=>'1996-12-04T23:36:17','version'=>'5.05' },{'date'=>'1997-01-27T23:53:38','version'=>'5.06' },{'date'=>'1997-02-11T14:20:18','version'=>'5.07' },{'date'=>'1997-04-05T13:10:16','version'=>'5.08' },{'date'=>'1997-06-10T11:07:01','version'=>'5.09' },{'date'=>'1997-06-20T10:51:10','version'=>'5.10' },{'date'=>'1997-08-06T08:41:11','version'=>'5.11' },{'date'=>'1997-09-05T09:38:58','version'=>'5.12' },{'date'=>'1997-09-20T12:50:59','version'=>'5.13' },{'date'=>'1997-10-12T20:55:32','version'=>'5.14' },{'date'=>'1997-11-06T20:23:06','version'=>'5.15' },{'date'=>'1997-12-12T17:44:29','version'=>'5.18' },{'date'=>'1997-12-16T22:25:00','version'=>'5.18_03' },{'date'=>'1997-12-17T10:08:54','version'=>'5.18_04' },{'date'=>'1998-01-20T18:16:51','version'=>'5.18_05' },{'date'=>'1998-01-26T23:55:39','version'=>'5.19' },{'date'=>'1998-02-12T23:43:23','version'=>'5.20' },{'date'=>'1998-03-12T18:39:08','version'=>'5.21' },{'date'=>'1998-03-24T19:42:54','version'=>'5.22' },{'date'=>'1998-03-31T22:25:14','version'=>'5.30' },{'date'=>'1998-04-10T15:07:10','version'=>'5.31' },{'date'=>'1998-04-17T05:23:45','version'=>'5.32' },{'date'=>'1998-05-07T15:10:00','version'=>'5.33' },{'date'=>'1998-07-07T16:06:51','version'=>'5.34' },{'date'=>'1998-07-09T23:05:12','version'=>'5.35' },{'date'=>'1998-08-04T15:15:44','version'=>'5.36' },{'date'=>'1998-10-12T17:42:28','version'=>'5.40_01' },{'date'=>'1998-11-19T22:17:29','version'=>'5.41' },{'date'=>'1999-03-20T07:52:48','version'=>'5.42' },{'date'=>'1999-05-09T19:26:17','version'=>'5.43' },{'date'=>'1999-06-25T20:34:40','version'=>'5.44' },{'date'=>'1999-09-20T13:36:22','version'=>'5.45' },{'date'=>'1999-10-28T12:30:45','version'=>'5.46' },{'date'=>'1999-11-16T14:59:58','version'=>'5.47' },{'date'=>'2000-04-09T19:45:32','version'=>'5.48' },{'date'=>'2001-01-01T06:35:20','version'=>'5.49' },{'date'=>'2001-01-12T20:58:43','version'=>'5.50' },{'date'=>'2001-03-14T21:33:03','version'=>'5.51' },{'date'=>'2001-03-29T21:39:12','version'=>'5.52' },{'date'=>'2001-04-10T23:15:00','version'=>'5.53' },{'date'=>'2001-04-19T06:13:35','version'=>'5.53_90' },{'date'=>'2001-04-21T05:02:13','version'=>'5.53_91' },{'date'=>'2001-04-25T17:37:11','version'=>'5.53_92' },{'date'=>'2001-04-29T06:28:31','version'=>'5.53_93' },{'date'=>'2001-05-05T13:57:20','version'=>'5.53_94' },{'date'=>'2001-08-07T00:46:18','version'=>'5.53_95' },{'date'=>'2001-08-28T05:59:46','version'=>'5.53_96' },{'date'=>'2001-09-20T00:33:20','version'=>'5.53_97' },{'date'=>'2001-10-26T23:30:57','version'=>'5.60' },{'date'=>'2001-11-17T02:56:46','version'=>'5.61' },{'date'=>'2001-11-21T19:00:47','version'=>'5.62' },{'date'=>'2001-12-14T21:01:09','version'=>'5.63' },{'date'=>'2002-02-09T18:54:35','version'=>'5.64' },{'date'=>'2002-05-31T20:59:15','version'=>'5.65' },{'date'=>'2002-12-20T19:28:34','version'=>'5.66' },{'date'=>'2003-01-01T16:53:11','version'=>'5.67' },{'date'=>'2003-01-03T05:04:44','version'=>'5.68' },{'date'=>'2003-01-24T16:55:35','version'=>'5.69' },{'date'=>'2003-10-13T20:56:35','version'=>'5.70' },{'date'=>'2003-10-14T19:12:56','version'=>'5.71' },{'date'=>'2003-10-15T19:53:47','version'=>'5.72' },{'date'=>'2003-10-19T20:04:40','version'=>'5.73' },{'date'=>'2003-10-23T19:26:57','version'=>'5.74' },{'date'=>'2003-10-26T22:10:48','version'=>'5.75' },{'date'=>'2003-11-21T19:33:09','version'=>'5.76' },{'date'=>'2004-04-06T13:41:45','version'=>'5.77' },{'date'=>'2004-04-07T11:13:36','version'=>'5.78' },{'date'=>'2004-04-13T08:09:08','version'=>'5.79' },{'date'=>'2004-06-16T10:43:42','version'=>'5.800' },{'date'=>'2004-11-12T18:32:17','version'=>'5.801' },{'date'=>'2004-11-30T13:06:01','version'=>'5.802' },{'date'=>'2004-12-11T15:48:30','version'=>'5.803' },{'date'=>'2005-12-06T09:36:12','version'=>'5.804' },{'date'=>'2005-12-08T12:29:02','version'=>'5.805' },{'date'=>'2007-07-19T21:31:44','version'=>'5.806' },{'date'=>'2007-07-31T13:14:54','version'=>'5.807' },{'date'=>'2007-08-05T13:29:17','version'=>'5.808' },{'date'=>'2008-04-08T11:47:19','version'=>'5.810' },{'date'=>'2008-04-14T08:28:19','version'=>'5.811' },{'date'=>'2008-04-16T10:32:51','version'=>'5.812' },{'date'=>'2008-06-17T20:37:17','version'=>'5.813' },{'date'=>'2008-07-25T09:09:53','version'=>'5.814' },{'date'=>'2008-09-24T18:10:11','version'=>'5.815' },{'date'=>'2008-09-29T09:27:09','version'=>'5.816' },{'date'=>'2008-10-10T21:31:27','version'=>'5.817' },{'date'=>'2008-10-16T10:32:24','version'=>'5.818' },{'date'=>'2008-10-20T11:43:37','version'=>'5.819' },{'date'=>'2008-11-05T18:07:29','version'=>'5.820' },{'date'=>'2008-11-25T00:16:49','version'=>'5.821' },{'date'=>'2008-12-05T19:18:40','version'=>'5.822' },{'date'=>'2009-01-12T16:50:02','version'=>'5.823' },{'date'=>'2009-02-13T14:12:29','version'=>'5.824' },{'date'=>'2009-02-16T10:00:35','version'=>'5.825' },{'date'=>'2009-04-24T20:42:45','version'=>'5.826' },{'date'=>'2009-06-15T19:36:37','version'=>'5.827' },{'date'=>'2009-06-25T19:44:55','version'=>'5.828' },{'date'=>'2009-07-08T20:03:11','version'=>'5.829' },{'date'=>'2009-07-26T19:39:49','version'=>'5.830' },{'date'=>'2009-08-13T20:53:34','version'=>'5.831' },{'date'=>'2009-09-21T18:24:41','version'=>'5.832' },{'date'=>'2009-10-06T21:23:39','version'=>'5.833' },{'date'=>'2009-11-21T13:09:14','version'=>'5.834' },{'date'=>'2010-05-05T21:13:47','version'=>'5.835' },{'date'=>'2010-05-13T07:34:58','version'=>'5.836' },{'date'=>'2010-09-20T21:24:38','version'=>'5.837' },{'date'=>'2010-11-04T15:16:35','version'=>'5.837' },{'date'=>'2011-03-08T19:25:05','version'=>'6.00' },{'date'=>'2011-03-09T23:30:57','version'=>'6.01' },{'date'=>'2011-03-27T11:35:01','version'=>'6.02' },{'date'=>'2011-10-15T13:38:28','version'=>'6.03' },{'date'=>'2012-02-18T22:13:13','version'=>'6.04' },{'date'=>'2013-03-11T21:47:56','version'=>'6.05' },{'date'=>'2014-04-16T18:38:49','version'=>'6.06' },{'date'=>'2014-07-02T05:10:47','version'=>'6.07' },{'date'=>'2014-07-25T03:19:43','version'=>'6.08' },{'date'=>'2015-02-10T02:58:40','version'=>'6.09' },{'date'=>'2015-02-12T17:40:48','version'=>'6.10' },{'date'=>'2015-02-13T21:38:49','version'=>'6.11' },{'date'=>'2015-02-14T00:16:15','version'=>'6.12' },{'date'=>'2015-02-14T18:45:12','version'=>'6.13' },{'date'=>'2015-11-25T20:23:47','version'=>'6.14_001' },{'date'=>'2015-12-05T06:01:09','version'=>'6.15' },{'date'=>'2016-01-05T00:29:20','version'=>'6.15_001' },{'date'=>'2016-01-14T01:52:18','version'=>'6.15_002' },{'date'=>'2016-01-14T02:01:20','version'=>'6.15_003' },{'date'=>'2016-02-13T06:18:45','version'=>'6.15_004' },{'date'=>'2017-01-18T14:22:22','version'=>'6.16' },{'date'=>'2017-01-31T19:39:10','version'=>'6.17' },{'date'=>'2017-02-03T20:31:54','version'=>'6.18' },{'date'=>'2017-02-14T19:56:20','version'=>'6.19' },{'date'=>'2017-02-21T15:19:06','version'=>'6.20' },{'date'=>'2017-02-21T20:38:03','version'=>'6.21' },{'date'=>'2017-03-01T15:27:43','version'=>'6.22' },{'date'=>'2017-03-07T03:49:52','version'=>'6.23' },{'date'=>'2017-03-14T16:36:38','version'=>'6.24' },{'date'=>'2017-04-03T17:20:06','version'=>'6.25' },{'date'=>'2017-04-12T15:36:20','version'=>'6.26' },{'date'=>'2017-09-21T22:32:37','version'=>'6.27' },{'date'=>'2017-11-06T15:43:47','version'=>'6.28' },{'date'=>'2017-11-06T20:34:56','version'=>'6.29' },{'date'=>'2017-12-08T01:57:23','version'=>'6.30' },{'date'=>'2017-12-11T01:57:47','version'=>'6.31' },{'date'=>'2018-02-20T19:41:40','version'=>'6.32' },{'date'=>'2018-02-27T04:04:55','version'=>'6.33' },{'date'=>'2018-06-05T18:50:45','version'=>'6.34' },{'date'=>'2018-07-16T04:51:16','version'=>'6.35' },{'date'=>'2018-10-10T02:21:49','version'=>'6.36' },{'date'=>'2019-03-06T20:51:05','version'=>'6.37' }]},'mod_perl'=>{'advisories'=>[{'affected_versions'=>'<1.31','cves'=>['CVE-2009-0796' ],'description'=>'XSS in Apache::Status.
  ','distribution'=>'mod_perl','fixed_versions'=>'>=1.31','id'=>'CPANSA-mod_perl-2009-01','references'=>['https://metacpan.org/changes/distribution/mod_perl' ],'reported'=>'2009-05-11' },{'affected_versions'=>'<1.30','cves'=>['CVE-2007-1349' ],'description'=>'Unescaped variable interpolation in Apache::PerlRun regular expression could cause regex engine tampering.
  ','distribution'=>'mod_perl','fixed_versions'=>'>=1.30','id'=>'CPANSA-mod_perl-2007-01','references'=>['https://metacpan.org/changes/distribution/mod_perl' ],'reported'=>'2007-03-29' }],'main_module'=>'mod_perl2','versions'=>[{'date'=>'1996-05-21T02:07:05','version'=>'0.60' },{'date'=>'1996-05-21T20:51:37','version'=>'0.60' },{'date'=>'1996-06-18T19:41:55','version'=>'0.60' },{'date'=>'1996-06-25T15:49:56','version'=>'0.60' },{'date'=>'1996-07-14T23:39:07','version'=>'0.70' },{'date'=>'1996-07-26T20:39:23','version'=>'0.76' },{'date'=>'1996-09-08T22:13:32','version'=>'0.81' },{'date'=>'1996-10-04T15:50:31','version'=>'0.83_02' },{'date'=>'1996-10-09T07:10:24','version'=>'0.83_03' },{'date'=>'1996-10-14T03:46:54','version'=>'0.83_04' },{'date'=>'1996-10-15T13:34:22','version'=>'0.83_05' },{'date'=>'1996-10-17T03:48:27','version'=>'0.83_06' },{'date'=>'1996-10-18T22:18:01','version'=>'0.83_07' },{'date'=>'1996-10-21T01:37:29','version'=>'0.83_09' },{'date'=>'1996-10-25T14:09:06','version'=>'0.83_10' },{'date'=>'1996-10-28T00:01:00','version'=>'0.84' },{'date'=>'1996-11-13T05:39:14','version'=>'0.85' },{'date'=>'1996-11-14T07:21:01','version'=>'0.85_01' },{'date'=>'1996-11-27T17:19:02','version'=>'0.85_02' },{'date'=>'1996-12-05T03:37:12','version'=>'0.85_03' },{'date'=>'1996-12-10T23:17:33','version'=>'0.85_04' },{'date'=>'1996-12-17T13:31:40','version'=>'0.85_06' },{'date'=>'1996-12-19T14:32:44','version'=>'0.86' },{'date'=>'1996-12-24T04:19:35','version'=>'0.87' },{'date'=>'1996-12-24T20:41:28','version'=>'0.88' },{'date'=>'1996-12-31T04:43:25','version'=>'0.89' },{'date'=>'1996-12-31T07:52:56','version'=>'0.90' },{'date'=>'1997-01-20T10:04:20','version'=>'0.90_01' },{'date'=>'1997-01-23T00:58:22','version'=>'0.91' },{'date'=>'1997-01-23T15:56:19','version'=>'0.92' },{'date'=>'1997-01-28T02:37:30','version'=>'0.93' },{'date'=>'1997-03-05T03:19:32','version'=>'0.93_01' },{'date'=>'1997-03-10T12:07:39','version'=>'0.94' },{'date'=>'1997-03-23T18:53:46','version'=>'0.95' },{'date'=>'1997-03-23T18:54:02','version'=>'0.95_02' },{'date'=>'1997-04-01T04:44:44','version'=>'0.95_03' },{'date'=>'1997-04-02T01:35:22','version'=>'0.95_04' },{'date'=>'1997-04-02T03:20:37','version'=>'0.95_05' },{'date'=>'1997-04-02T04:42:28','version'=>'0.95_06' },{'date'=>'1997-04-04T05:33:39','version'=>'0.96' },{'date'=>'1997-04-16T03:54:02','version'=>'0.97' },{'date'=>'1997-04-23T03:29:01','version'=>'0.97_01' },{'date'=>'1997-04-30T03:56:50','version'=>'0.97_02' },{'date'=>'1997-05-02T19:58:12','version'=>'0.98' },{'date'=>'1997-05-19T22:59:20','version'=>'0.98_03' },{'date'=>'1997-05-23T00:24:28','version'=>'0.98_05' },{'date'=>'1997-05-30T02:07:03','version'=>'0.98_08' },{'date'=>'1997-06-02T00:05:45','version'=>'0.98_09' },{'date'=>'1997-06-03T03:15:48','version'=>'0.98_10' },{'date'=>'1997-06-04T01:54:46','version'=>'0.98_11' },{'date'=>'1997-06-06T01:14:09','version'=>'0.98_12' },{'date'=>'1997-06-12T00:36:43','version'=>'0.99' },{'date'=>'1997-06-30T03:04:22','version'=>'1.00' },{'date'=>'1997-07-08T06:20:15','version'=>'1.00' },{'date'=>'1997-07-30T20:57:59','version'=>'1.00' },{'date'=>'1997-08-25T22:00:29','version'=>'0.85_05' },{'date'=>'1997-09-16T01:09:06','version'=>'1.00_02' },{'date'=>'1997-09-21T21:40:32','version'=>'1.00_03' },{'date'=>'1997-10-17T00:04:35','version'=>'1.01' },{'date'=>'1997-10-17T15:40:45','version'=>'1.02' },{'date'=>'1997-10-24T04:02:30','version'=>'1.03' },{'date'=>'1997-10-31T03:59:22','version'=>'1.04' },{'date'=>'1997-11-07T04:32:07','version'=>'1.05' },{'date'=>'1997-11-26T02:09:01','version'=>'1.07' },{'date'=>'1997-12-02T21:34:03','version'=>'1.07_01' },{'date'=>'1997-12-22T09:29:56','version'=>'1.07_02' },{'date'=>'1998-01-08T10:21:31','version'=>'1.07_03' },{'date'=>'1998-01-28T02:10:28','version'=>'1.07_03' },{'date'=>'1998-01-29T00:47:52','version'=>'1.07_03' },{'date'=>'1998-02-10T11:04:03','version'=>'1.07_04' },{'date'=>'1998-02-12T15:08:20','version'=>'1.07_04' },{'date'=>'1998-02-20T03:43:49','version'=>'1.08' },{'date'=>'1998-03-07T01:06:09','version'=>'1.08' },{'date'=>'1998-03-19T07:39:18','version'=>'1.09' },{'date'=>'1998-03-21T04:14:02','version'=>'1.10' },{'date'=>'1998-03-27T16:52:20','version'=>'1.10' },{'date'=>'1998-04-21T14:43:05','version'=>'1.11' },{'date'=>'1998-04-24T18:58:30','version'=>'1.11' },{'date'=>'1998-06-09T16:51:19','version'=>'1.11' },{'date'=>'1998-06-14T19:21:25','version'=>'1.12' },{'date'=>'1998-07-14T01:13:07','version'=>'1.13' },{'date'=>'1998-07-19T00:19:20','version'=>'1.14' },{'date'=>'1998-07-24T13:52:53','version'=>'1.15' },{'date'=>'1998-07-24T15:59:13','version'=>'1.15' },{'date'=>'1998-09-20T00:02:57','version'=>'1.15_01' },{'date'=>'1998-10-02T23:10:02','version'=>'1.16' },{'date'=>'1998-10-28T18:16:45','version'=>'1.16' },{'date'=>'1998-11-24T23:54:59','version'=>'1.16_01' },{'date'=>'1998-12-01T00:01:25','version'=>'1.16_02' },{'date'=>'1999-01-28T06:27:45','version'=>'1.18' },{'date'=>'1999-06-11T17:22:35','version'=>'1.20' },{'date'=>'1999-07-02T23:43:56','version'=>'1.21' },{'date'=>'2000-03-06T01:32:31','version'=>'1.21_01' },{'date'=>'2000-03-07T07:56:53','version'=>'1.21_02' },{'date'=>'2000-03-15T10:25:52','version'=>'1.21_03' },{'date'=>'2000-03-23T06:51:53','version'=>'1.22' },{'date'=>'2000-04-21T06:51:47','version'=>'1.23' },{'date'=>'2000-05-17T05:44:34','version'=>'1.24' },{'date'=>'2000-10-10T16:44:39','version'=>'1.24_01' },{'date'=>'2001-01-30T04:33:45','version'=>'1.25' },{'date'=>'2001-07-06T21:27:16','version'=>'1.25_01' },{'date'=>'2001-07-12T02:23:32','version'=>'1.26' },{'date'=>'2002-04-07T04:58:26','version'=>'1.99_01' },{'date'=>'2002-06-02T03:05:50','version'=>'1.27' },{'date'=>'2002-06-02T03:27:13','version'=>'1.99_02' },{'date'=>'2002-06-15T23:59:37','version'=>'1.99_03' },{'date'=>'2002-06-21T22:45:41','version'=>'1.99_04' },{'date'=>'2002-08-20T16:54:13','version'=>'1.99_05' },{'date'=>'2002-09-27T15:19:03','version'=>'1.99_06' },{'date'=>'2002-09-27T19:41:50','version'=>'1.99_07' },{'date'=>'2003-01-11T04:22:19','version'=>'1.99_08' },{'date'=>'2003-04-28T02:36:59','version'=>'1.99_09' },{'date'=>'2003-07-03T03:32:20','version'=>'1.28' },{'date'=>'2003-09-29T17:11:24','version'=>'1.99_10' },{'date'=>'2003-10-08T04:54:22','version'=>'1.29' },{'date'=>'2003-11-10T21:04:15','version'=>'1.99_11' },{'date'=>'2003-12-22T19:56:22','version'=>'1.99_12' },{'date'=>'2004-03-09T00:29:43','version'=>'1.99_13' },{'date'=>'2004-05-21T18:02:49','version'=>'1.99_14' },{'date'=>'2004-08-20T18:35:12','version'=>'1.99_15' },{'date'=>'2004-08-23T05:59:47','version'=>'1.99_16' },{'date'=>'2004-10-22T21:38:19','version'=>'1.99_17' },{'date'=>'2004-12-12T23:22:37','version'=>'v2.0.0' },{'date'=>'2004-12-23T23:38:49','version'=>'v2.0.0' },{'date'=>'2005-01-06T01:27:43','version'=>'v2.0.0' },{'date'=>'2005-01-22T08:55:19','version'=>'v2.0.0' },{'date'=>'2005-04-14T13:19:23','version'=>'v2.0.0' },{'date'=>'2005-05-04T02:48:58','version'=>'v2.0.0' },{'date'=>'2005-05-20T05:12:45','version'=>'v2.0.0' },{'date'=>'2005-06-17T21:05:23','version'=>'v2.0.1' },{'date'=>'2005-10-21T01:27:23','version'=>'v2.0.2' },{'date'=>'2006-11-29T08:29:30','version'=>'v2.0.3' },{'date'=>'2007-03-30T06:19:02','version'=>'1.30' },{'date'=>'2008-04-17T06:32:36','version'=>'v2.0.4' },{'date'=>'2009-05-13T02:29:50','version'=>'1.31' },{'date'=>'2011-02-07T23:31:36','version'=>'v2.0.5' },{'date'=>'2012-04-25T15:31:27','version'=>'v2.0.6' },{'date'=>'2012-06-06T02:40:24','version'=>'v2.0.7' },{'date'=>'2013-04-18T02:15:56','version'=>'2.0.8' },{'date'=>'2015-06-18T21:16:34','version'=>'2.0.9' },{'date'=>'2016-10-27T21:16:36','version'=>'2.0.10' }]}},'module2dist'=>{'APR'=>'mod_perl','APR::Base64'=>'mod_perl','APR::Brigade'=>'mod_perl','APR::Bucket'=>'mod_perl','APR::BucketAlloc'=>'mod_perl','APR::BucketType'=>'mod_perl','APR::Const'=>'mod_perl','APR::Date'=>'mod_perl','APR::Error'=>'mod_perl','APR::Finfo'=>'mod_perl','APR::FunctionTable'=>'mod_perl','APR::IpSubnet'=>'mod_perl','APR::OS'=>'mod_perl','APR::PerlIO'=>'mod_perl','APR::Pool'=>'mod_perl','APR::Request'=>'libapreq2','APR::Request::Apache2'=>'libapreq2','APR::Request::CGI'=>'libapreq2','APR::Request::Cookie'=>'libapreq2','APR::Request::Error'=>'libapreq2','APR::Request::Param'=>'libapreq2','APR::SockAddr'=>'mod_perl','APR::Socket'=>'mod_perl','APR::Status'=>'mod_perl','APR::String'=>'mod_perl','APR::Table'=>'mod_perl','APR::ThreadMutex'=>'mod_perl','APR::ThreadRWLock'=>'mod_perl','APR::URI'=>'mod_perl','APR::UUID'=>'mod_perl','APR::Util'=>'mod_perl','APR::XSLoader'=>'mod_perl','Apache'=>'mod_perl','Apache2::Access'=>'mod_perl','Apache2::Build'=>'mod_perl','Apache2::CmdParms'=>'mod_perl','Apache2::Command'=>'mod_perl','Apache2::Connection'=>'mod_perl','Apache2::ConnectionUtil'=>'mod_perl','Apache2::ConstantsTable'=>'mod_perl','Apache2::Cookie'=>'libapreq2','Apache2::Directive'=>'mod_perl','Apache2::Filter'=>'mod_perl','Apache2::FilterRec'=>'mod_perl','Apache2::FunctionTable'=>'mod_perl','Apache2::HookRun'=>'mod_perl','Apache2::Log'=>'mod_perl','Apache2::MPM'=>'mod_perl','Apache2::Module'=>'mod_perl','Apache2::ParseSource'=>'mod_perl','Apache2::ParseSource::Scan'=>'mod_perl','Apache2::PerlSections'=>'mod_perl','Apache2::PerlSections::Dump'=>'mod_perl','Apache2::Process'=>'mod_perl','Apache2::Provider'=>'mod_perl','Apache2::Request'=>'libapreq2','Apache2::RequestIO'=>'mod_perl','Apache2::RequestRec'=>'mod_perl','Apache2::RequestUtil'=>'mod_perl','Apache2::Resource'=>'mod_perl','Apache2::Response'=>'mod_perl','Apache2::ServerRec'=>'mod_perl','Apache2::ServerUtil'=>'mod_perl','Apache2::SourceTables'=>'mod_perl','Apache2::Status'=>'mod_perl','Apache2::Status::_version'=>'mod_perl','Apache2::StructureTable'=>'mod_perl','Apache2::SubProcess'=>'mod_perl','Apache2::SubRequest'=>'mod_perl','Apache2::URI'=>'mod_perl','Apache2::Upload'=>'libapreq2','Apache2::Util'=>'mod_perl','Apache2::XSLoader'=>'mod_perl','Apache2::compat'=>'mod_perl','Apache2::porting'=>'mod_perl','Apache::AuthCAS'=>'Apache-AuthCAS','Apache::Connection'=>'mod_perl','Apache::Constants'=>'mod_perl','Apache::Constants::Exports'=>'mod_perl','Apache::Debug'=>'mod_perl','Apache::ExtUtils'=>'mod_perl','Apache::FakeRequest'=>'mod_perl','Apache::File'=>'mod_perl','Apache::Include'=>'mod_perl','Apache::Leak'=>'mod_perl','Apache::Log'=>'mod_perl','Apache::ModuleConfig'=>'mod_perl','Apache::Opcode'=>'mod_perl','Apache::Options'=>'mod_perl','Apache::PerlRun'=>'mod_perl','Apache::PerlRunXS'=>'mod_perl','Apache::PerlSections'=>'mod_perl','Apache::ReadConfig'=>'mod_perl','Apache::RedirectLogFix'=>'mod_perl','Apache::Registry'=>'mod_perl','Apache::RegistryBB'=>'mod_perl','Apache::RegistryLoader'=>'mod_perl','Apache::RegistryNG'=>'mod_perl','Apache::Resource'=>'mod_perl','Apache::SIG'=>'mod_perl','Apache::SOAP'=>'SOAP-Lite','Apache::Server'=>'mod_perl','Apache::SessionX'=>'Apache-SessionX','Apache::SessionX::Generate::MD5'=>'Apache-SessionX','Apache::SessionX::Manager'=>'Apache-SessionX','Apache::SessionX::Store::File'=>'Apache-SessionX','Apache::StatINC'=>'mod_perl','Apache::Status'=>'mod_perl','Apache::Symbol'=>'mod_perl','Apache::Symdump'=>'mod_perl','Apache::Table'=>'mod_perl','Apache::URI'=>'mod_perl','Apache::Util'=>'mod_perl','Apache::XMLRPC::Lite'=>'SOAP-Lite','Apache::fork'=>'mod_perl','Apache::httpd_conf'=>'mod_perl','Apache::src'=>'mod_perl','Apache::testold'=>'mod_perl','App::Cpan'=>'CPAN','App::Github::Email'=>'App-Github-Email','App::Packer::Backend::PAR'=>'PAR','App::Packer::PAR'=>'PAR-Packer','App::Packer::Temp'=>'PAR','Archive::Tar'=>'Archive-Tar','Archive::Tar::Constant'=>'Archive-Tar','Archive::Tar::File'=>'Archive-Tar','Archive::Tar::Std'=>'Archive-Tar','Archive::Tar::Std::_io'=>'Archive-Tar','Archive::Tar::Win32'=>'Archive-Tar','Archive::Tar::_io'=>'Archive-Tar','Archive::Zip'=>'Archive-Zip','Archive::Zip::Archive'=>'Archive-Zip','Archive::Zip::BufferedFileHandle'=>'Archive-Zip','Archive::Zip::DirectoryMember'=>'Archive-Zip','Archive::Zip::FileMember'=>'Archive-Zip','Archive::Zip::Member'=>'Archive-Zip','Archive::Zip::MemberRead'=>'Archive-Zip','Archive::Zip::MockFileHandle'=>'Archive-Zip','Archive::Zip::NewFileMember'=>'Archive-Zip','Archive::Zip::StringMember'=>'Archive-Zip','Archive::Zip::Tree'=>'Archive-Zip','Archive::Zip::ZipFileMember'=>'Archive-Zip','Bio::DB::GFF::Aggregator::match_gap'=>'GBrowse','Bio::DB::GFF::Aggregator::reftranscript'=>'GBrowse','Bio::DB::GFF::Aggregator::waba_alignment'=>'GBrowse','Bio::DB::GFF::Aggregator::wormbase_gene'=>'GBrowse','Bio::DB::SeqFeature::Store::Alias'=>'GBrowse','Bio::DB::SeqFeature::Store::Alias::Iterator'=>'GBrowse','Bio::DB::SeqFeature::Store::Alias::Segment'=>'GBrowse','Bio::DB::SeqFeature::Store::BedLoader'=>'GBrowse','Bio::DB::Tagger'=>'GBrowse','Bio::DB::Tagger::Iterator'=>'GBrowse','Bio::DB::Tagger::Tag'=>'GBrowse','Bio::DB::Tagger::mysql'=>'GBrowse','Bio::Graphics::Browser2'=>'GBrowse','Bio::Graphics::Browser2::Action'=>'GBrowse','Bio::Graphics::Browser2::AdminTracks'=>'GBrowse','Bio::Graphics::Browser2::AuthorizedFeatureFile'=>'GBrowse','Bio::Graphics::Browser2::CAlign'=>'GBrowse','Bio::Graphics::Browser2::CachedTrack'=>'GBrowse','Bio::Graphics::Browser2::DataBase'=>'GBrowse','Bio::Graphics::Browser2::DataLoader'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::archive'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::bam'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::bed'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::bigbed'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::bigwig'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::featurefile'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::generic'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::gff'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::gff3'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::sam'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::useq'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::wig2bigwig'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::wiggle'=>'GBrowse','Bio::Graphics::Browser2::DataSource'=>'GBrowse','Bio::Graphics::Browser2::ExternalData'=>'GBrowse','Bio::Graphics::Browser2::GFFhelper'=>'GBrowse','Bio::Graphics::Browser2::I18n'=>'GBrowse','Bio::Graphics::Browser2::Markup'=>'GBrowse','Bio::Graphics::Browser2::MetaDB'=>'GBrowse','Bio::Graphics::Browser2::MetaSegment'=>'GBrowse','Bio::Graphics::Browser2::MetaSegment::Iterator'=>'GBrowse','Bio::Graphics::Browser2::OptionPick'=>'GBrowse','Bio::Graphics::Browser2::PadAlignment'=>'GBrowse','Bio::Graphics::Browser2::Plugin'=>'GBrowse','Bio::Graphics::Browser2::Plugin::AuthPlugin'=>'GBrowse','Bio::Graphics::Browser2::PluginSet'=>'GBrowse','Bio::Graphics::Browser2::Realign'=>'GBrowse','Bio::Graphics::Browser2::Region'=>'GBrowse','Bio::Graphics::Browser2::RegionSearch'=>'GBrowse','Bio::Graphics::Browser2::RemoteSet'=>'GBrowse','Bio::Graphics::Browser2::Render'=>'GBrowse','Bio::Graphics::Browser2::Render::HTML'=>'GBrowse','Bio::Graphics::Browser2::Render::HTML::TrackListing'=>'GBrowse','Bio::Graphics::Browser2::Render::HTML::TrackListing::Categories'=>'GBrowse','Bio::Graphics::Browser2::Render::Login'=>'GBrowse','Bio::Graphics::Browser2::Render::Slave'=>'GBrowse','Bio::Graphics::Browser2::Render::Slave::AWS_Balancer'=>'GBrowse','Bio::Graphics::Browser2::Render::Slave::StagingServer'=>'GBrowse','Bio::Graphics::Browser2::Render::Slave::Status'=>'GBrowse','Bio::Graphics::Browser2::Render::SnapshotManager'=>'GBrowse','Bio::Graphics::Browser2::Render::TrackConfig'=>'GBrowse','Bio::Graphics::Browser2::RenderPanels'=>'GBrowse','Bio::Graphics::Browser2::SendMail'=>'GBrowse','Bio::Graphics::Browser2::Session'=>'GBrowse','Bio::Graphics::Browser2::Shellwords'=>'GBrowse','Bio::Graphics::Browser2::SubtrackTable'=>'GBrowse','Bio::Graphics::Browser2::TrackDumper'=>'GBrowse','Bio::Graphics::Browser2::TrackDumper::RichSeqMaker'=>'GBrowse','Bio::Graphics::Browser2::UserConf'=>'GBrowse','Bio::Graphics::Browser2::UserDB'=>'GBrowse','Bio::Graphics::Browser2::UserTracks'=>'GBrowse','Bio::Graphics::Browser2::UserTracks::Database'=>'GBrowse','Bio::Graphics::Browser2::UserTracks::Filesystem'=>'GBrowse','Bio::Graphics::Browser2::Util'=>'GBrowse','Bio::Graphics::GBrowseFeature'=>'GBrowse','Bio::Graphics::Karyotype'=>'GBrowse','Bio::Graphics::Wiggle::Loader::Nosample'=>'GBrowse','Bundle::Apache'=>'mod_perl','Bundle::Apache2'=>'mod_perl','Bundle::DBD::mysql'=>'DBD-mysql','Bundle::DBI'=>'DBI','Bundle::LWP'=>'libwww-perl','CBC'=>'Crypt-CBC','CGI'=>'CGI','CGI::Application::Dispatch'=>'CGI-Application-Dispatch','CGI::Application::Dispatch::PSGI'=>'CGI-Application-Dispatch','CGI::Application::Dispatch::Regexp'=>'CGI-Application-Dispatch','CGI::Application::Plugin::AutoRunmode'=>'CGI-Application-Plugin-AutoRunmode','CGI::Application::Plugin::AutoRunmode::FileDelegate'=>'CGI-Application-Plugin-AutoRunmode','CGI::Application::Plugin::RunmodeDeclare'=>'CGI-Application-Plugin-RunmodeDeclare','CGI::Auth::Basic'=>'CGI-Auth-Basic','CGI::Carp'=>'CGI','CGI::Cookie'=>'CGI','CGI::File::Temp'=>'CGI','CGI::HTML::Functions'=>'CGI','CGI::MultipartBuffer'=>'CGI','CGI::Pretty'=>'CGI','CGI::Push'=>'CGI','CGI::Simple'=>'CGI-Simple','CGI::Simple::Cookie'=>'CGI-Simple','CGI::Simple::Standard'=>'CGI-Simple','CGI::Simple::Util'=>'CGI-Simple','CGI::Toggle'=>'GBrowse','CGI::Util'=>'CGI','CGI::apacheSSI'=>'CGI-apacheSSI','CGI::apacheSSI::Gmt'=>'CGI-apacheSSI','CGI::apacheSSI::LMOD'=>'CGI-apacheSSI','CGI::apacheSSI::Local'=>'CGI-apacheSSI','CGI::mod_perl'=>'mod_perl','CPAN'=>'CPAN','CPAN::Admin'=>'CPAN','CPAN::Author'=>'CPAN','CPAN::Bundle'=>'CPAN','CPAN::CacheMgr'=>'CPAN','CPAN::Complete'=>'CPAN','CPAN::Debug'=>'CPAN','CPAN::DeferredCode'=>'CPAN','CPAN::Distribution'=>'CPAN','CPAN::Distroprefs'=>'CPAN','CPAN::Distroprefs::Iterator'=>'CPAN','CPAN::Distroprefs::Pref'=>'CPAN','CPAN::Distroprefs::Result'=>'CPAN','CPAN::Distroprefs::Result::Error'=>'CPAN','CPAN::Distroprefs::Result::Fatal'=>'CPAN','CPAN::Distroprefs::Result::Success'=>'CPAN','CPAN::Distroprefs::Result::Warning'=>'CPAN','CPAN::Distrostatus'=>'CPAN','CPAN::Eval'=>'CPAN','CPAN::Exception::RecursiveDependency'=>'CPAN','CPAN::Exception::RecursiveDependency::na'=>'CPAN','CPAN::Exception::blocked_urllist'=>'CPAN','CPAN::Exception::yaml_not_installed'=>'CPAN','CPAN::Exception::yaml_process_error'=>'CPAN','CPAN::FTP'=>'CPAN','CPAN::FTP::netrc'=>'CPAN','CPAN::FirstTime'=>'CPAN','CPAN::HTTP::Client'=>'CPAN','CPAN::HTTP::Credentials'=>'CPAN','CPAN::HandleConfig'=>'CPAN','CPAN::Index'=>'CPAN','CPAN::InfoObj'=>'CPAN','CPAN::Kwalify'=>'CPAN','CPAN::LWP::UserAgent'=>'CPAN','CPAN::Mirrored::By'=>'CPAN','CPAN::Mirrors'=>'CPAN','CPAN::Module'=>'CPAN','CPAN::Nox'=>'CPAN','CPAN::Plugin'=>'CPAN','CPAN::Plugin::Specfile'=>'CPAN','CPAN::Prompt'=>'CPAN','CPAN::Queue'=>'CPAN','CPAN::Queue::Item'=>'CPAN','CPAN::Shell'=>'CPAN','CPAN::Tarzip'=>'CPAN','CPAN::URL'=>'CPAN','CPAN::Version'=>'CPAN','Catalyst'=>'Catalyst-Runtime','Catalyst::Action'=>'Catalyst-Runtime','Catalyst::ActionChain'=>'Catalyst-Runtime','Catalyst::ActionContainer'=>'Catalyst-Runtime','Catalyst::ActionRole::ConsumesContent'=>'Catalyst-Runtime','Catalyst::ActionRole::HTTPMethods'=>'Catalyst-Runtime','Catalyst::ActionRole::QueryMatching'=>'Catalyst-Runtime','Catalyst::ActionRole::Scheme'=>'Catalyst-Runtime','Catalyst::Authentication::Store::LDAP'=>'Catalyst-Authentication-Store-LDAP','Catalyst::Authentication::Store::LDAP::Backend'=>'Catalyst-Authentication-Store-LDAP','Catalyst::Authentication::Store::LDAP::User'=>'Catalyst-Authentication-Store-LDAP','Catalyst::Base'=>'Catalyst-Runtime','Catalyst::ClassData'=>'Catalyst-Runtime','Catalyst::Component'=>'Catalyst-Runtime','Catalyst::Component::ApplicationAttribute'=>'Catalyst-Runtime','Catalyst::Component::ContextClosure'=>'Catalyst-Runtime','Catalyst::Controller'=>'Catalyst-Runtime','Catalyst::Controller::Combine'=>'Catalyst-Controller-Combine','Catalyst::DispatchType'=>'Catalyst-Runtime','Catalyst::DispatchType::Chained'=>'Catalyst-Runtime','Catalyst::DispatchType::Default'=>'Catalyst-Runtime','Catalyst::DispatchType::Index'=>'Catalyst-Runtime','Catalyst::DispatchType::Path'=>'Catalyst-Runtime','Catalyst::Dispatcher'=>'Catalyst-Runtime','Catalyst::Engine'=>'Catalyst-Runtime','Catalyst::Engine::CGI'=>'Catalyst-Runtime','Catalyst::Engine::FastCGI'=>'Catalyst-Runtime','Catalyst::Engine::HTTP'=>'Catalyst-Runtime','Catalyst::Engine::HTTP::Restarter'=>'Catalyst-Runtime','Catalyst::Engine::HTTP::Restarter::Watcher'=>'Catalyst-Runtime','Catalyst::EngineLoader'=>'Catalyst-Runtime','Catalyst::Exception'=>'Catalyst-Runtime','Catalyst::Exception::Base'=>'Catalyst-Runtime','Catalyst::Exception::Basic'=>'Catalyst-Runtime','Catalyst::Exception::Detach'=>'Catalyst-Runtime','Catalyst::Exception::Go'=>'Catalyst-Runtime','Catalyst::Exception::Interface'=>'Catalyst-Runtime','Catalyst::Helper::Controller::Combine'=>'Catalyst-Controller-Combine','Catalyst::Log'=>'Catalyst-Runtime','Catalyst::Middleware::Stash'=>'Catalyst-Runtime','Catalyst::Model'=>'Catalyst-Runtime','Catalyst::Plugin::Static'=>'Catalyst-Plugin-Static','Catalyst::Plugin::Unicode::Encoding'=>'Catalyst-Runtime','Catalyst::Request'=>'Catalyst-Runtime','Catalyst::Request::PartData'=>'Catalyst-Runtime','Catalyst::Request::Upload'=>'Catalyst-Runtime','Catalyst::Response'=>'Catalyst-Runtime','Catalyst::Response::Writer'=>'Catalyst-Runtime','Catalyst::Runtime'=>'Catalyst-Runtime','Catalyst::Script::CGI'=>'Catalyst-Runtime','Catalyst::Script::Create'=>'Catalyst-Runtime','Catalyst::Script::FastCGI'=>'Catalyst-Runtime','Catalyst::Script::Server'=>'Catalyst-Runtime','Catalyst::Script::Test'=>'Catalyst-Runtime','Catalyst::ScriptRole'=>'Catalyst-Runtime','Catalyst::ScriptRunner'=>'Catalyst-Runtime','Catalyst::Stats'=>'Catalyst-Runtime','Catalyst::Test'=>'Catalyst-Runtime','Catalyst::Utils'=>'Catalyst-Runtime','Catalyst::View'=>'Catalyst-Runtime','CatalystX::Controller::OpenSearch'=>'Search-OpenSearch-Server','Cmd::Dwarf'=>'Cmd-Dwarf','Compress::LZ4'=>'Compress-LZ4','Compress::Raw::Bunzip2'=>'Compress-Raw-Bzip2','Compress::Raw::Bzip2'=>'Compress-Raw-Bzip2','Compress::Raw::Zlib'=>'Compress-Raw-Zlib','Config::Model'=>'Config-Model','Config::Model::Annotation'=>'Config-Model','Config::Model::AnyId'=>'Config-Model','Config::Model::AnyThing'=>'Config-Model','Config::Model::Backend::Any'=>'Config-Model','Config::Model::Backend::CdsFile'=>'Config-Model','Config::Model::Backend::Fstab'=>'Config-Model','Config::Model::Backend::IniFile'=>'Config-Model','Config::Model::Backend::Json'=>'Config-Model','Config::Model::Backend::PerlFile'=>'Config-Model','Config::Model::Backend::PlainFile'=>'Config-Model','Config::Model::Backend::ShellVar'=>'Config-Model','Config::Model::BackendMgr'=>'Config-Model','Config::Model::BackendTrackOrder'=>'Config-Model','Config::Model::CheckList'=>'Config-Model','Config::Model::DeprecatedHandle'=>'Config-Model','Config::Model::Describe'=>'Config-Model','Config::Model::DumpAsData'=>'Config-Model','Config::Model::Dumper'=>'Config-Model','Config::Model::Exception'=>'Config-Model','Config::Model::Exception::AncestorClass'=>'Config-Model','Config::Model::Exception::Any'=>'Config-Model','Config::Model::Exception::ConfigFile'=>'Config-Model','Config::Model::Exception::ConfigFile::Missing'=>'Config-Model','Config::Model::Exception::Fatal'=>'Config-Model','Config::Model::Exception::Formula'=>'Config-Model','Config::Model::Exception::Internal'=>'Config-Model','Config::Model::Exception::Load'=>'Config-Model','Config::Model::Exception::LoadData'=>'Config-Model','Config::Model::Exception::Model'=>'Config-Model','Config::Model::Exception::ModelDeclaration'=>'Config-Model','Config::Model::Exception::ObsoleteElement'=>'Config-Model','Config::Model::Exception::Syntax'=>'Config-Model','Config::Model::Exception::UnavailableElement'=>'Config-Model','Config::Model::Exception::UnknownElement'=>'Config-Model','Config::Model::Exception::UnknownId'=>'Config-Model','Config::Model::Exception::User'=>'Config-Model','Config::Model::Exception::WarpError'=>'Config-Model','Config::Model::Exception::WrongType'=>'Config-Model','Config::Model::Exception::WrongValue'=>'Config-Model','Config::Model::FuseUI'=>'Config-Model','Config::Model::HashId'=>'Config-Model','Config::Model::IdElementReference'=>'Config-Model','Config::Model::Instance'=>'Config-Model','Config::Model::Iterator'=>'Config-Model','Config::Model::ListId'=>'Config-Model','Config::Model::Lister'=>'Config-Model','Config::Model::Loader'=>'Config-Model','Config::Model::Node'=>'Config-Model','Config::Model::ObjTreeScanner'=>'Config-Model','Config::Model::Report'=>'Config-Model','Config::Model::Role::ComputeFunction'=>'Config-Model','Config::Model::Role::FileHandler'=>'Config-Model','Config::Model::Role::Grab'=>'Config-Model','Config::Model::Role::HelpAsText'=>'Config-Model','Config::Model::Role::NodeLoader'=>'Config-Model','Config::Model::Role::WarpMaster'=>'Config-Model','Config::Model::SearchElement'=>'Config-Model','Config::Model::SimpleUI'=>'Config-Model','Config::Model::TermUI'=>'Config-Model','Config::Model::TreeSearcher'=>'Config-Model','Config::Model::Utils::GenClassPod'=>'Config-Model','Config::Model::Value'=>'Config-Model','Config::Model::Value::LayeredInclude'=>'Config-Model','Config::Model::ValueComputer'=>'Config-Model','Config::Model::WarpedNode'=>'Config-Model','Config::Model::Warper'=>'Config-Model','Cpanel::JSON::XS'=>'Cpanel-JSON-XS','Cpanel::JSON::XS::Type'=>'Cpanel-JSON-XS','Crypt::CBC'=>'Crypt-CBC','Crypt::OpenSSL::DSA'=>'Crypt-OpenSSL-DSA','Crypt::Passwd::XS'=>'Crypt-Passwd-XS','Cwd'=>'PathTools','DBD::DBM'=>'DBI','DBD::DBM::Statement'=>'DBI','DBD::DBM::Table'=>'DBI','DBD::DBM::db'=>'DBI','DBD::DBM::dr'=>'DBI','DBD::DBM::st'=>'DBI','DBD::ExampleP'=>'DBI','DBD::ExampleP::db'=>'DBI','DBD::ExampleP::dr'=>'DBI','DBD::ExampleP::st'=>'DBI','DBD::File'=>'DBI','DBD::File::DataSource::File'=>'DBI','DBD::File::DataSource::Stream'=>'DBI','DBD::File::Statement'=>'DBI','DBD::File::Table'=>'DBI','DBD::File::TableSource::FileSystem'=>'DBI','DBD::File::db'=>'DBI','DBD::File::dr'=>'DBI','DBD::File::st'=>'DBI','DBD::Gofer'=>'DBI','DBD::Gofer::Policy::Base'=>'DBI','DBD::Gofer::Policy::classic'=>'DBI','DBD::Gofer::Policy::pedantic'=>'DBI','DBD::Gofer::Policy::rush'=>'DBI','DBD::Gofer::Transport::Base'=>'DBI','DBD::Gofer::Transport::corostream'=>'DBI','DBD::Gofer::Transport::null'=>'DBI','DBD::Gofer::Transport::pipeone'=>'DBI','DBD::Gofer::Transport::stream'=>'DBI','DBD::Gofer::db'=>'DBI','DBD::Gofer::dr'=>'DBI','DBD::Gofer::st'=>'DBI','DBD::MariaDB'=>'DBD-MariaDB','DBD::Mem'=>'DBI','DBD::Mem::DataSource'=>'DBI','DBD::Mem::Statement'=>'DBI','DBD::Mem::Table'=>'DBI','DBD::Mem::db'=>'DBI','DBD::Mem::dr'=>'DBI','DBD::Mem::st'=>'DBI','DBD::NullP'=>'DBI','DBD::NullP::db'=>'DBI','DBD::NullP::dr'=>'DBI','DBD::NullP::st'=>'DBI','DBD::Proxy'=>'DBI','DBD::Proxy::RPC::PlClient'=>'DBI','DBD::Proxy::db'=>'DBI','DBD::Proxy::dr'=>'DBI','DBD::Proxy::st'=>'DBI','DBD::Sponge'=>'DBI','DBD::Sponge::db'=>'DBI','DBD::Sponge::dr'=>'DBI','DBD::Sponge::st'=>'DBI','DBD::mysql'=>'DBD-mysql','DBD::mysql::GetInfo'=>'DBD-mysql','DBD::mysql::db'=>'DBD-mysql','DBD::mysql::dr'=>'DBD-mysql','DBD::mysql::st'=>'DBD-mysql','DBD::mysqlPP'=>'DBD-mysqlPP','DBD::mysqlPP::db'=>'DBD-mysqlPP','DBD::mysqlPP::dr'=>'DBD-mysqlPP','DBD::mysqlPP::st'=>'DBD-mysqlPP','DBDI'=>'DBI','DBI'=>'DBI','DBI::Const::GetInfo::ANSI'=>'DBI','DBI::Const::GetInfo::ODBC'=>'DBI','DBI::Const::GetInfoReturn'=>'DBI','DBI::Const::GetInfoType'=>'DBI','DBI::DBD'=>'DBI','DBI::DBD::Metadata'=>'DBI','DBI::DBD::SqlEngine'=>'DBI','DBI::DBD::SqlEngine::DataSource'=>'DBI','DBI::DBD::SqlEngine::Statement'=>'DBI','DBI::DBD::SqlEngine::Table'=>'DBI','DBI::DBD::SqlEngine::TableSource'=>'DBI','DBI::DBD::SqlEngine::TieMeta'=>'DBI','DBI::DBD::SqlEngine::TieTables'=>'DBI','DBI::DBD::SqlEngine::db'=>'DBI','DBI::DBD::SqlEngine::dr'=>'DBI','DBI::DBD::SqlEngine::st'=>'DBI','DBI::FAQ'=>'DBI','DBI::Gofer::Execute'=>'DBI','DBI::Gofer::Request'=>'DBI','DBI::Gofer::Response'=>'DBI','DBI::Gofer::Serializer::Base'=>'DBI','DBI::Gofer::Serializer::DataDumper'=>'DBI','DBI::Gofer::Serializer::Storable'=>'DBI','DBI::Gofer::Transport::Base'=>'DBI','DBI::Gofer::Transport::pipeone'=>'DBI','DBI::Gofer::Transport::stream'=>'DBI','DBI::Profile'=>'DBI','DBI::ProfileData'=>'DBI','DBI::ProfileDumper'=>'DBI','DBI::ProfileDumper::Apache'=>'DBI','DBI::ProfileSubs'=>'DBI','DBI::ProxyServer'=>'DBI','DBI::ProxyServer::db'=>'DBI','DBI::ProxyServer::dr'=>'DBI','DBI::ProxyServer::st'=>'DBI','DBI::SQL::Nano'=>'DBI','DBI::SQL::Nano::Statement_'=>'DBI','DBI::SQL::Nano::Table_'=>'DBI','DBI::Util::CacheMemory'=>'DBI','DBI::Util::_accessor'=>'DBI','DBI::common'=>'DBI','DBIx::Custom'=>'DBIx-Custom','DBIx::Custom::Mapper'=>'DBIx-Custom','DBIx::Custom::Model'=>'DBIx-Custom','DBIx::Custom::NotExists'=>'DBIx-Custom','DBIx::Custom::Order'=>'DBIx-Custom','DBIx::Custom::Query'=>'DBIx-Custom','DBIx::Custom::QueryBuilder'=>'DBIx-Custom','DBIx::Custom::Result'=>'DBIx-Custom','DBIx::Custom::Tag'=>'DBIx-Custom','DBIx::Custom::Util'=>'DBIx-Custom','DBIx::Custom::Where'=>'DBIx-Custom','DBIx::Otogiri'=>'Otogiri','DBIx::Otogiri::Iterator'=>'Otogiri','Dancer'=>'Dancer','Dancer2'=>'Dancer2','Dancer2::CLI'=>'Dancer2','Dancer2::CLI::Command::gen'=>'Dancer2','Dancer2::CLI::Command::version'=>'Dancer2','Dancer2::Core'=>'Dancer2','Dancer2::Core::App'=>'Dancer2','Dancer2::Core::Cookie'=>'Dancer2','Dancer2::Core::DSL'=>'Dancer2','Dancer2::Core::Dispatcher'=>'Dancer2','Dancer2::Core::Error'=>'Dancer2','Dancer2::Core::Factory'=>'Dancer2','Dancer2::Core::HTTP'=>'Dancer2','Dancer2::Core::Hook'=>'Dancer2','Dancer2::Core::MIME'=>'Dancer2','Dancer2::Core::Request'=>'Dancer2','Dancer2::Core::Request::Upload'=>'Dancer2','Dancer2::Core::Response'=>'Dancer2','Dancer2::Core::Response::Delayed'=>'Dancer2','Dancer2::Core::Role::ConfigReader'=>'Dancer2','Dancer2::Core::Role::DSL'=>'Dancer2','Dancer2::Core::Role::Engine'=>'Dancer2','Dancer2::Core::Role::Handler'=>'Dancer2','Dancer2::Core::Role::HasLocation'=>'Dancer2','Dancer2::Core::Role::Hookable'=>'Dancer2','Dancer2::Core::Role::Logger'=>'Dancer2','Dancer2::Core::Role::Serializer'=>'Dancer2','Dancer2::Core::Role::SessionFactory'=>'Dancer2','Dancer2::Core::Role::SessionFactory::File'=>'Dancer2','Dancer2::Core::Role::StandardResponses'=>'Dancer2','Dancer2::Core::Role::Template'=>'Dancer2','Dancer2::Core::Route'=>'Dancer2','Dancer2::Core::Runner'=>'Dancer2','Dancer2::Core::Session'=>'Dancer2','Dancer2::Core::Time'=>'Dancer2','Dancer2::Core::Types'=>'Dancer2','Dancer2::FileUtils'=>'Dancer2','Dancer2::Handler::AutoPage'=>'Dancer2','Dancer2::Handler::File'=>'Dancer2','Dancer2::Logger::Capture'=>'Dancer2','Dancer2::Logger::Capture::Trap'=>'Dancer2','Dancer2::Logger::Console'=>'Dancer2','Dancer2::Logger::Diag'=>'Dancer2','Dancer2::Logger::File'=>'Dancer2','Dancer2::Logger::Note'=>'Dancer2','Dancer2::Logger::Null'=>'Dancer2','Dancer2::Plugin'=>'Dancer2','Dancer2::Serializer::Dumper'=>'Dancer2','Dancer2::Serializer::JSON'=>'Dancer2','Dancer2::Serializer::Mutable'=>'Dancer2','Dancer2::Serializer::YAML'=>'Dancer2','Dancer2::Session::Simple'=>'Dancer2','Dancer2::Session::YAML'=>'Dancer2','Dancer2::Template::Implementation::ForkedTiny'=>'Dancer2','Dancer2::Template::Simple'=>'Dancer2','Dancer2::Template::TemplateToolkit'=>'Dancer2','Dancer2::Template::Tiny'=>'Dancer2','Dancer2::Test'=>'Dancer2','Dancer::App'=>'Dancer','Dancer::Config'=>'Dancer','Dancer::Config::Object'=>'Dancer','Dancer::Continuation'=>'Dancer','Dancer::Continuation::Halted'=>'Dancer','Dancer::Continuation::Route'=>'Dancer','Dancer::Continuation::Route::ErrorSent'=>'Dancer','Dancer::Continuation::Route::FileSent'=>'Dancer','Dancer::Continuation::Route::Forwarded'=>'Dancer','Dancer::Continuation::Route::Passed'=>'Dancer','Dancer::Continuation::Route::Templated'=>'Dancer','Dancer::Cookie'=>'Dancer','Dancer::Cookies'=>'Dancer','Dancer::Deprecation'=>'Dancer','Dancer::Engine'=>'Dancer','Dancer::Error'=>'Dancer','Dancer::Exception'=>'Dancer','Dancer::Exception::Base'=>'Dancer','Dancer::Exceptions'=>'Dancer','Dancer::Factory::Hook'=>'Dancer','Dancer::FileUtils'=>'Dancer','Dancer::GetOpt'=>'Dancer','Dancer::HTTP'=>'Dancer','Dancer::Handler'=>'Dancer','Dancer::Handler::Debug'=>'Dancer','Dancer::Handler::PSGI'=>'Dancer','Dancer::Handler::Standalone'=>'Dancer','Dancer::Hook'=>'Dancer','Dancer::Hook::Properties'=>'Dancer','Dancer::Logger'=>'Dancer','Dancer::Logger::Abstract'=>'Dancer','Dancer::Logger::Capture'=>'Dancer','Dancer::Logger::Capture::Trap'=>'Dancer','Dancer::Logger::Console'=>'Dancer','Dancer::Logger::Diag'=>'Dancer','Dancer::Logger::File'=>'Dancer','Dancer::Logger::Note'=>'Dancer','Dancer::Logger::Null'=>'Dancer','Dancer::MIME'=>'Dancer','Dancer::ModuleLoader'=>'Dancer','Dancer::Object'=>'Dancer','Dancer::Object::Singleton'=>'Dancer','Dancer::Plugin'=>'Dancer','Dancer::Plugin::Ajax'=>'Dancer','Dancer::Renderer'=>'Dancer','Dancer::Request'=>'Dancer','Dancer::Request::Upload'=>'Dancer','Dancer::Response'=>'Dancer','Dancer::Route'=>'Dancer','Dancer::Route::Cache'=>'Dancer','Dancer::Route::Registry'=>'Dancer','Dancer::Serializer'=>'Dancer','Dancer::Serializer::Abstract'=>'Dancer','Dancer::Serializer::Dumper'=>'Dancer','Dancer::Serializer::JSON'=>'Dancer','Dancer::Serializer::JSONP'=>'Dancer','Dancer::Serializer::Mutable'=>'Dancer','Dancer::Serializer::XML'=>'Dancer','Dancer::Serializer::YAML'=>'Dancer','Dancer::Session'=>'Dancer','Dancer::Session::Abstract'=>'Dancer','Dancer::Session::Simple'=>'Dancer','Dancer::Session::YAML'=>'Dancer','Dancer::SharedData'=>'Dancer','Dancer::Template'=>'Dancer','Dancer::Template::Abstract'=>'Dancer','Dancer::Template::Simple'=>'Dancer','Dancer::Template::TemplateToolkit'=>'Dancer','Dancer::Test'=>'Dancer','Dancer::Timer'=>'Dancer','Data::Dumper'=>'Data-Dumper','Dezi'=>'Dezi','Dezi::Config'=>'Dezi','Dezi::Server'=>'Dezi','Dezi::Server::About'=>'Dezi','Dwarf'=>'Cmd-Dwarf','Email::Address'=>'Email-Address','Encode'=>'Encode','Encode::Alias'=>'Encode','Encode::Byte'=>'Encode','Encode::CJKConstants'=>'Encode','Encode::CN'=>'Encode','Encode::CN::HZ'=>'Encode','Encode::Config'=>'Encode','Encode::EBCDIC'=>'Encode','Encode::Encoder'=>'Encode','Encode::Encoding'=>'Encode','Encode::GSM0338'=>'Encode','Encode::Guess'=>'Encode','Encode::Internal'=>'Encode','Encode::JP'=>'Encode','Encode::JP::H2Z'=>'Encode','Encode::JP::JIS7'=>'Encode','Encode::KR'=>'Encode','Encode::KR::2022_KR'=>'Encode','Encode::MIME::Header'=>'Encode','Encode::MIME::Header::ISO_2022_JP'=>'Encode','Encode::MIME::Name'=>'Encode','Encode::Symbol'=>'Encode','Encode::TW'=>'Encode','Encode::UTF_EBCDIC'=>'Encode','Encode::Unicode'=>'Encode','Encode::Unicode::UTF7'=>'Encode','Encode::XS'=>'Encode','Encode::utf8'=>'Encode','ExtUtils::Command'=>'ExtUtils-MakeMaker','ExtUtils::Command::MM'=>'ExtUtils-MakeMaker','ExtUtils::Liblist'=>'ExtUtils-MakeMaker','ExtUtils::Liblist::Kid'=>'ExtUtils-MakeMaker','ExtUtils::MM'=>'ExtUtils-MakeMaker','ExtUtils::MM_AIX'=>'ExtUtils-MakeMaker','ExtUtils::MM_Any'=>'ExtUtils-MakeMaker','ExtUtils::MM_BeOS'=>'ExtUtils-MakeMaker','ExtUtils::MM_Cygwin'=>'ExtUtils-MakeMaker','ExtUtils::MM_DOS'=>'ExtUtils-MakeMaker','ExtUtils::MM_Darwin'=>'ExtUtils-MakeMaker','ExtUtils::MM_MacOS'=>'ExtUtils-MakeMaker','ExtUtils::MM_NW5'=>'ExtUtils-MakeMaker','ExtUtils::MM_OS2'=>'ExtUtils-MakeMaker','ExtUtils::MM_QNX'=>'ExtUtils-MakeMaker','ExtUtils::MM_UWIN'=>'ExtUtils-MakeMaker','ExtUtils::MM_Unix'=>'ExtUtils-MakeMaker','ExtUtils::MM_VMS'=>'ExtUtils-MakeMaker','ExtUtils::MM_VOS'=>'ExtUtils-MakeMaker','ExtUtils::MM_Win32'=>'ExtUtils-MakeMaker','ExtUtils::MM_Win95'=>'ExtUtils-MakeMaker','ExtUtils::MY'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::Config'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::Locale'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::_version'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::charstar'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::version'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::version::regex'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::version::vpp'=>'ExtUtils-MakeMaker','ExtUtils::Mkbootstrap'=>'ExtUtils-MakeMaker','ExtUtils::Mksymlists'=>'ExtUtils-MakeMaker','ExtUtils::testlib'=>'ExtUtils-MakeMaker','FCGI'=>'FCGI','FCGI::Stream'=>'FCGI','Fake::Encode'=>'Fake-Encode','Fake::Our'=>'Fake-Our','FakeHomol'=>'GBrowse','Fh'=>'CGI','File::DataClass'=>'File-DataClass','File::DataClass::Cache'=>'File-DataClass','File::DataClass::Constants'=>'File-DataClass','File::DataClass::Exception'=>'File-DataClass','File::DataClass::Functions'=>'File-DataClass','File::DataClass::IO'=>'File-DataClass','File::DataClass::List'=>'File-DataClass','File::DataClass::Result'=>'File-DataClass','File::DataClass::ResultSet'=>'File-DataClass','File::DataClass::ResultSource'=>'File-DataClass','File::DataClass::Schema'=>'File-DataClass','File::DataClass::Storage'=>'File-DataClass','File::DataClass::Storage::Any'=>'File-DataClass','File::DataClass::Storage::JSON'=>'File-DataClass','File::DataClass::Types'=>'File-DataClass','File::Path'=>'File-Path','File::Spec'=>'PathTools','File::Spec::AmigaOS'=>'PathTools','File::Spec::Cygwin'=>'PathTools','File::Spec::Epoc'=>'PathTools','File::Spec::Functions'=>'PathTools','File::Spec::Mac'=>'PathTools','File::Spec::OS2'=>'PathTools','File::Spec::Unix'=>'PathTools','File::Spec::VMS'=>'PathTools','File::Spec::Win32'=>'PathTools','HTML::Perlinfo'=>'HTML-Perlinfo','HTML::Perlinfo::Apache'=>'HTML-Perlinfo','HTML::Perlinfo::Base'=>'HTML-Perlinfo','HTML::Perlinfo::Common'=>'HTML-Perlinfo','HTML::Perlinfo::General'=>'HTML-Perlinfo','HTML::Perlinfo::Loaded'=>'HTML-Perlinfo','HTML::Perlinfo::Modules'=>'HTML-Perlinfo','HTML::Perlinfo::_version'=>'HTML-Perlinfo','HTML::Scrubber'=>'HTML-Scrubber','HTTP::Body'=>'HTTP-Body','HTTP::Body::MultiPart'=>'HTTP-Body','HTTP::Body::OctetStream'=>'HTTP-Body','HTTP::Body::UrlEncoded'=>'HTTP-Body','HTTP::Body::XForms'=>'HTTP-Body','HTTP::Body::XFormsMultipart'=>'HTTP-Body','HTTP::Session2'=>'HTTP-Session2','HTTP::Session2::Base'=>'HTTP-Session2','HTTP::Session2::ClientStore'=>'HTTP-Session2','HTTP::Session2::ClientStore2'=>'HTTP-Session2','HTTP::Session2::Expired'=>'HTTP-Session2','HTTP::Session2::Random'=>'HTTP-Session2','HTTP::Session2::ServerStore'=>'HTTP-Session2','HTTP::Tiny'=>'HTTP-Tiny','HTTP::Tiny::NoProxy'=>'Dancer','Imager'=>'Imager','Imager::Color'=>'Imager','Imager::Color::Float'=>'Imager','Imager::Color::Table'=>'Imager','Imager::CountColor'=>'Imager','Imager::Expr'=>'Imager','Imager::Expr::Assem'=>'Imager','Imager::Expr::Infix'=>'Imager','Imager::Expr::Postfix'=>'Imager','Imager::ExtUtils'=>'Imager','Imager::FORMATS'=>'Imager','Imager::File::CUR'=>'Imager','Imager::File::ICO'=>'Imager','Imager::File::SGI'=>'Imager','Imager::Fill'=>'Imager','Imager::Filter::DynTest'=>'Imager','Imager::Filter::Flines'=>'Imager','Imager::Filter::Mandelbrot'=>'Imager','Imager::Font'=>'Imager','Imager::Font::BBox'=>'Imager','Imager::Font::FreeType2'=>'Imager','Imager::Font::Image'=>'Imager','Imager::Font::Test'=>'Imager','Imager::Font::Truetype'=>'Imager','Imager::Font::Type1'=>'Imager','Imager::Font::Wrap'=>'Imager','Imager::Fountain'=>'Imager','Imager::IO'=>'Imager','Imager::Matrix2d'=>'Imager','Imager::Preprocess'=>'Imager','Imager::Probe'=>'Imager','Imager::Regops'=>'Imager','Imager::Test'=>'Imager','Imager::Test::OverUtf8'=>'Imager','Imager::Transform'=>'Imager','LRUCache'=>'GBrowse','LWP'=>'libwww-perl','LWP::Authen::Basic'=>'libwww-perl','LWP::Authen::Digest'=>'libwww-perl','LWP::Authen::Ntlm'=>'libwww-perl','LWP::ConnCache'=>'libwww-perl','LWP::Debug'=>'libwww-perl','LWP::Debug::TraceHTTP'=>'libwww-perl','LWP::DebugFile'=>'libwww-perl','LWP::MemberMixin'=>'libwww-perl','LWP::Protocol'=>'libwww-perl','LWP::Protocol::Net::Curl'=>'LWP-Protocol-Net-Curl','LWP::Protocol::cpan'=>'libwww-perl','LWP::Protocol::data'=>'libwww-perl','LWP::Protocol::file'=>'libwww-perl','LWP::Protocol::ftp'=>'libwww-perl','LWP::Protocol::gopher'=>'libwww-perl','LWP::Protocol::http'=>'libwww-perl','LWP::Protocol::loopback'=>'libwww-perl','LWP::Protocol::mailto'=>'libwww-perl','LWP::Protocol::nntp'=>'libwww-perl','LWP::Protocol::nogo'=>'libwww-perl','LWP::RobotUA'=>'libwww-perl','LWP::Simple'=>'libwww-perl','LWP::UserAgent'=>'libwww-perl','Legacy::DB::SyntenyBlock'=>'GBrowse','Legacy::DB::SyntenyIO'=>'GBrowse','Legacy::Graphics::Browser'=>'GBrowse','Legacy::Graphics::Browser::I18n'=>'GBrowse','Legacy::Graphics::Browser::PageSettings'=>'GBrowse','Legacy::Graphics::Browser::Synteny'=>'GBrowse','Legacy::Graphics::Browser::Util'=>'GBrowse','Legacy::Graphics::BrowserConfig'=>'GBrowse','Lemonldap::NG::Portal'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Engines::Default'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Ext2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Mail2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Register::TOTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Register::U2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Register::Yubikey'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::TOTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::U2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::UTOTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Yubikey'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::AD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Apache'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Combination'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Custom'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Demo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Facebook'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::GPG'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Kerberos'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::LinkedIn'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Null'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::OpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::PAM'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Proxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Radius'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Remote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::SSL'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Slave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Twitter'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::WebID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::_WebForm'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthAD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthApache'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthBrowserID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthCAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthChoice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthDBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthDemo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthFacebook'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthGoogle'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthKerberos'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthLDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthLinkedIn'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthMulti'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthOpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthOpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthProxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthRadius'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthRemote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthSAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthSSL'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthSlave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthTwitter'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthWebID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthYubikey'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::CDA'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::CDC'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Display'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::Get'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::OpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBCAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBGet'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBOpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBOpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBSAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Captcha'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Combination::UserLogger'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Net::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Notifications::JSON'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Notifications::XML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OneTimeToken'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OpenID::SREG'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OpenID::Server'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OtherSessions'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OverConf'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::RESTProxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Remote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::SMTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::SOAPProxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Slave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::U2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Wrapper'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::MailReset'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Auth'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Constants'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Display'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Init'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Issuer'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Menu'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Plugin'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Plugins'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Process'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Request'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Run'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::SecondFactor'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Menu'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::OpenID::SREG'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::OpenID::Server'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::AD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Base'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Custom'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Demo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Null'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBAD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBChoice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBDBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBDemo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBLDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::AutoSignin'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::BruteForceProtection'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::CDA'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::CheckState'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::ForceAuthn'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::GrantSession'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::History'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::MailPasswordReset'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::MailReset'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::Notifications'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::PublicPages'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::RESTServer'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::Register'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::SOAPServer'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::SingleSession'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::Status'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::StayConnected'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::Upgrade'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register::AD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register::Custom'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register::Demo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::RegisterDBAD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::RegisterDBDemo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::RegisterDBLDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::RegisterDBNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::SharedConf'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Simple'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::AD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Combination'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Custom'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Demo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Facebook'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Null'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::OpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Proxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Remote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Slave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::WebID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBAD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBChoice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBDBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBDemo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBFacebook'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBGoogle'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBLDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBMulti'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBOpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBOpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBProxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBRemote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBSAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBSlave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBWebID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Browser'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_LibAccess'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Multi'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Proxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Remote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_SMTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_SOAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Slave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_WebForm'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_i18n'=>'Lemonldap-NG-Portal','MHonArc::Char'=>'MHonArc','MHonArc::Char::JP'=>'MHonArc','MHonArc::Char::KR'=>'MHonArc','MHonArc::CharEnt'=>'MHonArc','MHonArc::CharEnt::AppleArabic'=>'MHonArc','MHonArc::CharEnt::AppleCenteuro'=>'MHonArc','MHonArc::CharEnt::AppleCroatian'=>'MHonArc','MHonArc::CharEnt::AppleCyrillic'=>'MHonArc','MHonArc::CharEnt::AppleGreek'=>'MHonArc','MHonArc::CharEnt::AppleHebrew'=>'MHonArc','MHonArc::CharEnt::AppleIceland'=>'MHonArc','MHonArc::CharEnt::AppleRoman'=>'MHonArc','MHonArc::CharEnt::AppleRomanian'=>'MHonArc','MHonArc::CharEnt::AppleThai'=>'MHonArc','MHonArc::CharEnt::AppleTurkish'=>'MHonArc','MHonArc::CharEnt::BIG5_ETEN'=>'MHonArc','MHonArc::CharEnt::BIG5_HKSCS'=>'MHonArc','MHonArc::CharEnt::CP1250'=>'MHonArc','MHonArc::CharEnt::CP1251'=>'MHonArc','MHonArc::CharEnt::CP1252'=>'MHonArc','MHonArc::CharEnt::CP1253'=>'MHonArc','MHonArc::CharEnt::CP1254'=>'MHonArc','MHonArc::CharEnt::CP1255'=>'MHonArc','MHonArc::CharEnt::CP1256'=>'MHonArc','MHonArc::CharEnt::CP1257'=>'MHonArc','MHonArc::CharEnt::CP1258'=>'MHonArc','MHonArc::CharEnt::CP866'=>'MHonArc','MHonArc::CharEnt::CP932'=>'MHonArc','MHonArc::CharEnt::CP936'=>'MHonArc','MHonArc::CharEnt::CP949'=>'MHonArc','MHonArc::CharEnt::CP950'=>'MHonArc','MHonArc::CharEnt::EUC_JP'=>'MHonArc','MHonArc::CharEnt::GB2312'=>'MHonArc','MHonArc::CharEnt::GOST19768_87'=>'MHonArc','MHonArc::CharEnt::HP_ROMAN8'=>'MHonArc','MHonArc::CharEnt::ISO8859_1'=>'MHonArc','MHonArc::CharEnt::ISO8859_10'=>'MHonArc','MHonArc::CharEnt::ISO8859_11'=>'MHonArc','MHonArc::CharEnt::ISO8859_13'=>'MHonArc','MHonArc::CharEnt::ISO8859_14'=>'MHonArc','MHonArc::CharEnt::ISO8859_15'=>'MHonArc','MHonArc::CharEnt::ISO8859_16'=>'MHonArc','MHonArc::CharEnt::ISO8859_2'=>'MHonArc','MHonArc::CharEnt::ISO8859_3'=>'MHonArc','MHonArc::CharEnt::ISO8859_4'=>'MHonArc','MHonArc::CharEnt::ISO8859_5'=>'MHonArc','MHonArc::CharEnt::ISO8859_6'=>'MHonArc','MHonArc::CharEnt::ISO8859_7'=>'MHonArc','MHonArc::CharEnt::ISO8859_8'=>'MHonArc','MHonArc::CharEnt::ISO8859_9'=>'MHonArc','MHonArc::CharEnt::KOI8_A'=>'MHonArc','MHonArc::CharEnt::KOI8_B'=>'MHonArc','MHonArc::CharEnt::KOI8_E'=>'MHonArc','MHonArc::CharEnt::KOI8_F'=>'MHonArc','MHonArc::CharEnt::KOI8_R'=>'MHonArc','MHonArc::CharEnt::KOI8_U'=>'MHonArc','MHonArc::CharEnt::KOI_0'=>'MHonArc','MHonArc::CharEnt::KOI_7'=>'MHonArc','MHonArc::CharEnt::VISCII'=>'MHonArc','MHonArc::CharMaps'=>'MHonArc','MHonArc::Encode'=>'MHonArc','MHonArc::RFC822'=>'MHonArc','MHonArc::UTF8'=>'MHonArc','MHonArc::UTF8::AppleArabic'=>'MHonArc','MHonArc::UTF8::AppleCenteuro'=>'MHonArc','MHonArc::UTF8::AppleCroatian'=>'MHonArc','MHonArc::UTF8::AppleCyrillic'=>'MHonArc','MHonArc::UTF8::AppleGreek'=>'MHonArc','MHonArc::UTF8::AppleHebrew'=>'MHonArc','MHonArc::UTF8::AppleIceland'=>'MHonArc','MHonArc::UTF8::AppleRoman'=>'MHonArc','MHonArc::UTF8::AppleRomanian'=>'MHonArc','MHonArc::UTF8::AppleThai'=>'MHonArc','MHonArc::UTF8::AppleTurkish'=>'MHonArc','MHonArc::UTF8::BIG5_ETEN'=>'MHonArc','MHonArc::UTF8::BIG5_HKSCS'=>'MHonArc','MHonArc::UTF8::CP1250'=>'MHonArc','MHonArc::UTF8::CP1251'=>'MHonArc','MHonArc::UTF8::CP1252'=>'MHonArc','MHonArc::UTF8::CP1253'=>'MHonArc','MHonArc::UTF8::CP1254'=>'MHonArc','MHonArc::UTF8::CP1255'=>'MHonArc','MHonArc::UTF8::CP1256'=>'MHonArc','MHonArc::UTF8::CP1257'=>'MHonArc','MHonArc::UTF8::CP1258'=>'MHonArc','MHonArc::UTF8::CP866'=>'MHonArc','MHonArc::UTF8::CP932'=>'MHonArc','MHonArc::UTF8::CP936'=>'MHonArc','MHonArc::UTF8::CP949'=>'MHonArc','MHonArc::UTF8::CP950'=>'MHonArc','MHonArc::UTF8::EUC_JP'=>'MHonArc','MHonArc::UTF8::Encode'=>'MHonArc','MHonArc::UTF8::GB2312'=>'MHonArc','MHonArc::UTF8::GOST19768_87'=>'MHonArc','MHonArc::UTF8::HP_ROMAN8'=>'MHonArc','MHonArc::UTF8::ISO8859_1'=>'MHonArc','MHonArc::UTF8::ISO8859_10'=>'MHonArc','MHonArc::UTF8::ISO8859_11'=>'MHonArc','MHonArc::UTF8::ISO8859_13'=>'MHonArc','MHonArc::UTF8::ISO8859_14'=>'MHonArc','MHonArc::UTF8::ISO8859_15'=>'MHonArc','MHonArc::UTF8::ISO8859_16'=>'MHonArc','MHonArc::UTF8::ISO8859_2'=>'MHonArc','MHonArc::UTF8::ISO8859_3'=>'MHonArc','MHonArc::UTF8::ISO8859_4'=>'MHonArc','MHonArc::UTF8::ISO8859_5'=>'MHonArc','MHonArc::UTF8::ISO8859_6'=>'MHonArc','MHonArc::UTF8::ISO8859_7'=>'MHonArc','MHonArc::UTF8::ISO8859_8'=>'MHonArc','MHonArc::UTF8::ISO8859_9'=>'MHonArc','MHonArc::UTF8::KOI8_A'=>'MHonArc','MHonArc::UTF8::KOI8_B'=>'MHonArc','MHonArc::UTF8::KOI8_E'=>'MHonArc','MHonArc::UTF8::KOI8_F'=>'MHonArc','MHonArc::UTF8::KOI8_R'=>'MHonArc','MHonArc::UTF8::KOI8_U'=>'MHonArc','MHonArc::UTF8::KOI_0'=>'MHonArc','MHonArc::UTF8::KOI_7'=>'MHonArc','MHonArc::UTF8::MapUTF8'=>'MHonArc','MHonArc::UTF8::MhaEncode'=>'MHonArc','MHonArc::UTF8::VISCII'=>'MHonArc','MM'=>'ExtUtils-MakeMaker','MY'=>'ExtUtils-MakeMaker','ModPerl::BuildMM'=>'mod_perl','ModPerl::BuildOptions'=>'mod_perl','ModPerl::CScan'=>'mod_perl','ModPerl::Code'=>'mod_perl','ModPerl::Config'=>'mod_perl','ModPerl::FunctionMap'=>'mod_perl','ModPerl::FunctionTable'=>'mod_perl','ModPerl::Global'=>'mod_perl','ModPerl::InterpPool'=>'mod_perl','ModPerl::Interpreter'=>'mod_perl','ModPerl::MM'=>'mod_perl','ModPerl::Manifest'=>'mod_perl','ModPerl::MapBase'=>'mod_perl','ModPerl::MapUtil'=>'mod_perl','ModPerl::MethodLookup'=>'mod_perl','ModPerl::ParseSource'=>'mod_perl','ModPerl::PerlRun'=>'mod_perl','ModPerl::PerlRunPrefork'=>'mod_perl','ModPerl::Registry'=>'mod_perl','ModPerl::RegistryBB'=>'mod_perl','ModPerl::RegistryCooker'=>'mod_perl','ModPerl::RegistryLoader'=>'mod_perl','ModPerl::RegistryPrefork'=>'mod_perl','ModPerl::StructureMap'=>'mod_perl','ModPerl::TestConfig'=>'mod_perl','ModPerl::TestReport'=>'mod_perl','ModPerl::TestRun'=>'mod_perl','ModPerl::TiPool'=>'mod_perl','ModPerl::TiPoolConfig'=>'mod_perl','ModPerl::TypeMap'=>'mod_perl','ModPerl::Util'=>'mod_perl','ModPerl::WrapXS'=>'mod_perl','Module::Signature'=>'Module-Signature','Mojo'=>'Mojolicious','Mojo::Asset'=>'Mojolicious','Mojo::Asset::File'=>'Mojolicious','Mojo::Asset::Memory'=>'Mojolicious','Mojo::Base'=>'Mojolicious','Mojo::ByteStream'=>'Mojolicious','Mojo::Cache'=>'Mojolicious','Mojo::Collection'=>'Mojolicious','Mojo::Content'=>'Mojolicious','Mojo::Content::MultiPart'=>'Mojolicious','Mojo::Content::Single'=>'Mojolicious','Mojo::Cookie'=>'Mojolicious','Mojo::Cookie::Request'=>'Mojolicious','Mojo::Cookie::Response'=>'Mojolicious','Mojo::DOM'=>'Mojolicious','Mojo::DOM::CSS'=>'Mojolicious','Mojo::DOM::HTML'=>'Mojolicious','Mojo::Date'=>'Mojolicious','Mojo::DynamicMethods'=>'Mojolicious','Mojo::EventEmitter'=>'Mojolicious','Mojo::Exception'=>'Mojolicious','Mojo::File'=>'Mojolicious','Mojo::Headers'=>'Mojolicious','Mojo::HelloWorld'=>'Mojolicious','Mojo::Home'=>'Mojolicious','Mojo::IOLoop'=>'Mojolicious','Mojo::IOLoop::Client'=>'Mojolicious','Mojo::IOLoop::Delay'=>'Mojolicious','Mojo::IOLoop::Server'=>'Mojolicious','Mojo::IOLoop::Stream'=>'Mojolicious','Mojo::IOLoop::Subprocess'=>'Mojolicious','Mojo::IOLoop::TLS'=>'Mojolicious','Mojo::JSON'=>'Mojolicious','Mojo::JSON::Pointer'=>'Mojolicious','Mojo::Loader'=>'Mojolicious','Mojo::Log'=>'Mojolicious','Mojo::Message'=>'Mojolicious','Mojo::Message::Request'=>'Mojolicious','Mojo::Message::Response'=>'Mojolicious','Mojo::Parameters'=>'Mojolicious','Mojo::Path'=>'Mojolicious','Mojo::Promise'=>'Mojolicious','Mojo::Reactor'=>'Mojolicious','Mojo::Reactor::EV'=>'Mojolicious','Mojo::Reactor::Poll'=>'Mojolicious','Mojo::Server'=>'Mojolicious','Mojo::Server::CGI'=>'Mojolicious','Mojo::Server::Daemon'=>'Mojolicious','Mojo::Server::Hypnotoad'=>'Mojolicious','Mojo::Server::Morbo'=>'Mojolicious','Mojo::Server::Morbo::Backend'=>'Mojolicious','Mojo::Server::Morbo::Backend::Poll'=>'Mojolicious','Mojo::Server::PSGI'=>'Mojolicious','Mojo::Server::PSGI::_IO'=>'Mojolicious','Mojo::Server::Prefork'=>'Mojolicious','Mojo::Template'=>'Mojolicious','Mojo::Transaction'=>'Mojolicious','Mojo::Transaction::HTTP'=>'Mojolicious','Mojo::Transaction::WebSocket'=>'Mojolicious','Mojo::URL'=>'Mojolicious','Mojo::Upload'=>'Mojolicious','Mojo::UserAgent'=>'Mojolicious','Mojo::UserAgent::CookieJar'=>'Mojolicious','Mojo::UserAgent::Proxy'=>'Mojolicious','Mojo::UserAgent::Server'=>'Mojolicious','Mojo::UserAgent::Transactor'=>'Mojolicious','Mojo::Util'=>'Mojolicious','Mojo::WebSocket'=>'Mojolicious','MojoMojo'=>'MojoMojo','MojoMojo::Controller::Admin'=>'MojoMojo','MojoMojo::Controller::Attachment'=>'MojoMojo','MojoMojo::Controller::Comment'=>'MojoMojo','MojoMojo::Controller::Export'=>'MojoMojo','MojoMojo::Controller::Gallery'=>'MojoMojo','MojoMojo::Controller::Image'=>'MojoMojo','MojoMojo::Controller::JSON'=>'MojoMojo','MojoMojo::Controller::Journal'=>'MojoMojo','MojoMojo::Controller::Jsrpc'=>'MojoMojo','MojoMojo::Controller::Page'=>'MojoMojo','MojoMojo::Controller::PageAdmin'=>'MojoMojo','MojoMojo::Controller::Root'=>'MojoMojo','MojoMojo::Controller::Tag'=>'MojoMojo','MojoMojo::Controller::User'=>'MojoMojo','MojoMojo::Declaw'=>'MojoMojo','MojoMojo::Extension'=>'MojoMojo','MojoMojo::Extensions::Counter'=>'MojoMojo','MojoMojo::Formatter'=>'MojoMojo','MojoMojo::Formatter::Amazon'=>'MojoMojo','MojoMojo::Formatter::CPANHyperlink'=>'MojoMojo','MojoMojo::Formatter::Comment'=>'MojoMojo','MojoMojo::Formatter::Defang'=>'MojoMojo','MojoMojo::Formatter::Dir'=>'MojoMojo','MojoMojo::Formatter::DocBook'=>'MojoMojo','MojoMojo::Formatter::DocBook::Colorize'=>'MojoMojo','MojoMojo::Formatter::Emote'=>'MojoMojo','MojoMojo::Formatter::File'=>'MojoMojo','MojoMojo::Formatter::File::DocBook'=>'MojoMojo','MojoMojo::Formatter::File::Image'=>'MojoMojo','MojoMojo::Formatter::File::Pod'=>'MojoMojo','MojoMojo::Formatter::File::Test'=>'MojoMojo','MojoMojo::Formatter::File::Text'=>'MojoMojo','MojoMojo::Formatter::Gist'=>'MojoMojo','MojoMojo::Formatter::GoogleCalendar'=>'MojoMojo','MojoMojo::Formatter::GoogleSearch'=>'MojoMojo','MojoMojo::Formatter::IDLink'=>'MojoMojo','MojoMojo::Formatter::IRCLog'=>'MojoMojo','MojoMojo::Formatter::Include'=>'MojoMojo','MojoMojo::Formatter::Main'=>'MojoMojo','MojoMojo::Formatter::Markdown'=>'MojoMojo','MojoMojo::Formatter::Pod'=>'MojoMojo','MojoMojo::Formatter::Pod::Simple::HTML'=>'MojoMojo','MojoMojo::Formatter::RSS'=>'MojoMojo','MojoMojo::Formatter::Redirect'=>'MojoMojo','MojoMojo::Formatter::SyntaxHighlight'=>'MojoMojo','MojoMojo::Formatter::TOC'=>'MojoMojo','MojoMojo::Formatter::Text'=>'MojoMojo','MojoMojo::Formatter::Textile'=>'MojoMojo','MojoMojo::Formatter::Wiki'=>'MojoMojo','MojoMojo::Formatter::WikipediaLink'=>'MojoMojo','MojoMojo::Formatter::YouTube'=>'MojoMojo','MojoMojo::I18N'=>'MojoMojo','MojoMojo::Model::DBIC'=>'MojoMojo','MojoMojo::Model::Search'=>'MojoMojo','MojoMojo::Model::Themes'=>'MojoMojo','MojoMojo::Schema'=>'MojoMojo','MojoMojo::Schema::Base::Result'=>'MojoMojo','MojoMojo::Schema::Base::ResultSet'=>'MojoMojo','MojoMojo::Schema::Result::Attachment'=>'MojoMojo','MojoMojo::Schema::Result::Comment'=>'MojoMojo','MojoMojo::Schema::Result::Content'=>'MojoMojo','MojoMojo::Schema::Result::Entry'=>'MojoMojo','MojoMojo::Schema::Result::Journal'=>'MojoMojo','MojoMojo::Schema::Result::Link'=>'MojoMojo','MojoMojo::Schema::Result::Page'=>'MojoMojo','MojoMojo::Schema::Result::PageVersion'=>'MojoMojo','MojoMojo::Schema::Result::PathPermissions'=>'MojoMojo','MojoMojo::Schema::Result::Person'=>'MojoMojo','MojoMojo::Schema::Result::Photo'=>'MojoMojo','MojoMojo::Schema::Result::Preference'=>'MojoMojo','MojoMojo::Schema::Result::Role'=>'MojoMojo','MojoMojo::Schema::Result::RoleMember'=>'MojoMojo','MojoMojo::Schema::Result::RolePrivilege'=>'MojoMojo','MojoMojo::Schema::Result::Tag'=>'MojoMojo','MojoMojo::Schema::Result::WantedPage'=>'MojoMojo','MojoMojo::Schema::ResultSet::Attachment'=>'MojoMojo','MojoMojo::Schema::ResultSet::Content'=>'MojoMojo','MojoMojo::Schema::ResultSet::Page'=>'MojoMojo','MojoMojo::Schema::ResultSet::Person'=>'MojoMojo','MojoMojo::Schema::ResultSet::Role'=>'MojoMojo','MojoMojo::Schema::ResultSet::Tag'=>'MojoMojo','MojoMojo::View::Email'=>'MojoMojo','MojoMojo::View::JSON'=>'MojoMojo','MojoMojo::View::TT'=>'MojoMojo','MojoMojo::WordDiff'=>'MojoMojo','Mojolicious'=>'Mojolicious','Mojolicious::Command'=>'Mojolicious','Mojolicious::Command::Author::cpanify'=>'Mojolicious','Mojolicious::Command::Author::generate'=>'Mojolicious','Mojolicious::Command::Author::generate::app'=>'Mojolicious','Mojolicious::Command::Author::generate::lite_app'=>'Mojolicious','Mojolicious::Command::Author::generate::makefile'=>'Mojolicious','Mojolicious::Command::Author::generate::plugin'=>'Mojolicious','Mojolicious::Command::Author::inflate'=>'Mojolicious','Mojolicious::Command::cgi'=>'Mojolicious','Mojolicious::Command::cpanify'=>'Mojolicious','Mojolicious::Command::daemon'=>'Mojolicious','Mojolicious::Command::eval'=>'Mojolicious','Mojolicious::Command::generate'=>'Mojolicious','Mojolicious::Command::generate::app'=>'Mojolicious','Mojolicious::Command::generate::lite_app'=>'Mojolicious','Mojolicious::Command::generate::makefile'=>'Mojolicious','Mojolicious::Command::generate::plugin'=>'Mojolicious','Mojolicious::Command::get'=>'Mojolicious','Mojolicious::Command::inflate'=>'Mojolicious','Mojolicious::Command::prefork'=>'Mojolicious','Mojolicious::Command::psgi'=>'Mojolicious','Mojolicious::Command::routes'=>'Mojolicious','Mojolicious::Command::test'=>'Mojolicious','Mojolicious::Command::version'=>'Mojolicious','Mojolicious::Commands'=>'Mojolicious','Mojolicious::Controller'=>'Mojolicious','Mojolicious::Lite'=>'Mojolicious','Mojolicious::Plugin'=>'Mojolicious','Mojolicious::Plugin::Config'=>'Mojolicious','Mojolicious::Plugin::Config::Sandbox'=>'Mojolicious','Mojolicious::Plugin::DefaultHelpers'=>'Mojolicious','Mojolicious::Plugin::EPLRenderer'=>'Mojolicious','Mojolicious::Plugin::EPRenderer'=>'Mojolicious','Mojolicious::Plugin::HeaderCondition'=>'Mojolicious','Mojolicious::Plugin::JSONConfig'=>'Mojolicious','Mojolicious::Plugin::Mount'=>'Mojolicious','Mojolicious::Plugin::OAuth2'=>'Mojolicious-Plugin-OAuth2','Mojolicious::Plugin::PODRenderer'=>'Mojolicious','Mojolicious::Plugin::TagHelpers'=>'Mojolicious','Mojolicious::Plugins'=>'Mojolicious','Mojolicious::Renderer'=>'Mojolicious','Mojolicious::Routes'=>'Mojolicious','Mojolicious::Routes::Match'=>'Mojolicious','Mojolicious::Routes::Pattern'=>'Mojolicious','Mojolicious::Routes::Route'=>'Mojolicious','Mojolicious::Sessions'=>'Mojolicious','Mojolicious::Static'=>'Mojolicious','Mojolicious::Types'=>'Mojolicious','Mojolicious::Validator'=>'Mojolicious','Mojolicious::Validator::Validation'=>'Mojolicious','MultipartBuffer'=>'CGI','My::Chat'=>'SOAP-Lite','My::Examples'=>'SOAP-Lite','My::Parameters'=>'SOAP-Lite','My::PersistentIterator'=>'SOAP-Lite','My::PingPong'=>'SOAP-Lite','My::SessionIterator'=>'SOAP-Lite','MyFeatureFileLoader'=>'GBrowse','Mysql'=>'DBD-mysql','Mysql::Statement'=>'DBD-mysql','Mysql::db'=>'DBD-mysql','Mysql::dr'=>'DBD-mysql','Mysql::st'=>'DBD-mysql','Net::DNS'=>'Net-DNS','Net::DNS::Domain'=>'Net-DNS','Net::DNS::DomainName'=>'Net-DNS','Net::DNS::DomainName1035'=>'Net-DNS','Net::DNS::DomainName2535'=>'Net-DNS','Net::DNS::Header'=>'Net-DNS','Net::DNS::Mailbox'=>'Net-DNS','Net::DNS::Mailbox1035'=>'Net-DNS','Net::DNS::Mailbox2535'=>'Net-DNS','Net::DNS::Nameserver'=>'Net-DNS','Net::DNS::Packet'=>'Net-DNS','Net::DNS::Parameters'=>'Net-DNS','Net::DNS::Question'=>'Net-DNS','Net::DNS::RR'=>'Net-DNS','Net::DNS::RR::A'=>'Net-DNS','Net::DNS::RR::AAAA'=>'Net-DNS','Net::DNS::RR::AFSDB'=>'Net-DNS','Net::DNS::RR::APL'=>'Net-DNS','Net::DNS::RR::APL::Item'=>'Net-DNS','Net::DNS::RR::CAA'=>'Net-DNS','Net::DNS::RR::CDNSKEY'=>'Net-DNS','Net::DNS::RR::CDS'=>'Net-DNS','Net::DNS::RR::CERT'=>'Net-DNS','Net::DNS::RR::CNAME'=>'Net-DNS','Net::DNS::RR::CSYNC'=>'Net-DNS','Net::DNS::RR::DHCID'=>'Net-DNS','Net::DNS::RR::DLV'=>'Net-DNS','Net::DNS::RR::DNAME'=>'Net-DNS','Net::DNS::RR::DNSKEY'=>'Net-DNS','Net::DNS::RR::DS'=>'Net-DNS','Net::DNS::RR::EUI48'=>'Net-DNS','Net::DNS::RR::EUI64'=>'Net-DNS','Net::DNS::RR::GPOS'=>'Net-DNS','Net::DNS::RR::HINFO'=>'Net-DNS','Net::DNS::RR::HIP'=>'Net-DNS','Net::DNS::RR::IPSECKEY'=>'Net-DNS','Net::DNS::RR::ISDN'=>'Net-DNS','Net::DNS::RR::KEY'=>'Net-DNS','Net::DNS::RR::KX'=>'Net-DNS','Net::DNS::RR::L32'=>'Net-DNS','Net::DNS::RR::L64'=>'Net-DNS','Net::DNS::RR::LOC'=>'Net-DNS','Net::DNS::RR::LP'=>'Net-DNS','Net::DNS::RR::MB'=>'Net-DNS','Net::DNS::RR::MG'=>'Net-DNS','Net::DNS::RR::MINFO'=>'Net-DNS','Net::DNS::RR::MR'=>'Net-DNS','Net::DNS::RR::MX'=>'Net-DNS','Net::DNS::RR::NAPTR'=>'Net-DNS','Net::DNS::RR::NID'=>'Net-DNS','Net::DNS::RR::NS'=>'Net-DNS','Net::DNS::RR::NSEC'=>'Net-DNS','Net::DNS::RR::NSEC3'=>'Net-DNS','Net::DNS::RR::NSEC3PARAM'=>'Net-DNS','Net::DNS::RR::NULL'=>'Net-DNS','Net::DNS::RR::OPENPGPKEY'=>'Net-DNS','Net::DNS::RR::OPT'=>'Net-DNS','Net::DNS::RR::OPT::CHAIN'=>'Net-DNS','Net::DNS::RR::OPT::CLIENT_SUBNET'=>'Net-DNS','Net::DNS::RR::OPT::COOKIE'=>'Net-DNS','Net::DNS::RR::OPT::DAU'=>'Net-DNS','Net::DNS::RR::OPT::DHU'=>'Net-DNS','Net::DNS::RR::OPT::EXPIRE'=>'Net-DNS','Net::DNS::RR::OPT::KEY_TAG'=>'Net-DNS','Net::DNS::RR::OPT::N3U'=>'Net-DNS','Net::DNS::RR::OPT::PADDING'=>'Net-DNS','Net::DNS::RR::OPT::TCP_KEEPALIVE'=>'Net-DNS','Net::DNS::RR::PTR'=>'Net-DNS','Net::DNS::RR::PX'=>'Net-DNS','Net::DNS::RR::RP'=>'Net-DNS','Net::DNS::RR::RRSIG'=>'Net-DNS','Net::DNS::RR::RT'=>'Net-DNS','Net::DNS::RR::SIG'=>'Net-DNS','Net::DNS::RR::SMIMEA'=>'Net-DNS','Net::DNS::RR::SOA'=>'Net-DNS','Net::DNS::RR::SPF'=>'Net-DNS','Net::DNS::RR::SRV'=>'Net-DNS','Net::DNS::RR::SSHFP'=>'Net-DNS','Net::DNS::RR::TKEY'=>'Net-DNS','Net::DNS::RR::TLSA'=>'Net-DNS','Net::DNS::RR::TSIG'=>'Net-DNS','Net::DNS::RR::TXT'=>'Net-DNS','Net::DNS::RR::URI'=>'Net-DNS','Net::DNS::RR::X25'=>'Net-DNS','Net::DNS::Resolver'=>'Net-DNS','Net::DNS::Resolver::Base'=>'Net-DNS','Net::DNS::Resolver::MSWin32'=>'Net-DNS','Net::DNS::Resolver::Recurse'=>'Net-DNS','Net::DNS::Resolver::UNIX'=>'Net-DNS','Net::DNS::Resolver::android'=>'Net-DNS','Net::DNS::Resolver::cygwin'=>'Net-DNS','Net::DNS::Resolver::os2'=>'Net-DNS','Net::DNS::Resolver::os390'=>'Net-DNS','Net::DNS::Text'=>'Net-DNS','Net::DNS::Update'=>'Net-DNS','Net::DNS::ZoneFile'=>'Net-DNS','Net::DNS::ZoneFile::Generator'=>'Net-DNS','Net::DNS::ZoneFile::Text'=>'Net-DNS','Net::OpenID::Association'=>'Net-OpenID-Consumer','Net::OpenID::ClaimedIdentity'=>'Net-OpenID-Consumer','Net::OpenID::Consumer'=>'Net-OpenID-Consumer','Net::OpenID::VerifiedIdentity'=>'Net-OpenID-Consumer','Otogiri'=>'Otogiri','PAR'=>'PAR','PAR::Filter'=>'PAR-Packer','PAR::Filter::Bleach'=>'PAR-Packer','PAR::Filter::Bytecode'=>'PAR-Packer','PAR::Filter::Obfuscate'=>'PAR-Packer','PAR::Filter::PatchContent'=>'PAR-Packer','PAR::Filter::PodStrip'=>'PAR-Packer','PAR::Heavy'=>'PAR','PAR::Packer'=>'PAR-Packer','PAR::SetupProgname'=>'PAR','PAR::SetupTemp'=>'PAR','PAR::StrippedPARL::Base'=>'PAR-Packer','Perl::Version'=>'Perl-Version','Plack::Middleware::Session'=>'Plack-Middleware-Session','Plack::Middleware::Session::Cookie'=>'Plack-Middleware-Session','Plack::Session'=>'Plack-Middleware-Session','Plack::Session::Cleanup'=>'Plack-Middleware-Session','Plack::Session::State'=>'Plack-Middleware-Session','Plack::Session::State::Cookie'=>'Plack-Middleware-Session','Plack::Session::Store'=>'Plack-Middleware-Session','Plack::Session::Store::Cache'=>'Plack-Middleware-Session','Plack::Session::Store::DBI'=>'Plack-Middleware-Session','Plack::Session::Store::File'=>'Plack-Middleware-Session','Plack::Session::Store::Null'=>'Plack-Middleware-Session','RT::Authen::ExternalAuth'=>'RT-Authen-ExternalAuth','RT::Authen::ExternalAuth::DBI'=>'RT-Authen-ExternalAuth','RT::Authen::ExternalAuth::DBI::Cookie'=>'RT-Authen-ExternalAuth','RT::Authen::ExternalAuth::LDAP'=>'RT-Authen-ExternalAuth','RT::Extension::MobileUI'=>'RT-Extension-MobileUI','RTMP::Client'=>'RTMP-Client','SOAP::Apache'=>'SOAP-Lite','SOAP::Cloneable'=>'SOAP-Lite','SOAP::Constants'=>'SOAP-Lite','SOAP::Custom::XML::Data'=>'SOAP-Lite','SOAP::Custom::XML::Deserializer'=>'SOAP-Lite','SOAP::Data'=>'SOAP-Lite','SOAP::Deserializer'=>'SOAP-Lite','SOAP::Fault'=>'SOAP-Lite','SOAP::Header'=>'SOAP-Lite','SOAP::Lite'=>'SOAP-Lite','SOAP::Lite::COM'=>'SOAP-Lite','SOAP::Lite::Deserializer::XMLSchema1999'=>'SOAP-Lite','SOAP::Lite::Deserializer::XMLSchema2001'=>'SOAP-Lite','SOAP::Lite::Deserializer::XMLSchemaSOAP1_1'=>'SOAP-Lite','SOAP::Lite::Deserializer::XMLSchemaSOAP1_2'=>'SOAP-Lite','SOAP::Lite::Packager'=>'SOAP-Lite','SOAP::Lite::Packager::DIME'=>'SOAP-Lite','SOAP::Lite::Packager::MIME'=>'SOAP-Lite','SOAP::Lite::Utils'=>'SOAP-Lite','SOAP::MIMEParser'=>'SOAP-Lite','SOAP::Packager'=>'SOAP-Lite','SOAP::Packager::DIME'=>'SOAP-Lite','SOAP::Packager::MIME'=>'SOAP-Lite','SOAP::SOM'=>'SOAP-Lite','SOAP::Schema'=>'SOAP-Lite','SOAP::Schema::Deserializer'=>'SOAP-Lite','SOAP::Schema::WSDL'=>'SOAP-Lite','SOAP::Server'=>'SOAP-Lite','SOAP::Server::Object'=>'SOAP-Lite','SOAP::Server::Parameters'=>'SOAP-Lite','SOAP::Test'=>'SOAP-Lite','SOAP::Test::Server'=>'SOAP-Lite','SOAP::Trace'=>'SOAP-Lite','SOAP::Transport'=>'SOAP-Lite','SOAP::Transport::HTTP'=>'SOAP-Lite','SOAP::Transport::HTTP::Daemon'=>'SOAP-Lite','SOAP::Transport::HTTP::Daemon::ForkAfterProcessing'=>'SOAP-Lite','SOAP::Transport::HTTP::Daemon::ForkOnAccept'=>'SOAP-Lite','SOAP::Transport::HTTP::FCGI'=>'SOAP-Lite','SOAP::Transport::IO'=>'SOAP-Lite','SOAP::Transport::IO::Server'=>'SOAP-Lite','SOAP::Transport::LOCAL'=>'SOAP-Lite','SOAP::Transport::LOCAL::Client'=>'SOAP-Lite','SOAP::Transport::LOOPBACK'=>'SOAP-Lite','SOAP::Transport::LOOPBACK::Client'=>'SOAP-Lite','SOAP::Transport::MAILTO'=>'SOAP-Lite','SOAP::Transport::MAILTO::Client'=>'SOAP-Lite','SOAP::Transport::POP3'=>'SOAP-Lite','SOAP::Transport::POP3::Server'=>'SOAP-Lite','SOAP::Transport::TCP'=>'SOAP-Lite','SOAP::Transport::TCP::Client'=>'SOAP-Lite','SOAP::Transport::TCP::Server'=>'SOAP-Lite','SOAP::Utils'=>'SOAP-Lite','SOAP::XMLSchema1999::Deserializer'=>'SOAP-Lite','SOAP::XMLSchema1999::Serializer'=>'SOAP-Lite','SOAP::XMLSchema2001::Deserializer'=>'SOAP-Lite','SOAP::XMLSchema2001::Serializer'=>'SOAP-Lite','SOAP::XMLSchema::Serializer'=>'SOAP-Lite','SOAP::XMLSchemaApacheSOAP::Deserializer'=>'SOAP-Lite','SOAP::XMLSchemaSOAP1_1::Deserializer'=>'SOAP-Lite','SOAP::XMLSchemaSOAP1_2::Deserializer'=>'SOAP-Lite','SVG::Sparkline'=>'SVG-Sparkline','SVG::Sparkline::Area'=>'SVG-Sparkline','SVG::Sparkline::Bar'=>'SVG-Sparkline','SVG::Sparkline::Line'=>'SVG-Sparkline','SVG::Sparkline::RangeArea'=>'SVG-Sparkline','SVG::Sparkline::RangeBar'=>'SVG-Sparkline','SVG::Sparkline::Utils'=>'SVG-Sparkline','SVG::Sparkline::Whisker'=>'SVG-Sparkline','SVN::Look'=>'SVN-Look','Search::OpenSearch::Result'=>'Search-OpenSearch-Server','Search::OpenSearch::Server'=>'Search-OpenSearch-Server','Search::OpenSearch::Server::Catalyst'=>'Search-OpenSearch-Server','Search::OpenSearch::Server::Plack'=>'Search-OpenSearch-Server','Storable'=>'Storable','TempFile'=>'CGI','Test::Mojo'=>'Mojolicious','Test::Simply'=>'Fake-Our','Text::SmartyPants'=>'MojoMojo','Text::Wikispaces2Markdown'=>'MojoMojo','Tie::Watch'=>'Tk','Tk'=>'Tk','Tk::Adjuster'=>'Tk','Tk::Adjuster::Item'=>'Tk','Tk::After'=>'Tk','Tk::Animation'=>'Tk','Tk::Balloon'=>'Tk','Tk::Bitmap'=>'Tk','Tk::BrowseEntry'=>'Tk','Tk::Button'=>'Tk','Tk::Canvas'=>'Tk','Tk::Checkbutton'=>'Tk','Tk::Clipboard'=>'Tk','Tk::CmdLine'=>'Tk','Tk::ColorDialog'=>'Tk','Tk::ColorEditor'=>'Tk','Tk::ColorSelect'=>'Tk','Tk::Compound'=>'Tk','Tk::Configure'=>'Tk','Tk::Derived'=>'Tk','Tk::Dialog'=>'Tk','Tk::DialogBox'=>'Tk','Tk::DirTree'=>'Tk','Tk::DirTreeDialog'=>'Tk','Tk::Dirlist'=>'Tk','Tk::DragDrop'=>'Tk','Tk::DragDrop::Common'=>'Tk','Tk::DragDrop::Local'=>'Tk','Tk::DragDrop::Rect'=>'Tk','Tk::DragDrop::SunConst'=>'Tk','Tk::DragDrop::SunDrop'=>'Tk','Tk::DragDrop::SunSite'=>'Tk','Tk::DragDrop::Win32Drop'=>'Tk','Tk::DragDrop::Win32Site'=>'Tk','Tk::DragDrop::XDNDDrop'=>'Tk','Tk::DragDrop::XDNDSite'=>'Tk','Tk::DropSite'=>'Tk','Tk::DummyEncode'=>'Tk','Tk::DummyEncode::iso8859_1'=>'Tk','Tk::English'=>'Tk','Tk::Entry'=>'Tk','Tk::ErrorDialog'=>'Tk','Tk::Event'=>'Tk','Tk::Event::IO'=>'Tk','Tk::FBox'=>'Tk','Tk::FileSelect'=>'Tk','Tk::FloatEntry'=>'Tk','Tk::Font'=>'Tk','Tk::Frame'=>'Tk','Tk::HList'=>'Tk','Tk::IO'=>'Tk','Tk::IconList'=>'Tk','Tk::Image'=>'Tk','Tk::InputO'=>'Tk','Tk::ItemStyle'=>'Tk','Tk::JPEG'=>'Tk','Tk::LabEntry'=>'Tk','Tk::LabFrame'=>'Tk','Tk::LabRadiobutton'=>'Tk','Tk::Label'=>'Tk','Tk::LabeledEntryLabeledRadiobutton'=>'Tk','Tk::Labelframe'=>'Tk','Tk::Listbox'=>'Tk','Tk::MMtry'=>'Tk','Tk::MMutil'=>'Tk','Tk::MainWindow'=>'Tk','Tk::MakeDepend'=>'Tk','Tk::Menu'=>'Tk','Tk::Menu::Button'=>'Tk','Tk::Menu::Cascade'=>'Tk','Tk::Menu::Checkbutton'=>'Tk','Tk::Menu::Item'=>'Tk','Tk::Menu::Radiobutton'=>'Tk','Tk::Menu::Separator'=>'Tk','Tk::Menubar'=>'Tk','Tk::Menubutton'=>'Tk','Tk::Message'=>'Tk','Tk::MsgBox'=>'Tk','Tk::Mwm'=>'Tk','Tk::NBFrame'=>'Tk','Tk::NoteBook'=>'Tk','Tk::Optionmenu'=>'Tk','Tk::PNG'=>'Tk','Tk::Pane'=>'Tk','Tk::Panedwindow'=>'Tk','Tk::Photo'=>'Tk','Tk::Pixmap'=>'Tk','Tk::Pretty'=>'Tk','Tk::ProgressBar'=>'Tk','Tk::ROText'=>'Tk','Tk::Radiobutton'=>'Tk','Tk::Region'=>'Tk','Tk::Reindex'=>'Tk','Tk::ReindexedROText'=>'Tk','Tk::ReindexedText'=>'Tk','Tk::Scale'=>'Tk','Tk::Scrollbar'=>'Tk','Tk::Spinbox'=>'Tk','Tk::Stats'=>'Tk','Tk::Stdio'=>'PAR','Tk::Stdio::Handle'=>'PAR','Tk::Submethods'=>'Tk','Tk::TList'=>'Tk','Tk::Table'=>'Tk','Tk::Text'=>'Tk','Tk::Text::Tag'=>'Tk','Tk::TextEdit'=>'Tk','Tk::TextList'=>'Tk','Tk::TextUndo'=>'Tk','Tk::Tiler'=>'Tk','Tk::TixGrid'=>'Tk','Tk::Toplevel'=>'Tk','Tk::Trace'=>'Tk','Tk::Tree'=>'Tk','Tk::Widget'=>'Tk','Tk::WinPhoto'=>'Tk','Tk::Wm'=>'Tk','Tk::X'=>'Tk','Tk::X11Font'=>'Tk','Tk::Xlib'=>'Tk','Tk::Xrm'=>'Tk','Tk::install'=>'Tk','Tk::widgets'=>'Tk','UDDI::Constants'=>'SOAP-Lite','UI::Dialog'=>'UI-Dialog','UI::Dialog::Backend'=>'UI-Dialog','UI::Dialog::Backend::ASCII'=>'UI-Dialog','UI::Dialog::Backend::CDialog'=>'UI-Dialog','UI::Dialog::Backend::GDialog'=>'UI-Dialog','UI::Dialog::Backend::KDialog'=>'UI-Dialog','UI::Dialog::Backend::Nautilus'=>'UI-Dialog','UI::Dialog::Backend::NotifySend'=>'UI-Dialog','UI::Dialog::Backend::Whiptail'=>'UI-Dialog','UI::Dialog::Backend::XDialog'=>'UI-Dialog','UI::Dialog::Backend::XOSD'=>'UI-Dialog','UI::Dialog::Backend::Zenity'=>'UI-Dialog','UI::Dialog::Console'=>'UI-Dialog','UI::Dialog::GNOME'=>'UI-Dialog','UI::Dialog::Gauged'=>'UI-Dialog','UI::Dialog::KDE'=>'UI-Dialog','UI::Dialog::Screen::Druid'=>'UI-Dialog','UI::Dialog::Screen::Menu'=>'UI-Dialog','URI::jabber'=>'SOAP-Lite','WidgetDemo'=>'Tk','XML::LibXML'=>'XML-LibXML','XML::LibXML::Attr'=>'XML-LibXML','XML::LibXML::AttributeHash'=>'XML-LibXML','XML::LibXML::Boolean'=>'XML-LibXML','XML::LibXML::CDATASection'=>'XML-LibXML','XML::LibXML::Comment'=>'XML-LibXML','XML::LibXML::Common'=>'XML-LibXML','XML::LibXML::Devel'=>'XML-LibXML','XML::LibXML::Document'=>'XML-LibXML','XML::LibXML::DocumentFragment'=>'XML-LibXML','XML::LibXML::Dtd'=>'XML-LibXML','XML::LibXML::Element'=>'XML-LibXML','XML::LibXML::ErrNo'=>'XML-LibXML','XML::LibXML::Error'=>'XML-LibXML','XML::LibXML::InputCallback'=>'XML-LibXML','XML::LibXML::Literal'=>'XML-LibXML','XML::LibXML::NamedNodeMap'=>'XML-LibXML','XML::LibXML::Namespace'=>'XML-LibXML','XML::LibXML::Node'=>'XML-LibXML','XML::LibXML::NodeList'=>'XML-LibXML','XML::LibXML::Number'=>'XML-LibXML','XML::LibXML::PI'=>'XML-LibXML','XML::LibXML::Pattern'=>'XML-LibXML','XML::LibXML::Reader'=>'XML-LibXML','XML::LibXML::RegExp'=>'XML-LibXML','XML::LibXML::RelaxNG'=>'XML-LibXML','XML::LibXML::SAX'=>'XML-LibXML','XML::LibXML::SAX::AttributeNode'=>'XML-LibXML','XML::LibXML::SAX::Builder'=>'XML-LibXML','XML::LibXML::SAX::Generator'=>'XML-LibXML','XML::LibXML::SAX::Parser'=>'XML-LibXML','XML::LibXML::Schema'=>'XML-LibXML','XML::LibXML::Text'=>'XML-LibXML','XML::LibXML::XPathContext'=>'XML-LibXML','XML::LibXML::XPathExpression'=>'XML-LibXML','XML::LibXML::_SAXParser'=>'XML-LibXML','back_tick_a_command'=>'PAR','encoding'=>'Encode','mod_perl'=>'mod_perl','mod_perl2'=>'mod_perl','ojo'=>'Mojolicious','pipe_a_command'=>'PAR','pp'=>'PAR-Packer','prior_to_test'=>'PAR','remove_file_and_try_executable_again'=>'PAR','test_in_further_subdir'=>'PAR' }}}1;
CPAN_AUDIT_DB

$fatpacked{"CPAN/Audit/Discover.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_DISCOVER';
  package CPAN::Audit::Discover;use strict;use warnings;use CPAN::Audit::Discover::Cpanfile;use CPAN::Audit::Discover::CpanfileSnapshot;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub discover {my$self=shift;my ($path)=@_;if (-f "$path/cpanfile.snapshot"){return CPAN::Audit::Discover::CpanfileSnapshot->new->discover("$path/cpanfile.snapshot")}elsif (-f "$path/cpanfile"){return CPAN::Audit::Discover::Cpanfile->new->discover("$path/cpanfile")}else {}return}1;
CPAN_AUDIT_DISCOVER

$fatpacked{"CPAN/Audit/Discover/Cpanfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_DISCOVER_CPANFILE';
  package CPAN::Audit::Discover::Cpanfile;use strict;use warnings;use Module::CPANfile;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub discover {my$self=shift;my ($cpanfile_path)=@_;my$cpanfile=Module::CPANfile->load($cpanfile_path);my$prereqs=$cpanfile->prereqs->as_string_hash;my@deps;for my$phase (keys %$prereqs){for my$type (keys %{$prereqs->{$phase}}){for my$module (keys %{$prereqs->{$phase}->{$type}}){my$version=$prereqs->{$phase}->{$type}->{$module};next if$module eq 'perl';push@deps,{module=>$module,version=>$version,}}}}return@deps}1;
CPAN_AUDIT_DISCOVER_CPANFILE

$fatpacked{"CPAN/Audit/Discover/CpanfileSnapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_DISCOVER_CPANFILESNAPSHOT';
  package CPAN::Audit::Discover::CpanfileSnapshot;use strict;use warnings;use CPAN::DistnameInfo;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub discover {my$self=shift;my ($cpanfile_snapshot_path)=@_;open my$fh,'<',$cpanfile_snapshot_path or die $!;my@deps;while (defined(my$line=<$fh>)){if ($line =~ m/pathname: ([^\s]+)/){next unless my$d=CPAN::DistnameInfo->new($1);next unless$d->dist && $d->version;push@deps,{dist=>$d->dist,version=>$d->version,}}}close$fh;return@deps}1;
CPAN_AUDIT_DISCOVER_CPANFILESNAPSHOT

$fatpacked{"CPAN/Audit/Installed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_INSTALLED';
  package CPAN::Audit::Installed;use strict;use warnings;use File::Find ();use Cwd ();sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{db}=$params{db};$self->{cb}=$params{cb};return$self}sub find {my$self=shift;my (@inc)=@_;@inc=@INC unless@inc;@inc=grep {defined && -d $_}map {Cwd::realpath($_)}@inc;my%seen;my@deps;File::Find::find({wanted=>sub {my$path=$File::Find::name;if ($path && -f $path && m/\.pm$/){return unless my$module=module_from_file($path);return unless my$distname=$self->{db}->{module2dist}->{$module};my$dist=$self->{db}->{dists}->{$distname};if ($dist->{main_module}eq $module){return if$seen{$module}++;return unless my$version=module_version($path);push@deps,{dist=>$distname,version=>$version };if ($self->{cb}){$self->{cb}->({path=>$path,distname=>$distname,version=>$version })}}}},follow=>1,follow_skip=>2,},@inc);return@deps}sub module_version {my ($parsefile)=@_;open my$mod,'<',$parsefile or die $!;my$inpod=0;my$result;local $_;while (<$mod>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;chomp;next unless m/([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;my$eval=qq{
              package CPAN::Audit::_version;
              no strict;
  
              local $1$2;
              \$$2=undef; do {
                  $_
              }; \$$2
          };local $^W=0;$result=eval($eval);warn "Could not eval '$eval' in $parsefile: $@" if $@;$result="undef" unless defined$result;last}close$mod;return$result}sub module_from_file {my ($path)=@_;my$module;open my$fh,'<',$path or return;while (my$line=<$fh>){if ($line =~ m/package\s+(.*?)\s*;/ms){$module=$1;last}}close$fh;return unless$module}1;
CPAN_AUDIT_INSTALLED

$fatpacked{"CPAN/Audit/Query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_QUERY';
  package CPAN::Audit::Query;use strict;use warnings;use CPAN::Audit::Version;sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{db}=$params{db}|| {};return$self}sub advisories_for {my$self=shift;my ($distname,$version_range)=@_;my$dist=$self->{db}->{dists}->{$distname};return unless$dist;my@advisories=@{$dist->{advisories}};my@versions=@{$dist->{versions}};if (!$version_range){return@advisories}my$version_checker=CPAN::Audit::Version->new;my@all_versions=map {$_->{version}}@versions;my@selected_versions;for my$version (@all_versions){if ($version_checker->in_range($version,$version_range)){push@selected_versions,$version}}if (!@selected_versions){return}my@matched_advisories;for my$advisory (@advisories){my@affected_versions=$version_checker->affected_versions(\@all_versions,$advisory->{affected_versions});next unless@affected_versions;for my$affected_version (reverse@affected_versions){if ($version_checker->in_range($affected_version,$version_range)){push@matched_advisories,$advisory;last}}}if (!@matched_advisories){return}return@matched_advisories}1;
CPAN_AUDIT_QUERY

$fatpacked{"CPAN/Audit/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_VERSION';
  package CPAN::Audit::Version;use strict;use warnings;use version;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub in_range {my$self=shift;my ($version,$range)=@_;return unless defined$version && defined$range;my@ands=split /\s*,\s*/,$range;return unless defined($version=eval {version->parse($version)});for my$and (@ands){my ($op,$range_version)=$and =~ m/^(<=|<|>=|>|==|!=)?\s*([^\s]+)$/;return unless defined($range_version=eval {version->parse($range_version)});$op='>=' unless defined$op;if ($op eq '<'){return unless$version < $range_version}elsif ($op eq '<='){return unless$version <= $range_version}elsif ($op eq '>'){return unless$version > $range_version}elsif ($op eq '>='){return unless$version >= $range_version}elsif ($op eq '=='){return unless$version==$range_version}elsif ($op eq '!='){return unless$version!=$range_version}else {return 0}}return 1}sub affected_versions {my$self=shift;my ($available_versions,$range)=@_;my@affected_versions;for my$version (@$available_versions){if ($self->in_range($version,$range)){push@affected_versions,$version}}return@affected_versions}1;
CPAN_AUDIT_VERSION

$fatpacked{"CPAN/Changes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_CHANGES';
  package CPAN::Changes;use strict;use warnings;use CPAN::Changes::Release;use Scalar::Util ();use version ();use Encode qw(decode FB_CROAK LEAVE_SRC);our$VERSION='0.400002';our$W3CDTF_REGEX=qr{(\d\d\d\d) # Year
                   (?:-(\d\d) # -Month
                   (?:-(\d\d) # -Day
                   (?:[T\s]
                     (\d\d):(\d\d) # Hour:Minute
                     (?:
                       :(\d\d)     # :Second
                       (\.\d+)?    # .Fractional_Second
                     )?
                     ( Z          # UTC
                     | [+-]\d\d:\d\d    # Hour:Minute TZ offset
                       (?::\d\d)?       # :Second TZ offset
                   )?)?)?)?}x;my@m=qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);my%months=map {$m[$_ ]=>$_ + 1}0 .. 11;our$UNKNOWN_VALS=join('|',('Unknown Release Date','Unknown','Not Released','Development Release','Development','Developer Release',));sub new {my$class=shift;return bless {preamble=>'',releases=>{},months=>\%months,@_,},$class}sub load {my ($class,$file,@args)=@_;open(my$fh,'<:raw',$file)or die $!;my$content=do {local $/;<$fh>};close$fh;eval {$content=decode('UTF-8',$content,FB_CROAK | LEAVE_SRC)};return$class->load_string($content,@args)}sub load_string {my ($class,$string,@args)=@_;my$changes=$class->new(@args);my$preamble='';my (@releases,$ingroup,$indent);$string =~ s/(?:\015{1,2}\012|\015|\012)/\n/gs;my@lines=split("\n",$string);my$version_line_re =$changes->{next_token }? qr/^(?:$version::LAX|$changes->{next_token})/ : qr/^$version::LAX/;$preamble .= shift(@lines)."\n" while@lines && $lines[0 ]!~ $version_line_re;for my$l (@lines){if ($l =~ $version_line_re){my ($v,$n)=split m{\s[\W\s]*},$l,2;my$match='';my$d;if ($n){if ($n =~ m{^($UNKNOWN_VALS)}i){$d=$1;$match=$d}elsif ($n =~ m{^(\D{3}\s+(\D{3})\s+(\d{1,2})\s+([\d:]+)?\D*(\d{4}))}){$match=$1;if ($4){$d=sprintf('%d-%02d-%02dT%sZ',$5,$changes->{months }->{$2 },$3,$4)}else {$d=sprintf('%d-%02d-%02d',$5,$changes->{months }->{$2 },$3)}}elsif ($n =~ m{^(\D{3}, (\d{1,2}) (\D{3}) (\d{4}) (\d\d:\d\d:\d\d) ([+-])(\d{2})(\d{2}))}){$match=$1;$d=sprintf('%d-%02d-%02dT%s%s%02d:%02d',$4,$changes->{months }->{$3 },$2,$5,$6,$7,$8)}elsif ($n =~ m{^((\d{4}-\d\d-\d\d)\s+(\d\d:\d\d(?::\d\d)?))(?:\s+[A-Za-z]+/[A-Za-z_-]+)}){$match=$1;$d=sprintf('%sT%sZ',$2,$3)}elsif ($n =~ m{^($W3CDTF_REGEX)}){$match=$1;$d=$match;$d =~ s{ }{T};$d .= 'Z' if length($d)==16 || length($d)==19 || $d =~ m{\.\d+$}}$n =~ s{^\Q$match\E\s*}{}}undef$d unless length$d;undef$n unless length$n;push@releases,CPAN::Changes::Release->new(version=>$v,date=>$d,_parsed_date=>$match,note=>$n,);$ingroup=undef;$indent=undef;next}if ($l =~ m{^\s+\[\s*([^\[\]]+?)\s*\]\s*$}){$ingroup=$1;$releases[-1 ]->add_group($1);next}$ingroup='' if!defined$ingroup;next if$l =~ m{^\s*$};if (!defined$indent){$indent =$l =~ m{^(\s+)} ? '\s' x length $1 : ''}$l =~ s{^$indent}{};if ($l =~ m{^\s} &&!@{$releases[-1 ]->changes($ingroup)}){$l =~ m{^(\s+)};$indent=$1;$l =~ s{^\s+}{}}if ($l =~ m{^\s}){$l =~ s{^\s+}{};my$changeset=$releases[-1 ]->changes($ingroup);$changeset->[-1 ].= " $l"}else {$l =~ s{^[^[:alnum:]]+\s}{};$releases[-1 ]->add_changes({group=>$ingroup },$l)}}$changes->preamble($preamble);$changes->releases(@releases);return$changes}sub preamble {my$self=shift;if (@_){my$preamble=shift;$preamble =~ s{\s+$}{}s;$self->{preamble }=$preamble}return$self->{preamble }}sub releases {my$self=shift;if (@_){$self->{releases }={};$self->add_release(@_)}my$sort_function=sub {(eval {(my$v=$a->version)=~ s/-TRIAL$//;version->parse($v)}|| 0)<=> (eval {(my$v=$b->version)=~ s/-TRIAL$//;version->parse($v)}|| 0)or ($a->date || '')cmp($b->date || '')};my$next_token=$self->{next_token };my$token_sort_function=sub {$a->version =~ $next_token - $b->version =~ $next_token or $sort_function->()};my$sort=$next_token ? $token_sort_function : $sort_function;return sort$sort values %{$self->{releases }}}sub add_release {my$self=shift;for my$release (@_){my$new=Scalar::Util::blessed$release ? $release : CPAN::Changes::Release->new(%$release);$self->{releases }->{$new->version }=$new}}sub delete_release {my$self=shift;delete$self->{releases }->{$_ }for @_}sub release {my ($self,$version)=@_;return unless exists$self->{releases }->{$version };return$self->{releases }->{$version }}sub delete_empty_groups {my$self=shift;$_->delete_empty_groups for$self->releases}sub serialize {my$self=shift;my%args=@_;my%release_args;$release_args{group_sort }=$args{group_sort }if$args{group_sort };my$output;$output=$self->preamble ."\n\n" if$self->preamble;my@r=$self->releases;@r=reverse@r unless$args{reverse};$output .= $_->serialize(%release_args)for@r;$output =~ s/\n\n+\z/\n/;return$output}1;
CPAN_CHANGES

$fatpacked{"CPAN/Changes/Group.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_CHANGES_GROUP';
  package CPAN::Changes::Group;use strict;use warnings;use Text::Wrap ();sub new {my$class=shift;return bless {changes=>[],@_,},$class}sub name {my$self=shift;if (not exists$self->{name }){$self->{name }=q[]}return$self->{name }}sub changes {my$self=shift;return$self->{changes }}sub add_changes {my$self=shift;push @{$self->{changes }},@_}sub set_changes {my$self=shift;$self->{changes }=\@_}sub clear_changes {my$self=shift;$self->{changes }=[]}sub is_empty {my$self=shift;return!@{$self->changes}}sub serialize {my$self=shift;my%args=@_;my$output='';my$name=$self->name;$output .= sprintf " [%s]\n",$name if length$name;local$Text::Wrap::break='[\t ]';local$Text::Wrap::huge='overflow';$output .= Text::Wrap::wrap(' - ','   ',$_)."\n" for @{$self->changes};return$output}1;
CPAN_CHANGES_GROUP

$fatpacked{"CPAN/Changes/Release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_CHANGES_RELEASE';
  package CPAN::Changes::Release;use strict;use warnings;use Text::Wrap ();use CPAN::Changes::Group;use Scalar::Util qw(blessed);sub new {my$class=shift;return bless {changes=>{},@_,},$class}sub version {my$self=shift;if (@_){$self->{version }=shift}return$self->{version }}sub date {my$self=shift;if (@_){$self->{date }=shift}return$self->{date }}sub note {my$self=shift;if (@_){$self->{note }=shift}return$self->{note }}sub changes {my$self=shift;if (@_){my$group=shift;return unless exists$self->{changes }->{$group };return$self->{changes }->{$group }->changes}return {map {$_=>$self->{changes }->{$_}->changes}keys %{$self->{changes }}}}sub add_changes {my$self=shift;my$group='';if (ref $_[0 ]){$group=shift->{group }}$self->get_group($group)->add_changes(@_)}sub set_changes {my$self=shift;my$group='';if (ref $_[0 ]){$group=shift->{group }}$self->get_group($group)->set_changes(@_)}sub clear_changes {my$self=shift;$self->{changes }={}}sub groups {my$self=shift;my%args=@_;$args{sort }||= sub {sort @_};return$args{sort }->(keys %{$self->{changes }})}sub get_group {my$self=shift;my$group='';if ($_[0 ]){$group=shift}if (!exists$self->{changes }->{$group }){$self->{changes }->{$group }=CPAN::Changes::Group->new(name=>$group)}if (not blessed$self->{changes}->{$group}){$self->{changes }->{$group }=CPAN::Changes::Group->new(name=>$group,changes=>$self->{changes}->{$group})}return$self->{changes }->{$group }}sub attach_group {my$self=shift;my$group=shift;die "Not a group" unless blessed$group;my$name=$group->name;$self->{changes}->{$name}=$group}sub group_values {my$self=shift;return map {$self->get_group($_)}$self->groups(@_)}sub add_group {my$self=shift;$self->{changes }->{$_ }=CPAN::Changes::Group->new(name=>$_)for @_}sub delete_group {my$self=shift;my@groups=@_;@groups=('')unless@groups;delete$self->{changes }->{$_ }for@groups}sub delete_empty_groups {my$self=shift;$self->delete_group($_->name)for grep {$_->is_empty}$self->group_values}sub serialize {my$self=shift;my%args=@_;my$output=join(' ',grep {defined && length}($self->version,$self->date,$self->note))."\n";$output .= join "\n",map {$_->serialize}$self->group_values(sort=>$args{group_sort });$output .= "\n";return$output}1;
CPAN_CHANGES_RELEASE

$fatpacked{"CPAN/Common/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index;our$VERSION='0.010';use Carp ();use Class::Tiny;sub index_age {time}sub refresh_index {1}sub attributes {{}}sub validate_attributes {1}1;
CPAN_COMMON_INDEX

$fatpacked{"CPAN/Common/Index/LocalPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_LOCALPACKAGE';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::LocalPackage;our$VERSION='0.010';use parent 'CPAN::Common::Index::Mirror';use Class::Tiny qw/source/;use Carp;use File::Basename ();use File::Copy ();use File::Spec;use File::stat ();sub BUILD {my$self=shift;my$file=$self->source;if (!defined$file){Carp::croak("'source' parameter must be provided")}elsif (!-f $file){Carp::croak("index file '$file' does not exist")}return}sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($self->source));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub refresh_index {my ($self)=@_;my$source=$self->source;my$basename=File::Basename::basename($source);if ($source =~ /\.gz$/){Carp::croak "can't load gz source files without IO::Uncompress::Gunzip\n" unless$CPAN::Common::Index::Mirror::HAS_IO_UNCOMPRESS_GUNZIP;(my$uncompressed=$basename)=~ s/\.gz$//;$uncompressed=File::Spec->catfile($self->cache,$uncompressed);if (!-f $uncompressed or File::stat::stat($source)->mtime > File::stat::stat($uncompressed)->mtime){no warnings 'once';IO::Uncompress::Gunzip::gunzip(map {"$_"}$source,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}else {my$dest=File::Spec->catfile($self->cache,$basename);File::Copy::copy($source,$dest)if!-e $dest || File::stat::stat($source)->mtime > File::stat::stat($dest)->mtime}return 1}sub search_authors {return};1;
CPAN_COMMON_INDEX_LOCALPACKAGE

$fatpacked{"CPAN/Common/Index/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_METADB';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::MetaDB;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/uri/;use Carp;use CPAN::Meta::YAML;use HTTP::Tiny;sub BUILD {my$self=shift;my$uri=$self->uri;$uri="http://cpanmetadb.plackperl.org/v1.0/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';return unless keys %$args==1 && exists$args->{package}&& ref$args->{package}eq '';my$mod=$args->{package};my$res=HTTP::Tiny->new->get($self->uri ."package/$mod");return unless$res->{success};if (my$yaml=CPAN::Meta::YAML->read_string($res->{content})){my$meta=$yaml->[0];if ($meta && $meta->{distfile}){my$file=$meta->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$meta->{version},uri=>"cpan:///distfile/$file",}}}return}sub index_age {return time};sub search_authors {return};1;
CPAN_COMMON_INDEX_METADB

$fatpacked{"CPAN/Common/Index/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MIRROR';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mirror;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/cache mirror/;use Carp;use CPAN::DistnameInfo;use File::Basename ();use File::Fetch;use File::Temp 0.19;use Search::Dict 1.07;use Tie::Handle::SkipHeader;use URI;our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};sub BUILD {my$self=shift;my$cache=$self->cache;$cache=File::Temp->newdir unless defined$cache;if (!-d $cache){Carp::croak("Cache directory '$cache' does not exist")}$self->cache($cache);my$mirror=$self->mirror;$mirror="http://www.cpan.org/" unless defined$mirror;$mirror =~ s{/?$}{/};$self->mirror($mirror);return}my%INDICES=(mailrc=>'authors/01mailrc.txt.gz',packages=>'modules/02packages.details.txt.gz',);my%TEST_GENERATORS=(regexp_nocase=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/i;return sub {$_[0]=~ $re}},regexp=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/;return sub {$_[0]=~ $re}},version=>sub {my$arg=shift;my$v=version->parse($arg);return sub {eval {version->parse($_[0])==$v}}},);my%QUERY_TYPES=(package=>'regexp',version=>'version',dist=>'regexp',id=>'regexp_nocase',fullname=>'regexp_nocase',email=>'regexp_nocase',);sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{packages}));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub cached_mailrc {my ($self)=@_;my$mailrc=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{mailrc}));$mailrc =~ s/\.gz$//;$self->refresh_index unless -r $mailrc;return$mailrc}sub refresh_index {my ($self)=@_;for my$file (values%INDICES){my$remote=URI->new_abs($file,$self->mirror);$remote =~ s/\.gz$// unless$HAS_IO_UNCOMPRESS_GUNZIP;my$ff=File::Fetch->new(uri=>$remote);my$where=$ff->fetch(to=>$self->cache)or Carp::croak($ff->error);if ($HAS_IO_UNCOMPRESS_GUNZIP){(my$uncompressed=$where)=~ s/\.gz$//;no warnings 'once';IO::Uncompress::Gunzip::gunzip($where,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}return 1}sub index_age {my ($self)=@_;my$package=$self->cached_package;return (-r $package ? (stat($package))[9]: 0)}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_package;die "Can't read $index_path" unless -r $index_path;my$fh=IO::Handle->new;tie *$fh,'Tie::Handle::SkipHeader',"<",$index_path or die "Can't tie $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{package}and ref$args->{package}eq ''){my$pos=look$fh,$args->{package},{xfrm=>\&_xform_package,fold=>1 };return if$pos==-1;LINE: while (my$line=<$fh>){last unless$line =~ /\A\Q$args->{package}\E\s+/i;push@found,_match_package_line($line,$rules)}}else {LINE: while (my$line=<$fh>){push@found,_match_package_line($line,$rules)}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_mailrc;die "Can't read $index_path" unless -r $index_path;open my$fh,$index_path or die "Can't open $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{id}and ref$args->{id}eq ''){my$pos=look$fh,$args->{id},{xfrm=>\&_xform_mailrc,fold=>1 };return if$pos==-1;my$line=<$fh>;push@found,_match_mailrc_line($line,$rules)}else {LINE: while (my$line=<$fh>){push@found,_match_mailrc_line($line,$rules)}}return wantarray ? @found : $found[0]}sub _rulify {my ($key,$arg)=@_;return$arg if ref($arg)eq 'CODE';return$TEST_GENERATORS{$QUERY_TYPES{$key}}->($arg)}sub _xform_package {my@fields=split " ",$_[0],2;return$fields[0]}sub _xform_mailrc {my@fields=split " ",$_[0],3;return$fields[1]}sub _match_package_line {my ($line,$rules)=@_;return unless defined$line;my ($mod,$version,$dist,$comment)=split " ",$line,4;if ($rules->{package}){return unless$rules->{package}->($mod)}if ($rules->{version}){return unless$rules->{version}->($version)}if ($rules->{dist}){return unless$rules->{dist}->($dist)}$dist =~ s{\A./../}{};return {package=>$mod,version=>$version,uri=>"cpan:///distfile/$dist",}}sub _match_mailrc_line {my ($line,$rules)=@_;return unless defined$line;my ($id,$address)=$line =~ m{\Aalias\s+(\S+)\s+"(.*)"};my ($fullname,$email)=$address =~ m{([^<]+)<([^>]+)>};$fullname =~ s/\s*$//;if ($rules->{id}){return unless$rules->{id}->($id)}if ($rules->{fullname}){return unless$rules->{fullname}->($fullname)}if ($rules->{email}){return unless$rules->{email}->($email)}return {id=>$id,fullname=>$fullname,email=>$email,}}1;
CPAN_COMMON_INDEX_MIRROR

$fatpacked{"CPAN/Common/Index/Mux/Ordered.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MUX_ORDERED';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mux::Ordered;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/resolvers/;use Module::Load ();sub BUILD {my$self=shift;my$resolvers=$self->resolvers;$resolvers=[]unless defined$resolvers;if (ref$resolvers ne 'ARRAY'){Carp::croak("The 'resolvers' argument must be an array reference")}for my$r (@$resolvers){if (!eval {$r->isa("CPAN::Common::Index")}){Carp::croak("Resolver '$r' is not a CPAN::Common::Index object")}}$self->resolvers($resolvers);return}sub assemble {my ($class,@backends)=@_;my@resolvers;while (@backends){my ($subclass,$config)=splice@backends,0,2;my$full_class="CPAN::Common::Index::${subclass}";eval {Module::Load::load($full_class);1}or Carp::croak($@);my$object=$full_class->new($config);push@resolvers,$object}return$class->new({resolvers=>\@resolvers })}sub validate_attributes {my ($self)=@_;my$resolvers=$self->resolvers;return 1}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_packages($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_packages($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_authors($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_authors($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}1;
CPAN_COMMON_INDEX_MUX_ORDERED

$fatpacked{"CPAN/DistnameInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_DISTNAMEINFO';
  package CPAN::DistnameInfo;$VERSION="0.12";use strict;sub distname_info {my$file=shift or return;my ($dist,$version)=$file =~ /^
      ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
       (?:
  	[A-Za-z](?=[^A-Za-z]|$)
  	|
  	\d(?=-)
       )(?<![._-][vV])
      )+)(.*)
    $/xs or return ($file,undef,undef);if ($dist =~ /-undef\z/ and!length$version){$dist =~ s/-undef\z//}$version =~ s/-withoutworldwriteables$//;if ($version =~ /^(-[Vv].*)-(\d.*)/){$dist .= $1;$version=$2}if ($version =~ /(.+_.*)-(\d.*)/){$dist .= $1;$version=$2}$dist =~ s{\.pm$}{};$version=$1 if!length$version and $dist =~ s/-(\d+\w)$//;$version=$1 .$version if$version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;if ($version =~ /\d\.\d/){$version =~ s/^[-_.]+//}else {$version =~ s/^[-_]+//}my$dev;if (length$version){if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/){$dev=1 if (($1 > 6 and $1 & 1)or ($2 and $2 >= 50))or $3}elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/){$dev=1}}else {$version=undef}($dist,$version,$dev)}sub new {my$class=shift;my$distfile=shift;$distfile =~ s,//+,/,g;my%info=(pathname=>$distfile);($info{filename}=$distfile)=~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,, and $info{cpanid}=$6;if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i){$info{distvname}=$1;$info{extension}=$2}@info{qw(dist version beta)}=distname_info($info{distvname});$info{maturity}=delete$info{beta}? 'developer' : 'released';return bless \%info,$class}sub dist {shift->{dist}}sub version {shift->{version}}sub maturity {shift->{maturity}}sub filename {shift->{filename}}sub cpanid {shift->{cpanid}}sub distvname {shift->{distvname}}sub extension {shift->{extension}}sub pathname {shift->{pathname}}sub properties {%{$_[0]}}1;
CPAN_DISTNAMEINFO

$fatpacked{"CPAN/Meta/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CHECK';
  package CPAN::Meta::Check;$CPAN::Meta::Check::VERSION='0.014';use strict;use warnings;use base 'Exporter';our@EXPORT=qw//;our@EXPORT_OK=qw/check_requirements requirements_for verify_dependencies/;our%EXPORT_TAGS=(all=>[@EXPORT,@EXPORT_OK ]);use CPAN::Meta::Prereqs '2.132830';use CPAN::Meta::Requirements 2.121;use Module::Metadata 1.000023;sub _check_dep {my ($reqs,$module,$dirs)=@_;$module eq 'perl' and return ($reqs->accepts_module($module,$])? (): sprintf "Your Perl (%s) is not in the range '%s'",$],$reqs->requirements_for_module($module));my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return "Module '$module' is not installed" if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is not in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if not $reqs->accepts_module($module,$version || 0);return}sub _check_conflict {my ($reqs,$module,$dirs)=@_;my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if$reqs->accepts_module($module,$version);return}sub requirements_for {my ($meta,$phases,$type)=@_;my$prereqs=ref($meta)eq 'CPAN::Meta' ? $meta->effective_prereqs : $meta;return$prereqs->merged_requirements(ref($phases)? $phases : [$phases ],[$type ])}sub check_requirements {my ($reqs,$type,$dirs)=@_;return +{map {$_=>$type ne 'conflicts' ? scalar _check_dep($reqs,$_,$dirs): scalar _check_conflict($reqs,$_,$dirs)}$reqs->required_modules }}sub verify_dependencies {my ($meta,$phases,$type,$dirs)=@_;my$reqs=requirements_for($meta,$phases,$type);my$issues=check_requirements($reqs,$type,$dirs);return grep {defined}values %{$issues}}1;
CPAN_META_CHECK

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;use strict;use warnings;package Capture::Tiny;our$VERSION='0.48';use Carp ();use Exporter ();use IO::Handle ();use File::Spec ();use File::Temp qw/tempfile tmpnam/;use Scalar::Util qw/reftype blessed/;BEGIN {local $@;eval {require PerlIO;PerlIO->can('get_layers')}or *PerlIO::get_layers=sub {return ()}}my%api=(capture=>[1,1,0,0],capture_stdout=>[1,0,0,0],capture_stderr=>[0,1,0,0],capture_merged=>[1,1,1,0],tee=>[1,1,0,1],tee_stdout=>[1,0,0,1],tee_stderr=>[0,1,0,1],tee_merged=>[1,1,1,1],);for my$sub (keys%api){my$args=join q{, },@{$api{$sub}};eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"}our@ISA=qw/Exporter/;our@EXPORT_OK=keys%api;our%EXPORT_TAGS=('all'=>\@EXPORT_OK);my$IS_WIN32=$^O eq 'MSWin32';our$TIMEOUT=30;my@cmd=($^X,'-C0','-e',<<'HERE');sub _relayer {my ($fh,$apply_layers)=@_;binmode($fh,":raw");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")}my@to_apply=@$apply_layers;shift@to_apply;binmode($fh,":" .join(":",@to_apply))}sub _name {my$glob=shift;no strict 'refs';return *{$glob}{NAME}}sub _open {open $_[0],$_[1]or Carp::confess "Error from open(" .join(q{, },@_)."): $!"}sub _close {close $_[0]or Carp::confess "Error from close(" .join(q{, },@_)."): $!"}my%dup;my%proxy_count;sub _proxy_std {my%proxies;if (!defined fileno STDIN){$proxy_count{stdin}++;if (defined$dup{stdin}){_open \*STDIN,"<&=" .fileno($dup{stdin})}else {_open \*STDIN,"<" .File::Spec->devnull;_open$dup{stdin}=IO::Handle->new,"<&=STDIN"}$proxies{stdin}=\*STDIN;binmode(STDIN,':utf8')if $] >= 5.008}if (!defined fileno STDOUT){$proxy_count{stdout}++;if (defined$dup{stdout}){_open \*STDOUT,">&=" .fileno($dup{stdout})}else {_open \*STDOUT,">" .File::Spec->devnull;_open$dup{stdout}=IO::Handle->new,">&=STDOUT"}$proxies{stdout}=\*STDOUT;binmode(STDOUT,':utf8')if $] >= 5.008}if (!defined fileno STDERR){$proxy_count{stderr}++;if (defined$dup{stderr}){_open \*STDERR,">&=" .fileno($dup{stderr})}else {_open \*STDERR,">" .File::Spec->devnull;_open$dup{stderr}=IO::Handle->new,">&=STDERR"}$proxies{stderr}=\*STDERR;binmode(STDERR,':utf8')if $] >= 5.008}return%proxies}sub _unproxy {my (%proxies)=@_;for my$p (keys%proxies){$proxy_count{$p}--;if (!$proxy_count{$p}){_close$proxies{$p};_close$dup{$p}unless $] < 5.008;delete$dup{$p}}}}sub _copy_std {my%handles;for my$h (qw/stdout stderr stdin/){next if$h eq 'stdin' &&!$IS_WIN32;my$redir=$h eq 'stdin' ? "<&" : ">&";_open$handles{$h}=IO::Handle->new(),$redir .uc($h)}return \%handles}sub _open_std {my ($handles)=@_;_open \*STDIN,"<&" .fileno$handles->{stdin}if defined$handles->{stdin};_open \*STDOUT,">&" .fileno$handles->{stdout}if defined$handles->{stdout};_open \*STDERR,">&" .fileno$handles->{stderr}if defined$handles->{stderr}}sub _start_tee {my ($which,$stash)=@_;$stash->{$_}{$which}=IO::Handle->new for qw/tee reader/;pipe$stash->{reader}{$which},$stash->{tee}{$which};select((select($stash->{tee}{$which}),$|=1)[0]);$stash->{new}{$which}=$stash->{tee}{$which};$stash->{child}{$which}={stdin=>$stash->{reader}{$which},stdout=>$stash->{old}{$which},stderr=>$stash->{capture}{$which},};$stash->{flag_files}{$which}=scalar(tmpnam()).$$;if ($IS_WIN32){my$old_eval_err=$@;undef $@;eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";my$os_fhandle=GetOsFHandle($stash->{tee}{$which});my$result=SetHandleInformation($os_fhandle,HANDLE_FLAG_INHERIT(),0);_open_std($stash->{child}{$which});$stash->{pid}{$which}=system(1,@cmd,$stash->{flag_files}{$which});$@=$old_eval_err}else {_fork_exec($which,$stash)}}sub _fork_exec {my ($which,$stash)=@_;my$pid=fork;if (not defined$pid){Carp::confess "Couldn't fork(): $!"}elsif ($pid==0){untie*STDIN;untie*STDOUT;untie*STDERR;_close$stash->{tee}{$which};_open_std($stash->{child}{$which});exec@cmd,$stash->{flag_files}{$which}}$stash->{pid}{$which}=$pid}my$have_usleep=eval "use Time::HiRes 'usleep'; 1";sub _files_exist {return 1 if @_==grep {-f}@_;Time::HiRes::usleep(1000)if$have_usleep;return 0}sub _wait_for_tees {my ($stash)=@_;my$start=time;my@files=values %{$stash->{flag_files}};my$timeout=defined$ENV{PERL_CAPTURE_TINY_TIMEOUT}? $ENV{PERL_CAPTURE_TINY_TIMEOUT}: $TIMEOUT;1 until _files_exist(@files)|| ($timeout && (time - $start > $timeout));Carp::confess "Timed out waiting for subprocesses to start" if!_files_exist(@files);unlink $_ for@files}sub _kill_tees {my ($stash)=@_;if ($IS_WIN32){close($_)for values %{$stash->{tee}};my$start=time;1 until wait==-1 || (time - $start > 30)}else {_close $_ for values %{$stash->{tee}};waitpid $_,0 for values %{$stash->{pid}}}}sub _slurp {my ($name,$stash)=@_;my ($fh,$pos)=map {$stash->{$_}{$name}}qw/capture pos/;seek($fh,$pos,0)or die "Couldn't seek on capture handle for $name\n";my$text=do {local $/;scalar readline$fh};return defined($text)? $text : ""}sub _capture_tee {my ($do_stdout,$do_stderr,$do_merge,$do_tee,$code,@opts)=@_;my%do=($do_stdout ? (stdout=>1): (),$do_stderr ? (stderr=>1): ());Carp::confess("Custom capture options must be given as key/value pairs\n")unless@opts % 2==0;my$stash={capture=>{@opts }};for (keys %{$stash->{capture}}){my$fh=$stash->{capture}{$_};Carp::confess "Custom handle for $_ must be seekable\n" unless ref($fh)eq 'GLOB' || (blessed($fh)&& $fh->isa("IO::Seekable"))}local*CT_ORIG_STDIN=*STDIN ;local*CT_ORIG_STDOUT=*STDOUT;local*CT_ORIG_STDERR=*STDERR;my%layers=(stdin=>[PerlIO::get_layers(\*STDIN)],stdout=>[PerlIO::get_layers(\*STDOUT,output=>1)],stderr=>[PerlIO::get_layers(\*STDERR,output=>1)],);$layers{stdout}=[PerlIO::get_layers(tied*STDOUT)]if tied(*STDOUT)&& (reftype tied*STDOUT eq 'GLOB');$layers{stderr}=[PerlIO::get_layers(tied*STDERR)]if tied(*STDERR)&& (reftype tied*STDERR eq 'GLOB');my%localize;$localize{stdin}++,local(*STDIN)if grep {$_ eq 'scalar'}@{$layers{stdin}};$localize{stdout}++,local(*STDOUT)if$do_stdout && grep {$_ eq 'scalar'}@{$layers{stdout}};$localize{stderr}++,local(*STDERR)if ($do_stderr || $do_merge)&& grep {$_ eq 'scalar'}@{$layers{stderr}};$localize{stdin}++,local(*STDIN),_open(\*STDIN,"<&=0")if tied*STDIN && $] >= 5.008;$localize{stdout}++,local(*STDOUT),_open(\*STDOUT,">&=1")if$do_stdout && tied*STDOUT && $] >= 5.008;$localize{stderr}++,local(*STDERR),_open(\*STDERR,">&=2")if ($do_stderr || $do_merge)&& tied*STDERR && $] >= 5.008;my%proxy_std=_proxy_std();$layers{stdout}=[PerlIO::get_layers(\*STDOUT,output=>1)]if$proxy_std{stdout};$layers{stderr}=[PerlIO::get_layers(\*STDERR,output=>1)]if$proxy_std{stderr};$stash->{old}=_copy_std();$stash->{new}={%{$stash->{old}}};for (keys%do){$stash->{new}{$_}=($stash->{capture}{$_}||= File::Temp->new);seek($stash->{capture}{$_},0,2)or die "Could not seek on capture handle for $_\n";$stash->{pos}{$_}=tell$stash->{capture}{$_};_start_tee($_=>$stash)if$do_tee}_wait_for_tees($stash)if$do_tee;$stash->{new}{stderr}=$stash->{new}{stdout}if$do_merge;_open_std($stash->{new});my ($exit_code,$inner_error,$outer_error,$orig_pid,@result);{$orig_pid=$$;local*STDIN=*CT_ORIG_STDIN if$localize{stdin};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;my$old_eval_err=$@;undef $@;eval {@result=$code->();$inner_error=$@};$exit_code=$?;$outer_error=$@;STDOUT->flush if$do_stdout;STDERR->flush if$do_stderr;$@=$old_eval_err}_open_std($stash->{old});_close($_)for values %{$stash->{old}};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;_unproxy(%proxy_std);_kill_tees($stash)if$do_tee;my%got;if ($orig_pid==$$ and (defined wantarray or ($do_tee && keys%localize))){for (keys%do){_relayer($stash->{capture}{$_},$layers{$_});$got{$_}=_slurp($_,$stash)}print CT_ORIG_STDOUT$got{stdout}if$do_stdout && $do_tee && $localize{stdout};print CT_ORIG_STDERR$got{stderr}if$do_stderr && $do_tee && $localize{stderr}}$?=$exit_code;$@=$inner_error if$inner_error;die$outer_error if$outer_error;return unless defined wantarray;my@return;push@return,$got{stdout}if$do_stdout;push@return,$got{stderr}if$do_stderr &&!$do_merge;push@return,@result;return wantarray ? @return : $return[0]}1;
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
CAPTURE_TINY

$fatpacked{"Carton.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON';
  package Carton;use strict;use 5.008_005;use version;our$VERSION=version->declare("v1.0.34");1;
CARTON

$fatpacked{"Carton/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_BUILDER';
  package Carton::Builder;use strict;use Class::Tiny {mirror=>undef,index=>undef,cascade=>sub {1},without=>sub {[]},cpanfile=>undef,};sub effective_mirrors {my$self=shift;my@mirrors=($self->mirror);push@mirrors,Carton::Mirror->default if$self->custom_mirror;push@mirrors,Carton::Mirror->new('http://backpan.perl.org/');@mirrors}sub custom_mirror {my$self=shift;!$self->mirror->is_default}sub bundle {my($self,$path,$cache_path,$snapshot)=@_;for my$dist ($snapshot->distributions){my$source=$path->child("cache/authors/id/" .$dist->pathname);my$target=$cache_path->child("authors/id/" .$dist->pathname);if ($source->exists){warn "Copying ",$dist->pathname,"\n";$target->parent->mkpath;$source->copy($target)or warn "$target: $!"}else {warn "Couldn't find @{[ $dist->pathname ]}\n"}}my$has_io_gzip=eval {require IO::Compress::Gzip;1};my$ext=$has_io_gzip ? ".txt.gz" : ".txt";my$index=$cache_path->child("modules/02packages.details$ext");$index->parent->mkpath;warn "Writing $index\n";my$out=$index->openw;if ($has_io_gzip){$out=IO::Compress::Gzip->new($out)or die "gzip failed: $IO::Compress::Gzip::GzipError"}$snapshot->index->write($out);close$out;unless ($has_io_gzip){unlink "$index.gz";!system 'gzip',$index or die "Running gzip command failed: $!"}}sub install {my($self,$path)=@_;$self->run_install("-L",$path,(map {("--mirror",$_->url)}$self->effective_mirrors),($self->index ? ("--mirror-index",$self->index): ()),($self->cascade ? "--cascade-search" : ()),($self->custom_mirror ? "--mirror-only" : ()),"--save-dists","$path/cache",$self->groups,"--cpanfile",$self->cpanfile,"--installdeps",$self->cpanfile->dirname,)or die "Installing modules failed\n"}sub groups {my$self=shift;my@options=('--with-all-features','--with-develop');for my$group (@{$self->without}){push@options,'--without-develop' if$group eq 'develop';push@options,"--without-feature=$group"}return@options}sub update {my($self,$path,@modules)=@_;$self->run_install("-L",$path,(map {("--mirror",$_->url)}$self->effective_mirrors),($self->custom_mirror ? "--mirror-only" : ()),"--save-dists","$path/cache",@modules)or die "Updating modules failed\n"}sub run_install {my($self,@args)=@_;require Menlo::CLI::Compat;local$ENV{PERL_CPANM_OPT};my$cli=Menlo::CLI::Compat->new;$cli->parse_options("--quiet","--notest",@args);$cli->run;!$cli->status}1;
CARTON_BUILDER

$fatpacked{"Carton/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CLI';
  package Carton::CLI;use strict;use warnings;use Config;use Getopt::Long;use Path::Tiny;use Try::Tiny;use Module::CoreList;use Scalar::Util qw(blessed);use Carton;use Carton::Builder;use Carton::Mirror;use Carton::Snapshot;use Carton::Util;use Carton::Environment;use Carton::Error;use constant {SUCCESS=>0,INFO=>1,WARN=>2,ERROR=>3 };our$UseSystem=0;use Class::Tiny {verbose=>undef,carton=>sub {$_[0]->_build_carton},mirror=>sub {$_[0]->_build_mirror},};sub _build_mirror {my$self=shift;Carton::Mirror->new($ENV{PERL_CARTON_MIRROR}|| $Carton::Mirror::DefaultMirror)}sub run {my($self,@args)=@_;my@commands;my$p=Getopt::Long::Parser->new(config=>["no_ignore_case","pass_through" ],);$p->getoptionsfromarray(\@args,"h|help"=>sub {unshift@commands,'help'},"v|version"=>sub {unshift@commands,'version'},"verbose!"=>sub {$self->verbose($_[1])},);push@commands,@args;my$cmd=shift@commands || 'install';my$code=try {my$call=$self->can("cmd_$cmd")or Carton::Error::CommandNotFound->throw(error=>"Could not find command '$cmd'");$self->$call(@commands);return 0}catch {die $_ unless blessed $_ && $_->can('rethrow');if ($_->isa('Carton::Error::CommandExit')){return $_->code || 255}elsif ($_->isa('Carton::Error::CommandNotFound')){warn $_->error,"\n\n";$self->cmd_usage;return 255}elsif ($_->isa('Carton::Error')){warn $_->error,"\n";return 255}};return$code}sub commands {my$self=shift;no strict 'refs';map {s/^cmd_//;$_}grep {/^cmd_.*/ && $self->can($_)}sort keys %{__PACKAGE__."::"}}sub cmd_usage {my$self=shift;$self->print(<<HELP)}sub parse_options {my($self,$args,@spec)=@_;my$p=Getopt::Long::Parser->new(config=>["no_auto_abbrev","no_ignore_case" ],);$p->getoptionsfromarray($args,@spec)}sub parse_options_pass_through {my($self,$args,@spec)=@_;my$p=Getopt::Long::Parser->new(config=>["no_auto_abbrev","no_ignore_case","pass_through" ],);$p->getoptionsfromarray($args,@spec);shift @$args if$args->[0]&& $args->[0]eq '--'}sub printf {my$self=shift;my$type=pop;my($temp,@args)=@_;$self->print(sprintf($temp,@args),$type)}sub print {my($self,$msg,$type)=@_;my$fh=$type && $type >= WARN ? *STDERR : *STDOUT;print {$fh}$msg}sub error {my($self,$msg)=@_;$self->print($msg,ERROR);Carton::Error::CommandExit->throw}sub cmd_help {my$self=shift;my$module=$_[0]? ("Carton::Doc::" .ucfirst $_[0]): "Carton.pm";system "perldoc",$module}sub cmd_version {my$self=shift;$self->print("carton $Carton::VERSION\n")}sub cmd_bundle {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;$self->print("Bundling modules using @{[$env->cpanfile]}\n");my$builder=Carton::Builder->new(mirror=>$self->mirror,cpanfile=>$env->cpanfile,);$builder->bundle($env->install_path,$env->vendor_cache,$env->snapshot);$self->printf("Complete! Modules were bundled into %s\n",$env->vendor_cache,SUCCESS)}sub cmd_fatpack {my($self,@args)=@_;my$env=Carton::Environment->build;require Carton::Packer;Carton::Packer->new->fatpack_carton($env->vendor_bin)}sub cmd_install {my($self,@args)=@_;my($install_path,$cpanfile_path,@without);$self->parse_options(\@args,"p|path=s"=>\$install_path,"cpanfile=s"=>\$cpanfile_path,"without=s"=>sub {push@without,split /,/,$_[1]},"deployment!"=>\my$deployment,"cached!"=>\my$cached,);my$env=Carton::Environment->build($cpanfile_path,$install_path);$env->snapshot->load_if_exists;if ($deployment &&!$env->snapshot->loaded){$self->error("--deployment requires cpanfile.snapshot: Run `carton install` and make sure cpanfile.snapshot is checked into your version control.\n")}my$builder=Carton::Builder->new(cascade=>1,mirror=>$self->mirror,without=>\@without,cpanfile=>$env->cpanfile,);if ($deployment){$self->print("Installing modules using @{[$env->cpanfile]} (deployment mode)\n");$builder->cascade(0)}else {$self->print("Installing modules using @{[$env->cpanfile]}\n")}if ($env->snapshot->loaded){my$index_file=$env->install_path->child("cache/modules/02packages.details.txt");$index_file->parent->mkpath;$env->snapshot->write_index($index_file);$builder->index($index_file)}if ($cached){$builder->mirror(Carton::Mirror->new($env->vendor_cache))}$builder->install($env->install_path);unless ($deployment){$env->cpanfile->load;$env->snapshot->find_installs($env->install_path,$env->cpanfile->requirements);$env->snapshot->save}$self->print("Complete! Modules were installed into @{[$env->install_path]}\n",SUCCESS)}sub cmd_show {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;for my$module (@args){my$dist=$env->snapshot->find($module)or $self->error("Couldn't locate $module in cpanfile.snapshot\n");$self->print($dist->name ."\n")}}sub cmd_list {my($self,@args)=@_;my$format='name';$self->parse_options(\@args,"distfile"=>sub {$format='distfile'},);my$env=Carton::Environment->build;$env->snapshot->load;for my$dist ($env->snapshot->distributions){$self->print($dist->$format ."\n")}}sub cmd_tree {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;$env->cpanfile->load;my%seen;my$dumper=sub {my($dependency,$reqs,$level)=@_;return if$level==0;return Carton::Tree::STOP if$dependency->dist->is_core;return Carton::Tree::STOP if$seen{$dependency->distname}++;$self->printf("%s%s (%s)\n"," " x ($level - 1),$dependency->module,$dependency->distname,INFO)};$env->tree->walk_down($dumper)}sub cmd_check {my($self,@args)=@_;my$cpanfile_path;$self->parse_options(\@args,"cpanfile=s"=>\$cpanfile_path,);my$env=Carton::Environment->build($cpanfile_path);$env->snapshot->load;$env->cpanfile->load;my$merged_reqs=$env->tree->merged_requirements;my@missing;for my$module ($merged_reqs->required_modules){my$install=$env->snapshot->find_or_core($module);if ($install){unless ($merged_reqs->accepts_module($module=>$install->version_for($module))){push@missing,[$module,1,$install->version_for($module)]}}else {push@missing,[$module,0 ]}}if (@missing){$self->print("Following dependencies are not satisfied.\n",INFO);for my$missing (@missing){my($module,$unsatisfied,$version)=@$missing;if ($unsatisfied){$self->printf("  %s has version %s. Needs %s\n",$module,$version,$merged_reqs->requirements_for_module($module),INFO)}else {$self->printf("  %s is not installed. Needs %s\n",$module,$merged_reqs->requirements_for_module($module),INFO)}}$self->printf("Run `carton install` to install them.\n",INFO);Carton::Error::CommandExit->throw}else {$self->print("cpanfile's dependencies are satisfied.\n",INFO)}}sub cmd_update {my($self,@args)=@_;my$env=Carton::Environment->build;$env->cpanfile->load;my$cpanfile=Module::CPANfile->load($env->cpanfile);@args=grep {$_ ne 'perl'}$env->cpanfile->required_modules unless@args;$env->snapshot->load;my@modules;for my$module (@args){my$dist=$env->snapshot->find_or_core($module)or $self->error("Could not find module $module.\n");next if$dist->is_core;push@modules,"$module~" .$env->cpanfile->requirements_for_module($module)}return unless@modules;my$builder=Carton::Builder->new(mirror=>$self->mirror,cpanfile=>$env->cpanfile,);$builder->update($env->install_path,@modules);$env->snapshot->find_installs($env->install_path,$env->cpanfile->requirements);$env->snapshot->save}sub cmd_run {my($self,@args)=@_;local$UseSystem=1;$self->cmd_exec(@args)}sub cmd_exec {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;@args=map {/^(-[I])(.+)/ ? ($1,$2): $_}@args;while (@args){if ($args[0]eq '-I'){warn "exec -Ilib is deprecated. You might want to run: carton exec perl -Ilib ...\n";splice(@args,0,2)}else {last}}$self->parse_options_pass_through(\@args);unless (@args){$self->error("carton exec needs a command to run.\n")}my$path=$env->install_path;local$ENV{PERL5LIB}="$path/lib/perl5";local$ENV{PATH}="$path/bin:$ENV{PATH}";if ($UseSystem){system@args}else {exec@args;exit 127}}1;
  Usage: carton <command>
  
  where <command> is one of:
    @{[ join ", ", $self->commands ]}
  
  Run carton -h <command> for help.
  HELP
CARTON_CLI

$fatpacked{"Carton/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CPANFILE';
  package Carton::CPANfile;use Path::Tiny ();use Module::CPANfile;use overload q{""}=>sub {$_[0]->stringify},fallback=>1;use subs 'path';use Class::Tiny {path=>undef,_cpanfile=>undef,requirements=>sub {$_[0]->_build_requirements},};sub stringify {shift->path->stringify(@_)}sub dirname {shift->path->dirname(@_)}sub prereqs {shift->_cpanfile->prereqs(@_)}sub required_modules {shift->requirements->required_modules(@_)}sub requirements_for_module {shift->requirements->requirements_for_module(@_)}sub path {my$self=shift;if (@_){$self->{path}=Path::Tiny->new($_[0])}else {$self->{path}}}sub load {my$self=shift;$self->_cpanfile(Module::CPANfile->load($self->path))}sub _build_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;$reqs->add_requirements($self->prereqs->requirements_for($_,'requires'))for qw(configure build runtime test develop);$reqs->clear_requirement('perl');$reqs}1;
CARTON_CPANFILE

$fatpacked{"Carton/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DEPENDENCY';
  package Carton::Dependency;use strict;use Class::Tiny {module=>undef,requirement=>undef,dist=>undef,};sub requirements {shift->dist->requirements(@_)}sub distname {my$self=shift;$self->dist->name}sub version {my$self=shift;$self->dist->version_for($self->module)}1;
CARTON_DEPENDENCY

$fatpacked{"Carton/Dist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST';
  package Carton::Dist;use strict;use Class::Tiny {name=>undef,pathname=>undef,provides=>sub {+{}},requirements=>sub {$_[0]->_build_requirements},};use CPAN::Meta;sub add_string_requirement {shift->requirements->add_string_requirement(@_)}sub required_modules {shift->requirements->required_modules(@_)}sub requirements_for_module {shift->requirements->requirements_for_module(@_)}sub is_core {0}sub distfile {my$self=shift;$self->pathname}sub _build_requirements {CPAN::Meta::Requirements->new}sub provides_module {my($self,$module)=@_;exists$self->provides->{$module}}sub version_for {my($self,$module)=@_;$self->provides->{$module}{version}}1;
CARTON_DIST

$fatpacked{"Carton/Dist/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST_CORE';
  package Carton::Dist::Core;use strict;use parent 'Carton::Dist';use Class::Tiny qw(module_version);sub BUILDARGS {my($class,%args)=@_;$args{name}=~ s/::/-/g;\%args}sub is_core {1}sub version_for {my($self,$module)=@_;$self->module_version}1;
CARTON_DIST_CORE

$fatpacked{"Carton/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ENVIRONMENT';
  package Carton::Environment;use strict;use Carton::CPANfile;use Carton::Snapshot;use Carton::Error;use Carton::Tree;use Path::Tiny;use Class::Tiny {cpanfile=>undef,snapshot=>sub {$_[0]->_build_snapshot},install_path=>sub {$_[0]->_build_install_path},vendor_cache=>sub {$_[0]->_build_vendor_cache},tree=>sub {$_[0]->_build_tree},};sub _build_snapshot {my$self=shift;Carton::Snapshot->new(path=>$self->cpanfile .".snapshot")}sub _build_install_path {my$self=shift;if ($ENV{PERL_CARTON_PATH}){return Path::Tiny->new($ENV{PERL_CARTON_PATH})}else {return$self->cpanfile->path->parent->child("local")}}sub _build_vendor_cache {my$self=shift;Path::Tiny->new($self->install_path->dirname ."/vendor/cache")}sub _build_tree {my$self=shift;Carton::Tree->new(cpanfile=>$self->cpanfile,snapshot=>$self->snapshot)}sub vendor_bin {my$self=shift;$self->vendor_cache->parent->child('bin')}sub build_with {my($class,$cpanfile)=@_;$cpanfile=Path::Tiny->new($cpanfile)->absolute;if ($cpanfile->is_file){return$class->new(cpanfile=>Carton::CPANfile->new(path=>$cpanfile))}else {Carton::Error::CPANfileNotFound->throw(error=>"Can't locate cpanfile: $cpanfile")}}sub build {my($class,$cpanfile_path,$install_path)=@_;my$self=$class->new;$cpanfile_path &&= Path::Tiny->new($cpanfile_path)->absolute;my$cpanfile=$self->locate_cpanfile($cpanfile_path || $ENV{PERL_CARTON_CPANFILE});if ($cpanfile && $cpanfile->is_file){$self->cpanfile(Carton::CPANfile->new(path=>$cpanfile))}else {Carton::Error::CPANfileNotFound->throw(error=>"Can't locate cpanfile: (@{[ $cpanfile_path || 'cpanfile' ]})")}$self->install_path(Path::Tiny->new($install_path)->absolute)if$install_path;$self}sub locate_cpanfile {my($self,$path)=@_;if ($path){return Path::Tiny->new($path)->absolute}my$current=Path::Tiny->cwd;my$previous='';until ($current eq '/' or $current eq $previous){my$try=$current->child('cpanfile');if ($try->is_file){return$try->absolute}($previous,$current)=($current,$current->parent)}return}1;
CARTON_ENVIRONMENT

$fatpacked{"Carton/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ERROR';
  package Carton::Error;use strict;use overload '""'=>sub {$_[0]->error};use Carp;sub throw {my($class,@args)=@_;die$class->new(@args)}sub rethrow {die $_[0]}sub new {my($class,%args)=@_;bless \%args,$class}sub error {$_[0]->{error}|| ref $_[0]}package Carton::Error::CommandNotFound;use parent 'Carton::Error';package Carton::Error::CommandExit;use parent 'Carton::Error';sub code {$_[0]->{code}}package Carton::Error::CPANfileNotFound;use parent 'Carton::Error';package Carton::Error::SnapshotParseError;use parent 'Carton::Error';sub path {$_[0]->{path}}package Carton::Error::SnapshotNotFound;use parent 'Carton::Error';sub path {$_[0]->{path}}1;
CARTON_ERROR

$fatpacked{"Carton/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_INDEX';
  package Carton::Index;use strict;use Class::Tiny {_packages=>sub {+{}},generator=>sub {require Carton;"Carton $Carton::VERSION"},};sub add_package {my($self,$package)=@_;$self->_packages->{$package->name}=$package}sub count {my$self=shift;scalar keys %{$self->_packages}}sub packages {my$self=shift;sort {lc$a->name cmp lc$b->name}values %{$self->_packages}}sub write {my($self,$fh)=@_;print$fh <<EOF;for my$p ($self->packages){print$fh $self->_format_line($p->name,$p->version_format,$p->pathname)}}sub _format_line {my($self,@row)=@_;my$one=30;my$two=8;if (length$row[0]> $one){$one += 8 - length$row[1];$two=length$row[1]}sprintf "%-${one}s %${two}s  %s\n",@row}sub pad {my($str,$len,$left)=@_;my$howmany=$len - length($str);return$str if$howmany <= 0;my$pad=" " x $howmany;return$left ? "$pad$str" : "$str$pad"}1;
  File:         02packages.details.txt
  URL:          http://www.perl.com/CPAN/modules/02packages.details.txt
  Description:  Package names found in cpanfile.snapshot
  Columns:      package name, version, path
  Intended-For: Automated fetch routines, namespace documentation.
  Written-By:   @{[ $self->generator ]}
  Line-Count:   @{[ $self->count ]}
  Last-Updated: @{[ scalar localtime ]}
  
  EOF
CARTON_INDEX

$fatpacked{"Carton/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_MIRROR';
  package Carton::Mirror;use strict;use Class::Tiny qw(url);our$DefaultMirror='http://cpan.metacpan.org/';sub BUILDARGS {my($class,$url)=@_;return {url=>$url }}sub default {my$class=shift;$class->new($DefaultMirror)}sub is_default {my$self=shift;$self->url eq $DefaultMirror}1;
CARTON_MIRROR

$fatpacked{"Carton/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKAGE';
  package Carton::Package;use strict;use Class::Tiny qw(name version pathname);sub BUILDARGS {my($class,@args)=@_;return {name=>$args[0],version=>$args[1],pathname=>$args[2]}}sub version_format {my$self=shift;defined$self->version ? $self->version : 'undef'}1;
CARTON_PACKAGE

$fatpacked{"Carton/Packer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKER';
  package Carton::Packer;use Class::Tiny;use warnings NONFATAL=>'all';use App::FatPacker;use File::pushd ();use Path::Tiny ();use CPAN::Meta ();use File::Find ();sub fatpack_carton {my($self,$dir)=@_;my$temp=Path::Tiny->tempdir;my$pushd=File::pushd::pushd$temp;my$file=$temp->child('carton.pre.pl');$file->spew(<<'EOF');my$fatpacked=$self->do_fatpack($file);my$executable=$dir->child('carton');warn "Bundling $executable\n";$dir->mkpath;$executable->spew($fatpacked);chmod 0755,$executable}sub do_fatpack {my($self,$file)=@_;my$packer=App::FatPacker->new;my@modules=split /\r?\n/,$packer->trace(args=>[$file],use=>$self->required_modules);my@packlists=$packer->packlists_containing(\@modules);$packer->packlists_to_tree(Path::Tiny->new('fatlib')->absolute,\@packlists);my$fatpacked=do {local$SIG{__WARN__}=sub {};$packer->fatpack_file($file)};use Config;$fatpacked =~ s/\$fatpacked\{"$Config{archname}\/(Cwd|File)/\$fatpacked{"$1/g;$fatpacked}sub required_modules {my$self=shift;my%requirements;for my$dist (qw(Carton Menlo-Legacy Menlo)){$requirements{$_}=1 for$self->required_modules_for($dist)}my@extra=qw(Menlo::Index::Mirror);[keys%requirements,@extra ]}sub required_modules_for {my($self,$dist)=@_;my$meta=$self->installed_meta($dist)or die "Couldn't find install metadata for $dist";my%excludes=(perl=>1,'ExtUtils::MakeMaker'=>1,'Module::Build'=>1,);grep!$excludes{$_},$meta->effective_prereqs->requirements_for('runtime','requires')->required_modules}sub installed_meta {my($self,$dist)=@_;my@meta;my$finder=sub {if (m!\b$dist-.*[\\/]MYMETA.json!){my$meta=CPAN::Meta->load_file($_);push@meta,$meta if$meta->name eq $dist}};my@meta_dirs=grep -d,map "$_/.meta",@INC;File::Find::find({wanted=>$finder,no_chdir=>1 },@meta_dirs)if@meta_dirs;@meta=sort {version->new($b->version)cmp version->new($a->version)}@meta;return$meta[0]}1;
  #!/usr/bin/env perl
  use strict;
  use 5.008001;
  use Carton::CLI;
  $Carton::Fatpacked = 1;
  exit Carton::CLI->new->run(@ARGV);
  EOF
CARTON_PACKER

$fatpacked{"Carton/Snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT';
  package Carton::Snapshot;use strict;use Config;use Carton::Dist;use Carton::Dist::Core;use Carton::Error;use Carton::Package;use Carton::Index;use Carton::Util;use Carton::Snapshot::Emitter;use Carton::Snapshot::Parser;use CPAN::Meta;use CPAN::Meta::Requirements;use File::Find ();use Try::Tiny;use Path::Tiny ();use Module::CoreList;use constant CARTON_SNAPSHOT_VERSION=>'1.0';use subs 'path';use Class::Tiny {path=>undef,version=>sub {CARTON_SNAPSHOT_VERSION},loaded=>undef,_distributions=>sub {+[]},};sub BUILD {my$self=shift;$self->path($self->{path})}sub path {my$self=shift;if (@_){$self->{path}=Path::Tiny->new($_[0])}else {$self->{path}}}sub load_if_exists {my$self=shift;$self->load if$self->path->is_file}sub load {my$self=shift;return 1 if$self->loaded;if ($self->path->is_file){my$parser=Carton::Snapshot::Parser->new;$parser->parse($self->path->slurp_utf8,$self);$self->loaded(1);return 1}else {Carton::Error::SnapshotNotFound->throw(error=>"Can't find cpanfile.snapshot: Run `carton install` to build the snapshot file.",path=>$self->path,)}}sub save {my$self=shift;$self->path->spew_utf8(Carton::Snapshot::Emitter->new->emit($self))}sub find {my($self,$module)=@_;(grep $_->provides_module($module),$self->distributions)[0]}sub find_or_core {my($self,$module)=@_;$self->find($module)|| $self->find_in_core($module)}sub find_in_core {my($self,$module)=@_;if (exists$Module::CoreList::version{$]}{$module}){my$version=$Module::CoreList::version{$]}{$module};return Carton::Dist::Core->new(name=>$module,module_version=>$version)}return}sub index {my$self=shift;my$index=Carton::Index->new;for my$package ($self->packages){$index->add_package($package)}return$index}sub distributions {@{$_[0]->_distributions}}sub add_distribution {my($self,$dist)=@_;push @{$self->_distributions},$dist}sub packages {my$self=shift;my@packages;for my$dist ($self->distributions){while (my($package,$provides)=each %{$dist->provides}){push@packages,Carton::Package->new($package,$provides->{version},$dist->pathname)}}return@packages}sub write_index {my($self,$file)=@_;open my$fh,">",$file or die $!;$self->index->write($fh)}sub find_installs {my($self,$path,$reqs)=@_;my$libdir="$path/lib/perl5/$Config{archname}/.meta";return {}unless -e $libdir;my@installs;my$wanted=sub {if ($_ eq 'install.json'){push@installs,[$File::Find::name,"$File::Find::dir/MYMETA.json" ]}};File::Find::find($wanted,$libdir);my%installs;my$accepts=sub {my$module=shift;return 0 unless$reqs->accepts_module($module->{name},$module->{provides}{$module->{name}}{version});if (my$exist=$installs{$module->{name}}){my$old_ver=version::->new($exist->{provides}{$module->{name}}{version});my$new_ver=version::->new($module->{provides}{$module->{name}}{version});return$new_ver >= $old_ver}else {return 1}};for my$file (@installs){my$module=Carton::Util::load_json($file->[0]);my$prereqs=-f $file->[1]? CPAN::Meta->load_file($file->[1])->effective_prereqs : CPAN::Meta::Prereqs->new;my$reqs=CPAN::Meta::Requirements->new;$reqs->add_requirements($prereqs->requirements_for($_,'requires'))for qw(configure build runtime);if ($accepts->($module)){$installs{$module->{name}}=Carton::Dist->new(name=>$module->{dist},pathname=>$module->{pathname},provides=>$module->{provides},version=>$module->{version},requirements=>$reqs,)}}my@new_dists;for my$module (sort keys%installs){push@new_dists,$installs{$module}}$self->_distributions(\@new_dists)}1;
CARTON_SNAPSHOT

$fatpacked{"Carton/Snapshot/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_EMITTER';
  package Carton::Snapshot::Emitter;use Class::Tiny;use warnings NONFATAL=>'all';sub emit {my($self,$snapshot)=@_;my$data='';$data .= "# carton snapshot format: version @{[$snapshot->version]}\n";$data .= "DISTRIBUTIONS\n";for my$dist (sort {$a->name cmp $b->name}$snapshot->distributions){$data .= "  @{[$dist->name]}\n";$data .= "    pathname: @{[$dist->pathname]}\n";$data .= "    provides:\n";for my$package (sort keys %{$dist->provides}){my$version=$dist->provides->{$package}{version};$version='undef' unless defined$version;$data .= "      $package $version\n"}$data .= "    requirements:\n";for my$module (sort$dist->required_modules){$data .= "      $module @{[ $dist->requirements_for_module($module) || '0' ]}\n"}}$data}1;
CARTON_SNAPSHOT_EMITTER

$fatpacked{"Carton/Snapshot/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_PARSER';
  package Carton::Snapshot::Parser;use Class::Tiny;use warnings NONFATAL=>'all';use Carton::Dist;use Carton::Error;my$machine={init=>[{re=>qr/^\# carton snapshot format: version (1\.0)/,code=>sub {my($stash,$snapshot,$ver)=@_;$snapshot->version($ver)},goto=>'section',},],section=>[{re=>qr/^DISTRIBUTIONS$/,goto=>'dists',},{re=>qr/^__EOF__$/,done=>1,},],dists=>[{re=>qr/^  (\S+)$/,code=>sub {$_[0]->{dist}=Carton::Dist->new(name=>$1)},goto=>'distmeta',},{re=>qr/^\S/,goto=>'section',redo=>1,},],distmeta=>[{re=>qr/^    pathname: (.*)$/,code=>sub {$_[0]->{dist}->pathname($1)},},{re=>qr/^\s{4}provides:$/,code=>sub {$_[0]->{property}='provides'},goto=>'properties',},{re=>qr/^\s{4}requirements:$/,code=>sub {$_[0]->{property}='requirements'},goto=>'properties',},{re=>qr/^\s{0,2}\S/,code=>sub {my($stash,$snapshot)=@_;$snapshot->add_distribution($stash->{dist});%$stash=()},goto=>'dists',redo=>1,},],properties=>[{re=>qr/^\s{6}([0-9A-Za-z_:]+) ([v0-9\._,=\!<>\s]+|undef)/,code=>sub {my($stash,$snapshot,$module,$version)=@_;if ($stash->{property}eq 'provides'){$stash->{dist}->provides->{$module}={version=>$version }}else {$stash->{dist}->add_string_requirement($module,$version)}},},{re=>qr/^\s{0,4}\S/,goto=>'distmeta',redo=>1,},],};sub parse {my($self,$data,$snapshot)=@_;my@lines=split /\r?\n/,$data;my$state=$machine->{init};my$stash={};LINE: for my$line (@lines,'__EOF__'){last LINE unless @$state;STATE: {for my$trans (@{$state}){if (my@match=$line =~ $trans->{re}){if (my$code=$trans->{code}){$code->($stash,$snapshot,@match)}if (my$goto=$trans->{goto}){$state=$machine->{$goto};if ($trans->{redo}){redo STATE}else {next LINE}}last STATE}}Carton::Error::SnapshotParseError->throw(error=>"Could not parse snapshot file: $line")}}}1;
CARTON_SNAPSHOT_PARSER

$fatpacked{"Carton/Tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_TREE';
  package Carton::Tree;use strict;use Carton::Dependency;use Class::Tiny qw(cpanfile snapshot);use constant STOP=>-1;sub walk_down {my($self,$cb)=@_;my$dumper;$dumper=sub {my($dependency,$reqs,$level,$parent)=@_;my$ret=$cb->($dependency,$reqs,$level);return if$ret && $ret==STOP;local$parent->{$dependency->distname}=1 if$dependency;for my$module (sort$reqs->required_modules){my$dependency=$self->dependency_for($module,$reqs);if ($dependency->dist){next if$parent->{$dependency->distname};$dumper->($dependency,$dependency->requirements,$level + 1,$parent)}else {}}};$dumper->(undef,$self->cpanfile->requirements,0,{});undef$dumper}sub dependency_for {my($self,$module,$reqs)=@_;my$requirement=$reqs->requirements_for_module($module);my$dep=Carton::Dependency->new;$dep->module($module);$dep->requirement($requirement);if (my$dist=$self->snapshot->find_or_core($module)){$dep->dist($dist)}return$dep}sub merged_requirements {my$self=shift;my$merged_reqs=CPAN::Meta::Requirements->new;my%seen;$self->walk_down(sub {my($dependency,$reqs,$level)=@_;return Carton::Tree::STOP if$dependency && $seen{$dependency->distname}++;$merged_reqs->add_requirements($reqs)});$merged_reqs->clear_requirement('perl');$merged_reqs->finalize;$merged_reqs}1;
CARTON_TREE

$fatpacked{"Carton/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_UTIL';
  package Carton::Util;use strict;use warnings;sub load_json {my$file=shift;open my$fh,"<",$file or die "$file: $!";from_json(join '',<$fh>)}sub dump_json {my($data,$file)=@_;open my$fh,">",$file or die "$file: $!";binmode$fh;print$fh to_json($data)}sub from_json {require JSON::PP;JSON::PP->new->utf8->decode($_[0])}sub to_json {my($data)=@_;require JSON::PP;JSON::PP->new->utf8->pretty->canonical->encode($data)}1;
CARTON_UTIL

$fatpacked{"Class/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_TINY';
  use 5.006;use strict;no strict 'refs';use warnings;package Class::Tiny;our$VERSION='1.006';use Carp ();require($] >= 5.010 ? "mro.pm" : "MRO/Compat.pm");my%CLASS_ATTRIBUTES;sub import {my$class=shift;my$pkg=caller;$class->prepare_class($pkg);$class->create_attributes($pkg,@_)if @_}sub prepare_class {my ($class,$pkg)=@_;@{"${pkg}::ISA"}="Class::Tiny::Object" unless @{"${pkg}::ISA"}}sub create_attributes {my ($class,$pkg,@spec)=@_;my%defaults=map {ref $_ eq 'HASH' ? %$_ : ($_=>undef)}@spec;my@attr=grep {defined and!ref and /^[^\W\d]\w*$/s or Carp::croak "Invalid accessor name '$_'"}keys%defaults;$CLASS_ATTRIBUTES{$pkg}{$_}=$defaults{$_}for@attr;$class->_gen_accessor($pkg,$_)for grep {!*{"$pkg\::$_"}{CODE}}@attr;Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub _gen_accessor {my ($class,$pkg,$name)=@_;my$outer_default=$CLASS_ATTRIBUTES{$pkg}{$name};my$sub=$class->__gen_sub_body($name,defined($outer_default),ref($outer_default));eval "package $pkg; my \$default=\$outer_default; $sub";Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub __gen_sub_body {my ($self,$name,$has_default,$default_type)=@_;if ($has_default && $default_type eq 'CODE'){return << "HERE"}elsif ($has_default){return << "HERE"}else {return << "HERE"}}sub get_all_attributes_for {my ($class,$pkg)=@_;my%attr=map {$_=>undef}map {keys %{$CLASS_ATTRIBUTES{$_}|| {}}}@{mro::get_linear_isa($pkg)};return keys%attr}sub get_all_attribute_defaults_for {my ($class,$pkg)=@_;my$defaults={};for my$p (reverse @{mro::get_linear_isa($pkg)}){while (my ($k,$v)=each %{$CLASS_ATTRIBUTES{$p}|| {}}){$defaults->{$k}=$v}}return$defaults}package Class::Tiny::Object;our$VERSION='1.006';my (%HAS_BUILDARGS,%BUILD_CACHE,%DEMOLISH_CACHE,%ATTR_CACHE);my$_PRECACHE=sub {no warnings 'once';my ($class)=@_;my$linear_isa=@{"$class\::ISA"}==1 && ${"$class\::ISA"}[0]eq "Class::Tiny::Object" ? [$class]: mro::get_linear_isa($class);$DEMOLISH_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::DEMOLISH"}@$linear_isa ];$BUILD_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::BUILD"}reverse @$linear_isa ];$HAS_BUILDARGS{$class}=$class->can("BUILDARGS");return$ATTR_CACHE{$class}={map {$_=>1}Class::Tiny->get_all_attributes_for($class)}};sub new {my$class=shift;my$valid_attrs=$ATTR_CACHE{$class}|| $_PRECACHE->($class);my$args;if ($HAS_BUILDARGS{$class}){$args=$class->BUILDARGS(@_)}else {if (@_==1 && ref $_[0]){my%copy=eval {%{$_[0]}};Carp::croak("Argument to $class->new() could not be dereferenced as a hash")if $@;$args=\%copy}elsif (@_ % 2==0){$args={@_}}else {Carp::croak("$class->new() got an odd number of elements")}}my$self=bless {map {$_=>$args->{$_}}grep {exists$valid_attrs->{$_}}keys %$args },$class;$self->BUILDALL($args)if!delete$args->{__no_BUILD__}&& @{$BUILD_CACHE{$class}};return$self}sub BUILDALL {$_->(@_)for @{$BUILD_CACHE{ref $_[0]}}}require Devel::GlobalDestruction unless defined ${^GLOBAL_PHASE};sub DESTROY {my$self=shift;my$class=ref$self;my$in_global_destruction=defined ${^GLOBAL_PHASE} ? ${^GLOBAL_PHASE} eq 'DESTRUCT' : Devel::GlobalDestruction::in_global_destruction();for my$demolisher (@{$DEMOLISH_CACHE{$class}}){my$e=do {local ($?,$@);eval {$demolisher->($self,$in_global_destruction)};$@};no warnings 'misc';die$e if$e}}1;
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default->( \$_[0] ) )
      );
  }
  HERE
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default )
      );
  }
  HERE
  sub $name {
      return \@_ == 1 ? \$_[0]{$name} : ( \$_[0]{$name} =  \$_[1] );
  }
  HERE
CLASS_TINY

$fatpacked{"Clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLONE';
  package Clone;use strict;use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD);require Exporter;require DynaLoader;require AutoLoader;@ISA=qw(Exporter DynaLoader);@EXPORT=qw();@EXPORT_OK=qw(clone);$VERSION='0.41';bootstrap Clone$VERSION;1;
CLONE

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.012';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$dirs)=@_;my%localdir_for;if ($dirs && %$dirs){%localdir_for=%$dirs}else {for my$type ($self->install_types){$localdir_for{$type}=File::Spec->catdir('blib',$type)}}my (%map,@skipping);for my$type (keys%localdir_for){next if not -e $localdir_for{$type};if (my$dest=$self->install_destination($type)){$map{$localdir_for{$type}}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use Exporter ();use File::Spec ();our$VERSION='1.23';our@ISA='Exporter';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if($^O eq 'MSWin32'){@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"HTTP/Tinyish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.15';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my($self,$url)=@_;my($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

$fatpacked{"HTTP/Tinyish/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if(/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

$fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version'],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my($self,$url,$opts)=@_;my@options=('--location','--silent','--max-time',($self->{timeout}|| 60),'--max-redirs',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

$fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

$fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field}=$hdrs->header($field)}\%headers}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(delete$attr{max_redirect}|| 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

$fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my(undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

$fatpacked{"IO/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_STRING';
  package IO::String;require 5.005_03;use strict;use vars qw($VERSION $DEBUG $IO_CONSTANTS);$VERSION="1.08";use Symbol ();sub new {my$class=shift;my$self=bless Symbol::gensym(),ref($class)|| $class;tie *$self,$self;$self->open(@_);return$self}sub open {my$self=shift;return$self->new(@_)unless ref($self);if (@_){my$bufref=ref($_[0])? $_[0]: \$_[0];$$bufref="" unless defined $$bufref;*$self->{buf}=$bufref}else {my$buf="";*$self->{buf}=\$buf}*$self->{pos}=0;*$self->{lno}=0;return$self}sub pad {my$self=shift;my$old=*$self->{pad};*$self->{pad}=substr($_[0],0,1)if @_;return "\0" unless defined($old)&& length($old);return$old}sub dump {require Data::Dumper;my$self=shift;print Data::Dumper->Dump([$self],['*self']);print Data::Dumper->Dump([*$self{HASH}],['$self{HASH}']);return}sub TIEHANDLE {print "TIEHANDLE @_\n" if$DEBUG;return $_[0]if ref($_[0]);my$class=shift;my$self=bless Symbol::gensym(),$class;$self->open(@_);return$self}sub DESTROY {print "DESTROY @_\n" if$DEBUG}sub close {my$self=shift;delete *$self->{buf};delete *$self->{pos};delete *$self->{lno};undef *$self if $] eq "5.008";return 1}sub opened {my$self=shift;return defined *$self->{buf}}sub binmode {my$self=shift;return 1 unless @_;return 0}sub getc {my$self=shift;my$buf;return$buf if$self->read($buf,1);return undef}sub ungetc {my$self=shift;$self->setpos($self->getpos()- 1);return 1}sub eof {my$self=shift;return length(${*$self->{buf}})<= *$self->{pos}}sub print {my$self=shift;if (defined $\){if (defined $,){$self->write(join($,,@_).$\)}else {$self->write(join("",@_).$\)}}else {if (defined $,){$self->write(join($,,@_))}else {$self->write(join("",@_))}}return 1}*printflush=\*print;sub printf {my$self=shift;print "PRINTF(@_)\n" if$DEBUG;my$fmt=shift;$self->write(sprintf($fmt,@_));return 1}my($SEEK_SET,$SEEK_CUR,$SEEK_END);sub _init_seek_constants {if ($IO_CONSTANTS){require IO::Handle;$SEEK_SET=&IO::Handle::SEEK_SET;$SEEK_CUR=&IO::Handle::SEEK_CUR;$SEEK_END=&IO::Handle::SEEK_END}else {$SEEK_SET=0;$SEEK_CUR=1;$SEEK_END=2}}sub seek {my($self,$off,$whence)=@_;my$buf=*$self->{buf}|| return 0;my$len=length($$buf);my$pos=*$self->{pos};_init_seek_constants()unless defined$SEEK_SET;if ($whence==$SEEK_SET){$pos=$off}elsif ($whence==$SEEK_CUR){$pos += $off}elsif ($whence==$SEEK_END){$pos=$len + $off}else {die "Bad whence ($whence)"}print "SEEK(POS=$pos,OFF=$off,LEN=$len)\n" if$DEBUG;$pos=0 if$pos < 0;$self->truncate($pos)if$pos > $len;*$self->{pos}=$pos;return 1}sub pos {my$self=shift;my$old=*$self->{pos};if (@_){my$pos=shift || 0;my$buf=*$self->{buf};my$len=$buf ? length($$buf): 0;$pos=$len if$pos > $len;*$self->{pos}=$pos}return$old}sub getpos {shift->pos}*sysseek=\&seek;*setpos=\&pos;*tell=\&getpos;sub getline {my$self=shift;my$buf=*$self->{buf}|| return;my$len=length($$buf);my$pos=*$self->{pos};return if$pos >= $len;unless (defined $/){*$self->{pos}=$len;return substr($$buf,$pos)}unless (length $/){my$para="";my$eol=0;my$c;while (defined($c=$self->getc)){if ($c eq "\n"){$eol++;next if$eol > 2}elsif ($eol > 1){$self->ungetc($c);last}else {$eol=0}$para .= $c}return$para}my$idx=index($$buf,$/,$pos);if ($idx < 0){*$self->{pos}=$len;$.=++ *$self->{lno};return substr($$buf,$pos)}$len=$idx - $pos + length($/);*$self->{pos}+= $len;$.=++ *$self->{lno};return substr($$buf,$pos,$len)}sub getlines {die "getlines() called in scalar context\n" unless wantarray;my$self=shift;my($line,@lines);push(@lines,$line)while defined($line=$self->getline);return@lines}sub READLINE {goto&getlines if wantarray;goto&getline}sub input_line_number {my$self=shift;my$old=*$self->{lno};*$self->{lno}=shift if @_;return$old}sub truncate {my$self=shift;my$len=shift || 0;my$buf=*$self->{buf};if (length($$buf)>= $len){substr($$buf,$len)='';*$self->{pos}=$len if$len < *$self->{pos}}else {$$buf .= ($self->pad x ($len - length($$buf)))}return 1}sub read {my$self=shift;my$buf=*$self->{buf};return undef unless$buf;my$pos=*$self->{pos};my$rem=length($$buf)- $pos;my$len=$_[1];$len=$rem if$len > $rem;return undef if$len < 0;if (@_ > 2){substr($_[0],$_[2])=substr($$buf,$pos,$len)}else {$_[0]=substr($$buf,$pos,$len)}*$self->{pos}+= $len;return$len}sub write {my$self=shift;my$buf=*$self->{buf};return unless$buf;my$pos=*$self->{pos};my$slen=length($_[0]);my$len=$slen;my$off=0;if (@_ > 1){$len=$_[1]if $_[1]< $len;if (@_ > 2){$off=$_[2]|| 0;die "Offset outside string" if$off > $slen;if ($off < 0){$off += $slen;die "Offset outside string" if$off < 0}my$rem=$slen - $off;$len=$rem if$rem < $len}}substr($$buf,$pos,$len)=substr($_[0],$off,$len);*$self->{pos}+= $len;return$len}*sysread=\&read;*syswrite=\&write;sub stat {my$self=shift;return unless$self->opened;return 1 unless wantarray;my$len=length ${*$self->{buf}};return (undef,undef,0666,1,$>,$),undef,$len,undef,undef,undef,512,int(($len+511)/512))}sub FILENO {return undef}sub blocking {my$self=shift;my$old=*$self->{blocking}|| 0;*$self->{blocking}=shift if @_;return$old}my$notmuch=sub {return};*fileno=$notmuch;*error=$notmuch;*clearerr=$notmuch;*sync=$notmuch;*flush=$notmuch;*setbuf=$notmuch;*setvbuf=$notmuch;*untaint=$notmuch;*autoflush=$notmuch;*fcntl=$notmuch;*ioctl=$notmuch;*GETC=\&getc;*PRINT=\&print;*PRINTF=\&printf;*READ=\&read;*WRITE=\&write;*SEEK=\&seek;*TELL=\&getpos;*EOF=\&eof;*CLOSE=\&close;*BINMODE=\&binmode;sub string_ref {my$self=shift;return *$self->{buf}}*sref=\&string_ref;1;
IO_STRING

$fatpacked{"IPC/Run3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

$fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

$fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

$fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

$fatpacked{"IPC/Run3/ProfPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

$fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time)}=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::PP::ISA=('Exporter')}use overload ();use JSON::PP::Boolean;use Carp ();$JSON::PP::VERSION='4.03';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true;return ($false,$true)}else {delete$self->{false};delete$self->{true};return}}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($props->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){if (!$relaxed or $ch ne "\t"){$at--;decode_error('invalid character encountered while parsing JSON string')}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::PP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> 0x20){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20"){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::PP::Boolean::VERSION='4.03';1;
JSON_PP_BOOLEAN

$fatpacked{"Menlo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO';
  package Menlo;our$VERSION="1.9019";1;
MENLO

$fatpacked{"Menlo/Builder/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_BUILDER_STATIC';
  package Menlo::Builder::Static;use strict;use warnings;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/dirname/;use File::Find ();use File::Path qw/mkpath/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;sub new {my($class,%args)=@_;bless {meta=>$args{meta},},$class}sub meta {my$self=shift;$self->{meta}}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared },catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}1},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and return;1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/});1},);sub build {my$self=shift;my$action=@_ && $_[0]=~ /\A\w+\z/ ? shift @_ : 'build';die "No such action '$action'\n" if not $actions{$action};my%opt;GetOptionsFromArray([@$_],\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($self->{env},$self->{configure_args},\@_);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),$self->meta);$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub configure {my$self=shift;$self->{env}=defined$ENV{PERL_MB_OPT}? [split_like_shell($ENV{PERL_MB_OPT})]: [];$self->{configure_args}=[@_];$self->meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MENLO_BUILDER_STATIC

$fatpacked{"Menlo/CLI/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_CLI_COMPAT';
  package Menlo::CLI::Compat;use strict;use Config;use Cwd ();use Menlo;use Menlo::Dependency;use Menlo::Util qw(WIN32);use File::Basename ();use File::Find ();use File::Path ();use File::Spec ();use File::Copy ();use File::Temp ();use File::Which qw(which);use Getopt::Long ();use Symbol ();use version ();use constant BAD_TAR=>($^O eq 'solaris' || $^O eq 'hpux');use constant CAN_SYMLINK=>eval {symlink("","");1};our$VERSION='1.9022';if ($INC{"App/FatPacker/Trace.pm"}){require version::vpp}sub qs($) {Menlo::Util::shell_quote($_[0])}sub determine_home {my$class=shift;my$homedir=$ENV{HOME}|| eval {require File::HomeDir;File::HomeDir->my_home}|| join('',@ENV{qw(HOMEDRIVE HOMEPATH)});if (WIN32){require Win32;$homedir=Win32::GetShortPathName($homedir)}return "$homedir/.cpanm"}sub new {my$class=shift;my$self=bless {name=>"Menlo",home=>$class->determine_home,cmd=>'install',seen=>{},notest=>undef,test_only=>undef,installdeps=>undef,force=>undef,sudo=>undef,make=>undef,verbose=>undef,quiet=>undef,interactive=>undef,log=>undef,mirrors=>[],mirror_only=>undef,mirror_index=>undef,cpanmetadb=>"http://cpanmetadb.plackperl.org/v1.0/",perl=>$^X,argv=>[],local_lib=>undef,self_contained=>undef,exclude_vendor=>undef,prompt_timeout=>0,prompt=>undef,configure_timeout=>60,build_timeout=>3600,test_timeout=>1800,try_lwp=>1,try_wget=>1,try_curl=>1,uninstall_shadows=>($] < 5.012),skip_installed=>1,skip_satisfied=>0,static_install=>1,auto_cleanup=>7,pod2man=>1,installed_dists=>0,install_types=>['requires'],with_develop=>0,with_configure=>0,showdeps=>0,scandeps=>0,scandeps_tree=>[],format=>'tree',save_dists=>undef,skip_configure=>0,verify=>0,report_perl_version=>!$class->maybe_ci,build_args=>{},features=>{},pure_perl=>0,cpanfile_path=>'cpanfile',@_,},$class;$self}sub env {my($self,$key)=@_;$ENV{"PERL_CPANM_" .$key}}sub maybe_ci {my$class=shift;grep$ENV{$_},qw(TRAVIS CI AUTOMATED_TESTING AUTHOR_TESTING)}sub install_type_handlers {my$self=shift;my@handlers;for my$type (qw(recommends suggests)){push@handlers,"with-$type"=>sub {my%uniq;$self->{install_types}=[grep!$uniq{$_}++,@{$self->{install_types}},$type ]};push@handlers,"without-$type"=>sub {$self->{install_types}=[grep $_ ne $type,@{$self->{install_types}}]}}@handlers}sub build_args_handlers {my$self=shift;my@handlers;for my$phase (qw(configure build test install)){push@handlers,"$phase-args=s"=>\($self->{build_args}{$phase})}@handlers}sub parse_options {my$self=shift;local@ARGV=@{$self->{argv}};push@ARGV,grep length,split /\s+/,$self->env('OPT');push@ARGV,@_;Getopt::Long::Configure("bundling");Getopt::Long::GetOptions('f|force'=>sub {$self->{skip_installed}=0;$self->{force}=1},'n|notest!'=>\$self->{notest},'test-only'=>sub {$self->{notest}=0;$self->{skip_installed}=0;$self->{test_only}=1},'S|sudo!'=>\$self->{sudo},'v|verbose'=>\$self->{verbose},'verify!'=>\$self->{verify},'q|quiet!'=>\$self->{quiet},'h|help'=>sub {$self->{action}='show_help'},'V|version'=>sub {$self->{action}='show_version'},'perl=s'=>sub {$self->diag("--perl is deprecated since it's known to be fragile in figuring out dependencies. Run `$_[1] -S cpanm` instead.\n",1);$self->{perl}=$_[1]},'l|local-lib=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1])},'L|local-lib-contained=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1]);$self->{self_contained}=1;$self->{pod2man}=undef},'self-contained!'=>\$self->{self_contained},'exclude-vendor!'=>\$self->{exclude_vendor},'mirror=s@'=>$self->{mirrors},'mirror-only!'=>\$self->{mirror_only},'mirror-index=s'=>sub {$self->{mirror_index}=$self->maybe_abs($_[1])},'M|from=s'=>sub {$self->{mirrors}=[$_[1]];$self->{mirror_only}=1},'cpanmetadb=s'=>\$self->{cpanmetadb},'cascade-search!'=>\$self->{cascade_search},'prompt!'=>\$self->{prompt},'installdeps'=>\$self->{installdeps},'skip-installed!'=>\$self->{skip_installed},'skip-satisfied!'=>\$self->{skip_satisfied},'reinstall'=>sub {$self->{skip_installed}=0},'interactive!'=>\$self->{interactive},'i|install'=>sub {$self->{cmd}='install'},'info'=>sub {$self->{cmd}='info'},'look'=>sub {$self->{cmd}='look';$self->{skip_installed}=0},'U|uninstall'=>sub {$self->{cmd}='uninstall'},'self-upgrade'=>sub {$self->{action}='self_upgrade'},'uninst-shadows!'=>\$self->{uninstall_shadows},'lwp!'=>\$self->{try_lwp},'wget!'=>\$self->{try_wget},'curl!'=>\$self->{try_curl},'auto-cleanup=s'=>\$self->{auto_cleanup},'man-pages!'=>\$self->{pod2man},'scandeps'=>\$self->{scandeps},'showdeps'=>sub {$self->{showdeps}=1;$self->{skip_installed}=0},'format=s'=>\$self->{format},'save-dists=s'=>sub {$self->{save_dists}=$self->maybe_abs($_[1])},'skip-configure!'=>\$self->{skip_configure},'static-install!'=>\$self->{static_install},'dev!'=>\$self->{dev_release},'metacpan!'=>\$self->{metacpan},'report-perl-version!'=>\$self->{report_perl_version},'configure-timeout=i'=>\$self->{configure_timeout},'build-timeout=i'=>\$self->{build_timeout},'test-timeout=i'=>\$self->{test_timeout},'with-develop'=>\$self->{with_develop},'without-develop'=>sub {$self->{with_develop}=0},'with-configure'=>\$self->{with_configure},'without-configure'=>sub {$self->{with_configure}=0},'with-feature=s'=>sub {$self->{features}{$_[1]}=1},'without-feature=s'=>sub {$self->{features}{$_[1]}=0},'with-all-features'=>sub {$self->{features}{__all}=1},'pp|pureperl!'=>\$self->{pure_perl},"cpanfile=s"=>\$self->{cpanfile_path},$self->install_type_handlers,$self->build_args_handlers,);if (!@ARGV && $0 ne '-' &&!-t STDIN){push@ARGV,$self->load_argv_from_fh(\*STDIN);$self->{load_from_stdin}=1}$self->{argv}=\@ARGV}sub check_upgrade {my$self=shift;my$install_base=$ENV{PERL_LOCAL_LIB_ROOT}? $self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}): $Config{installsitebin};if ($0 eq '-'){return}elsif ($0 !~ /^$install_base/){if ($0 =~ m!perlbrew/bin!){die <<DIE}else {die <<DIE}}}sub check_libs {my$self=shift;return if$self->{_checked}++;$self->bootstrap_local_lib}sub setup_verify {my$self=shift;my$has_modules=eval {require Module::Signature;require Digest::SHA;1};$self->{cpansign}=which('cpansign');unless ($has_modules && $self->{cpansign}){warn "WARNING: Module::Signature and Digest::SHA is required for distribution verifications.\n";$self->{verify}=0}}sub parse_module_args {my($self,$module)=@_;$module =~ s/^([A-Za-z0-9_:]+)@([v\d\._]+)$/$1~== $2/;if ($module =~ /\~[v\d\._,\!<>= ]+$/){return split '~',$module,2}else {return$module,undef}}sub run {my$self=shift;my$code;eval {$code=($self->_doit==0)};if (my$e=$@){warn$e;$code=1}$self->{status}=$code}sub status {$_[0]->{status}}sub _doit {my$self=shift;$self->setup_home;$self->init_tools;$self->setup_verify if$self->{verify};if (my$action=$self->{action}){$self->$action()and return 1}return$self->show_help(1)unless @{$self->{argv}}or $self->{load_from_stdin};$self->configure_mirrors;my$cwd=Cwd::cwd;my@fail;for my$module (@{$self->{argv}}){if ($module =~ s/\.pm$//i){my ($volume,$dirs,$file)=File::Spec->splitpath($module);$module=join '::',grep {$_}File::Spec->splitdir($dirs),$file}($module,my$version)=$self->parse_module_args($module);$self->chdir($cwd);if ($self->{cmd}eq 'uninstall'){$self->uninstall_module($module)or push@fail,$module}else {$self->install_module($module,0,$version)or push@fail,$module}}if ($self->{base}&& $self->{auto_cleanup}){$self->cleanup_workdirs}if ($self->{installed_dists}){my$dists=$self->{installed_dists}> 1 ? "distributions" : "distribution";$self->diag("$self->{installed_dists} $dists installed\n",1)}if ($self->{scandeps}){$self->dump_scandeps()}$self->chdir($cwd);return!@fail}sub setup_home {my$self=shift;$self->{home}=$self->env('HOME')if$self->env('HOME');unless (_writable($self->{home})){die "Can't write to cpanm home '$self->{home}': You should fix it with chown/chmod first.\n"}$self->{base}="$self->{home}/work/" .time .".$$";File::Path::mkpath([$self->{base}],0,0777);$self->{log}=File::Spec->catfile($self->{base},"build.log");my$final_log="$self->{home}/build.log";{open my$out,">$self->{log}" or die "$self->{log}: $!"}if (CAN_SYMLINK){my$build_link="$self->{home}/latest-build";unlink$build_link;symlink$self->{base},$build_link;unlink$final_log;symlink$self->{log},$final_log}else {my$log=$self->{log};my$home=$self->{home};$self->{at_exit}=sub {my$self=shift;my$temp_log="$home/build.log." .time .".$$";File::Copy::copy($log,$temp_log)&& unlink($final_log);rename($temp_log,$final_log)}}$self->chat("cpanm ($self->{name}) $Menlo::VERSION on perl $] built for $Config{archname}\n" ."Work directory is $self->{base}\n")}sub search_mirror_index_local {my ($self,$local,$module,$version)=@_;require CPAN::Common::Index::LocalPackage;my$index=CPAN::Common::Index::LocalPackage->new({source=>$local });$self->search_common($index,{package=>$module },$version)}sub search_mirror_index {my ($self,$mirror,$module,$version)=@_;require Menlo::Index::Mirror;my$index=Menlo::Index::Mirror->new({mirror=>$mirror,cache=>$self->source_for($mirror),fetcher=>sub {$self->mirror(@_)},});$self->search_common($index,{package=>$module },$version)}sub search_common {my($self,$index,$search_args,$want_version)=@_;$index->refresh_index;my$found=$index->search_packages($search_args);$found=$self->cpan_module_common($found)if$found;return$found unless$self->{cascade_search};if ($found){if ($self->satisfy_version($found->{module},$found->{module_version},$want_version)){return$found}else {$self->chat("Found $found->{module} $found->{module_version} which doesn't satisfy $want_version.\n")}}return}sub with_version_range {my($self,$version)=@_;defined($version)&& $version =~ /(?:<|!=|==)/}sub search_metacpan {my($self,$module,$version,$dev_release)=@_;require Menlo::Index::MetaCPAN;$self->chat("Searching $module ($version) on metacpan ...\n");my$index=Menlo::Index::MetaCPAN->new({include_dev=>$self->{dev_release}});my$pkg=$self->search_common($index,{package=>$module,version_range=>$version },$version);return$pkg if$pkg;$self->diag_fail("Finding $module ($version) on metacpan failed.");return}sub search_database {my($self,$module,$version)=@_;my$found;if ($self->{dev_release}or $self->{metacpan}){$found=$self->search_metacpan($module,$version,$self->{dev_release})and return$found;$found=$self->search_cpanmetadb($module,$version,$self->{dev_release})and return$found}else {$found=$self->search_cpanmetadb($module,$version)and return$found;$found=$self->search_metacpan($module,$version)and return$found}}sub search_cpanmetadb {my($self,$module,$version,$dev_release)=@_;require Menlo::Index::MetaDB;$self->chat("Searching $module ($version) on cpanmetadb ...\n");my$args={package=>$module };if ($self->with_version_range($version)){$args->{version_range}=$version}my$index=Menlo::Index::MetaDB->new({uri=>$self->{cpanmetadb}});my$pkg=$self->search_common($index,$args,$version);return$pkg if$pkg;$self->diag_fail("Finding $module on cpanmetadb failed.");return}sub search_module {my($self,$module,$version)=@_;if ($self->{mirror_index}){$self->mask_output(chat=>"Searching $module on mirror index $self->{mirror_index} ...\n");my$pkg=$self->search_mirror_index_local($self->{mirror_index},$module,$version);return$pkg if$pkg;unless ($self->{cascade_search}){$self->mask_output(diag_fail=>"Finding $module ($version) on mirror index $self->{mirror_index} failed.");return}}unless ($self->{mirror_only}){my$found=$self->search_database($module,$version);return$found if$found}MIRROR: for my$mirror (@{$self->{mirrors}}){$self->mask_output(chat=>"Searching $module on mirror $mirror ...\n");my$pkg=$self->search_mirror_index($mirror,$module,$version);return$pkg if$pkg;$self->mask_output(diag_fail=>"Finding $module ($version) on mirror $mirror failed.")}return}sub source_for {my($self,$mirror)=@_;$mirror =~ s/[^\w\.\-]+/%/g;my$dir="$self->{home}/sources/$mirror";File::Path::mkpath([$dir ],0,0777);return$dir}sub load_argv_from_fh {my($self,$fh)=@_;my@argv;while(defined(my$line=<$fh>)){chomp$line;$line =~ s/#.+$//;$line =~ s/^\s+//;$line =~ s/\s+$//;push@argv,split ' ',$line if$line}return@argv}sub show_version {my$self=shift;print "cpanm ($self->{name}) version $VERSION ($0)\n";print "perl version $] ($^X)\n\n";print "  \%Config:\n";for my$key (qw(archname installsitelib installsitebin installman1dir installman3dir sitearchexp sitelibexp vendorarch vendorlibexp archlibexp privlibexp)){print "    $key=$Config{$key}\n" if$Config{$key}}print "  \%ENV:\n";for my$key (grep /^PERL/,sort keys%ENV){print "    $key=$ENV{$key}\n"}print "  \@INC:\n";for my$inc (@INC){print "    $inc\n" unless ref($inc)eq 'CODE'}return 1}sub show_help {my$self=shift;if ($_[0]){print <<USAGE;return}print <<HELP;return 1}sub _writable {my$dir=shift;my@dir=File::Spec->splitdir($dir);while (@dir){$dir=File::Spec->catdir(@dir);if (-e $dir){return -w _}pop@dir}return}sub maybe_abs {my($self,$lib)=@_;if ($lib eq '_' or $lib =~ /^~/ or File::Spec->file_name_is_absolute($lib)){return$lib}else {return File::Spec->canonpath(File::Spec->catdir(Cwd::cwd(),$lib))}}sub local_lib_target {my($self,$root)=@_;(grep {$_ ne ''}split /\Q$Config{path_sep}/,$root)[0]}sub bootstrap_local_lib {my$self=shift;if ($self->{local_lib}){return$self->setup_local_lib($self->{local_lib})}if ($ENV{PERL_LOCAL_LIB_ROOT}&& $ENV{PERL_MM_OPT}){return$self->setup_local_lib($self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}),1)}return if$self->{sudo}or (_writable($Config{installsitelib})and _writable($Config{installsitebin}));if ($ENV{PERL_MM_OPT}and ($ENV{MODULEBUILDRC}or $ENV{PERL_MB_OPT})){return}$self->setup_local_lib;$self->diag(<<DIAG,1);sleep 2}sub upgrade_toolchain {my($self,$config_deps)=@_;my%deps=map {$_->module=>$_}@$config_deps;my$reqs=CPAN::Meta::Requirements->from_string_hash({'Module::Build'=>'0.38','ExtUtils::MakeMaker'=>'6.58','ExtUtils::Install'=>'1.46',});if ($deps{"ExtUtils::MakeMaker"}){$deps{"ExtUtils::MakeMaker"}->merge_with($reqs)}elsif ($deps{"Module::Build"}){$deps{"Module::Build"}->merge_with($reqs);$deps{"ExtUtils::Install"}||= Menlo::Dependency->new("ExtUtils::Install",0,'configure');$deps{"ExtUtils::Install"}->merge_with($reqs)}@$config_deps=values%deps}sub _core_only_inc {my($self,$base)=@_;require local::lib;(local::lib->resolve_path(local::lib->install_base_arch_path($base)),local::lib->resolve_path(local::lib->install_base_perl_path($base)),(!$self->{exclude_vendor}? grep {$_}@Config{qw(vendorarch vendorlibexp)}: ()),@Config{qw(archlibexp privlibexp)},)}sub _setup_local_lib_env {my($self,$base)=@_;$self->diag(<<WARN,1)if$base =~ /\s/;local$SIG{__WARN__}=sub {};local::lib->setup_env_hash_for($base,0)}sub setup_local_lib {my($self,$base,$no_env)=@_;$base=undef if$base eq '_';require local::lib;{local $0='cpanm';$base ||= "~/perl5";$base=local::lib->resolve_path($base);if ($self->{self_contained}){my@inc=$self->_core_only_inc($base);$self->{search_inc}=[@inc ]}else {$self->{search_inc}=[local::lib->install_base_arch_path($base),local::lib->install_base_perl_path($base),@INC,]}$self->_setup_local_lib_env($base)unless$no_env;$self->{local_lib}=$base}}sub prompt_bool {my($self,$mess,$def)=@_;my$val=$self->prompt($mess,$def);return lc$val eq 'y'}sub prompt {my($self,$mess,$def)=@_;my$isa_tty=-t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT));my$dispdef=defined$def ? "[$def] " : " ";$def=defined$def ? $def : "";if (!$self->{prompt}|| (!$isa_tty && eof STDIN)){return$def}local $|=1;local $\;my$ans;eval {local$SIG{ALRM}=sub {undef$ans;die "alarm\n"};print STDOUT "$mess $dispdef";alarm$self->{prompt_timeout}if$self->{prompt_timeout};$ans=<STDIN>;alarm 0};if (defined$ans){chomp$ans}else {print STDOUT "\n"}return (!defined$ans || $ans eq '')? $def : $ans}sub diag_ok {my($self,$msg)=@_;chomp$msg;$msg ||= "OK";if ($self->{in_progress}){$self->_diag("$msg\n");$self->{in_progress}=0}$self->log("-> $msg\n")}sub diag_fail {my($self,$msg,$always)=@_;chomp$msg;if ($self->{in_progress}){$self->_diag("FAIL\n");$self->{in_progress}=0}if ($msg){$self->_diag("! $msg\n",$always,1);$self->log("-> FAIL $msg\n")}}sub diag_progress {my($self,$msg)=@_;chomp$msg;$self->{in_progress}=1;$self->_diag("$msg ... ");$self->log("$msg\n")}sub _diag {my($self,$msg,$always,$error)=@_;my$fh=$error ? *STDERR : *STDOUT;print {$fh}$msg if$always or $self->{verbose}or!$self->{quiet}}sub diag {my($self,$msg,$always)=@_;$self->_diag($msg,$always);$self->log($msg)}sub chat {my$self=shift;print STDERR @_ if$self->{verbose};$self->log(@_)}sub mask_output {my$self=shift;my$method=shift;$self->$method($self->mask_uri_passwords(@_))}sub log {my$self=shift;open my$out,">>$self->{log}";print$out @_}sub run_command {my($self,$cmd)=@_;if (ref$cmd eq 'CODE'){if ($self->{verbose}){return$cmd->()}else {require Capture::Tiny;open my$logfh,">>",$self->{log};my$ret;Capture::Tiny::capture(sub {$ret=$cmd->()},stdout=>$logfh,stderr=>$logfh);return$ret}}if (WIN32){$cmd=Menlo::Util::shell_quote(@$cmd)if ref$cmd eq 'ARRAY';unless ($self->{verbose}){$cmd .= " >> " .Menlo::Util::shell_quote($self->{log})." 2>&1"}!system$cmd}else {my$pid=fork;if ($pid){waitpid$pid,0;return!$?}else {$self->run_exec($cmd)}}}sub run_exec {my($self,$cmd)=@_;if (ref$cmd eq 'ARRAY'){unless ($self->{verbose}){open my$logfh,">>",$self->{log};open STDERR,'>&',$logfh;open STDOUT,'>&',$logfh;close$logfh}exec @$cmd}else {unless ($self->{verbose}){$cmd .= " >> " .Menlo::Util::shell_quote($self->{log})." 2>&1"}exec$cmd}}sub run_timeout {my($self,$cmd,$timeout)=@_;return$self->run_command($cmd)if ref($cmd)eq 'CODE' || WIN32 || $self->{verbose}||!$timeout;my$pid=fork;if ($pid){eval {local$SIG{ALRM}=sub {die "alarm\n"};alarm$timeout;waitpid$pid,0;alarm 0};if ($@ && $@ eq "alarm\n"){$self->diag_fail("Timed out (> ${timeout}s). Use --verbose to retry.");local$SIG{TERM}='IGNORE';kill TERM=>0;waitpid$pid,0;return}return!$?}elsif ($pid==0){$self->run_exec($cmd)}else {$self->chat("! fork failed: falling back to system()\n");$self->run_command($cmd)}}sub append_args {my($self,$cmd,$phase)=@_;return$cmd if ref$cmd ne 'ARRAY';if (my$args=$self->{build_args}{$phase}){$cmd=join ' ',Menlo::Util::shell_quote(@$cmd),$args}$cmd}sub _use_unsafe_inc {my($self,$dist)=@_;if (exists$ENV{PERL_USE_UNSAFE_INC}){return$ENV{PERL_USE_UNSAFE_INC}}if (exists$dist->{meta}{x_use_unsafe_inc}){$self->chat("Distribution opts in x_use_unsafe_inc: $dist->{meta}{x_use_unsafe_inc}\n");return$dist->{meta}{x_use_unsafe_inc}}return 1}sub configure {my($self,$cmd,$dist,$depth)=@_;local$ENV{PERL5_CPAN_IS_RUNNING}=local$ENV{PERL5_CPANPLUS_IS_RUNNING}=$$;local$ENV{PERL5_CPANM_IS_RUNNING}=$$;my$use_default=!$self->{interactive};local$ENV{PERL_MM_USE_DEFAULT}=$use_default;local$ENV{PERL_MM_OPT}=$ENV{PERL_MM_OPT};local$ENV{PERL_MB_OPT}=$ENV{PERL_MB_OPT};unless ($self->{pod2man}){$ENV{PERL_MM_OPT}.= " INSTALLMAN1DIR=none INSTALLMAN3DIR=none";$ENV{PERL_MB_OPT}.= " --config installman1dir= --config installsiteman1dir= --config installman3dir= --config installsiteman3dir="}if ($self->{pure_perl}){$ENV{PERL_MM_OPT}.= " PUREPERL_ONLY=1";$ENV{PERL_MB_OPT}.= " --pureperl-only"}local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'configure')if$depth==0;local$self->{verbose}=$self->{verbose}|| $self->{interactive};$self->run_timeout($cmd,$self->{configure_timeout})}sub build {my($self,$cmd,$distname,$dist,$depth)=@_;local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'build')if$depth==0;return 1 if$self->run_timeout($cmd,$self->{build_timeout});while (1){my$ans=lc$self->prompt("Building $distname failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->build($cmd,$distname,$dist,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}sub test {my($self,$cmd,$distname,$dist,$depth)=@_;return 1 if$self->{notest};local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{NONINTERACTIVE_TESTING}=!$self->{interactive};local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'test')if$depth==0;return 1 if$self->run_timeout($cmd,$self->{test_timeout});if ($self->{force}){$self->diag_fail("Testing $distname failed but installing it anyway.");return 1}else {$self->diag_fail;while (1){my$ans=lc$self->prompt("Testing $distname failed.\nYou can s)kip, r)etry, f)orce install, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->test($cmd,$distname,$dist,$depth)if$ans eq 'r';return 1 if$ans eq 'f';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}}sub install {my($self,$cmd,$uninst_opts,$dist,$depth)=@_;if ($depth==0 && $self->{test_only}){return 1}return$self->run_command($cmd)if ref$cmd eq 'CODE';local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);if ($self->{sudo}){unshift @$cmd,"sudo"}if ($self->{uninstall_shadows}&&!$ENV{PERL_MM_OPT}){push @$cmd,@$uninst_opts}$cmd=$self->append_args($cmd,'install')if$depth==0;$self->run_command($cmd)}sub look {my$self=shift;my$shell=$ENV{SHELL};$shell ||= $ENV{COMSPEC}if WIN32;if ($shell){my$cwd=Cwd::cwd;$self->diag("Entering $cwd with $shell\n");system$shell}else {$self->diag_fail("You don't seem to have a SHELL :/")}}sub show_build_log {my$self=shift;my@pagers=($ENV{PAGER},(WIN32 ? (): ('less')),'more');my$pager;while (@pagers){$pager=shift@pagers;next unless$pager;$pager=which($pager);next unless$pager;last}if ($pager){if (WIN32){system "@{[ qs $pager ]} < @{[ qs $self->{log}]}"}else {system$pager,$self->{log}}}else {$self->diag_fail("You don't seem to have a PAGER :/")}}sub chdir {my$self=shift;Cwd::chdir(File::Spec->canonpath($_[0]))or die "$_[0]: $!"}sub configure_mirrors {my$self=shift;unless (@{$self->{mirrors}}){$self->{mirrors}=['http://www.cpan.org' ]}for (@{$self->{mirrors}}){s!^/!file:///!;s!/$!!}}sub self_upgrade {my$self=shift;$self->check_upgrade;$self->{argv}=['Menlo' ];return}sub install_module {my($self,$module,$depth,$version,$dep)=@_;$self->check_libs;if ($self->{seen}{$module}++){$self->chat("Already tried $module. Skipping.\n");return 1}if ($self->{skip_satisfied}){my($ok,$local)=$self->check_module($module,$version || 0);if ($ok){$self->diag("You have $module ($local)\n",1);return 1}}my$dist=$self->resolve_name($module,$version,$dep);unless ($dist){my$what=$module .($version ? " ($version)" : "");$self->diag_fail("Couldn't find module or a distribution $what",1);return}if ($dist->{distvname}&& $self->{seen}{$dist->{distvname}}++){$self->chat("Already tried $dist->{distvname}. Skipping.\n");return 1}if ($self->{cmd}eq 'info'){print$self->format_dist($dist),"\n";return 1}$dist->{depth}=$depth;if ($dist->{module}){unless ($self->satisfy_version($dist->{module},$dist->{module_version},$version)){$self->diag("Found $dist->{module} $dist->{module_version} which doesn't satisfy $version.\n",1);return}my$cmp=$version ? "==" : "";my$requirement=$dist->{module_version}? "$cmp$dist->{module_version}" : 0;my($ok,$local)=$self->check_module($dist->{module},$requirement);if ($self->{skip_installed}&& $ok){$self->diag("$dist->{module} is up to date. ($local)\n",1);return 1}}if ($dist->{dist}eq 'perl'){$self->diag("skipping $dist->{pathname}\n");return 1}$self->diag("--> Working on $module\n");$dist->{dir}||= $self->fetch_module($dist);unless ($dist->{dir}){$self->diag_fail("Failed to fetch distribution $dist->{distvname}",1);return}$self->chat("Entering $dist->{dir}\n");$self->chdir($self->{base});$self->chdir($dist->{dir});if ($self->{cmd}eq 'look'){$self->look;return 1}return$self->build_stuff($module,$dist,$depth)}sub uninstall_search_path {my$self=shift;$self->{local_lib}? (local::lib->install_base_arch_path($self->{local_lib}),local::lib->install_base_perl_path($self->{local_lib})): @Config{qw(installsitearch installsitelib)}}sub uninstall_module {my ($self,$module)=@_;$self->check_libs;my@inc=$self->uninstall_search_path;my($metadata,$packlist)=$self->packlists_containing($module,\@inc);unless ($packlist){$self->diag_fail(<<DIAG,1);return}my@uninst_files=$self->uninstall_target($metadata,$packlist);$self->ask_permission($module,\@uninst_files)or return;$self->uninstall_files(@uninst_files,$packlist);$self->diag("Successfully uninstalled $module\n",1);return 1}sub packlists_containing {my($self,$module,$inc)=@_;require Module::Metadata;my$metadata=Module::Metadata->new_from_module($module,inc=>$inc)or return;my$packlist;my$wanted=sub {return unless $_ eq '.packlist' && -f $_;for my$file ($self->unpack_packlist($File::Find::name)){$packlist ||= $File::Find::name if$file eq $metadata->filename}};{require File::pushd;my$pushd=File::pushd::pushd();my@search=grep -d $_,map File::Spec->catdir($_,'auto'),@$inc;File::Find::find($wanted,@search)}return$metadata,$packlist}sub uninstall_target {my($self,$metadata,$packlist)=@_;if ($self->has_shadow_install($metadata)or $self->{local_lib}){grep$self->should_unlink($_),$self->unpack_packlist($packlist)}else {$self->unpack_packlist($packlist)}}sub has_shadow_install {my($self,$metadata)=@_;my@shadow=grep defined,map Module::Metadata->new_from_module($metadata->name,inc=>[$_]),@INC;@shadow >= 2}sub should_unlink {my($self,$file)=@_;if ($self->{local_lib}){$file =~ /^\Q$self->{local_lib}\E/}else {!(grep$file =~ /^\Q$_\E/,@Config{qw(installbin installscript installman1dir installman3dir)})}}sub ask_permission {my ($self,$module,$files)=@_;$self->diag("$module contains the following files:\n\n");for my$file (@$files){$self->diag("  $file\n")}$self->diag("\n");return 'force uninstall' if$self->{force};local$self->{prompt}=1;return$self->prompt_bool("Are you sure you want to uninstall $module?",'y')}sub unpack_packlist {my ($self,$packlist)=@_;open my$fh,'<',$packlist or die "$packlist: $!";map {chomp;$_}<$fh>}sub uninstall_files {my ($self,@files)=@_;$self->diag("\n");for my$file (@files){$self->diag("Unlink: $file\n");unlink$file or $self->diag_fail("$!: $file")}$self->diag("\n");return 1}sub format_dist {my($self,$dist)=@_;return "$dist->{cpanid}/$dist->{filename}"}sub trim {local $_=shift;tr/\n/ /d;s/^\s*|\s*$//g;$_}sub fetch_module {my($self,$dist)=@_;$self->chdir($self->{base});for my$uri (@{$dist->{uris}}){$self->mask_output(diag_progress=>"Fetching $uri");my$filename=$dist->{filename}|| $uri;my$name=File::Basename::basename($filename);my$cancelled;my$fetch=sub {my$file;eval {local$SIG{INT}=sub {$cancelled=1;die "SIGINT\n"};$self->mirror($uri,$name);$file=$name if -e $name};$self->diag("ERROR: " .trim("$@")."\n",1)if $@ && $@ ne "SIGINT\n";return$file};my($try,$file);while ($try++ < 3){$file=$fetch->();last if$cancelled or $file;$self->mask_output(diag_fail=>"Download $uri failed. Retrying ... ")}if ($cancelled){$self->diag_fail("Download cancelled.");return}unless ($file){$self->mask_output(diag_fail=>"Failed to download $uri");next}$self->diag_ok;$dist->{local_path}=File::Spec->rel2abs($name);my$dir=$self->unpack($file,$uri,$dist);next unless$dir;if (my$save=$self->{save_dists}){my$path=$dist->{pathname}? "$save/authors/id/$dist->{pathname}" : "$save/vendor/$file";$self->chat("Copying $name to $path\n");File::Path::mkpath([File::Basename::dirname($path)],0,0777);File::Copy::copy($file,$path)or warn $!}return$dist,$dir}}sub unpack {my($self,$file,$uri,$dist)=@_;if ($self->{verify}){$self->verify_archive($file,$uri,$dist)or return}$self->chat("Unpacking $file\n");my$dir=$file =~ /\.zip/i ? $self->unzip($file): $self->untar($file);unless ($dir){$self->diag_fail("Failed to unpack $file: no directory")}return$dir}sub verify_checksums_signature {my($self,$chk_file)=@_;require Module::Signature;$self->chat("Verifying the signature of CHECKSUMS\n");my$rv=eval {local$SIG{__WARN__}=sub {};my$v=Module::Signature::_verify($chk_file);$v==Module::Signature::SIGNATURE_OK()};if ($rv){$self->chat("Verified OK!\n")}else {$self->diag_fail("Verifying CHECKSUMS signature failed: $rv\n");return}return 1}sub verify_archive {my($self,$file,$uri,$dist)=@_;unless ($dist->{cpanid}){$self->chat("Archive '$file' does not seem to be from PAUSE. Skip verification.\n");return 1}(my$mirror=$uri)=~ s!/authors/id.*$!!;(my$chksum_uri=$uri)=~ s!/[^/]*$!/CHECKSUMS!;my$chk_file=$self->source_for($mirror)."/$dist->{cpanid}.CHECKSUMS";$self->mask_output(diag_progress=>"Fetching $chksum_uri");$self->mirror($chksum_uri,$chk_file);unless (-e $chk_file){$self->diag_fail("Fetching $chksum_uri failed.\n");return}$self->diag_ok;$self->verify_checksums_signature($chk_file)or return;$self->verify_checksum($file,$chk_file)}sub verify_checksum {my($self,$file,$chk_file)=@_;$self->chat("Verifying the SHA1 for $file\n");open my$fh,"<$chk_file" or die "$chk_file: $!";my$data=join '',<$fh>;$data =~ s/\015?\012/\n/g;require Safe;my$chksum=Safe->new->reval($data);if (!ref$chksum or ref$chksum ne 'HASH'){$self->diag_fail("! Checksum file downloaded from $chk_file is broken.\n");return}if (my$sha=$chksum->{$file}{sha256}){my$hex=$self->sha_for(256,$file);if ($hex eq $sha){$self->chat("Checksum for $file: Verified!\n")}else {$self->diag_fail("Checksum mismatch for $file\n");return}}else {$self->chat("Checksum for $file not found in CHECKSUMS.\n");return}}sub sha_for {my($self,$alg,$file)=@_;require Digest::SHA;open my$fh,"<",$file or die "$file: $!";my$dg=Digest::SHA->new($alg);my($data);while (read($fh,$data,4096)){$dg->add($data)}return$dg->hexdigest}sub verify_signature {my($self,$dist)=@_;$self->diag_progress("Verifying the SIGNATURE file");my$out=`@{[ qs $self->{cpansign} ]} -v --skip 2>&1`;$self->log($out);if ($out =~ /Signature verified OK/){$self->diag_ok("Verified OK");return 1}else {$self->diag_fail("SIGNATURE verification for $dist->{filename} failed\n");return}}sub resolve_name {my($self,$module,$version,$dep)=@_;if ($dep && $dep->url){if ($dep->url =~ m!authors/id/(.*)!){return$self->cpan_dist($1,$dep->url)}else {return {uris=>[$dep->url ]}}}if ($dep && $dep->dist){return$self->cpan_dist($dep->dist,undef,$dep->mirror)}if ($module =~ /(?:^git:|\.git(?:@.+)?$)/){return$self->git_uri($module)}if ($module =~ /^(ftp|https?|file):/){if ($module =~ m!authors/id/(.*)!){return$self->cpan_dist($1,$module)}else {return {uris=>[$module ]}}}if ($module =~ m!^[\./]! && -d $module){return {source=>'local',dir=>Cwd::abs_path($module),}}if (-f $module){return {source=>'local',uris=>["file://" .Cwd::abs_path($module)],}}if ($module =~ s!^cpan:///distfile/!!){return$self->cpan_dist($module)}if ($module =~ m!^(?:[A-Z]/[A-Z]{2}/)?([A-Z]{2}[\-A-Z0-9]*/.*)$!){return$self->cpan_dist($1)}return$self->search_module($module,$version)}sub cpan_module_common {my($self,$match)=@_;(my$distfile=$match->{uri})=~ s!^cpan:///distfile/!!;my$mirrors=$self->{mirrors};if ($match->{download_uri}){(my$mirror=$match->{download_uri})=~ s!/authors/id/.*$!!;$mirrors=[$mirror]}local$self->{mirrors}=$mirrors;return$self->cpan_module($match->{package},$distfile,$match->{version})}sub cpan_module {my($self,$module,$dist_file,$version)=@_;my$dist=$self->cpan_dist($dist_file);$dist->{module}=$module;$dist->{module_version}=$version if$version && $version ne 'undef';return$dist}sub cpan_dist {my($self,$dist,$url,$mirror)=@_;$mirror =~ s!/$!! if$mirror;$dist =~ s!^([A-Z]{2})!substr($1,0,1)."/".substr($1,0,2)."/".$1!e;require CPAN::DistnameInfo;my$d=CPAN::DistnameInfo->new($dist);if ($url){$url=[$url ]unless ref$url eq 'ARRAY'}else {my$id=$d->cpanid;my$fn=substr($id,0,1)."/" .substr($id,0,2)."/" .$id ."/" .$d->filename;my@mirrors=$mirror ? ($mirror): @{$self->{mirrors}};my@urls=map "$_/authors/id/$fn",@mirrors;$url=\@urls,}return {$d->properties,source=>'cpan',uris=>$url,}}sub git_uri {my ($self,$uri)=@_;($uri,my$commitish)=split /(?<=\.git)@/i,$uri,2;my$dir=File::Temp::tempdir(CLEANUP=>1);$self->mask_output(diag_progress=>"Cloning $uri");$self->run_command(['git','clone',$uri,$dir ]);unless (-e "$dir/.git"){$self->diag_fail("Failed cloning git repository $uri",1);return}if ($commitish){require File::pushd;my$dir=File::pushd::pushd($dir);unless ($self->run_command(['git','checkout',$commitish ])){$self->diag_fail("Failed to checkout '$commitish' in git repository $uri\n");return}}$self->diag_ok;return {source=>'local',dir=>$dir,}}sub core_version_for {my($self,$module)=@_;require Module::CoreList;unless (exists$Module::CoreList::version{$]+0}){die sprintf("Module::CoreList %s (loaded from %s) doesn't seem to have entries for perl $]. " ."You're strongly recommended to upgrade Module::CoreList from CPAN.\n",$Module::CoreList::VERSION,$INC{"Module/CoreList.pm"})}unless (exists$Module::CoreList::version{$]+0}{$module}){return -1}return$Module::CoreList::version{$]+0}{$module}}sub search_inc {my$self=shift;$self->{search_inc}||= do {if (defined$::Bin){[grep!/^\Q$::Bin\E\/..\/(?:fat)?lib$/,@INC]}else {[@INC]}}}sub check_module {my($self,$mod,$want_ver)=@_;require Module::Metadata;my$meta=Module::Metadata->new_from_module($mod,inc=>$self->search_inc)or return 0,undef;my$version=$meta->version;if ($self->{self_contained}&& $self->loaded_from_perl_lib($meta)){$version=$self->core_version_for($mod);return 0,undef if$version && $version==-1}$self->{local_versions}{$mod}=$version;if ($self->is_deprecated($meta)){return 0,$version}elsif ($self->satisfy_version($mod,$version,$want_ver)){return 1,($version || 'undef')}else {return 0,$version}}sub satisfy_version {my($self,$mod,$version,$want_ver)=@_;$want_ver='0' unless defined($want_ver)&& length($want_ver);require CPAN::Meta::Requirements;my$requirements=CPAN::Meta::Requirements->new;$requirements->add_string_requirement($mod,$want_ver);$requirements->accepts_module($mod,$version)}sub unsatisfy_how {my($self,$ver,$want_ver)=@_;if ($want_ver =~ /^[v0-9\.\_]+$/){return "$ver < $want_ver"}else {return "$ver doesn't satisfy $want_ver"}}sub is_deprecated {my($self,$meta)=@_;my$deprecated=eval {require Module::CoreList;Module::CoreList::is_deprecated($meta->{module})};return$deprecated && $self->loaded_from_perl_lib($meta)}sub loaded_from_perl_lib {my($self,$meta)=@_;require Config;my@dirs=qw(archlibexp privlibexp);if ($self->{self_contained}&&!$self->{exclude_vendor}&& $Config{vendorarch}){unshift@dirs,qw(vendorarch vendorlibexp)}for my$dir (@dirs){my$confdir=$Config{$dir};if ($confdir eq substr($meta->filename,0,length($confdir))){return 1}}return}sub should_install {my($self,$mod,$ver)=@_;$self->chat("Checking if you have $mod $ver ... ");my($ok,$local)=$self->check_module($mod,$ver);if ($ok){$self->chat("Yes ($local)\n")}elsif ($local){$self->chat("No (" .$self->unsatisfy_how($local,$ver).")\n")}else {$self->chat("No\n")}return$mod unless$ok;return}sub check_perl_version {my($self,$version)=@_;require CPAN::Meta::Requirements;my$req=CPAN::Meta::Requirements->from_string_hash({perl=>$version });$req->accepts_module(perl=>$])}sub install_deps {my($self,$dir,$depth,@deps)=@_;my(@install,%seen,@fail);for my$dep (@deps){next if$seen{$dep->module};if ($dep->module eq 'perl'){if ($dep->is_requirement &&!$self->check_perl_version($dep->version)){$self->diag("Needs perl @{[$dep->version]}, you have $]\n");push@fail,'perl'}}elsif ($self->should_install($dep->module,$dep->version)){push@install,$dep;$seen{$dep->module}=1}}if (@install){$self->diag("==> Found dependencies: " .join(", ",map $_->module,@install)."\n")}for my$dep (@install){$self->install_module($dep->module,$depth + 1,$dep->version,$dep)}$self->chdir($self->{base});$self->chdir($dir)if$dir;if ($self->{scandeps}){return 1}my@not_ok=$self->unsatisfied_deps(@deps);if (@not_ok){return 0,\@not_ok}else {return 1}}sub unsatisfied_deps {my($self,@deps)=@_;require CPAN::Meta::Check;require CPAN::Meta::Requirements;my$reqs=CPAN::Meta::Requirements->new;for my$dep (grep $_->is_requirement,@deps){$reqs->add_string_requirement($dep->module=>$dep->requires_version || '0')}my$ret=CPAN::Meta::Check::check_requirements($reqs,'requires',$self->{search_inc});grep defined,values %$ret}sub install_deps_bailout {my($self,$target,$dir,$depth,@deps)=@_;my($ok,$fail)=$self->install_deps($dir,$depth,@deps);if (!$ok){$self->diag_fail("Installing the dependencies failed: " .join(", ",@$fail),1);unless ($self->prompt_bool("Do you want to continue building $target anyway?","n")){$self->diag_fail("Bailing out the installation for $target.",1);return}}return 1}sub build_stuff {my($self,$stuff,$dist,$depth)=@_;if ($self->{verify}&& -e 'SIGNATURE'){$self->verify_signature($dist)or return}require CPAN::Meta;my($meta_file)=grep -f,qw(META.json META.yml);if ($meta_file){$self->chat("Checking configure dependencies from $meta_file\n");$dist->{cpanmeta}=eval {CPAN::Meta->load_file($meta_file)}}elsif ($dist->{dist}&& $dist->{version}){$self->chat("META.yml/json not found. Creating skeleton for it.\n");$dist->{cpanmeta}=CPAN::Meta->new({name=>$dist->{dist},version=>$dist->{version}})}$dist->{meta}=$dist->{cpanmeta}? $dist->{cpanmeta}->as_struct : {};if ($self->opts_in_static_install($dist->{cpanmeta})){$dist->{static_install}=1}my@config_deps;if ($dist->{cpanmeta}){push@config_deps,Menlo::Dependency->from_prereqs($dist->{cpanmeta}->effective_prereqs,['configure'],$self->{install_types},)}if (-e 'Build.PL' &&!@config_deps){push@config_deps,Menlo::Dependency->from_versions({'Module::Build'=>'0.38' },'configure',)}$self->merge_with_cpanfile($dist,\@config_deps);$self->upgrade_toolchain(\@config_deps);my$target=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $dist->{dir};unless ($self->skip_configure($dist,$depth)){$self->install_deps_bailout($target,$dist->{dir},$depth,@config_deps)or return}$self->diag_progress("Configuring $target");my$configure_state=$self->configure_this($dist,$depth);$self->diag_ok($configure_state->{configured_ok}? "OK" : "N/A");if ($dist->{cpanmeta}&& $dist->{source}eq 'cpan'){$dist->{provides}=$dist->{cpanmeta}{provides}|| $self->extract_packages($dist->{cpanmeta},".")}my$deps_only=$self->deps_only($depth);$dist->{want_phases}=$self->{notest}&&!$self->deps_only($depth)? [qw(build runtime)]: [qw(build test runtime)];push @{$dist->{want_phases}},'develop' if$self->{with_develop}&& $depth==0;push @{$dist->{want_phases}},'configure' if$self->{with_configure}&& $depth==0;my@deps=$self->find_prereqs($dist);my$module_name=$self->find_module_name($configure_state)|| $dist->{meta}{name};$module_name =~ s/-/::/g;if ($self->{showdeps}){for my$dep (@config_deps,@deps){print$dep->module,($dep->version ? ("~".$dep->version): ""),"\n"}return 1}my$distname=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $stuff;my$walkup;if ($self->{scandeps}){$walkup=$self->scandeps_append_child($dist)}$self->install_deps_bailout($distname,$dist->{dir},$depth,@deps)or return;if ($self->{scandeps}){unless ($configure_state->{configured_ok}){my$diag=<<DIAG;if (@config_deps){my@tree=@{$self->{scandeps_tree}};$diag .= "!\n" .join("",map "! * $_->[0]{module}\n",@tree[0..$#tree-1])if@tree}$self->diag("!\n$diag!\n",1)}$walkup->();return 1}if ($self->{installdeps}&& $depth==0){if ($configure_state->{configured_ok}){$self->diag("<== Installed dependencies for $stuff. Finishing.\n");return 1}else {$self->diag("! Configuring $distname failed. See $self->{log} for details.\n",1);return}}my$installed;if ($configure_state->{static_install}){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build(sub {$configure_state->{static_install}->build},$distname,$dist,$depth)&& $self->test(sub {$configure_state->{static_install}->build("test")},$distname,$dist,$depth)&& $self->install(sub {$configure_state->{static_install}->build("install")},[],$dist,$depth)&& $installed++}elsif ($configure_state->{use_module_build}&& -e 'Build' && -f _){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{perl},"./Build" ],$distname,$dist,$depth)&& $self->test([$self->{perl},"./Build","test" ],$distname,$dist,$depth)&& $self->install([$self->{perl},"./Build","install" ],["--uninst",1 ],$dist,$depth)&& $installed++}elsif ($self->{make}&& -e 'Makefile'){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{make}],$distname,$dist,$depth)&& $self->test([$self->{make},"test" ],$distname,$dist,$depth)&& $self->install([$self->{make},"install" ],["UNINST=1" ],$dist,$depth)&& $installed++}else {my$why;my$configure_failed=$configure_state->{configured}&&!$configure_state->{configured_ok};if ($configure_failed){$why="Configure failed for $distname."}elsif ($self->{make}){$why="The distribution doesn't have a proper Makefile.PL/Build.PL"}else {$why="Can't configure the distribution. You probably need to have 'make'."}$self->diag_fail("$why See $self->{log} for details.",1);return}if ($installed && $self->{test_only}){$self->diag_ok;$self->diag("Successfully tested $distname\n",1)}elsif ($installed){my$local=$self->{local_versions}{$dist->{module}|| ''};my$version=$dist->{module_version}|| $dist->{meta}{version}|| $dist->{version};my$reinstall=$local && ($local eq $version);my$action=$local &&!$reinstall ? $self->is_downgrade($version,$local)? "downgraded" : "upgraded" : undef;my$how=$reinstall ? "reinstalled $distname" : $local ? "installed $distname ($action from $local)" : "installed $distname" ;my$msg="Successfully $how";$self->diag_ok;$self->diag("$msg\n",1);$self->{installed_dists}++;$self->save_meta($stuff,$dist,$module_name,\@config_deps,\@deps);return 1}else {my$what=$self->{test_only}? "Testing" : "Installing";$self->diag_fail("$what $stuff failed. See $self->{log} for details. Retry with --force to force install it.",1);return}}sub is_downgrade {my($self,$va,$vb)=@_;eval {version::->new($va)< $vb}}sub opts_in_static_install {my($self,$meta)=@_;return if!$self->{static_install};return if$self->{sudo}or $self->{uninstall_shadows};return$meta->{x_static_install}&& $meta->{x_static_install}==1}sub skip_configure {my($self,$dist,$depth)=@_;return 1 if$self->{skip_configure};return 1 if$dist->{static_install};return 1 if$self->no_dynamic_config($dist->{meta})&& $self->deps_only($depth);return}sub no_dynamic_config {my($self,$meta)=@_;exists$meta->{dynamic_config}&& $meta->{dynamic_config}==0}sub deps_only {my($self,$depth)=@_;($self->{installdeps}&& $depth==0)or $self->{showdeps}or $self->{scandeps}}sub perl_requirements {my($self,@requires)=@_;my@perl;for my$requires (grep defined,@requires){if (exists$requires->{perl}){push@perl,Menlo::Dependency->new(perl=>$requires->{perl})}}return@perl}sub configure_this {my($self,$dist,$depth)=@_;my$deps_only=$self->deps_only($depth);if (-e $self->{cpanfile_path}&& $deps_only){require Module::CPANfile;$dist->{cpanfile}=eval {Module::CPANfile->load($self->{cpanfile_path})};$self->diag_fail($@,1)if $@;$self->{cpanfile_global}||= $dist->{cpanfile};return {configured=>1,configured_ok=>!!$dist->{cpanfile},use_module_build=>0,}}if ($self->{skip_configure}){my$eumm=-e 'Makefile';my$mb=-e 'Build' && -f _;return {configured=>1,configured_ok=>$eumm || $mb,use_module_build=>$mb,}}if ($deps_only && $self->no_dynamic_config($dist->{meta})){return {configured=>1,configured_ok=>exists$dist->{meta}{prereqs},use_module_build=>0,}}my$state={};my$try_static=sub {if ($dist->{static_install}){$self->chat("Distribution opts in x_static_install: $dist->{meta}{x_static_install}\n");$self->static_install_configure($state,$dist,$depth)}};my$try_eumm=sub {if (-e 'Makefile.PL'){$self->chat("Running Makefile.PL\n");if ($self->configure([$self->{perl},"Makefile.PL" ],$dist,$depth)){$state->{configured_ok}=-e 'Makefile'}$state->{configured}++}};my$try_mb=sub {if (-e 'Build.PL'){$self->chat("Running Build.PL\n");if ($self->configure([$self->{perl},"Build.PL" ],$dist,$depth)){$state->{configured_ok}=-e 'Build' && -f _}$state->{use_module_build}++;$state->{configured}++}};for my$try ($try_static,$try_mb,$try_eumm){$try->();last if$state->{configured_ok}}unless ($state->{configured_ok}){while (1){my$ans=lc$self->prompt("Configuring $dist->{dist} failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");last if$ans eq 's';return$self->configure_this($dist,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}return$state}sub static_install_configure {my($self,$state,$dist,$depth)=@_;my$args=$depth==0 ? $self->{build_args}{configure}: [];require Menlo::Builder::Static;my$builder=Menlo::Builder::Static->new(meta=>$dist->{cpanmeta});$self->configure(sub {$builder->configure($args || [])},$dist,$depth);$state->{configured_ok}=1;$state->{static_install}=$builder;$state->{configured}++}sub find_module_name {my($self,$state)=@_;return unless$state->{configured_ok};if ($state->{use_module_build}&& -e "_build/build_params"){my$params=do {open my$in,"_build/build_params";eval(join "",<$in>)};return eval {$params->[2]{module_name}}|| undef}elsif (-e "Makefile"){open my$mf,"Makefile";while (<$mf>){if (/^\#\s+NAME\s+=>\s+(.*)/){return eval($1)}}}return}sub list_files {my$self=shift;if (-e 'MANIFEST'){require ExtUtils::Manifest;my$manifest=eval {ExtUtils::Manifest::manifind()}|| {};return sort {lc$a cmp lc$b}keys %$manifest}else {require File::Find;my@files;my$finder=sub {my$name=$File::Find::name;$name =~ s!\.[/\\]!!;push@files,$name};File::Find::find($finder,".");return sort {lc$a cmp lc$b}@files}}sub extract_packages {my($self,$meta,$dir)=@_;my$try=sub {my$file=shift;return 0 if$file =~ m!^(?:x?t|inc|local|perl5|fatlib|_build)/!;return 1 unless$meta->{no_index};return 0 if grep {$file =~ m!^$_/!}@{$meta->{no_index}{directory}|| []};return 0 if grep {$file eq $_}@{$meta->{no_index}{file}|| []};return 1};require Parse::PMFile;my@files=grep {/\.pm(?:\.PL)?$/ && $try->($_)}$self->list_files;my$provides={};for my$file (@files){my$parser=Parse::PMFile->new($meta,{UNSAFE=>1,ALLOW_DEV_VERSION=>1 });my$packages=$parser->parse($file);while (my($package,$meta)=each %$packages){$provides->{$package}||= {file=>$meta->{infile},($meta->{version}eq 'undef')? (): (version=>$meta->{version}),}}}return$provides}sub save_meta {my($self,$module,$dist,$module_name,$config_deps,$build_deps)=@_;return unless$dist->{distvname}&& $dist->{source}eq 'cpan';my$base=($ENV{PERL_MM_OPT}|| '')=~ /INSTALL_BASE=/ ? ($self->install_base($ENV{PERL_MM_OPT})."/lib/perl5"): $Config{sitelibexp};my$provides=$dist->{provides};File::Path::mkpath("blib/meta",0,0777);my$local={name=>$module_name,target=>$module,version=>exists$provides->{$module_name}? ($provides->{$module_name}{version}|| $dist->{version}): $dist->{version},dist=>$dist->{distvname},pathname=>$dist->{pathname},provides=>$provides,};require JSON::PP;open my$fh,">","blib/meta/install.json" or die $!;print$fh JSON::PP::encode_json($local);File::Copy::copy("MYMETA.json","blib/meta/MYMETA.json");my@cmd=(($self->{sudo}? 'sudo' : ()),$^X,'-MExtUtils::Install=install','-e',qq[install({ 'blib/meta' => '$base/$Config{archname}/.meta/$dist->{distvname}' })],);$self->run_command(\@cmd)}sub install_base {my($self,$mm_opt)=@_;$mm_opt =~ /INSTALL_BASE=(\S+)/ and return $1;die "Your PERL_MM_OPT doesn't contain INSTALL_BASE"}sub configure_features {my($self,$dist,@features)=@_;map $_->identifier,grep {$self->effective_feature($dist,$_)}@features}sub effective_feature {my($self,$dist,$feature)=@_;if ($dist->{depth}==0){my$value=$self->{features}{$feature->identifier};return$value if defined$value;return 1 if$self->{features}{__all}}if ($self->{interactive}){require CPAN::Meta::Requirements;$self->diag("[@{[ $feature->description ]}]\n",1);my$req=CPAN::Meta::Requirements->new;for my$phase (@{$dist->{want_phases}}){for my$type (@{$self->{install_types}}){$req->add_requirements($feature->prereqs->requirements_for($phase,$type))}}my$reqs=$req->as_string_hash;my@missing;for my$module (keys %$reqs){if ($self->should_install($module,$req->{$module})){push@missing,$module}}if (@missing){my$howmany=@missing;$self->diag("==> Found missing dependencies: " .join(", ",@missing)."\n",1);local$self->{prompt}=1;return$self->prompt_bool("Install the $howmany optional module(s)?","y")}}return}sub find_prereqs {my($self,$dist)=@_;my@deps=$self->extract_meta_prereqs($dist);if ($dist->{module}=~ /^Bundle::/i){push@deps,$self->bundle_deps($dist)}$self->merge_with_cpanfile($dist,\@deps);return@deps}sub merge_with_cpanfile {my($self,$dist,$deps)=@_;if ($self->{cpanfile_requirements}&&!$dist->{cpanfile}){for my$dep (@$deps){$dep->merge_with($self->{cpanfile_requirements})}}if ($self->{cpanfile_global}){for my$dep (@$deps){my$opts=$self->{cpanfile_global}->options_for_module($dep->module)or next;$dep->dist($opts->{dist})if$opts->{dist};$dep->mirror($opts->{mirror})if$opts->{mirror};$dep->url($opts->{url})if$opts->{url}}}}sub extract_meta_prereqs {my($self,$dist)=@_;if ($dist->{cpanfile}){my@features=$self->configure_features($dist,$dist->{cpanfile}->features);my$prereqs=$dist->{cpanfile}->prereqs_with(@features);$self->{cpanfile_requirements}=$prereqs->merged_requirements($dist->{want_phases},['requires']);return Menlo::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}require CPAN::Meta;my@meta=qw(MYMETA.json MYMETA.yml);if ($self->no_dynamic_config($dist->{meta})){push@meta,qw(META.json META.yml)}my@deps;my($meta_file)=grep -f,@meta;if ($meta_file){$self->chat("Checking dependencies from $meta_file ...\n");my$mymeta=eval {CPAN::Meta->load_file($meta_file,{lazy_validation=>1 })};if ($mymeta){$dist->{meta}{name}=$mymeta->name;$dist->{meta}{version}=$mymeta->version;return$self->extract_prereqs($mymeta,$dist)}}$self->diag_fail("No MYMETA file is found after configure. Your toolchain is too old?");return}sub bundle_deps {my($self,$dist)=@_;my$match;if ($dist->{module}){$match=sub {my$meta=Module::Metadata->new_from_file($_[0]);$meta && ($meta->name eq $dist->{module})}}else {$match=sub {1}}my@files;File::Find::find({wanted=>sub {push@files,File::Spec->rel2abs($_)if /\.pm$/i && $match->($_)},no_chdir=>1,},'.');my@deps;for my$file (@files){open my$pod,"<",$file or next;my$in_contents;while (<$pod>){if (/^=head\d\s+CONTENTS/){$in_contents=1}elsif (/^=/){$in_contents=0}elsif ($in_contents){/^(\S+)\s*(\S+)?/ and push@deps,Menlo::Dependency->new($1,$self->maybe_version($2))}}}return@deps}sub maybe_version {my($self,$string)=@_;return$string && $string =~ /^\.?\d/ ? $string : undef}sub extract_prereqs {my($self,$meta,$dist)=@_;my@features=$self->configure_features($dist,$meta->features);my$prereqs=$meta->effective_prereqs(\@features)->clone;$self->adjust_prereqs($dist,$prereqs);return Menlo::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}sub adjust_prereqs {my($self,$dist,$prereqs)=@_;if (-e "inc/Module/Install.pm"){for my$phase (qw(build test runtime)){my$reqs=$prereqs->requirements_for($phase,'requires');if ($reqs->requirements_for_module('ExtUtils::MakeMaker')){$reqs->clear_requirement('ExtUtils::MakeMaker');$reqs->add_minimum('ExtUtils::MakeMaker'=>0)}}}if ($dist->{static_install}){my$reqs=$prereqs->requirements_for('test'=>'requires');$reqs->add_minimum('TAP::Harness::Env'=>0)}}sub cleanup_workdirs {my$self=shift;my$expire=time - 24 * 60 * 60 * $self->{auto_cleanup};my@targets;opendir my$dh,"$self->{home}/work";while (my$e=readdir$dh){next if$e !~ /^(\d+)\.\d+$/;my$time=$1;if ($time < $expire){push@targets,"$self->{home}/work/$e"}}if (@targets){if (@targets >= 64){$self->diag("Expiring " .scalar(@targets)." work directories. This might take a while...\n")}else {$self->chat("Expiring " .scalar(@targets)." work directories.\n")}File::Path::rmtree(\@targets,0,0)}}sub scandeps_append_child {my($self,$dist)=@_;my$new_node=[$dist,[]];my$curr_node=$self->{scandeps_current}|| [undef,$self->{scandeps_tree}];push @{$curr_node->[1]},$new_node;$self->{scandeps_current}=$new_node;return sub {$self->{scandeps_current}=$curr_node}}sub dump_scandeps {my$self=shift;if ($self->{format}eq 'tree'){$self->walk_down(sub {my($dist,$depth)=@_;if ($depth==0){print "$dist->{distvname}\n"}else {print " " x ($depth - 1);print "\\_ $dist->{distvname}\n"}},1)}elsif ($self->{format}=~ /^dists?$/){$self->walk_down(sub {my($dist,$depth)=@_;print$self->format_dist($dist),"\n"},0)}elsif ($self->{format}eq 'json'){require JSON::PP;print JSON::PP::encode_json($self->{scandeps_tree})}elsif ($self->{format}eq 'yaml'){require CPAN::Meta::YAML;print CPAN::Meta::YAML::Dump($self->{scandeps_tree})}else {$self->diag("Unknown format: $self->{format}\n")}}sub walk_down {my($self,$cb,$pre)=@_;$self->_do_walk_down($self->{scandeps_tree},$cb,0,$pre)}sub _do_walk_down {my($self,$children,$cb,$depth,$pre)=@_;for my$node (@$children){$cb->($node->[0],$depth)if$pre;$self->_do_walk_down($node->[1],$cb,$depth + 1,$pre);$cb->($node->[0],$depth)unless$pre}}sub DESTROY {my$self=shift;$self->{at_exit}->($self)if$self->{at_exit}}sub mirror {my($self,$uri,$local)=@_;if ($uri =~ /^file:/){$self->file_mirror($uri,$local)}else {$self->{http}->mirror($uri,$local)}}sub untar {$_[0]->{_backends}{untar}->(@_)};sub unzip {$_[0]->{_backends}{unzip}->(@_)};sub uri_to_file {my($self,$uri)=@_;if ($uri =~ s!file:/+!!){$uri="/$uri" unless$uri =~ m![a-zA-Z]:!}return$uri}sub file_get {my($self,$uri)=@_;my$file=$self->uri_to_file($uri);open my$fh,"<$file" or return;join '',<$fh>}sub file_mirror {my($self,$uri,$path)=@_;my$file=$self->uri_to_file($uri);my$source_mtime=(stat$file)[9];return 1 if -e $path && (stat$path)[9]>= $source_mtime;File::Copy::copy($file,$path);utime$source_mtime,$source_mtime,$path}sub configure_http {my$self=shift;require HTTP::Tinyish;my@try=qw(HTTPTiny);unshift@try,'Wget' if$self->{try_wget};unshift@try,'Curl' if$self->{try_curl};unshift@try,'LWP' if$self->{try_lwp};my@protocol=('http');push@protocol,'https' if grep /^https:/,@{$self->{mirrors}};my$backend;for my$try (map "HTTP::Tinyish::$_",@try){if (my$meta=HTTP::Tinyish->configure_backend($try)){if ((grep$try->supports($_),@protocol)==@protocol){for my$tool (sort keys %$meta){(my$desc=$meta->{$tool})=~ s/^(.*?)\n.*/$1/s;$self->chat("You have $tool: $desc\n")}$backend=$try;last}}}$backend->new(agent=>"Menlo/$Menlo::VERSION",verify_SSL=>1)}sub init_tools {my$self=shift;return if$self->{initialized}++;if ($self->{make}=which($Config{make})){$self->chat("You have make $self->{make}\n")}$self->{http}=$self->configure_http;my$tar=which('tar');my$tar_ver;my$maybe_bad_tar=sub {WIN32 || BAD_TAR || (($tar_ver=`@{[ qs $tar ]} --version 2>/dev/null`)=~ /GNU.*1\.13/i)};if ($tar &&!$maybe_bad_tar->()){chomp$tar_ver;$self->chat("You have $tar: $tar_ver\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$xf=($self->{verbose}? 'v' : '')."xf";my$ar=$tarfile =~ /bz2$/ ? 'j' : 'z';my($root,@others)=`@{[ qs $tar ]} ${ar}tf @{[ qs $tarfile ]}` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$self->run_command([$tar,$ar.$xf,$tarfile ]);return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif ($tar and my$gzip=which('gzip')and my$bzip2=which('bzip2')){$self->chat("You have $tar, $gzip and $bzip2\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$x="x" .($self->{verbose}? 'v' : '')."f -";my$ar=$tarfile =~ /bz2$/ ? $bzip2 : $gzip;my($root,@others)=`@{[ qs $ar ]} -dc @{[ qs $tarfile ]} | @{[ qs $tar ]} tf -` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}system "@{[ qs $ar ]} -dc @{[ qs $tarfile ]} | @{[ qs $tar ]} $x";return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif (eval {require Archive::Tar}){$self->chat("Falling back to Archive::Tar $Archive::Tar::VERSION\n");$self->{_backends}{untar}=sub {my$self=shift;my$t=Archive::Tar->new($_[0]);my($root,@others)=$t->list_files;FILE: {$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$t->extract;return -d $root ? $root : undef}}else {$self->{_backends}{untar}=sub {die "Failed to extract $_[1] - You need to have tar or Archive::Tar installed.\n"}}if (my$unzip=which('unzip')){$self->chat("You have $unzip\n");$self->{_backends}{unzip}=sub {my($self,$zipfile)=@_;my@opt=$self->{verbose}? (): ('-q');my(undef,$root,@others)=`@{[ qs $unzip ]} -t @{[ qs $zipfile ]}` or return undef;FILE: {chomp$root;if ($root !~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1}){$root=shift(@others);redo FILE if$root}}$self->run_command([$unzip,@opt,$zipfile ]);return$root if -d $root;$self->diag_fail("Bad archive: '$root' $zipfile");return undef}}else {$self->{_backends}{unzip}=sub {eval {require Archive::Zip}or die "Failed to extract $_[1] - You need to have unzip or Archive::Zip installed.\n";my($self,$file)=@_;my$zip=Archive::Zip->new();my$status;$status=$zip->read($file);$self->diag_fail("Read of file '$file' failed")if$status!=Archive::Zip::AZ_OK();my@members=$zip->members();for my$member (@members){my$af=$member->fileName();next if ($af =~ m!^(/|\.\./)!);$status=$member->extractToFileNamed($af);$self->diag_fail("Extracting of file 'af' from zipfile '$file' failed")if$status!=Archive::Zip::AZ_OK()}my ($root)=$zip->membersMatching(qr<^[^/]+/$>);$root &&= $root->fileName;return -d $root ? $root : undef}}}sub mask_uri_passwords {my($self,@strings)=@_;s{ (https?://) ([^:/]+) : [^@/]+ @ }{$1$2:********@}gx for@strings;return@strings}1;
  It appears your cpanm executable was installed via `perlbrew install-cpanm`.
  cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
  Run the following command to get it upgraded.
  
    perlbrew install-cpanm
  
  DIE
  You are running cpanm from the path where your current perl won't install executables to.
  Because of that, cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
    cpanm path   : $0
    Install path : $Config{installsitebin}
  
  It means you either installed cpanm globally with system perl, or use distro packages such
  as rpm or apt-get, and you have to use them again to upgrade cpanm.
  DIE
  Usage: cpanm [options] Module [...]
  
  Try `cpanm --help` or `man cpanm` for more options.
  USAGE
  Usage: cpanm [options] Module [...]
  
  Options:
    -v,--verbose              Turns on chatty output
    -q,--quiet                Turns off the most output
    --interactive             Turns on interactive configure (required for Task:: modules)
    -f,--force                force install
    -n,--notest               Do not run unit tests
    --test-only               Run tests only, do not install
    -S,--sudo                 sudo to run install commands
    --installdeps             Only install dependencies
    --showdeps                Only display direct dependencies
    --reinstall               Reinstall the distribution even if you already have the latest version installed
    --mirror                  Specify the base URL for the mirror (e.g. http://cpan.cpantesters.org/)
    --mirror-only             Use the mirror's index file instead of the CPAN Meta DB
    -M,--from                 Use only this mirror base URL and its index file
    --prompt                  Prompt when configure/build/test fails
    -l,--local-lib            Specify the install base to install modules
    -L,--local-lib-contained  Specify the install base to install all non-core modules
    --self-contained          Install all non-core modules, even if they're already installed.
    --auto-cleanup            Number of days that cpanm's work directories expire in. Defaults to 7
  
  Commands:
    --self-upgrade            upgrades itself
    --info                    Displays distribution info on CPAN
    --look                    Opens the distribution with your SHELL
    -U,--uninstall            Uninstalls the modules (EXPERIMENTAL)
    -V,--version              Displays software version
  
  Examples:
  
    cpanm Test::More                                          # install Test::More
    cpanm MIYAGAWA/Plack-0.99_05.tar.gz                       # full distribution path
    cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz           # install from URL
    cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz            # install from a local file
    cpanm --interactive Task::Kensho                          # Configure interactively
    cpanm .                                                   # install from local directory
    cpanm --installdeps .                                     # install all the deps for the current directory
    cpanm -L extlib Plack                                     # install Plack and all non-core deps into extlib
    cpanm --mirror http://cpan.cpantesters.org/ DBI           # use the fast-syncing mirror
    cpanm -M https://cpan.metacpan.org App::perlbrew          # use only this secure mirror and its index
  
  You can also specify the default options in PERL_CPANM_OPT environment variable in the shell rc:
  
    export PERL_CPANM_OPT="--prompt --reinstall -l ~/perl --mirror http://cpan.cpantesters.org"
  
  Type `man cpanm` or `perldoc cpanm` for the more detailed explanation of the options.
  
  HELP
  !
  ! Can't write to $Config{installsitelib} and $Config{installsitebin}: Installing modules to $ENV{HOME}/perl5
  ! To turn off this warning, you have to do one of the following:
  !   - run me as a root or with --sudo option (to install to $Config{installsitelib} and $Config{installsitebin})
  !   - Configure local::lib in your existing shell to set PERL_MM_OPT etc.
  !   - Install local::lib by running the following commands
  !
  !         cpanm --local-lib=~/perl5 local::lib && eval \$(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
  !
  DIAG
  WARNING: Your lib directory name ($base) contains a space in it. It's known to cause issues with perl builder tools such as local::lib and MakeMaker. You're recommended to rename your directory.
  WARN
  $module is not found in the following directories and can't be uninstalled.
  
  @{[ join("  \n", map "  $_", @inc) ]}
  
  DIAG
  ! Configuring $distname failed. See $self->{log} for details.
  ! You might have to install the following modules first to get --scandeps working correctly.
  DIAG
MENLO_CLI_COMPAT

$fatpacked{"Menlo/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_DEPENDENCY';
  package Menlo::Dependency;use strict;use CPAN::Meta::Requirements;use Class::Tiny qw(module version type original_version dist mirror url);sub BUILDARGS {my($class,$module,$version,$type)=@_;return {module=>$module,version=>$version,type=>$type || 'requires',}}sub from_prereqs {my($class,$prereqs,$phases,$types)=@_;my@deps;for my$type (@$types){push@deps,$class->from_versions($prereqs->merged_requirements($phases,[$type])->as_string_hash,$type,)}return@deps}sub from_versions {my($class,$versions,$type)=@_;my@deps;while (my($module,$version)=each %$versions){push@deps,$class->new($module,$version,$type)}@deps}sub merge_with {my($self,$requirements)=@_;$self->original_version($self->version);eval {$requirements->add_string_requirement($self->module,$self->version)};if ($@ =~ /illegal requirements/){warn sprintf("Can't merge requirements for %s: '%s' and '%s'",$self->module,$self->version,$requirements->requirements_for_module($self->module))}$self->version($requirements->requirements_for_module($self->module))}sub requires_version {my$self=shift;if (defined$self->original_version){return$self->original_version}$self->version}sub is_requirement {$_[0]->type eq 'requires'}1;
MENLO_DEPENDENCY

$fatpacked{"Menlo/Index/MetaCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_METACPAN';
  use 5.008001;use strict;use warnings;package Menlo::Index::MetaCPAN;use parent 'CPAN::Common::Index';use Class::Tiny qw/uri include_dev/;use Carp;use HTTP::Tinyish;use JSON::PP ();use Time::Local ();sub BUILD {my$self=shift;my$uri=$self->uri;$uri="https://fastapi.metacpan.org/v1/download_url/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my$range;if ($args->{version}){$range="== $args->{version}"}elsif ($args->{version_range}){$range=$args->{version_range}}my%query=(($self->include_dev ? (dev=>1): ()),($range ? (version=>$range): ()),);my$query=join "&",map {"$_=" .$self->_uri_escape($query{$_})}sort keys%query;my$uri=$self->uri .$args->{package}.($query ? "?$query" : "");my$res=HTTP::Tinyish->new->get($uri);return unless$res->{success};my$dist_meta=eval {JSON::PP::decode_json($res->{content})};if ($dist_meta && $dist_meta->{download_url}){(my$distfile=$dist_meta->{download_url})=~ s!.+/authors/id/\w/\w\w/!!;return {package=>$args->{package},version=>$dist_meta->{version},uri=>"cpan:///distfile/$distfile",download_uri=>$self->_download_uri("http://cpan.metacpan.org",$distfile),}}return}sub _parse_date {my($self,$date)=@_;my@date=$date =~ /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)$/;Time::Local::timegm($date[5],$date[4],$date[3],$date[2],$date[1]- 1,$date[0]- 1900)}sub _uri_escape {my($self,$string)=@_;$string =~ s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;$string}sub _download_uri {my($self,$base,$distfile)=@_;join "/",$base,"authors/id",substr($distfile,0,1),substr($distfile,0,2),$distfile}sub index_age {return time}sub search_authors {return}1;
MENLO_INDEX_METACPAN

$fatpacked{"Menlo/Index/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_METADB';
  use 5.008001;use strict;use warnings;package Menlo::Index::MetaDB;our$VERSION="1.9019";use parent 'CPAN::Common::Index';use Class::Tiny qw/uri/;use Carp;use CPAN::Meta::YAML;use CPAN::Meta::Requirements;use HTTP::Tiny;sub BUILD {my$self=shift;my$uri=$self->uri;$uri="http://cpanmetadb.plackperl.org/v1.0/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';return unless exists$args->{package}&& ref$args->{package}eq '';my$mod=$args->{package};if ($args->{version}|| $args->{version_range}){my$res=HTTP::Tiny->new->get($self->uri ."history/$mod");return unless$res->{success};my$range=defined$args->{version}? "== $args->{version}" : $args->{version_range};my$reqs=CPAN::Meta::Requirements->from_string_hash({$mod=>$range });my@found;for my$line (split /\r?\n/,$res->{content}){if ($line =~ /^$mod\s+(\S+)\s+(\S+)$/){push@found,{version=>$1,version_o=>version::->parse($1),distfile=>$2,}}}return unless@found;$found[-1]->{latest}=1;my$match;for my$try (sort {$b->{version_o}<=> $a->{version_o}}@found){if ($reqs->accepts_module($mod=>$try->{version_o})){$match=$try,last}}if ($match){my$file=$match->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$match->{version},uri=>"cpan:///distfile/$file",($match->{latest}? (): (download_uri=>"http://backpan.perl.org/authors/id/$match->{distfile}")),}}}else {my$res=HTTP::Tiny->new->get($self->uri ."package/$mod");return unless$res->{success};if (my$yaml=CPAN::Meta::YAML->read_string($res->{content})){my$meta=$yaml->[0];if ($meta && $meta->{distfile}){my$file=$meta->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$meta->{version},uri=>"cpan:///distfile/$file",}}}}return}sub index_age {return time};sub search_authors {return};1;
MENLO_INDEX_METADB

$fatpacked{"Menlo/Index/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_MIRROR';
  package Menlo::Index::Mirror;use strict;use parent qw(CPAN::Common::Index::Mirror);use Class::Tiny qw(fetcher);use File::Basename ();use File::Spec ();use URI ();our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};my%INDICES=(packages=>'modules/02packages.details.txt.gz',);sub refresh_index {my$self=shift;for my$file (values%INDICES){my$remote=URI->new_abs($file,$self->mirror);$remote =~ s/\.gz$// unless$HAS_IO_UNCOMPRESS_GUNZIP;my$local=File::Spec->catfile($self->cache,File::Basename::basename($file));$self->fetcher->($remote,$local)or Carp::croak("Cannot fetch $remote to $local");if ($HAS_IO_UNCOMPRESS_GUNZIP){(my$uncompressed=$local)=~ s/\.gz$//;IO::Uncompress::Gunzip::gunzip($local,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}}1;
MENLO_INDEX_MIRROR

$fatpacked{"Menlo/Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_LEGACY';
  package Menlo::Legacy;use strict;our$VERSION='1.9022';1;
MENLO_LEGACY

$fatpacked{"Menlo/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_UTIL';
  package Menlo::Util;use strict;use Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(WIN32);use constant WIN32=>$^O eq 'MSWin32';if (WIN32){require Win32::ShellQuote;*shell_quote=\&Win32::ShellQuote::quote_native}else {require String::ShellQuote;*shell_quote=\&String::ShellQuote::shell_quote_best_effort}1;
MENLO_UTIL

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;use strict;use warnings;use Cwd;use Carp ();use Module::CPANfile::Environment;use Module::CPANfile::Requirement;our$VERSION='1.1004';BEGIN {if (${^TAINT}){*untaint=sub {my$str=shift;($str)=$str =~ /^(.+)$/s;$str}}else {*untaint=sub {$_[0]}}}sub new {my($class,$file)=@_;bless {},$class}sub load {my($proto,$file)=@_;my$self=ref$proto ? $proto : $proto->new;$self->parse($file || _default_cpanfile());$self}sub save {my($self,$path)=@_;open my$out,">",$path or die "$path: $!";print {$out}$self->to_string}sub parse {my($self,$file)=@_;my$code=do {open my$fh,"<",$file or die "$file: $!";join '',<$fh>};$code=untaint$code;my$env=Module::CPANfile::Environment->new($file);$env->parse($code)or die $@;$self->{_mirrors}=$env->mirrors;$self->{_prereqs}=$env->prereqs}sub from_prereqs {my($proto,$prereqs)=@_;my$self=$proto->new;$self->{_prereqs}=Module::CPANfile::Prereqs->from_cpan_meta($prereqs);$self}sub mirrors {my$self=shift;$self->{_mirrors}|| []}sub features {my$self=shift;map$self->feature($_),$self->{_prereqs}->identifiers}sub feature {my($self,$identifier)=@_;$self->{_prereqs}->feature($identifier)}sub prereq {shift->prereqs}sub prereqs {my$self=shift;$self->{_prereqs}->as_cpan_meta}sub merged_requirements {my$self=shift;$self->{_prereqs}->merged_requirements}sub effective_prereqs {my($self,$features)=@_;$self->prereqs_with(@{$features || []})}sub prereqs_with {my($self,@feature_identifiers)=@_;my@others=map {$self->feature($_)->prereqs}@feature_identifiers;$self->prereqs->with_merged_prereqs(\@others)}sub prereq_specs {my$self=shift;$self->prereqs->as_string_hash}sub prereq_for_module {my($self,$module)=@_;$self->{_prereqs}->find($module)}sub options_for_module {my($self,$module)=@_;my$prereq=$self->prereq_for_module($module)or return;$prereq->requirement->options}sub merge_meta {my($self,$file,$version)=@_;require CPAN::Meta;$version ||= $file =~ /\.yml$/ ? '1.4' : '2';my$prereq=$self->prereqs;my$meta=CPAN::Meta->load_file($file);my$prereqs_hash=$prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;my$struct={%{$meta->as_struct},prereqs=>$prereqs_hash };CPAN::Meta->new($struct)->save($file,{version=>$version })}sub _d($) {require Data::Dumper;chomp(my$value=Data::Dumper->new([$_[0]])->Terse(1)->Dump);$value}sub _default_cpanfile {my$file=Cwd::abs_path('cpanfile');untaint$file}sub to_string {my($self,$include_empty)=@_;my$mirrors=$self->mirrors;my$prereqs=$self->prereq_specs;my$code='';$code .= $self->_dump_mirrors($mirrors);$code .= $self->_dump_prereqs($prereqs,$include_empty);for my$feature ($self->features){$code .= "feature @{[ _d $feature->{identifier} ]}, @{[ _d $feature->{description} ]} => sub {\n";$code .= $self->_dump_prereqs($feature->{prereqs}->as_string_hash,$include_empty,4);$code .= "};\n\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_mirrors {my($self,$mirrors)=@_;my$code="";for my$url (@$mirrors){$code .= "mirror @{[ _d $url ]};\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_prereqs {my($self,$prereqs,$include_empty,$base_indent)=@_;my$code='';for my$phase (qw(runtime configure build test develop)){my$indent=$phase eq 'runtime' ? '' : '    ';$indent .= (' ' x ($base_indent || 0));my($phase_code,$requirements);$phase_code .= "on $phase => sub {\n" unless$phase eq 'runtime';for my$type (qw(requires recommends suggests conflicts)){for my$mod (sort keys %{$prereqs->{$phase}{$type}}){my$ver=$prereqs->{$phase}{$type}{$mod};$phase_code .= $ver eq '0' ? "${indent}$type @{[ _d $mod ]}" : "${indent}$type @{[ _d $mod ]}, @{[ _d $ver ]}";my$options=$self->options_for_module($mod)|| {};if (%$options){my@opts;for my$key (keys %$options){my$k=$key =~ /^[a-zA-Z0-9_]+$/ ? $key : _d$key;push@opts,"$k => @{[ _d $options->{$k} ]}"}$phase_code .= ",\n" .join(",\n",map "  $indent$_",@opts)}$phase_code .= ";\n";$requirements++}}$phase_code .= "\n" unless$requirements;$phase_code .= "};\n" unless$phase eq 'runtime';$code .= $phase_code ."\n" if$requirements or $include_empty}$code =~ s/\n+$/\n/s;$code}1;
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;use strict;use warnings;use Module::CPANfile::Prereqs;use Carp ();my@bindings=qw(on requires recommends suggests conflicts feature osname mirror configure_requires build_requires test_requires author_requires);my$file_id=1;sub new {my($class,$file)=@_;bless {file=>$file,phase=>'runtime',feature=>undef,features=>{},prereqs=>Module::CPANfile::Prereqs->new,mirrors=>[],},$class}sub bind {my$self=shift;my$pkg=caller;for my$binding (@bindings){no strict 'refs';*{"$pkg\::$binding"}=sub {$self->$binding(@_)}}}sub parse {my($self,$code)=@_;my$err;{local $@;$file_id++;$self->_evaluate(<<EVAL);$err=$@}if ($err){die "Parsing $self->{file} failed: $err"};return 1}sub _evaluate {my$_environment=$_[0];eval $_[1]}sub prereqs {$_[0]->{prereqs}}sub mirrors {$_[0]->{mirrors}}sub on {my($self,$phase,$code)=@_;local$self->{phase}=$phase;$code->()}sub feature {my($self,$identifier,$description,$code)=@_;if (@_==3 && ref($description)eq 'CODE'){$code=$description;$description=$identifier}unless (ref$description eq '' && ref$code eq 'CODE'){Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }")}local$self->{feature}=$identifier;$self->prereqs->add_feature($identifier,$description);$code->()}sub osname {die "TODO"}sub mirror {my($self,$url)=@_;push @{$self->{mirrors}},$url}sub requirement_for {my($self,$module,@args)=@_;my$requirement=0;$requirement=shift@args if@args % 2;return Module::CPANfile::Requirement->new(name=>$module,version=>$requirement,@args,)}sub requires {my$self=shift;$self->add_prereq(requires=>@_)}sub recommends {my$self=shift;$self->add_prereq(recommends=>@_)}sub suggests {my$self=shift;$self->add_prereq(suggests=>@_)}sub conflicts {my$self=shift;$self->add_prereq(conflicts=>@_)}sub add_prereq {my($self,$type,$module,@args)=@_;$self->prereqs->add(feature=>$self->{feature},phase=>$self->{phase},type=>$type,module=>$module,requirement=>$self->requirement_for($module,@args),)}sub configure_requires {my($self,@args)=@_;$self->on(configure=>sub {$self->requires(@args)})}sub build_requires {my($self,@args)=@_;$self->on(build=>sub {$self->requires(@args)})}sub test_requires {my($self,@args)=@_;$self->on(test=>sub {$self->requires(@args)})}sub author_requires {my($self,@args)=@_;$self->on(develop=>sub {$self->requires(@args)})}1;
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  BEGIN { \$_environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  EVAL
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
  package Module::CPANfile::Prereq;use strict;sub new {my($class,%options)=@_;bless \%options,$class}sub feature {$_[0]->{feature}}sub phase {$_[0]->{phase}}sub type {$_[0]->{type}}sub module {$_[0]->{module}}sub requirement {$_[0]->{requirement}}1;
MODULE_CPANFILE_PREREQ

$fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
  package Module::CPANfile::Prereqs;use strict;use Carp ();use CPAN::Meta::Feature;use Module::CPANfile::Prereq;sub from_cpan_meta {my($class,$prereqs)=@_;my$self=$class->new;for my$phase (keys %$prereqs){for my$type (keys %{$prereqs->{$phase}}){while (my($module,$requirement)=each %{$prereqs->{$phase}{$type}}){$self->add(phase=>$phase,type=>$type,module=>$module,requirement=>Module::CPANfile::Requirement->new(name=>$module,version=>$requirement),)}}}$self}sub new {my$class=shift;bless {prereqs=>{},features=>{},},$class}sub add_feature {my($self,$identifier,$description)=@_;$self->{features}{$identifier}={description=>$description }}sub add {my($self,%args)=@_;my$feature=$args{feature}|| '';push @{$self->{prereqs}{$feature}},Module::CPANfile::Prereq->new(%args)}sub as_cpan_meta {my$self=shift;$self->{cpanmeta}||= $self->build_cpan_meta}sub build_cpan_meta {my($self,$feature)=@_;CPAN::Meta::Prereqs->new($self->specs($feature))}sub specs {my($self,$feature)=@_;$feature='' unless defined$feature;my$prereqs=$self->{prereqs}{$feature}|| [];my$specs={};for my$prereq (@$prereqs){$specs->{$prereq->phase}{$prereq->type}{$prereq->module}=$prereq->requirement->version}return$specs}sub merged_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;for my$prereq (@{$self->{prereqs}}){$reqs->add_string_requirement($prereq->module,$prereq->requirement->version)}$reqs}sub find {my($self,$module)=@_;for my$feature ('',keys %{$self->{features}}){for my$prereq (@{$self->{prereqs}{$feature}}){return$prereq if$prereq->module eq $module}}return}sub identifiers {my$self=shift;keys %{$self->{features}}}sub feature {my($self,$identifier)=@_;my$data=$self->{features}{$identifier}or Carp::croak("Unknown feature '$identifier'");my$prereqs=$self->build_cpan_meta($identifier);CPAN::Meta::Feature->new($identifier,{description=>$data->{description},prereqs=>$prereqs->as_string_hash,})}1;
MODULE_CPANFILE_PREREQS

$fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
  package Module::CPANfile::Requirement;use strict;sub new {my ($class,%args)=@_;$args{version}||= 0;bless +{name=>delete$args{name},version=>delete$args{version},options=>\%args,},$class}sub name {$_[0]->{name}}sub version {$_[0]->{version}}sub options {$_[0]->{options}}sub has_options {keys %{$_[0]->{options}}> 0}1;
MODULE_CPANFILE_REQUIREMENT

$fatpacked{"PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI';
  package PPI;use 5.006;use strict;our$VERSION='1.269';our ($XS_COMPATIBLE,@XS_EXCLUDE)=('0.845');use PPI::Util ();use PPI::Exception ();use PPI::Element ();use PPI::Token ();use PPI::Statement ();use PPI::Structure ();use PPI::Document ();use PPI::Document::File ();use PPI::Document::Fragment ();use PPI::Document::Normalized ();use PPI::Normal ();use PPI::Tokenizer ();use PPI::Lexer ();die if!$PPI::XS_DISABLE and!eval {require PPI::XS;1}and $@ !~ /^Can't locate .*? at /;1;
PPI

$fatpacked{"PPI/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_CACHE';
  package PPI::Cache;use strict;use Carp ();use File::Spec ();use File::Path ();use Storable 2.17 ();use Digest::MD5 2.35 ();use Params::Util qw{_INSTANCE _SCALAR};use PPI::Document ();our$VERSION='1.269';use constant VMS=>!!($^O eq 'VMS');sub import {my$class=ref $_[0]? ref shift : shift;return 1 unless @_;my$cache=$class->new(@_);unless (PPI::Document->set_cache($cache)){Carp::croak("Failed to set cache in PPI::Document")}1}sub new {my$class=shift;my%params=@_;my$path=$params{path}or Carp::croak("Cannot create PPI::Cache, no path provided");unless (-d $path){Carp::croak("Cannot create PPI::Cache, path does not exist")}unless (-r $path and -x $path){Carp::croak("Cannot create PPI::Cache, no read permissions for path")}if (!$params{readonly}and!-w $path){Carp::croak("Cannot create PPI::Cache, no write permissions for path")}my$self=bless {path=>$path,readonly=>!!$params{readonly},},$class;$self}sub path {$_[0]->{path}}sub readonly {$_[0]->{readonly}}sub get_document {my$self=ref $_[0]? shift : Carp::croak('PPI::Cache::get_document called as static method');my$md5hex=$self->_md5hex(shift)or return undef;$self->_load($md5hex)}sub store_document {my$self=shift;my$Document=_INSTANCE(shift,'PPI::Document')or return undef;return 1 if$self->readonly;my$md5hex=$Document->hex_id or return undef;$self->_store($md5hex,$Document)}sub _store {my ($self,$md5hex,$object)=@_;my ($dir,$file)=$self->_paths($md5hex);File::Path::mkpath($dir,0,0755)unless -d $dir;if (VMS){Storable::lock_nstore($object,$file)}else {Storable::nstore($object,$file)}}sub _load {my ($self,$md5hex)=@_;my (undef,$file)=$self->_paths($md5hex);return '' unless -f $file;my$object=VMS ? Storable::retrieve($file): Storable::lock_retrieve($file);unless (_INSTANCE($object,'PPI::Document')){Carp::croak("Security Violation: Object in '$file' is not a PPI::Document")}$object}sub _paths {my$self=shift;my$md5hex=lc shift;my$dir=File::Spec->catdir($self->path,substr($md5hex,0,1),substr($md5hex,0,2));my$file=File::Spec->catfile($dir,$md5hex .'.ppi');return ($dir,$file)}sub _md5hex {my$either=shift;my$it=_SCALAR($_[0])? PPI::Util::md5hex(${$_[0]}): $_[0];return (defined$it and!ref$it and $it =~ /^[[:xdigit:]]{32}\z/s)? lc$it : undef}1;
PPI_CACHE

$fatpacked{"PPI/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT';
  package PPI::Document;use strict;use Carp ();use List::Util 1.33 ();use Params::Util 1.00 qw{_SCALAR0 _ARRAY0 _INSTANCE};use Digest::MD5 ();use PPI::Util ();use PPI ();use PPI::Node ();use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';our$VERSION='1.269';our ($errstr,@ISA)=("","PPI::Node");use PPI::Document::Fragment ();my$CACHE;use constant LOCATION_LINE=>0;use constant LOCATION_CHARACTER=>1;use constant LOCATION_COLUMN=>2;use constant LOCATION_LOGICAL_LINE=>3;use constant LOCATION_LOGICAL_FILE=>4;sub new {local $_;my$class=ref $_[0]? ref shift : shift;unless (@_){my$self=$class->SUPER::new;$self->{readonly}=!1;$self->{tab_width}=1;return$self}my$source=shift;my%attr=@_;if (!defined$source){$class->_error("An undefined value was passed to PPI::Document::new")}elsif (!ref$source){if ($source =~ /(?:\012|\015)/){Carp::croak("API CHANGE: Source code should only be passed to PPI::Document->new as a SCALAR reference")}$attr{filename}||= $source;if ($CACHE){my$file_contents=PPI::Util::_slurp($source);return$class->_error($file_contents)if!ref$file_contents;my$document=$CACHE->get_document($file_contents);return$class->_setattr($document,%attr)if$document;$document=PPI::Lexer->lex_source($$file_contents);if ($document){$CACHE->store_document($document);return$class->_setattr($document,%attr)}}else {my$document=PPI::Lexer->lex_file($source);return$class->_setattr($document,%attr)if$document}}elsif (_SCALAR0($source)){my$document=PPI::Lexer->lex_source($$source);return$class->_setattr($document,%attr)if$document}elsif (_ARRAY0($source)){$source=join '',map {"$_\n"}@$source;my$document=PPI::Lexer->lex_source($source);return$class->_setattr($document,%attr)if$document}else {$class->_error("Unknown object or reference was passed to PPI::Document::new")}my$errstr;if (_INSTANCE($@,'PPI::Exception')){$errstr=$@->message}elsif ($@){$errstr=$@;$errstr =~ s/\sat line\s.+$//}elsif (PPI::Lexer->errstr){$errstr=PPI::Lexer->errstr}else {$errstr="Unknown error parsing Perl document"}PPI::Lexer->_clear;$class->_error($errstr)}sub load {Carp::croak("API CHANGE: File names should now be passed to PPI::Document->new to load a file")}sub _setattr {my ($class,$document,%attr)=@_;$document->{readonly}=!!$attr{readonly};$document->{filename}=$attr{filename};return$document}sub set_cache {my$class=ref $_[0]? ref shift : shift;if (defined $_[0]){my$object=_INSTANCE(shift,'PPI::Cache')or return undef;$CACHE=$object}else {$CACHE=undef}1}sub get_cache {$CACHE}sub filename {$_[0]->{filename}}sub readonly {$_[0]->{readonly}}sub tab_width {my$self=shift;return$self->{tab_width}unless @_;$self->{tab_width}=shift}sub save {my$self=shift;local*FILE;open(FILE,'>',$_[0])or return undef;binmode FILE;print FILE$self->serialize or return undef;close FILE or return undef;return 1}sub serialize {my$self=shift;my@tokens=$self->tokens;my$heredoc='';my$output='';for my$i (0 .. $#tokens){my$Token=$tokens[$i];unless ($Token->isa('PPI::Token::HereDoc')){my$content=$Token->content;unless ($heredoc ne '' and $content =~ /\n/){$output .= $content;next}if ($content eq "\n"){$output .= $content .$heredoc}else {$content =~ s/\n/\n$heredoc/;$output .= $content}$heredoc='';next}$output .= $Token->content;for my$line ($Token->heredoc){$heredoc .= $line}if ($Token->{_damaged}){my$last_index=$#tokens;if ($tokens[$last_index]->{content}=~ /^[^\n]*\n$/){$last_index--}my$last_line=List::Util::none {$tokens[$_]and $tokens[$_]->{content}=~ /\n/}(($i + 1).. $last_index);if (!defined$last_line){$last_line=1}my$any_after=List::Util::any {$tokens[$_]->isa('PPI::Token::HereDoc')and (scalar(@{$tokens[$_]->{_heredoc}})or defined$tokens[$_]->{_terminator_line})}(($i + 1).. $#tokens);if (!defined$any_after){$any_after=''}unless ($last_line and!$any_after){unless (defined$Token->{_terminator_line}){$Token->{_terminator_line}=$Token->{_terminator}}unless ($Token->{_terminator_line}=~ /\n$/){$Token->{_terminator_line}.= "\n"}}}if (defined$Token->{_terminator_line}){$heredoc .= $Token->{_terminator_line}}}if ($heredoc ne ''){unless ($output =~ /\n$/){$output .= "\n"}$output .= $heredoc}$output}sub hex_id {PPI::Util::md5hex($_[0]->serialize)}sub index_locations {my$self=shift;my@tokens=$self->tokens;my$heredoc=0;my ($first,$location)=();for (0 .. $#tokens){my$Token=$tokens[$_];next if$Token->{_location};if ($_){$location=$self->_add_location($location,$tokens[$_ - 1],\$heredoc)}else {my$logical_file=$self->can('filename')? $self->filename : undef;$location=[1,1,1,1,$logical_file ]}$first=$_;last}if (defined$first){for ($first .. $#tokens){my$Token=$tokens[$_];$Token->{_location}=$location;$location=$self->_add_location($location,$Token,\$heredoc);if ($Token->isa('PPI::Token::HereDoc')){$heredoc += $Token->heredoc + 1}}}1}sub _add_location {my ($self,$start,$Token,$heredoc)=@_;my$content=$Token->{content};my$newlines=()=$content =~ /\n/g;my ($logical_line,$logical_file)=$self->_logical_line_and_file($start,$Token,$newlines);unless ($newlines){return [$start->[LOCATION_LINE],$start->[LOCATION_CHARACTER]+ length($content),$start->[LOCATION_COLUMN]+ $self->_visual_length($content,$start->[LOCATION_COLUMN]),$logical_line,$logical_file,]}my$physical_line=$start->[LOCATION_LINE]+ $newlines;my$location=[$physical_line,1,1,$logical_line,$logical_file ];if ($heredoc and $$heredoc){$location->[LOCATION_LINE]+= $$heredoc;$location->[LOCATION_LOGICAL_LINE]+= $$heredoc;$$heredoc=0}if ($content =~ /\n([^\n]+?)\z/){$location->[LOCATION_CHARACTER]+= length($1);$location->[LOCATION_COLUMN]+= $self->_visual_length($1,$location->[LOCATION_COLUMN],)}$location}sub _logical_line_and_file {my ($self,$start,$Token,$newlines)=@_;if ($start->[LOCATION_CHARACTER]==1){if ($Token->isa('PPI::Token::Comment')){if ($Token->content =~ m<
  					\A
  					\#      \s*
  					line    \s+
  					(\d+)   \s*
  					(?: (\"?) ([^\"]* [^\s\"]) \2 )?
  					\s*
  					\z
  				>xms){return $1,($3 || $start->[LOCATION_LOGICAL_FILE])}}elsif ($Token->isa('PPI::Token::Pod')){my$content=$Token->content;my$line;my$file=$start->[LOCATION_LOGICAL_FILE];my$end_of_directive;while ($content =~ m<
  					^
  					\#      \s*?
  					line    \s+?
  					(\d+)   (?: (?! \n) \s)*
  					(?: (\"?) ([^\"]*? [^\s\"]) \2 )??
  					\s*?
  					$
  				>xmsg){($line,$file)=($1,($3 || $file));$end_of_directive=pos$content}if (defined$line){pos$content=$end_of_directive;my$post_directive_newlines=()=$content =~ m< \G [^\n]* \n >xmsg;return$line + $post_directive_newlines - 1,$file}}}return $start->[LOCATION_LOGICAL_LINE]+ $newlines,$start->[LOCATION_LOGICAL_FILE]}sub _visual_length {my ($self,$content,$pos)=@_;my$tab_width=$self->tab_width;my ($length,$vis_inc);return length$content if$content !~ /\t/;for my$part (split(/(\t)/,$content)){if ($part eq "\t"){$vis_inc=$tab_width - ($pos-1)% $tab_width}else {$vis_inc=length$part}$length += $vis_inc;$pos += $vis_inc}$length}sub flush_locations {shift->_flush_locations(@_)}sub normalized {PPI::Normal->process($_[0]->clone)}sub complete {my$self=shift;$self->find_any(sub {$_[1]->isa('PPI::Structure')and !$_[1]->complete})and return '';my@child=$self->children;while (@child and not $child[-1]->isa('PPI::Statement')){pop@child}return '' unless@child;return$child[-1]->_complete}sub scope() {1}sub insert_before {return undef}sub insert_after {return undef}sub replace {return undef}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}sub STORABLE_freeze {my$self=shift;my$class=ref$self;my%hash=%$self;return ($class,\%hash)}sub STORABLE_thaw {my ($self,undef,$class,$hash)=@_;bless$self,$class;for (keys %$hash){$self->{$_}=delete$hash->{$_}}$self->__link_children}1;
PPI_DOCUMENT

$fatpacked{"PPI/Document/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FILE';
  package PPI::Document::File;use strict;use Carp ();use Params::Util qw{_STRING _INSTANCE};use PPI::Document ();our$VERSION='1.269';our@ISA='PPI::Document';sub new {my$class=shift;my$filename=_STRING(shift);unless (defined$filename){return$class->_error("Did not provide a file name to load")}my$self=$class->SUPER::new($filename,@_)or return undef;if (_INSTANCE($self,'PPI::Document')){bless$self,'PPI::Document::File'}else {die "PPI::Document::File SUPER call returned an object of the wrong type"}$self}sub save {my$self=shift;my$filename=shift;unless (defined$filename){$filename=$self->filename}$self->SUPER::save($filename,@_)}1;
PPI_DOCUMENT_FILE

$fatpacked{"PPI/Document/Fragment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FRAGMENT';
  package PPI::Document::Fragment;use strict;use PPI::Document ();our$VERSION='1.269';our@ISA='PPI::Document';sub index_locations {warn "Useless attempt to index the locations of a document fragment";undef}sub scope() {''}1;
PPI_DOCUMENT_FRAGMENT

$fatpacked{"PPI/Document/Normalized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_NORMALIZED';
  package PPI::Document::Normalized;use strict;use Scalar::Util qw{refaddr reftype blessed};use Params::Util qw{_INSTANCE _ARRAY};use PPI::Util ();our$VERSION='1.269';use overload 'bool'=>\&PPI::Util::TRUE;use overload '=='=>'equal';sub new {my$class=shift;my%args=@_;my$Document=_INSTANCE($args{Document},'PPI::Document')or return undef;my$version=$args{version};my$functions=_ARRAY($args{functions})or return undef;my$self=bless {Document=>$Document,version=>$version,functions=>$functions,},$class;$self}sub _Document {$_[0]->{Document}}sub version {$_[0]->{version}}sub functions {$_[0]->{functions}}sub equal {my$self=shift;my$other=_INSTANCE(shift,'PPI::Document::Normalized')or return undef;return undef if$self->{processing};my$v1=$self->version || "undef";my$v2=$other->version || "undef";return '' if$v1 ne $v2;$self->_equal_ARRAY($self->functions,$other->functions)or return '';$self->{seen}={};my$rv=$self->_equal_blessed($self->_Document,$other->_Document);delete$self->{seen};$rv}sub _equal_blessed {my ($self,$this,$that)=@_;my ($bthis,$bthat)=(blessed$this,blessed$that);$bthis and $bthat and $bthis eq $bthat or return '';$self->_equal_reference($this,$that)}sub _equal_reference {my ($self,$this,$that)=@_;my ($rthis,$rthat)=(refaddr$this,refaddr$that);$rthis and $rthat or return undef;my$seen=$self->{seen}->{$rthis};if ($seen and $seen ne $rthat){return ''}my ($tthis,$tthat)=(reftype$this,reftype$that);$tthis and $tthat and $tthis eq $tthat or return undef;$self->{seen}->{$rthis}=$rthat;my$method="_equal_$tthat";my$rv=$self->$method($this,$that);delete$self->{seen}->{$rthis};$rv}sub _equal_SCALAR {my ($self,$this,$that)=@_;my ($cthis,$cthat)=($$this,$$that);return$self->_equal_blessed($cthis,$cthat)if blessed$cthis;return$self->_equal_reference($cthis,$cthat)if ref$cthis;return (defined$cthat and $cthis eq $cthat)if defined$cthis;!defined$cthat}sub _equal_REF {shift->_equal_SCALAR(@_)}sub _equal_ARRAY {my ($self,$this,$that)=@_;scalar(@$this)==scalar(@$that)or return '';for my$i (0 .. scalar(@$this)){my ($cthis,$cthat)=($this->[$i],$that->[$i]);if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_HASH {my ($self,$this,$that)=@_;return '' unless scalar(keys %$this)==scalar(keys %$that);for my$k (keys %$this){return '' unless exists$that->{$k};my ($cthis,$cthat)=($this->{$k},$that->{$k});if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_GLOB {my ($self,$this,$that)=@_;warn('GLOB comparisons are not supported');''}sub _equal_CODE {my ($self,$this,$that)=@_;refaddr$this==refaddr$that}sub _equal_IO {my ($self,$this,$that)=@_;warn('IO comparisons are not supported');''}sub DESTROY {if ($_[0]->{Document}){$_[0]->{Document}->DESTROY;delete $_[0]->{Document}}}1;
PPI_DOCUMENT_NORMALIZED

$fatpacked{"PPI/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DUMPER';
  package PPI::Dumper;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.269';sub new {my$class=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;my$self=bless {root=>$Element,display=>{memaddr=>'',indent=>2,class=>1,content=>1,whitespace=>1,comments=>1,locations=>0,},},$class;my@options=map {lc $_}@_;my%options=@options;for (keys %{$self->{display}}){if (exists$options{$_}){if ($_ eq 'indent'){$self->{display}->{indent}=$options{$_}}else {$self->{display}->{$_}=!!$options{$_}}}}$self->{indent_string}=join '',(' ' x $self->{display}->{indent});$self}sub print {CORE::print(shift->string)}sub string {my$array_ref=shift->_dump or return undef;join '',map {"$_\n"}@$array_ref}sub list {my$array_ref=shift->_dump or return ();@$array_ref}sub _dump {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$output=shift || [];my$show=1;if ($Element->isa('PPI::Token::Whitespace')){$show=0 unless$self->{display}->{whitespace}}elsif ($Element->isa('PPI::Token::Comment')){$show=0 unless$self->{display}->{comments}}push @$output,$self->_element_string($Element,$indent)if$show;if ($Element->isa('PPI::Node')){my$child_indent=$indent .$self->{indent_string};for my$child (@{$Element->{children}}){$self->_dump($child,$child_indent,$output)}}$output}sub _element_string {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$string='';if ($self->{display}->{memaddr}){$string .= $Element->refaddr .'  '}if ($self->{display}->{locations}){my$loc_string;if ($Element->isa('PPI::Token')){my$location=$Element->location;if ($location){$loc_string=sprintf("[ % 4d, % 3d, % 3d ] ",@$location)}}$string .= $loc_string || " " x 20}if ($self->{display}->{indent}){$string .= $indent}if ($self->{display}->{class}){$string .= ref$Element}if ($Element->isa('PPI::Token')){if ($self->{display}->{content}){my$content=$Element->content;$content =~ s/\n/\\n/g;$content =~ s/\t/\\t/g;$content =~ s/\f/\\f/g;$string .= "  \t'$content'"}}elsif ($Element->isa('PPI::Structure')){if ($self->{display}->{content}){my$start=$Element->start ? $Element->start->content : '???';my$finish=$Element->finish ? $Element->finish->content : '???';$string .= "  \t$start ... $finish"}}$string}1;
PPI_DUMPER

$fatpacked{"PPI/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_ELEMENT';
  package PPI::Element;use strict;use Clone 0.30 ();use Scalar::Util qw{refaddr};use Params::Util qw{_INSTANCE _ARRAY};use List::Util ();use PPI::Util ();use PPI::Node ();use PPI::Singletons '%_PARENT';our$VERSION='1.269';our$errstr="";use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';use overload '=='=>'__equals';use overload '!='=>'__nequals';use overload 'eq'=>'__eq';use overload 'ne'=>'__ne';sub significant() {1}sub class {ref($_[0])}sub tokens {$_[0]}sub content() {''}sub parent {$_PARENT{refaddr $_[0]}}sub descendant_of {my$cursor=shift;my$parent=shift or return undef;while (refaddr$cursor!=refaddr$parent){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub ancestor_of {my$self=shift;my$cursor=shift or return undef;while (refaddr$cursor!=refaddr$self){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub statement {my$cursor=shift;while (!_INSTANCE($cursor,'PPI::Statement')){$cursor=$_PARENT{refaddr$cursor}or return ''}$cursor}sub top {my$cursor=shift;while (my$parent=$_PARENT{refaddr$cursor}){$cursor=$parent}$cursor}sub document {my$top=shift->top;_INSTANCE($top,'PPI::Document')and $top}sub next_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;$elements->[$position + 1]|| ''}sub snext_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;while (defined(my$it=$elements->[++$position])){return$it if$it->significant}''}sub previous_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;$position and $elements->[$position - 1]or ''}sub sprevious_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;while ($position-- and defined(my$it=$elements->[$position])){return$it if$it->significant}''}sub first_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->first_element or die "Found empty PPI::Node while getting first token"}$cursor}sub last_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->last_element or die "Found empty PPI::Node while getting first token"}$cursor}sub next_token {my$cursor=shift;while (1){my$element=$cursor->next_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->first_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->finish){return$cursor->finish}}}sub previous_token {my$cursor=shift;while (1){my$element=$cursor->previous_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->last_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->start){return$cursor->start}}}sub clone {Clone::clone(shift)}sub __insert_before {my$self=shift;$self->parent->__insert_before_child($self,@_)}sub __insert_after {my$self=shift;$self->parent->__insert_after_child($self,@_)}sub remove {my$self=shift;my$parent=$self->parent or return$self;$parent->remove_child($self)}sub delete {$_[0]->remove or return undef;$_[0]->DESTROY;1}sub replace {my$self=ref $_[0]? shift : return undef;_INSTANCE(shift,ref$self)or return undef;die "The ->replace method has not yet been implemented"}sub location {my$self=shift;$self->_ensure_location_present or return undef;return [@{$self->{_location}}]}sub line_number {my$self=shift;my$location=$self->location()or return undef;return$location->[0]}sub column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[1]}sub visual_column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[2]}sub logical_line_number {my$self=shift;return$self->location()->[3]}sub logical_filename {my$self=shift;my$location=$self->location()or return undef;return$location->[4]}sub _ensure_location_present {my$self=shift;unless (exists$self->{_location}){my$Document=$self->document or return undef;if ($Document->isa('PPI::Document::Fragment')){return undef}$Document->index_locations or return undef;unless (exists$self->{_location}){return undef}}return 1}sub _flush_locations {my$self=shift;unless ($self==$self->top){return$self->top->_flush_locations($self)}my@Tokens=$self->tokens;if (_INSTANCE($_[0],'PPI::Element')){my$start=shift->first_token;while (my$Token=shift@Tokens){return 1 unless$Token->{_location};next unless refaddr($Token)==refaddr($start);delete $$Token->{_location};last}}for my$Token (@Tokens){delete$Token->{_location}}1}sub _xml_name {my$class=ref $_[0]|| $_[0];my$name=lc join('_',split /::/,$class);substr($name,4)}sub _xml_attr {return {}}sub _xml_content {defined $_[0]->{content}? $_[0]->{content}: ''}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub DESTROY {delete$_PARENT{refaddr $_[0]}}sub __equals {ref $_[1]and refaddr($_[0])==refaddr($_[1])}sub __nequals {!__equals(@_)}sub __eq {my$self=_INSTANCE($_[0],'PPI::Element')? $_[0]->content : $_[0];my$other=_INSTANCE($_[1],'PPI::Element')? $_[1]->content : $_[1];$self eq $other}sub __ne {!__eq(@_)}1;
PPI_ELEMENT

$fatpacked{"PPI/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION';
  package PPI::Exception;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.269';sub new {my$class=shift;return bless {@_ },$class if @_ > 1;return bless {message=>$_[0]},$class if @_;return bless {message=>'Unknown Exception' },$class}sub throw {my$it=shift;if (_INSTANCE($it,'PPI::Exception')){if ($it->{callers}){push @{$it->{callers}},[caller(0)]}else {$it->{callers}||= []}}else {my$message=$_[0]|| 'Unknown Exception';$it=$it->new(message=>$message,callers=>[[caller(0)],],)}die$it}sub message {$_[0]->{message}}sub callers {@{$_[0]->{callers}|| []}}1;
PPI_EXCEPTION

$fatpacked{"PPI/Exception/ParserRejection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION_PARSERREJECTION';
  package PPI::Exception::ParserRejection;use strict;use PPI::Exception ();our$VERSION='1.269';our@ISA='PPI::Exception';1;
PPI_EXCEPTION_PARSERREJECTION

$fatpacked{"PPI/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_FIND';
  package PPI::Find;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.269';sub new {my$class=ref $_[0]? ref shift : shift;my$wanted=ref $_[0]eq 'CODE' ? shift : return undef;my$self=bless {wanted=>$wanted,},$class;$self}sub clone {my$self=ref $_[0]? shift : die "->clone can only be called as an object method";my$class=ref$self;my$clone=bless {wanted=>$self->{wanted},},$class;$clone}sub in {my$self=shift;my$Element=shift;my%params=@_;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress',%params)}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object',%params)}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;return$self->_error("Error while searching: $errstr",%params)}delete$self->{in};if ($params{array_ref}){if (@{$self->{matches}}){return delete$self->{matches}}delete$self->{matches};return ''}my$matches=delete$self->{matches};@$matches}sub start {my$self=shift;my$Element=shift;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress')}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object')}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;$self->_error("Error while searching: $errstr");return undef}1}sub match {my$self=shift;return undef unless$self->{matches};my$match=shift @{$self->{matches}};return$match if$match;$self->finish;undef}sub finish {my$self=shift;delete$self->{in};delete$self->{matches};delete$self->{errstr};1}sub _execute {my$self=shift;my$wanted=$self->{wanted};my@queue=($self->{in});while (my$Element=shift@queue){my$rv=&$wanted($Element,$self->{in});push @{$self->{matches}},$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,$Element->children;unshift@queue,$Element->start if$Element->start}else {unshift@queue,$Element->children}}1}sub errstr {shift->{errstr}}sub _error {my$self=shift;$self->{errstr}=shift;my%params=@_;$params{array_ref}? undef : ()}1;
PPI_FIND

$fatpacked{"PPI/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_LEXER';
  package PPI::Lexer;use strict;use Scalar::Util ();use Params::Util qw{_STRING _INSTANCE};use PPI ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.269';our$errstr="";my%ROUND=('if'=>'PPI::Structure::Condition','elsif'=>'PPI::Structure::Condition','unless'=>'PPI::Structure::Condition','while'=>'PPI::Structure::Condition','until'=>'PPI::Structure::Condition','for'=>'PPI::Structure::For','foreach'=>'PPI::Structure::For',);my%RESOLVE=('('=>'_round','['=>'_square','{'=>'_curly',);our$X_TOKENIZER="PPI::Tokenizer";sub X_TOKENIZER {$X_TOKENIZER}sub new {my$class=shift->_clear;bless {Tokenizer=>undef,buffer=>[],delayed=>[],},$class}sub lex_file {my$self=ref $_[0]? shift : shift->new;my$file=_STRING(shift);unless (defined$file){return$self->_error("Did not pass a filename to PPI::Lexer::lex_file")}my$Tokenizer=eval {X_TOKENIZER->new($file)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_source {my$self=ref $_[0]? shift : shift->new;my$source=shift;unless (defined$source and not ref$source){return$self->_error("Did not pass a string to PPI::Lexer::lex_source")}my$Tokenizer=eval {X_TOKENIZER->new(\$source)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_tokenizer {my$self=ref $_[0]? shift : shift->new;my$Tokenizer=_INSTANCE(shift,'PPI::Tokenizer');return$self->_error("Did not pass a PPI::Tokenizer object to PPI::Lexer::lex_tokenizer")unless$Tokenizer;my$Document=PPI::Document->new;$self->{Tokenizer}=$Tokenizer;if (!eval {$self->_lex_document($Document);1}){undef$Document;if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}else {return$self->_error($errstr)}}return$Document}sub _lex_document {my ($self,$Document)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){$self->_add_element($Document,$Token);next}if ($Token->content eq ';'){$self->_add_element($Document,PPI::Statement::Null->new($Token),);next}unless (ref$Token eq 'PPI::Token::Structure'){my$Statement=$self->_statement($Document,$Token)->new($Token);$self->_add_delayed($Document);$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){$self->_add_element($Document,PPI::Statement::UnmatchedBrace->new($Token));next}PPI::Exception->throw('Lexer reached an illegal state')}unless (defined$Token){my$errstr=$self->{Tokenizer}? $self->{Tokenizer}->errstr : '';$errstr ||= 'Unknown Tokenizer Error';PPI::Exception->throw($errstr)}$self->_add_delayed($Document);my$perl6=$self->{Tokenizer}->{'perl6'};if (@$perl6){my$includes=$Document->find('PPI::Statement::Include::Perl6');for my$include (@$includes){unless (@$perl6){PPI::Exception->throw('Failed to find a perl6 section')}$include->{perl6}=shift @$perl6}}return 1}my%STATEMENT_CLASSES=('BEGIN'=>'PPI::Statement::Scheduled','CHECK'=>'PPI::Statement::Scheduled','UNITCHECK'=>'PPI::Statement::Scheduled','INIT'=>'PPI::Statement::Scheduled','END'=>'PPI::Statement::Scheduled','AUTOLOAD'=>'PPI::Statement::Sub','DESTROY'=>'PPI::Statement::Sub','package'=>'PPI::Statement::Package','no'=>'PPI::Statement::Include','require'=>'PPI::Statement::Include','my'=>'PPI::Statement::Variable','local'=>'PPI::Statement::Variable','our'=>'PPI::Statement::Variable','state'=>'PPI::Statement::Variable','if'=>'PPI::Statement::Compound','unless'=>'PPI::Statement::Compound','for'=>'PPI::Statement::Compound','foreach'=>'PPI::Statement::Compound','while'=>'PPI::Statement::Compound','until'=>'PPI::Statement::Compound','given'=>'PPI::Statement::Given','when'=>'PPI::Statement::When','default'=>'PPI::Statement::When','redo'=>'PPI::Statement::Break','next'=>'PPI::Statement::Break','last'=>'PPI::Statement::Break','return'=>'PPI::Statement::Break','goto'=>'PPI::Statement::Break','__DATA__'=>'PPI::Statement::Data','__END__'=>'PPI::Statement::End',);sub _statement {my ($self,$Parent,$Token)=@_;if ($Parent->isa('PPI::Structure::List')or $Parent->isa('PPI::Structure::Constructor')){if ($Token->isa('PPI::Token::Word')){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->isa('PPI::Token::Operator')and $Next->content eq '=>'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {last}}$self->_rollback($Next)}}my$is_lexsub=0;my$class=$STATEMENT_CLASSES{$Token->content};if ($class){my$Next;while ($Next=$self->_get_token){if (!$Next->significant){push @{$self->{delayed}},$Next;next}if ($Token->content =~ /^(?:my|our|state)$/ and $Next->isa('PPI::Token::Word')and $Next->content eq 'sub'){$class=undef;$is_lexsub=1;last}last if !$Next->isa('PPI::Token::Operator')or $Next->content ne '=>';$self->_rollback($Next);return 'PPI::Statement'}$self->_rollback($Next)}if ($Parent->isa('PPI::Structure::Subscript')){unless ($class and $class->isa('PPI::Statement::Expression')){return 'PPI::Statement::Expression'}my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->content eq '}'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {$self->_rollback($Next);return$class}}$self->_rollback($Next);return 'PPI::Statement::Expression'}return$class if$class;if ($is_lexsub || $Token->content eq 'sub'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}my$sclass=$STATEMENT_CLASSES{$Next->content};if ($sclass and $sclass eq 'PPI::Statement::Scheduled'){$self->_rollback($Next);return 'PPI::Statement::Scheduled'}if ($Next->isa('PPI::Token::Word')){$self->_rollback($Next);return 'PPI::Statement::Sub'}$self->_rollback($Next);return 'PPI::Statement'}$self->_rollback($Next);return 'PPI::Statement::Sub'}if ($Token->content eq 'use'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->isa('PPI::Token::Operator')and $Next->content eq '=>'){$self->_rollback($Next);return 'PPI::Statement'}elsif ($Next->content eq 'v6'){$self->_rollback($Next);return 'PPI::Statement::Include::Perl6'}else {$self->_rollback($Next);return 'PPI::Statement::Include'}}$self->_rollback($Next);return 'PPI::Statement::Include'}if ($Parent->isa('PPI::Structure::Condition')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::List')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::Given')or $Parent->isa('PPI::Structure::When')){return 'PPI::Statement::Expression'}if (_INSTANCE($Token,'PPI::Token::Label')){return 'PPI::Statement::Compound'}return 'PPI::Statement'}sub _lex_statement {my ($self,$Statement)=@_;if ($Statement->isa('PPI::Statement::End')){return$self->_lex_end($Statement)}my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}if ($Token->__LEXER__closes or $Token->isa('PPI::Token::Separator')){return$self->_rollback($Token)}unless ($Statement->__LEXER__normal){unless ($self->_continues($Statement,$Token)){return$self->_rollback($Token)}}unless ($Token->isa('PPI::Token::Structure')){$self->_add_element($Statement,$Token);next}if ($Token->content eq ';'){$self->_add_element($Statement,$Token);return 1}my$method=$RESOLVE{$Token->content};my$Structure=$self->$method($Statement)->new($Token);$self->_add_delayed($Statement);$self->_add_element($Statement,$Structure);$self->_lex_structure($Structure)}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _lex_end {my ($self,$Statement)=@_;my$Token;while ($Token=$self->_get_token){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Statement);push @{$Statement->{children}},$Token}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _continues {my ($self,$Statement,$Token)=@_;if ($Statement->schildren==1 and $Statement->schild(0)->isa('PPI::Structure::Block')){return ''}return 1 if ref$Statement !~ /\b(?:Scheduled|Sub|Compound|Given|When|Package)$/;my@part=$Statement->schildren;my$LastChild=$part[-1];return!$LastChild->isa('PPI::Structure::Block')if!$Statement->isa('PPI::Statement::Compound');my$type=$Statement->type;if ($type eq 'if'){unless ($LastChild->isa('PPI::Structure::Block')){return 1}my$NextLast=$Statement->schild(-2);if ($NextLast and $NextLast->isa('PPI::Token')and $NextLast->isa('PPI::Token::Word')and $NextLast->content eq 'else'){return ''}if ($Token->isa('PPI::Token::Word')and ($Token->content eq 'else' or $Token->content eq 'elsif')){return 1}return ''}if ($type eq 'label'){if ($Token->isa('PPI::Token::Word')and $Token->content =~ /^(?:while|until|for|foreach)$/){return 1}if ($Token->isa('PPI::Token::Structure')&& $Token->content eq '{'){return 1}return ''}if ($LastChild->isa('PPI::Structure')and $LastChild->braces eq '()'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($type eq 'for'){if ($LastChild->isa('PPI::Token::Word')and $LastChild->content =~ /^for(?:each)?\z/){if (($Token->isa('PPI::Token::Structure')and $Token->content eq '(')or $Token->isa('PPI::Token::QuoteLike::Words')){return 1}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}$type='foreach'}elsif ($LastChild->isa('PPI::Structure::Block')){return ''}elsif ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}if ($LastChild->isa('PPI::Token::Word')and $LastChild->content eq 'continue'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($LastChild->isa('PPI::Structure::Block')){if (_INSTANCE($part[-2],'PPI::Token::Word')and $part[-2]->content eq 'continue'){return ''}return$Token->isa('PPI::Token::Word')&& $Token->content eq 'continue'}if ($type eq 'block'){}if ($type eq 'while'){if ($LastChild->isa('PPI::Token::Word')and ($LastChild->content eq 'while' or $LastChild->content eq 'until')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '('}}if ($type eq 'foreach'){if ($LastChild->isa('PPI::Token::Symbol')){return 1 if$Token->isa('PPI::Token::Structure')&& $Token->content eq '(';return 1 if$Token->isa('PPI::Token::QuoteLike::Words');return ''}if ($LastChild->content eq 'foreach' or $LastChild->content eq 'for'){if ($Token->isa('PPI::Token::Word')and (($STATEMENT_CLASSES{$Token->content }|| '')eq 'PPI::Statement::Variable')){return 1}elsif ($Token->content =~ /^\$/){return 1}elsif ($Token->isa('PPI::Token::Structure')and $Token->content eq '('){return 1}elsif ($Token->isa('PPI::Token::QuoteLike::Words')){return 1}else {return ''}}if (($STATEMENT_CLASSES{$LastChild->content }|| '')eq 'PPI::Statement::Variable'){return$Token->content =~ /^\$/}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}PPI::Exception->throw("Illegal state in '$type' compound statement")}sub _round {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if (_INSTANCE($Element,'PPI::Token::Word')){my$rclass=$ROUND{$Element->content};return$rclass if$rclass}if ($Parent->isa('PPI::Statement::Compound')){if ($Parent->type =~ /^for(?:each)?$/){return 'PPI::Structure::For'}}elsif ($Parent->isa('PPI::Statement::Given')){return 'PPI::Structure::Given'}elsif ($Parent->isa('PPI::Statement::When')){return 'PPI::Structure::When'}if (_INSTANCE($Element,'PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1}'PPI::Structure::List'}sub _square {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if ($Element){if ($Element->isa('PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Symbol')and $Element->content =~ /^(?:\$|\@)/){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Cast')and $Element->content =~ /^(?:\@|\%)/){my$prior=$Parent->schild(-2);if ($prior and $prior->isa('PPI::Token::Operator')and $prior->content eq '->'){return 'PPI::Structure::Subscript'}}}'PPI::Structure::Constructor'}my%CURLY_CLASSES=('sub'=>'PPI::Structure::Block','grep'=>'PPI::Structure::Block','map'=>'PPI::Structure::Block','sort'=>'PPI::Structure::Block','do'=>'PPI::Structure::Block','scalar'=>'PPI::Structure::Constructor','='=>'PPI::Structure::Constructor','||='=>'PPI::Structure::Constructor','&&='=>'PPI::Structure::Constructor','//='=>'PPI::Structure::Constructor','||'=>'PPI::Structure::Constructor','&&'=>'PPI::Structure::Constructor','//'=>'PPI::Structure::Constructor','?'=>'PPI::Structure::Constructor',':'=>'PPI::Structure::Constructor',','=>'PPI::Structure::Constructor','=>'=>'PPI::Structure::Constructor','+'=>'PPI::Structure::Constructor','return'=>'PPI::Structure::Constructor','bless'=>'PPI::Structure::Constructor',);my@CURLY_LOOKAHEAD_CLASSES=({},{';'=>'PPI::Structure::Block','}'=>'PPI::Structure::Constructor',},{'=>'=>'PPI::Structure::Constructor',},);sub _curly {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);my$content=$Element ? $Element->content : '';if ($Element){if ($content eq '->' and $Element->isa('PPI::Token::Operator')){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($content =~ /^(?:\$|\@)/ and $Element->isa('PPI::Token::Symbol')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Cast')and $Element->content =~ /^(?:\@|\%|\*)/){my$prior=$Parent->schild(-2);if ($prior and $prior->isa('PPI::Token::Operator')and $prior->content eq '->'){return 'PPI::Structure::Subscript'}}if ($Element->isa('PPI::Structure::Block')){if (my$prior=$Parent->schild(-2)){my$prior_content=$prior->content();$prior->isa('PPI::Token::Cast')and ($prior_content eq '@' || $prior_content eq '$')and return 'PPI::Structure::Subscript'}}return 'PPI::Structure::Block' if$Parent->isa('PPI::Statement::Sub');return 'PPI::Structure::Block' if$Parent->isa('PPI::Statement::Package');if ($CURLY_CLASSES{$content}){return$CURLY_CLASSES{$content}}}if ($Parent->isa('PPI::Statement::Compound')){return 'PPI::Structure::Block'}if ($Parent->isa('PPI::Statement::Include')){if ($Parent->schildren==2 || $Parent->schildren==3 && $Parent->schild(2)->isa('PPI::Token::Number')){return 'PPI::Structure::Constructor'}}return 'PPI::Structure::Block' if$Element;if ($Parent->isa('PPI::Statement')and _INSTANCE($Parent->parent,'PPI::Structure::List')){my$function=$Parent->parent->parent->schild(-2);return 'PPI::Structure::Block' if$function and $function->content =~ /^(?:map|grep|sort|eval|do)$/;return 'PPI::Structure::Constructor' if not $function or $function->content !~ /^(?:print|say)$/}my$Next;my$position=0;my@delayed;while ($Next=$self->_get_token){unless ($Next->significant){push@delayed,$Next;next}if (++$position >= @CURLY_LOOKAHEAD_CLASSES){$self->_buffer(splice(@delayed),$Next);last}elsif (my$class=$CURLY_LOOKAHEAD_CLASSES[$position]{$Next->content}){$self->_buffer(splice(@delayed),$Next);return$class}push@delayed,$Next}$self->_buffer(splice(@delayed));if (ref$Parent eq 'PPI::Statement'){bless$Parent,'PPI::Statement::Compound'}return 'PPI::Structure::Block'}sub _lex_structure {my ($self,$Structure)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}unless ($Token->isa('PPI::Token::Structure')){$self->_add_delayed($Structure);my$Statement=$self->_statement($Structure,$Token)->new($Token);$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){if ($Token->content eq $Structure->start->__LEXER__opposite){$self->_add_delayed($Structure);$Structure->{finish}=$Token;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Structure);if ($Structure->isa('PPI::Structure::For')){if (2 > scalar grep {$_->isa('PPI::Statement')}$Structure->children){bless($Structure,'PPI::Structure::List')}}return 1}return$self->_rollback($Token)}$self->_add_element($Structure,PPI::Statement::Null->new($Token),)}unless (defined$Token){PPI::Exception->throw}$self->_add_delayed($Structure)}sub _get_token {shift(@{$_[0]->{buffer}})or $_[0]->{Tokenizer}->get_token}sub _add_element {my ($self,$Parent,$Element)=@_;if (ref$Parent eq 'PPI::Statement' and my$first=$Parent->schild(0)){if ($first->isa('PPI::Token::Label')and!(my$second=$Parent->schild(1))){my$new_class=$STATEMENT_CLASSES{$second->content};bless$Parent,$new_class if$new_class}}for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Element}=$Parent);push @{$Parent->{children}},@{$self->{delayed}},$Element;$self->{delayed}=[]}sub _add_delayed {my ($self,$Parent)=@_;for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}push @{$Parent->{children}},@{$self->{delayed}};$self->{delayed}=[]}sub _rollback {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}if (@{$self->{delayed}}){unshift @{$self->{buffer}},splice @{$self->{delayed}}}1}sub _buffer {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}1}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}1;
PPI_LEXER

$fatpacked{"PPI/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NODE';
  package PPI::Node;use strict;use Carp ();use Scalar::Util qw{refaddr};use List::Util ();use Params::Util qw{_INSTANCE _CLASS _CODELIKE _NUMBER};use PPI::Element ();use PPI::Singletons '%_PARENT';our$VERSION='1.269';our@ISA="PPI::Element";sub new {my$class=ref $_[0]|| $_[0];bless {children=>[]},$class}sub scope() {''}sub add_element {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;$_PARENT{refaddr$Element}and return undef;push @{$self->{children}},$Element;Scalar::Util::weaken($_PARENT{refaddr$Element}=$self);1}sub __add_element {Scalar::Util::weaken($_PARENT{refaddr $_[1]}=$_[0]);push @{$_[0]->{children}},$_[1]}sub elements {if (wantarray){return @{$_[0]->{children}}}else {return scalar @{$_[0]->{children}}}}sub first_element {$_[0]->{children}->[0]}sub last_element {$_[0]->{children}->[-1]}sub children {wantarray ? @{$_[0]->{children}}: scalar @{$_[0]->{children}}}sub schildren {return grep {$_->significant}@{$_[0]->{children}}if wantarray;my$count=0;for (@{$_[0]->{children}}){$count++ if $_->significant}return$count}sub child {my ($self,$index)=@_;PPI::Exception->throw("method child() needs an index")if not defined _NUMBER$index;$self->{children}->[$index]}sub schild {my$self=shift;my$idx=0 + shift;my$el=$self->{children};if ($idx < 0){my$cursor=0;while (exists$el->[--$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and ++$idx >= 0}}else {my$cursor=-1;while (exists$el->[++$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and --$idx < 0}}undef}sub contains {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;while ($Element=$Element->parent){return 1 if refaddr($self)==refaddr($Element)}''}sub find {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@found;my@queue=@{$self->{children}};my$ok=eval {while (@queue){my$Element=shift@queue;my$rv=&$wanted($self,$Element);push@found,$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if$Element->start}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}@found ? \@found : ''}sub find_first {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@queue=@{$self->{children}};my$rv;my$ok=eval {while (@queue){my$Element=shift@queue;my$element_rv=$wanted->($self,$Element);if ($element_rv){$rv=$Element;last}next if!defined$element_rv;next if!$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if defined($Element->finish);unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if defined($Element->start)}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}$rv or ''}sub find_any {my$self=shift;my$rv=$self->find_first(@_);$rv ? 1 : $rv}sub remove_child {my$self=shift;my$child=_INSTANCE(shift,'PPI::Element')or return undef;my$key=refaddr$child;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};return undef unless defined$p;splice(@{$self->{children}},$p,1);delete$_PARENT{refaddr$child};$child}sub prune {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my$pruned=0;my@queue=$self->children;my$ok=eval {while (my$element=shift@queue){my$rv=&$wanted($self,$element);if ($rv){$element->delete or return undef;$pruned++;next}next unless defined$rv;if (_INSTANCE($element,'PPI::Node')){unshift@queue,$element->children}}1};if (!$ok){return undef}$pruned}sub _wanted {my$either=shift;my$it=defined($_[0])? shift : do {Carp::carp('Undefined value passed as search condition')if $^W;return undef};return$it if _CODELIKE($it);if (ref$it){Carp::carp('Illegal non-CODE reference passed as search condition')if $^W;return undef}$it="PPI::$it" unless substr($it,0,5)eq 'PPI::';unless (_CLASS($it)and $it->isa('PPI::Element')){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}my$wanted_class="\n\treturn '' unless \$_[1]->isa('$it');";my$wanted_content='';if (defined $_[0]){my$content=shift;if (ref$content eq 'Regexp'){$content="$content"}elsif (ref$content){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}else {$content=quotemeta$content}$wanted_content .= "\n\treturn '' unless defined \$_[1]->{content};";$wanted_content .= "\n\treturn '' unless \$_[1]->{content} =~ /$content/;"}my$code="sub {" .$wanted_class .$wanted_content ."\n\t1;" ."\n}";$code=eval$code;(ref$code eq 'CODE')? $code : undef}sub tokens {map {$_->tokens}@{$_[0]->{children}}}sub content {join '',map {$_->content}@{$_[0]->{children}}}sub clone {my$self=shift;my$clone=$self->SUPER::clone;$clone->__link_children;$clone}sub location {my$self=shift;my$first=$self->{children}->[0]or return undef;$first->location}sub DESTROY {local $_;if ($_[0]->{children}){my@queue=$_[0];while (defined($_=shift@queue)){unshift@queue,@{delete $_->{children}}if $_->{children};%$_=()}}delete$_PARENT{refaddr $_[0]}}sub __position {my$key=refaddr $_[1];List::Util::first {refaddr $_[0]{children}[$_]==$key}0..$#{$_[0]{children}}}sub __insert_before_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,0,@_);1}sub __insert_after_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p + 1,0,@_);1}sub __replace_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,1,@_);1}sub __link_children {my$self=shift;my@queue=($self);while (my$Node=shift@queue){for my$Element (@{$Node->{children}}){Scalar::Util::weaken($_PARENT{refaddr($Element)}=$Node);unshift@queue,$Element if$Element->isa('PPI::Node')}next unless$Node->isa('PPI::Structure');Scalar::Util::weaken($_PARENT{refaddr($Node->start)}=$Node)if$Node->start;Scalar::Util::weaken($_PARENT{refaddr($Node->finish)}=$Node)if$Node->finish}1}1;
PPI_NODE

$fatpacked{"PPI/Normal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL';
  package PPI::Normal;use strict;use Carp ();use List::Util 1.33 ();use PPI::Util '_Document';use PPI::Document::Normalized ();use PPI::Normal::Standard ();use PPI::Singletons '%LAYER';our$VERSION='1.269';PPI::Normal::Standard->import;sub register {my$class=shift;while (@_){my$function=shift;SCOPE: {no strict 'refs';defined$function and defined &{"$function"}or Carp::croak("Bad function name provided to PPI::Normal")}if (List::Util::any {$_ eq $function}map @{$_},values%LAYER){return 1}my$layer=shift;defined$layer and $layer =~ /^(?:1|2)$/ or Carp::croak("Bad layer provided to PPI::Normal");push @{$LAYER{$layer}},$function}1}sub new {my$class=shift;my$layer=@_ ? (defined $_[0]and!ref $_[0]and $_[0]=~ /^[12]$/)? shift : return undef : 1;my$object=bless {layer=>$layer,},$class;$object}sub layer {$_[0]->{layer}}sub process {my$self=ref $_[0]? shift : shift->new;return undef if$self->{Document};$self->{Document}=_Document(shift)or return undef;my@functions=map {@{$LAYER{$_}}}(1 .. $self->layer);for my$function (@functions){no strict 'refs';&{"$function"}($self->{Document})}my$Normalized=PPI::Document::Normalized->new(Document=>$self->{Document},version=>__PACKAGE__->VERSION,functions=>\@functions,)or return undef;delete$self->{Document};return$Normalized}1;
PPI_NORMAL

$fatpacked{"PPI/Normal/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL_STANDARD';
  package PPI::Normal::Standard;use strict;our$VERSION='1.269';my@METHODS=(remove_insignificant_elements=>1,remove_useless_attributes=>1,remove_useless_pragma=>2,remove_statement_separator=>2,remove_useless_return=>2,);sub import {PPI::Normal->register(map {/\D/ ? "PPI::Normal::Standard::$_" : $_}@METHODS)or die "Failed to register PPI::Normal::Standard transforms"}sub remove_insignificant_elements {my$Document=shift;$Document->prune(sub {!$_[1]->significant})}sub remove_useless_attributes {my$Document=shift;delete$Document->{tab_width}}my$remove_pragma=map {$_=>1}qw{strict warnings diagnostics less};sub remove_useless_pragma {my$Document=shift;$Document->prune(sub {return '' unless $_[1]->isa('PPI::Statement::Include');return 1 if $_[1]->version;return 1 if$remove_pragma->{$_[1]->pragma};''})}sub remove_statement_separator {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Structure')or return '';$_[1]->content eq ';' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement')or return '';$_[1]->next_sibling and return '';1})}sub remove_useless_return {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Word')or return '';$_[1]->content eq 'return' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement::Break')or return '';$stmt->children==2 or return '';$stmt->next_sibling and return '';my$block=$stmt->parent or return '';$block->isa('PPI::Structure::Block')or return '';1})}1;
PPI_NORMAL_STANDARD

$fatpacked{"PPI/Singletons.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_SINGLETONS';
  package PPI::Singletons;use strict;use Exporter ();our$VERSION='1.269';our@ISA='Exporter';our@EXPORT_OK=qw{%_PARENT %OPERATOR %MAGIC %LAYER $CURLY_SYMBOL %QUOTELIKE %KEYWORDS};our%_PARENT;our%OPERATOR=map {$_=>1}(qw{-> ++ -- ** ! ~ + - =~ !~ * / % x . << >> < > <= >= lt gt le ge == != <=> eq ne cmp ~~ & | ^ && || // .. ... ? : = **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //= => <> <<>> and or xor not},',');our%MAGIC=map {$_=>1}qw{$1 $2 $3 $4 $5 $6 $7 $8 $9 $_ $& $` $' $+ @+ %+ $* $. $/ $| $\\ $" $; $% $= $- @- %- $) $~ $^ $: $? $! %! $@ $$ $< $> $( $0 $[ $] @_ @* $^L $^A $^E $^C $^D $^F $^H $^I $^M $^N $^O $^P $^R $^S $^T $^V $^W $^X %^H $::|},'$}','$,','$#','$#+','$#-';our%LAYER=(1=>[],2=>[]);our$CURLY_SYMBOL=qr{\G\^[[:upper:]_]\w+\}};our%QUOTELIKE=('q'=>'Quote::Literal','qq'=>'Quote::Interpolate','qx'=>'QuoteLike::Command','qw'=>'QuoteLike::Words','qr'=>'QuoteLike::Regexp','m'=>'Regexp::Match','s'=>'Regexp::Substitute','tr'=>'Regexp::Transliterate','y'=>'Regexp::Transliterate',);our%KEYWORDS=map {$_=>1}qw{abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir cmp connect continue cos crypt dbmclose dbmopen default defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent eof eq eval evalbytes exec exists exit exp fc fcntl fileno flock for foreach fork format formline ge getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt given glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst le length link listen local localtime lock log lstat lt m map mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack package pipe pop pos print printf prototype push q qq qr quotemeta qw qx rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir s say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study sub substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times tr truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray warn when while write x xor y};1;
PPI_SINGLETONS

$fatpacked{"PPI/Statement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT';
  package PPI::Statement;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.269';our@ISA="PPI::Node";use PPI::Statement::Break ();use PPI::Statement::Compound ();use PPI::Statement::Data ();use PPI::Statement::End ();use PPI::Statement::Expression ();use PPI::Statement::Include ();use PPI::Statement::Null ();use PPI::Statement::Package ();use PPI::Statement::Scheduled ();use PPI::Statement::Sub ();use PPI::Statement::Given ();use PPI::Statement::UnmatchedBrace ();use PPI::Statement::Unknown ();use PPI::Statement::Variable ();use PPI::Statement::When ();sub __LEXER__normal() {1}sub new {my$class=shift;if (ref$class){PPI::Exception->throw}my$self=bless {children=>[],},$class;my$token=shift;if (_INSTANCE($token,'PPI::Token')){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$token}=$self);push @{$self->{children}},$token}$self}sub label {my$first=shift->schild(1)or return '';$first->isa('PPI::Token::Label')? substr($first,0,length($first)- 1): ''}sub specialized {__PACKAGE__ ne ref $_[0]}sub stable {die "The ->stable method has not yet been implemented"}sub _complete {my$self=shift;my$semi=$self->schild(-1);return!!(defined$semi and $semi->isa('PPI::Token::Structure')and $semi->content eq ';')}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_after($Element)}''}1;
PPI_STATEMENT

$fatpacked{"PPI/Statement/Break.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_BREAK';
  package PPI::Statement::Break;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";1;
PPI_STATEMENT_BREAK

$fatpacked{"PPI/Statement/Compound.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_COMPOUND';
  package PPI::Statement::Compound;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";my%TYPES=('if'=>'if','unless'=>'if','while'=>'while','until'=>'while','for'=>'for','foreach'=>'foreach',);sub __LEXER__normal() {''}sub type {my$self=shift;my$p=0;my$Element=$self->schild($p)or return undef;if ($Element->isa('PPI::Token::Label')){$Element=$self->schild(++$p)or return 'label'}my$content=$Element->content;if ($content =~ /^for(?:each)?\z/){$Element=$self->schild(++$p)or return$content;if ($Element->isa('PPI::Token')){return 'foreach' if$Element->content =~ /^my|our|state\z/;return 'foreach' if$Element->isa('PPI::Token::Symbol');return 'foreach' if$Element->isa('PPI::Token::QuoteLike::Words')}if ($Element->isa('PPI::Structure::List')){return 'foreach'}return 'for'}return$TYPES{$content}if$Element->isa('PPI::Token::Word');return 'continue' if$Element->isa('PPI::Structure::Block');undef}sub scope() {1}sub _complete {my$self=shift;my$type=$self->type or die "Illegal compound statement type";if ($type eq 'if'){my$child=$self->schild(-1)or return '';$child->isa('PPI::Structure')or return '';$child->braces eq '{}' or return '';$child->_complete or return ''}elsif ($type eq 'while'){die "CODE INCOMPLETE"}else {die "CODE INCOMPLETE"}}1;
PPI_STATEMENT_COMPOUND

$fatpacked{"PPI/Statement/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_DATA';
  package PPI::Statement::Data;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";sub _complete () {''}1;
PPI_STATEMENT_DATA

$fatpacked{"PPI/Statement/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_END';
  package PPI::Statement::End;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_END

$fatpacked{"PPI/Statement/Expression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_EXPRESSION';
  package PPI::Statement::Expression;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";1;
PPI_STATEMENT_EXPRESSION

$fatpacked{"PPI/Statement/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_GIVEN';
  package PPI::Statement::Given;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_GIVEN

$fatpacked{"PPI/Statement/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE';
  package PPI::Statement::Include;use strict;use PPI::Statement ();use PPI::Statement::Include::Perl6 ();our$VERSION='1.269';our@ISA="PPI::Statement";sub type {my$self=shift;my$keyword=$self->schild(0)or return undef;$keyword->isa('PPI::Token::Word')and $keyword->content}sub module {my$self=shift;my$module=$self->schild(1)or return undef;$module->isa('PPI::Token::Word')and $module->content}sub module_version {my$self=shift;my$argument=$self->schild(3);if ($argument and $argument->isa('PPI::Token::Operator')){return undef}my$version=$self->schild(2)or return undef;return undef unless$version->isa('PPI::Token::Number');return$version}sub pragma {my$self=shift;my$module=$self->module or return '';$module =~ /^[a-z][a-z\d]*$/ ? $module : ''}sub version {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->content : ''}sub version_literal {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->literal : ''}sub arguments {my$self=shift;my@args=$self->schildren;shift@args;if ($args[-1]->isa('PPI::Token::Structure')and $args[-1]->content eq ';'){pop@args}shift@args;return unless@args;if ($args[0]->isa('PPI::Token::Number')){my$after=$args[1]or return;$after->isa('PPI::Token::Operator')or shift@args}return@args}1;
PPI_STATEMENT_INCLUDE

$fatpacked{"PPI/Statement/Include/Perl6.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE_PERL6';
  package PPI::Statement::Include::Perl6;use strict;use PPI::Statement::Include ();our$VERSION='1.269';our@ISA="PPI::Statement::Include";sub perl6 {$_[0]->{perl6}}1;
PPI_STATEMENT_INCLUDE_PERL6

$fatpacked{"PPI/Statement/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_NULL';
  package PPI::Statement::Null;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";sub significant() {''}1;
PPI_STATEMENT_NULL

$fatpacked{"PPI/Statement/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_PACKAGE';
  package PPI::Statement::Package;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub namespace {my$self=shift;my$namespace=$self->schild(1)or return '';$namespace->isa('PPI::Token::Word')? $namespace->content : ''}sub version {my$self=shift;my$version=$self->schild(2)or return '';$version->isa('PPI::Token::Structure')? '' : $version->content}sub file_scoped {my$self=shift;my ($Parent,$Document)=($self->parent,$self->top);$Parent and $Document and $Parent==$Document and $Document->isa('PPI::Document')and!$Document->isa('PPI::Document::Fragment')}1;
PPI_STATEMENT_PACKAGE

$fatpacked{"PPI/Statement/Scheduled.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SCHEDULED';
  package PPI::Statement::Scheduled;use strict;use PPI::Statement::Sub ();our$VERSION='1.269';our@ISA="PPI::Statement::Sub";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub type {my$self=shift;my@children=$self->schildren or return undef;$children[0]->content eq 'sub' ? $children[1]->content : $children[0]->content}sub name {shift->type(@_)}1;
PPI_STATEMENT_SCHEDULED

$fatpacked{"PPI/Statement/Sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SUB';
  package PPI::Statement::Sub;use strict;use List::Util ();use Params::Util qw{_INSTANCE};use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub name {my ($self)=@_;my$token=$self->schild(1);return$token->content if defined$token and $token->isa('PPI::Token::Word');$token=$self->schild(0);return$token->content if defined$token and $token->isa('PPI::Token::Word');return ''}sub prototype {my$self=shift;my$Prototype=List::Util::first {_INSTANCE($_,'PPI::Token::Prototype')}$self->children;defined($Prototype)? $Prototype->prototype : undef}sub block {my$self=shift;my$lastchild=$self->schild(-1)or return '';$lastchild->isa('PPI::Structure::Block')and $lastchild}sub forward {!shift->block}sub reserved {my$self=shift;my$name=$self->name or return '';$name eq uc$name}sub type {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');(_INSTANCE($schild[0],'PPI::Token::Word')and $schild[0]->content =~ /^(my|our|state)$/)? $schild[0]->content : undef}1;
PPI_STATEMENT_SUB

$fatpacked{"PPI/Statement/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNKNOWN';
  package PPI::Statement::Unknown;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_UNKNOWN

$fatpacked{"PPI/Statement/UnmatchedBrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNMATCHEDBRACE';
  package PPI::Statement::UnmatchedBrace;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_UNMATCHEDBRACE

$fatpacked{"PPI/Statement/Variable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_VARIABLE';
  package PPI::Statement::Variable;use strict;use Params::Util qw{_INSTANCE};use PPI::Statement::Expression ();our$VERSION='1.269';our@ISA="PPI::Statement::Expression";sub type {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');(_INSTANCE($schild[0],'PPI::Token::Word')and $schild[0]->content =~ /^(my|local|our|state)$/)? $schild[0]->content : undef}sub variables {map {$_->canonical}$_[0]->symbols}sub symbols {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');if (_INSTANCE($schild[1],'PPI::Token::Symbol')){return$schild[1]}if (_INSTANCE($schild[1],'PPI::Structure::List')){my$Expression=$schild[1]->schild(0);$Expression and $Expression->isa('PPI::Statement::Expression')or return ();if ($self->type eq 'my' or $self->type eq 'our' or $self->type eq 'state'){return grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}return grep {$self->_local_variable($_)}grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}()}sub _local_variable {my ($self,$el)=@_;my$n=$el->snext_sibling or return 1;my$p=$el->sprevious_sibling;if (!$p or $p eq ','){return 1 if$n eq ',';return 1 if$n eq '='}return ''}1;
PPI_STATEMENT_VARIABLE

$fatpacked{"PPI/Statement/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_WHEN';
  package PPI::Statement::When;use strict;use PPI::Statement ();our$VERSION='1.269';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_WHEN

$fatpacked{"PPI/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE';
  package PPI::Structure;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.269';our@ISA="PPI::Node";use PPI::Structure::Block ();use PPI::Structure::Condition ();use PPI::Structure::Constructor ();use PPI::Structure::For ();use PPI::Structure::Given ();use PPI::Structure::List ();use PPI::Structure::Subscript ();use PPI::Structure::Unknown ();use PPI::Structure::When ();sub new {my$class=shift;my$Token=PPI::Token::__LEXER__opens($_[0])? shift : return undef;my$self=bless {children=>[],start=>$Token,},$class;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$self);$self}sub start {$_[0]->{start}}sub finish {$_[0]->{finish}}sub braces {my$self=$_[0]->{start}? shift : return undef;return {'['=>'[]','('=>'()','{'=>'{}',}->{$self->{start}->{content}}}sub complete {!!($_[0]->{start}and $_[0]->{finish})}sub elements {my$self=shift;if (wantarray){return ($self->{start}|| (),@{$self->{children}},$self->{finish}|| ())}else {return scalar(@{$self->{children}})+ ($self->{start}? 1 : 0)+ ($self->{finish}? 1 : 0)}}sub first_element {$_[0]->{start}or $_[0]->{children}->[0]or $_[0]->{finish}}sub last_element {$_[0]->{finish}or $_[0]->{children}->[-1]or $_[0]->{start}}sub location {my$self=shift;my$first=$self->first_element or return undef;$first->location}sub tokens {my$self=shift;my@tokens=($self->{start}|| (),$self->SUPER::tokens(@_),$self->{finish}|| (),);@tokens}sub content {my$self=shift;my$content=$self->{start}? $self->{start}->content : '';for my$child (@{$self->{children}}){$content .= $child->content}$content .= $self->{finish}->content if$self->{finish};$content}sub _complete {!!(defined $_[0]->{finish})}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}1;
PPI_STRUCTURE

$fatpacked{"PPI/Structure/Block.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_BLOCK';
  package PPI::Structure::Block;use strict;use PPI::Structure ();our$VERSION='1.269';our@ISA="PPI::Structure";sub scope() {1}1;
PPI_STRUCTURE_BLOCK

$fatpacked{"PPI/Structure/Condition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONDITION';
  package PPI::Structure::Condition;use strict;use PPI::Structure ();our$VERSION='1.269';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_CONDITION

$fatpacked{"PPI/Structure/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONSTRUCTOR';
  package PPI::Structure::Constructor;use strict;use PPI::Structure ();our$VERSION='1.269';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_CONSTRUCTOR

$fatpacked{"PPI/Structure/For.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_FOR';
  package PPI::Structure::For;use strict;use PPI::Structure ();our$VERSION='1.269';our@ISA="PPI::Structure";my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){unless ($has_warned){warn("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_FOR

$fatpacked{"PPI/Structure/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_GIVEN';
  package PPI::Structure::Given;use strict;use PPI::Structure ();our$VERSION='1.269';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_GIVEN

$fatpacked{"PPI/Structure/List.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_LIST';
  package PPI::Structure::List;use strict;use Carp ();use PPI::Structure ();our$VERSION='1.269';our@ISA="PPI::Structure";my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){if ($_[0]->parent->isa('PPI::Statement::Compound')and $_[0]->parent->type =~ /^for/){unless ($has_warned){local$Carp::CarpLevel=$Carp::CarpLevel + 1;Carp::carp("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_LIST

$fatpacked{"PPI/Structure/Subscript.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_SUBSCRIPT';
  package PPI::Structure::Subscript;use strict;use PPI::Structure ();our$VERSION='1.269';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_SUBSCRIPT

$fatpacked{"PPI/Structure/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_UNKNOWN';
  package PPI::Structure::Unknown;use strict;use PPI::Structure ();our$VERSION='1.269';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_UNKNOWN

$fatpacked{"PPI/Structure/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_WHEN';
  package PPI::Structure::When;use strict;use PPI::Structure ();our$VERSION='1.269';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_WHEN

$fatpacked{"PPI/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN';
  package PPI::Token;use strict;use Params::Util qw{_INSTANCE};use PPI::Element ();use PPI::Exception ();our$VERSION='1.269';our@ISA='PPI::Element';use PPI::Token::BOM ();use PPI::Token::Whitespace ();use PPI::Token::Comment ();use PPI::Token::Pod ();use PPI::Token::Number ();use PPI::Token::Number::Binary ();use PPI::Token::Number::Octal ();use PPI::Token::Number::Hex ();use PPI::Token::Number::Float ();use PPI::Token::Number::Exp ();use PPI::Token::Number::Version ();use PPI::Token::Word ();use PPI::Token::DashedWord ();use PPI::Token::Symbol ();use PPI::Token::ArrayIndex ();use PPI::Token::Magic ();use PPI::Token::Quote::Single ();use PPI::Token::Quote::Double ();use PPI::Token::Quote::Literal ();use PPI::Token::Quote::Interpolate ();use PPI::Token::QuoteLike::Backtick ();use PPI::Token::QuoteLike::Command ();use PPI::Token::QuoteLike::Regexp ();use PPI::Token::QuoteLike::Words ();use PPI::Token::QuoteLike::Readline ();use PPI::Token::Regexp::Match ();use PPI::Token::Regexp::Substitute ();use PPI::Token::Regexp::Transliterate ();use PPI::Token::Operator ();use PPI::Token::Cast ();use PPI::Token::Structure ();use PPI::Token::Label ();use PPI::Token::HereDoc ();use PPI::Token::Separator ();use PPI::Token::Data ();use PPI::Token::End ();use PPI::Token::Prototype ();use PPI::Token::Attribute ();use PPI::Token::Unknown ();sub new {bless {content=>(defined $_[1]? "$_[1]" : '')},$_[0]}sub set_class {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;my$old_quote=(ref($self)=~ /\b(?:Quote|Regex)\b/o)? 1 : 0;my$new_quote=($class =~ /\b(?:Quote|Regex)\b/o)? 1 : 0;bless$self,$class;return$class if ($old_quote - $new_quote)==0;my$token=$class->new($self->{content});%$self=%$token;return$class}sub set_content {$_[0]->{content}=$_[1]}sub add_content {$_[0]->{content}.= $_[1]}sub length {CORE::length($_[0]->{content})}sub content {$_[0]->{content}}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}sub __TOKENIZER__on_line_start() {1}sub __TOKENIZER__on_line_end() {1}sub __TOKENIZER__on_char() {'Unknown'}sub __LEXER__opens {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\(|\[|\{)/}sub __LEXER__closes {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\)|\]|\})/}1;
PPI_TOKEN

$fatpacked{"PPI/Token/ArrayIndex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ARRAYINDEX';
  package PPI::Token::ArrayIndex;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_ARRAYINDEX

$fatpacked{"PPI/Token/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ATTRIBUTE';
  package PPI::Token::Attribute;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub identifier {my$self=shift;$self->{content}=~ /^(.+?)\(/ ? $1 : $self->{content}}sub parameters {my$self=shift;$self->{content}=~ /\((.*)\)$/ ? $1 : undef}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);unless ($char eq '('){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$string=$class->__TOKENIZER__scan_for_end($t);if (ref$string){$t->{token}->{content}.= $$string;$t->_finalize_token;return 0}$t->{token}->{content}.= $string;$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__scan_for_end {my$t=$_[1];my$string='';my$depth=0;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /\G((?:\\.|[^()])*?[()])/gc){$string .= substr($t->{line},$t->{line_cursor});$t->_fill_line(1)or return \$string;$t->{line_cursor}=0;next}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /\($/)? 1 : -1 and next;return$string}\$string}1;
PPI_TOKEN_ATTRIBUTE

$fatpacked{"PPI/Token/BOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_BOM';
  package PPI::Token::BOM;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub significant() {''}my%bom_types=("\x00\x00\xfe\xff"=>'UTF-32',"\xff\xfe\x00\x00"=>'UTF-32',"\xfe\xff"=>'UTF-16',"\xff\xfe"=>'UTF-16',"\xef\xbb\xbf"=>'UTF-8',);sub __TOKENIZER__on_line_start {my$t=$_[1];$_=$t->{line};if (m/^(\x00\x00\xfe\xff |  # UTF-32, big-endian
  		\xff\xfe\x00\x00 |  # UTF-32, little-endian
  		\xfe\xff         |  # UTF-16, big-endian
  		\xff\xfe         |  # UTF-16, little-endian
  		\xef\xbb\xbf)       # UTF-8
  	    /xs){my$bom=$1;if ($bom_types{$bom}ne 'UTF-8'){return$t->_error("$bom_types{$bom} is not supported")}$t->_new_token('BOM',$bom)or return undef;$t->{line_cursor}+= length$bom}$t->{class}='PPI::Token::Whitespace';return$t->{class}->__TOKENIZER__on_line_start($t)}1;
PPI_TOKEN_BOM

$fatpacked{"PPI/Token/Cast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_CAST';
  package PPI::Token::Cast;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";our%POSTFIX=map {$_=>1}(qw{%* @* $*},'$#*');sub __TOKENIZER__on_char {my$t=$_[1];my$char=substr($t->{line},$t->{line_cursor},1);my$content=$t->{token}->{content};return 1 if$POSTFIX{$content .$char };$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_CAST

$fatpacked{"PPI/Token/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_COMMENT';
  package PPI::Token::Comment;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub significant() {''}sub __TOKENIZER__on_char {my$t=$_[1];if (substr($t->{line},$t->{line_cursor},1)eq "\n"){return$t->_finalize_token->__TOKENIZER__on_char($t)}1}sub __TOKENIZER__commit {my$t=$_[1];my$rest=substr($t->{line},$t->{line_cursor});if (chomp$rest){$t->_new_token('Comment',$rest);$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$rest)}$t->{line_cursor}=$t->{line_length}- 1;0}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token};1}sub line {$_[0]->{content}=~ /\n$/ ? 1 : 0}1;
PPI_TOKEN_COMMENT

$fatpacked{"PPI/Token/DashedWord.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DASHEDWORD';
  package PPI::Token::DashedWord;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";*literal=*PPI::Token::Word::literal;sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}if ($t->{token}->{content}=~ /^\-[rwxoRWXOezsfdlpSbctugkTBMAC]$/){$t->{class}=$t->{token}->set_class('Operator')}else {$t->{class}=$t->{token}->set_class('Word')}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_DASHEDWORD

$fatpacked{"PPI/Token/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DATA';
  package PPI::Token::Data;use strict;use IO::String 1.07 ();use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub handle {my$self=shift;IO::String->new(\$self->{content})}sub __TOKENIZER__on_line_start {my ($self,$t)=@_;if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {defined($t->{token}=$t->{class}->new($t->{line}))or return undef}return 0}1;
PPI_TOKEN_DATA

$fatpacked{"PPI/Token/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_END';
  package PPI::Token::End;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub significant() {''}sub __TOKENIZER__on_char() {1}sub __TOKENIZER__on_line_start {my$t=$_[1];if ($t->{line}=~ /^=(\w+)/){$t->_new_token('Pod',$t->{line});unless ($1 eq 'cut'){$t->{class}='PPI::Token::Pod'}}else {if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {$t->_new_token('End',$t->{line})}}0}1;
PPI_TOKEN_END

$fatpacked{"PPI/Token/HereDoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_HEREDOC';
  package PPI::Token::HereDoc;use strict;our$VERSION='1.269';our@ISA="PPI::Token";sub heredoc {@{shift->{_heredoc}}}sub terminator {shift->{_terminator}}sub _is_terminator {my ($self,$terminator,$line,$indented)=@_;if ($indented){return$line =~ /^\s*\Q$terminator\E$/}else {return$line eq $terminator}}sub _indent {my ($self,$token)=@_;my ($indent)=$token->{_terminator_line}=~ /^(\s*)/;return$indent}sub _is_match_indent {my ($self,$token,$indent)=@_;return (grep {/^$indent/}@{$token->{_heredoc}})==@{$token->{_heredoc}}}sub __TOKENIZER__on_char {my ($self,$t)=@_;pos$t->{line}=$t->{line_cursor};if ($t->{line}!~ m/\G( ~? \s* (?: "[^"]*" | '[^']*' | `[^`]*` | \\?\w+ ) )/gcx){$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}my$token=$t->{token};$token->{content}.= $1;$t->{line_cursor}+= length $1;my$content=$token->{content};if ($content =~ /^\<\<(~?)(\w+)$/){$token->{_mode}='interpolate';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2}elsif ($content =~ /^\<\<(~?)\s*\'(.*)\'$/){$token->{_mode}='literal';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\'/'/g}elsif ($content =~ /^\<\<(~?)\s*\"(.*)\"$/){$token->{_mode}='interpolate';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\"/"/g}elsif ($content =~ /^\<\<(~?)\s*\`(.*)\`$/){$token->{_mode}='command';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\`/`/g}elsif ($content =~ /^\<\<(~?)\\(\w+)$/){$token->{_mode}='literal';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2}else {return undef}$token->{_heredoc}=\my@heredoc;my$terminator=$token->{_terminator}."\n";while (defined(my$line=$t->_get_line)){if ($self->_is_terminator($terminator,$line,$token->{_indented})){$token->{_terminator_line}=$line;if ($token->{_indented}){my$indent=$self->_indent($token);unless ($self->_is_match_indent($token,$indent)){push@heredoc,$line;last}s/^$indent// for@heredoc,$token->{_terminator_line}}return$t->_finalize_token->__TOKENIZER__on_char($t)}push@heredoc,$line}$token->{_terminator_line}=undef;if (@heredoc and defined$heredoc[-1]){if ($t->{source_eof_chop}){chop$heredoc[-1];$t->{source_eof_chop}=''}$token->{_terminator_line}=pop@heredoc if$self->_is_terminator($token->{_terminator},$heredoc[-1],$token->{_indented})}if ($token->{_indented}&& $token->{_terminator_line}){my$indent=$self->_indent($token);if ($self->_is_match_indent($token,$indent)){s/^$indent// for@heredoc}s/^$indent// for$token->{_terminator_line}}$token->{_damaged}=1;$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_HEREDOC

$fatpacked{"PPI/Token/Label.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_LABEL';
  package PPI::Token::Label;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";1;
PPI_TOKEN_LABEL

$fatpacked{"PPI/Token/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_MAGIC';
  package PPI::Token::Magic;use strict;use PPI::Token::Symbol ();use PPI::Token::Unknown ();use PPI::Singletons qw'%MAGIC $CURLY_SYMBOL';our$VERSION='1.269';our@ISA="PPI::Token::Symbol";sub __TOKENIZER__on_char {my$t=$_[1];my$c=$t->{token}->{content}.substr($t->{line},$t->{line_cursor},1);if ($c =~ /^  \$  .*  [  \w  :  \$  \{  ]  $/x){if ($c =~ /^(\$(?:\_[\w:]|::))/ or $c =~ /^\$\'[\w]/){if ($c =~ /^\$\'\d$/){return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Symbol');return PPI::Token::Symbol->__TOKENIZER__on_char($t)}if ($c =~ /^\$\$\w/){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Symbol','$')}if ($c eq '$${'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Magic','$')}}if ($c eq '$#$' or $c eq '$#{'){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($c =~ /^(\$\#)\w/){$t->{token}=PPI::Token::ArrayIndex->new("$1");return PPI::Token::ArrayIndex->__TOKENIZER__on_char($t)}if ($c =~ /^\$\^\w+$/o){my$next=substr($t->{line},$t->{line_cursor}+1,1);if ($MAGIC{$c}&& (!$next || $next !~ /\w/)){$t->{token}->{content}=$c;$t->{line_cursor}++}else {return 1}}if ($c =~ /^\$\#\{/){$t->{token}=PPI::Token::Cast->new('$#');$t->_finalize_token;return$t->_new_token('Structure','{')}}elsif ($c =~ /^%\^/){return 1 if$c eq '%^';if ($MAGIC{$c}){$t->{token}->{content}=$c;$t->{line_cursor}++}else {chop$t->{token}->{content};bless$t->{token},$t->{class}='PPI::Token::Operator';$t->{line_cursor}--}}if ($MAGIC{$c}){$t->{line_cursor}+= length($c)- length($t->{token}->{content});$t->{token}->{content}=$c}else {pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/($CURLY_SYMBOL)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}elsif ($c =~ /^\$\d+$/ and $t->{line}=~ /\G(\d+)/gc){$t->{token}{content}.= $1;$t->{line_cursor}+= length $1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub canonical {$_[0]->content}1;
PPI_TOKEN_MAGIC

$fatpacked{"PPI/Token/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER';
  package PPI::Token::Number;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub base() {10}sub literal {return 0 + $_[0]->_literal}sub _literal {my$self=shift;my$string=$self->content;$string =~ s/^\+//;$string =~ s/_//g;return$string}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';my$token=$t->{token};if ($token->{content}=~ /^-?0_*$/){if ($char eq 'x' || $char eq 'X'){$t->{class}=$t->{token}->set_class('Number::Hex');return 1}elsif ($char eq 'b' || $char eq 'B'){$t->{class}=$t->{token}->set_class('Number::Binary');return 1}elsif ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$token->{_error}="Illegal character in octal number '$char'"}$t->{class}=$t->{token}->set_class('Number::Octal');return 1}}return 1 if$char =~ /\d/o;if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char eq 'e' || $char eq 'E'){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER

$fatpacked{"PPI/Token/Number/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_BINARY';
  package PPI::Token::Number::Binary;use strict;use PPI::Token::Number ();our$VERSION='1.269';our@ISA="PPI::Token::Number";sub base() {2}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^0[bB]//;my$val=0;for my$bit ($str =~ m/(.)/g){$val=$val * 2 + $bit}return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[\w\d]/){unless ($char eq '1' or $char eq '0'){$t->{token}->{_error}="Illegal character in binary number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_BINARY

$fatpacked{"PPI/Token/Number/Exp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_EXP';
  package PPI::Token::Number::Exp;use strict;use PPI::Token::Number::Float ();our$VERSION='1.269';our@ISA="PPI::Token::Number::Float";sub literal {my$self=shift;return if$self->{_error};my ($mantissa,$exponent)=split m/e/i,$self->_literal;my$neg=$mantissa =~ s/^\-//;$mantissa =~ s/^\./0./;$exponent =~ s/^\+//;$exponent += 0;my$negpow=0;if ($exponent < 0){$negpow=1;$exponent *= -1}my$result=1;my$power=10;for (my$bit=1;$exponent;$bit=$bit << 1){if ($exponent & $bit){$exponent=$exponent ^ $bit;$result *= $power}$power *= $power}my$val=$neg ? 0 - $mantissa : $mantissa;return$negpow ? $val / $result : $val * $result}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($t->{token}->{content}=~ /e$/i){return 1 if$char eq '-' || $char eq '+';if ($t->{token}->{content}=~ s/\.(e)$//i){my$word=$1;$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','.');$t->_new_token('Word',$word);return$t->{class}->__TOKENIZER__on_char($t)}else {$t->{token}->{_error}="Illegal character in exponent '$char'"}}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_EXP

$fatpacked{"PPI/Token/Number/Float.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_FLOAT';
  package PPI::Token::Number::Float;use strict;use PPI::Token::Number ();our$VERSION='1.269';our@ISA="PPI::Token::Number";sub base() {10}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^\./0./;my$val=0+$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($char eq '.'){if ($t->{token}{content}=~ /\.$/){chop$t->{token}{content};$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','..');return 0}elsif ($t->{token}{content}=~ /\._/){($t->{token}{content},my$bareword)=split /\./,$t->{token}{content};$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','.');$t->_new_token('Word',$bareword);$t->_new_token('Operator','.');return 0}else {$t->{class}=$t->{token}->set_class('Number::Version');return 1}}my$char2=substr$t->{line},$t->{line_cursor}+1,1;if ("$char$char2" =~ /[eE][0-9+-]/){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_FLOAT

$fatpacked{"PPI/Token/Number/Hex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_HEX';
  package PPI::Token::Number::Hex;use strict;use PPI::Token::Number ();our$VERSION='1.269';our@ISA="PPI::Token::Number";sub base() {16}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=hex lc($str);return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[[:xdigit:]]/){return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_HEX

$fatpacked{"PPI/Token/Number/Octal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_OCTAL';
  package PPI::Token::Number::Octal;use strict;use PPI::Token::Number ();our$VERSION='1.269';our@ISA="PPI::Token::Number";sub base() {8}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=oct$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$t->{token}->{_error}="Illegal character in octal number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_OCTAL

$fatpacked{"PPI/Token/Number/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_VERSION';
  package PPI::Token::Number::Version;use strict;use PPI::Token::Number ();our$VERSION='1.269';our@ISA="PPI::Token::Number";sub base() {256}sub literal {my$self=shift;my$content=$self->{content};$content =~ s/^v//;return join '',map {chr $_}(split /\./,$content)}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char =~ /\d/o;if($char eq '_'){return 1 if$t->{token}{content}!~ /\.$/;chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number::Float')if$t->{token}{content}!~ /\..+\./;$t->_new_token('Operator','.');$t->_new_token('Word','_');return 0}if ($char eq '.'){if ($t->{token}->{content}=~ /\.$/){chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number::Float')if$t->{token}{content}!~ /\..+\./;$t->_new_token('Operator','..');return 0}else {return 1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my$t=$_[1];pos$t->{line}=$t->{line_cursor};return PPI::Token::Word->__TOKENIZER__commit($t)if$t->{line}!~ m/\G(v\d[_\d]*(?:\.\d[_\d]*)+|v\d[_\d]*\b)/gc;my$content=$1;return PPI::Token::Word->__TOKENIZER__commit($t)if$content !~ /\./ and $t->__current_token_is_forced_word($content);$t->{line_cursor}+= length$content;$t->_new_token('Number::Version',$content);$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_VERSION

$fatpacked{"PPI/Token/Operator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_OPERATOR';
  package PPI::Token::Operator;use strict;use PPI::Token ();use PPI::Singletons '%OPERATOR';our$VERSION='1.269';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$t=$_[1];my$char=substr($t->{line},$t->{line_cursor},1);my$content=$t->{token}->{content};if(length($content)< 4 && $content .substr($t->{line},$t->{line_cursor},4 - length($content))eq '<<>>'){return 1}return 1 if$OPERATOR{$content .$char };if ($content eq '.'){if ($char =~ /^[0-9]$/){$t->{class}=$t->{token}->set_class('Number::Float');return$t->{class}->__TOKENIZER__on_char($t)}}if ($content eq '<<'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G ~? (?: (?!\d)\w | \s*['"`] | \\\w ) /gcx){$t->{class}=$t->{token}->set_class('HereDoc');return$t->{class}->__TOKENIZER__on_char($t)}}$t->{class}=$t->{token}->set_class('QuoteLike::Readline')if$content eq '<>' or $content eq '<<>>';$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_OPERATOR

$fatpacked{"PPI/Token/Pod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_POD';
  package PPI::Token::Pod;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub merge {my$class=(!ref $_[0])? shift : return undef;if (grep {!_INSTANCE($_,'PPI::Token::Pod')}@_){return undef}my@content=(map {[$_->lines ]}@_)or return undef;for my$pod (@content){if (@$pod and $pod->[0]=~ /^=pod\b/o){shift @$pod}if (@$pod and $pod->[-1]=~ /^=cut\b/o){pop @$pod}while (@$pod and $pod->[0]eq ''){shift @$pod}while (@$pod and $pod->[-1]eq ''){pop @$pod}}@content=(['=pod' ],grep {@$_}@content,['=cut' ]);$class->new(join "\n",map {join("\n",@$_)."\n"}@content)}sub lines {split /(?:\015{1,2}\012|\015|\012)/,$_[0]->{content}}sub significant() {''}sub __TOKENIZER__on_line_start {my$t=$_[1];$t->{token}->{content}.= $t->{line};if ($t->{line}=~ /^=(\w+)/){$t->_finalize_token if $1 eq 'cut'}0}1;
PPI_TOKEN_POD

$fatpacked{"PPI/Token/Prototype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_PROTOTYPE';
  package PPI::Token::Prototype;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};die "regex should always match" if$t->{line}!~ m/\G(.*?(?:\)|$))/gc;$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1;return 0 unless $1 =~ /\)$/;$t->_finalize_token->__TOKENIZER__on_char($t)}sub prototype {my$self=shift;my$proto=$self->content;$proto =~ s/(^\(|\)$|\s+)//g;$proto}1;
PPI_TOKEN_PROTOTYPE

$fatpacked{"PPI/Token/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE';
  package PPI::Token::Quote;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";1;
PPI_TOKEN_QUOTE

$fatpacked{"PPI/Token/Quote/Double.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_DOUBLE';
  package PPI::Token::Quote::Double;use strict;use Params::Util qw{_INSTANCE};use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote};sub interpolations {!!($_[0]->content =~ /(?<!\\)(?:\\\\)*[\$\@]/)}sub simplify {my$self=_INSTANCE(shift,'PPI::Token::Quote::Double')or return undef;my$content=$self->content;my$value=substr($content,1,length($content)- 2);return$self if$value =~ /[\\\$@\'\"]/;$self->{content}="'$value'";bless$self,'PPI::Token::Quote::Single'}sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}1;
PPI_TOKEN_QUOTE_DOUBLE

$fatpacked{"PPI/Token/Quote/Interpolate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_INTERPOLATE';
  package PPI::Token::Quote::Interpolate;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote};sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}1;
PPI_TOKEN_QUOTE_INTERPOLATE

$fatpacked{"PPI/Token/Quote/Literal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_LITERAL';
  package PPI::Token::Quote::Literal;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote};sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}*literal=*PPI::Token::Quote::Single::literal;1;
PPI_TOKEN_QUOTE_LITERAL

$fatpacked{"PPI/Token/Quote/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_SINGLE';
  package PPI::Token::Quote::Single;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote};sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}my%UNESCAPE=("\\'"=>"'","\\\\"=>"\\",);sub literal {my$str=$_[0]->string;$str =~ s/(\\.)/$UNESCAPE{$1} || $1/ge;return$str}1;
PPI_TOKEN_QUOTE_SINGLE

$fatpacked{"PPI/Token/QuoteLike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE';
  package PPI::Token::QuoteLike;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";1;
PPI_TOKEN_QUOTELIKE

$fatpacked{"PPI/Token/QuoteLike/Backtick.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_BACKTICK';
  package PPI::Token::QuoteLike::Backtick;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_BACKTICK

$fatpacked{"PPI/Token/QuoteLike/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_COMMAND';
  package PPI::Token::QuoteLike::Command;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_COMMAND

$fatpacked{"PPI/Token/QuoteLike/Readline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_READLINE';
  package PPI::Token::QuoteLike::Readline;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_READLINE

$fatpacked{"PPI/Token/QuoteLike/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_REGEXP';
  package PPI::Token::QuoteLike::Regexp;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return undef}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_QUOTELIKE_REGEXP

$fatpacked{"PPI/Token/QuoteLike/Words.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_WORDS';
  package PPI::Token::QuoteLike::Words;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};sub literal {my ($self)=@_;my$content=$self->_section_content(0);return if!defined$content;my ($left,$right)=($self->_delimiters,'','');$content =~ s/\\([\Q$left$right\\\E])/$1/g;my@words=split ' ',$content;return@words}1;
PPI_TOKEN_QUOTELIKE_WORDS

$fatpacked{"PPI/Token/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP';
  package PPI::Token::Regexp;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return $_[0]->_section_content(1)}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_REGEXP

$fatpacked{"PPI/Token/Regexp/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_MATCH';
  package PPI::Token::Regexp::Match;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_MATCH

$fatpacked{"PPI/Token/Regexp/Substitute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_SUBSTITUTE';
  package PPI::Token::Regexp::Substitute;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_SUBSTITUTE

$fatpacked{"PPI/Token/Regexp/Transliterate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_TRANSLITERATE';
  package PPI::Token::Regexp::Transliterate;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.269';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_TRANSLITERATE

$fatpacked{"PPI/Token/Separator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SEPARATOR';
  package PPI::Token::Separator;use strict;use PPI::Token::Word ();our$VERSION='1.269';our@ISA="PPI::Token::Word";1;
PPI_TOKEN_SEPARATOR

$fatpacked{"PPI/Token/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_STRUCTURE';
  package PPI::Token::Structure;use strict;use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";my%MATCH=(ord '{'=>'}',ord '}'=>'{',ord '['=>']',ord ']'=>'[',ord '('=>')',ord ')'=>'(',);my%OPENS=(ord '{'=>1,ord '['=>1,ord '('=>1,);my%CLOSES=(ord '}'=>1,ord ']'=>1,ord ')'=>1,);sub __TOKENIZER__on_char {$_[1]->_finalize_token->__TOKENIZER__on_char($_[1])}sub __TOKENIZER__commit {my$t=$_[1];$t->_new_token('Structure',substr($t->{line},$t->{line_cursor},1));$t->_finalize_token;0}sub __LEXER__opposite {$MATCH{ord $_[0]->{content}}}sub next_sibling {return $_[0]->SUPER::next_sibling if $_[0]->{content}eq ';';return ''}sub snext_sibling {return $_[0]->SUPER::snext_sibling if $_[0]->{content}eq ';';return ''}sub previous_sibling {return $_[0]->SUPER::previous_sibling if $_[0]->{content}eq ';';return ''}sub sprevious_sibling {return $_[0]->SUPER::sprevious_sibling if $_[0]->{content}eq ';';return ''}sub next_token {my$self=shift;return$self->SUPER::next_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($OPENS{ord$self->{content}}){my$child=$structure->child(0);if ($child){return$child->isa('PPI::Token')? $child : $child->first_token}elsif ($structure->finish){return$structure->finish}}$structure->next_token}sub previous_token {my$self=shift;return$self->SUPER::previous_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($CLOSES{ord$self->{content}}){my$child=$structure->child(-1);if ($child){return$child->isa('PPI::Token')? $child : $child->last_token}elsif ($structure->start){return$structure->start}}$structure->previous_token}1;
PPI_TOKEN_STRUCTURE

$fatpacked{"PPI/Token/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SYMBOL';
  package PPI::Token::Symbol;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";sub canonical {my$symbol=shift->content;$symbol =~ s/\s+//;$symbol =~ s/\'/::/g;$symbol =~ s/(?<=[\$\@\%\&\*])::/main::/;$symbol}my%cast_which_trumps_braces=map {$_=>1}qw{$ @ %};sub symbol {my$self=shift;my$symbol=$self->canonical;my$type=substr($symbol,0,1);return$symbol if$type eq '&';my$after=$self->snext_sibling;return$symbol unless _INSTANCE($after,'PPI::Structure');my$braces=$after->braces;return$symbol unless defined$braces;if ($type eq '$'){my$before=$self->sprevious_sibling;return$symbol if$before && $before->isa('PPI::Token::Cast')&& $cast_which_trumps_braces{$before->content };substr($symbol,0,1,'@')if$braces eq '[]';substr($symbol,0,1,'%')if$braces eq '{}'}elsif ($type eq '@'){substr($symbol,0,1,'%')if$braces eq '{}'}elsif ($type eq '%'){substr($symbol,0,1,'@')if$braces eq '[]'}$symbol}sub raw_type {substr($_[0]->content,0,1)}sub symbol_type {substr($_[0]->symbol,0,1)}sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:\']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}my$content=$t->{token}->{content};if ($content eq '@_' or $content eq '$_'){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content eq '$::'){my$nextchar=substr($t->{line},$t->{line_cursor},1);if ($nextchar eq '|'){$t->{token}->{content}.= $nextchar;$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Magic')}return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^[\$%*@&]::(?:[^\w]|$)/){my$current=substr($content,0,3,'');$t->{token}->{content}=$current;$t->{line_cursor}-= length($content);return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^(?:\$|\@)\d+/){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}$content =~ /^(
  		[\$@%&*]
  		(?: : (?!:) | # Allow single-colon non-magic variables
  			(?: \w+ | \' (?!\d) \w+ | \:: \w+ )
  			(?:
  				# Allow both :: and ' in namespace separators
  				(?: \' (?!\d) \w+ | \:: \w+ )
  			)*
  			(?: :: )? # Technically a compiler-magic hash, but keep it here
  		)
  	)/x or return undef;unless (length $1 eq length$content){$t->{line_cursor}+= length($1)- length($content);$t->{token}->{content}=$1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_SYMBOL

$fatpacked{"PPI/Token/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_UNKNOWN';
  package PPI::Token::Unknown;use strict;use PPI::Token ();use PPI::Exception ();use PPI::Singletons qw'%MAGIC $CURLY_SYMBOL';our$VERSION='1.269';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my ($self,$t)=@_;my$c=$t->{token}->{content};my$char=substr($t->{line},$t->{line_cursor},1);if ($c eq '*'){if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char eq '*' || $char eq '='){$t->{class}=$t->{token}->set_class('Operator');return 1}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '$'){if ($char eq '*' || $char eq '#'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /[a-z_]/i){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '@'){if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /[\w:]/){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '%'){if ($char eq '*' || $char eq '['){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){if ($char eq '*'){$t->{class}=$t->{token}->set_class('Cast');return 1}if ($char eq '['){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}}}if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char eq '^' || $MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '&'){if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '-'){if ($char =~ /\d/o){$t->{class}=$t->{token}->set_class('Number');return 1}if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char =~ /[a-zA-Z]/){$t->{class}=$t->{token}->set_class('DashedWord');return 1}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq ':'){if ($char eq ':'){$t->{class}=$t->{token}->set_class('Word');return 1}if ($self->__TOKENIZER__is_an_attribute($t)){$t->{class}=$t->{token}->set_class('Operator');$t->{token}->{_attribute}=1;return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}PPI::Exception->throw('Unknown value in PPI::Token::Unknown token')}sub _is_cast_or_op {my ($self,$char)=@_;return 1 if$char eq '$';return 1 if$char eq '@';return 1 if$char eq '%';return 1 if$char eq '*';return 1 if$char eq '{';return}sub _as_cast_or_op {my ($self,$t)=@_;my$class=_cast_or_op($t);$t->{class}=$t->{token}->set_class($class);return$t->_finalize_token->__TOKENIZER__on_char($t)}sub _prev_significant_w_cursor {my ($tokens,$cursor,$extra_check)=@_;while ($cursor >= 0){my$token=$tokens->[$cursor-- ];next if!$token->significant;next if$extra_check and!$extra_check->($token);return ($token,$cursor)}return (undef,$cursor)}sub _cast_or_op {my ($t)=@_;my$tokens=$t->{tokens};my$cursor=scalar(@$tokens)- 1;my$token;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Cast' if!$token;if ($token->isa('PPI::Token::Structure')and $token->content eq '}'){my$structure_depth=1;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor,sub {my ($token)=@_;return if!$token->isa('PPI::Token::Structure');if ($token eq '}'){$structure_depth++;return}if ($token eq '{'){$structure_depth--;return if$structure_depth}return 1});return 'Operator' if!$token;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Operator' if!$token;return 'Operator' if$token->isa('PPI::Token::Symbol');my%meth_or_subscript_end=map {$_=>1}qw@-> } ]@;return 'Operator' if$meth_or_subscript_end{$token->content };my$content=$token->content;my$produces_or_wants_value=($token->isa('PPI::Token::Word')and ($content eq 'do' or $content eq 'eval'));return$produces_or_wants_value ? 'Operator' : 'Cast'}my%list_start_or_term_end=map {$_=>1}qw@; ( { [@;return 'Cast' if$token->isa('PPI::Token::Structure')and $list_start_or_term_end{$token->content }or $token->isa('PPI::Token::Cast')or $token->isa('PPI::Token::Operator')or $token->isa('PPI::Token::Label');return 'Operator' if!$token->isa('PPI::Token::Word');($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Cast' if!$token || $token->content ne '->';return 'Operator'}sub __TOKENIZER__is_an_attribute {my$t=$_[1];my@tokens=$t->_previous_significant_tokens(3);my$p0=$tokens[0];return '' if not $p0;return 1 if$p0->isa('PPI::Token::Attribute');return 1 if$p0->isa('PPI::Token::Prototype');return '' unless$p0->isa('PPI::Token::Word');if ($p0->isa('PPI::Token::Word')and $p0->content eq 'sub'){return 1}my$p1=$tokens[1];my$p2=$tokens[2];if ($p1 and $p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and (not $p2 or $p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq ''))){return 1}''}1;
PPI_TOKEN_UNKNOWN

$fatpacked{"PPI/Token/Whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WHITESPACE';
  package PPI::Token::Whitespace;use strict;use Clone ();use PPI::Token ();our$VERSION='1.269';our@ISA="PPI::Token";my$null;sub null {$null ||= $_[0]->new('');Clone::clone($null)}sub significant() {''}sub tidy {$_[0]->{content}=~ s/^\s+?(?>\n)//;1}my%COMMITMAP=(map({ord $_=>'PPI::Token::Word'}'a' .. 'u','A' .. 'Z',qw"w y z _"),map({ord $_=>'PPI::Token::Structure'}qw"; [ ] { } )"),ord '#'=>'PPI::Token::Comment',ord 'v'=>'PPI::Token::Number::Version',);my%CLASSMAP=(map({ord $_=>'Number'}0 .. 9),map({ord $_=>'Operator'}qw"= ? | + > . ! ~ ^"),map({ord $_=>'Unknown'}qw"* $ @ & : %"),ord ','=>'PPI::Token::Operator',ord "'"=>'Quote::Single',ord '"'=>'Quote::Double',ord '`'=>'QuoteLike::Backtick',ord '\\'=>'Cast',ord '_'=>'Word',9=>'Whitespace',10=>'Whitespace',12=>'Whitespace',13=>'Whitespace',32=>'Whitespace',);my%MATCHWORD=map {$_=>1}qw{return split if unless grep map};sub __TOKENIZER__on_line_start {my$t=$_[1];my$line=$t->{line};if ($line =~ /^\s*$/){$t->_new_token('Whitespace',$line);return 0}elsif ($line =~ /^\s*#/){$t->_new_token('Comment',$line);$t->_finalize_token;return 0}elsif ($line =~ /^=(\w+)/){$t->_new_token('Pod',$line);if ($1 eq 'cut'){}else {$t->{class}='PPI::Token::Pod'}return 0}elsif ($line =~ /^use v6\-alpha\;/){my@perl6;while (1){my$line6=$t->_get_line;last unless defined$line6;push@perl6,$line6}push @{$t->{perl6}},join '',@perl6;return 1}1}sub __TOKENIZER__on_char {my$t=$_[1];my$c=substr$t->{line},$t->{line_cursor},1;my$char=ord$c;return$COMMITMAP{$char}->__TOKENIZER__commit($t)if$COMMITMAP{$char};return$CLASSMAP{$char}if$CLASSMAP{$char};if ($char==40){$t->_finalize_token if$t->{token};my@tokens=$t->_previous_significant_tokens(3);my$p1=$tokens[1];my$p2=$tokens[2];if ($tokens[0]and $tokens[0]->isa('PPI::Token::Word')and $p1 and $p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and (not $p2 or $p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq '')or ($p2->isa('PPI::Token::Word')and $p2->content =~ /^(?:my|our|state)$/))){return 'Prototype'}my$p0=$tokens[0];if ($p0 and $p0->isa('PPI::Token::Word')and $p0->content eq 'sub' and not ($p1 and $p1->isa('PPI::Token::Operator')and $p1->content eq '->')){return 'Prototype'}return 'Structure'}elsif ($char==60){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;return 'Operator' if$prev and $prev->isa('PPI::Token::Symbol');return 'Operator' if$prev and $prev->isa('PPI::Token::Magic');return 'Operator' if$prev and $prev->isa('PPI::Token::Number');return 'Operator' if$prev and $prev->isa('PPI::Token::ArrayIndex');my$next_char=substr($t->{line},$t->{line_cursor}+ 1,2);return 'Operator' if$next_char =~ /<[^>]/;return 'Operator' if not $prev;my$prec=$prev->content;return 'QuoteLike::Readline' if ($prev->isa('PPI::Token::Structure')and $prec eq '(')or ($prev->isa('PPI::Token::Structure')and $prec eq ';')or ($prev->isa('PPI::Token::Word')and $prec eq 'while')or ($prev->isa('PPI::Token::Operator')and $prec eq '=')or ($prev->isa('PPI::Token::Operator')and $prec eq ',');if ($prev->isa('PPI::Token::Structure')and $prec eq '}'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G<(?!\d)\w+>/gc){return 'QuoteLike::Readline'}}return 'Operator'}elsif ($char==47){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;return 'Regexp::Match' if not $prev;my$prec=$prev->content;return 'Regexp::Match' if$prev->isa('PPI::Token::Operator');return 'Operator' if$prev->isa('PPI::Token::Symbol');if ($prec eq ']' and $prev->isa('PPI::Token::Structure')){return 'Operator'}return 'Operator' if$prev->isa('PPI::Token::Number');if ($prev->isa('PPI::Token::Structure')and ($prec eq '(' or $prec eq '{' or $prec eq ';')){return 'Regexp::Match'}if ($MATCHWORD{$prec}and $prev->isa('PPI::Token::Word')){return 'Regexp::Match'}my$next_char=substr$t->{line},$t->{line_cursor}+ 1,1;if (defined$next_char and length$next_char){if ($next_char =~ /(?:\^|\[|\\)/){return 'Regexp::Match'}}return 'Operator'}elsif ($char==120){if ($t->_current_x_is_operator){pos$t->{line}=$t->{line_cursor}+ 1;return 'Operator' if$t->{line}=~ m/\G(?:
  				\d  # x op with no whitespace e.g. 'x3'
  				|
  				(?!(  # negative lookahead
  					=>  # not on left of fat comma
  					|
  					\w  # not a word like "xyzzy"
  					|
  					\s  # not x op plus whitespace
  				))
  			)/gcx}return PPI::Token::Word->__TOKENIZER__commit($t)}elsif ($char==45){my$context=$t->_opcontext;if ($context eq 'operator'){return 'Operator'}else {return 'Unknown'}}elsif ($char >= 128){return 'PPI::Token::Word'->__TOKENIZER__commit($t)if$c =~ /\w/;return 'Whitespace' if$c =~ /\s/}PPI::Exception->throw("Encountered unexpected character '$char'")}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token}}1;
PPI_TOKEN_WHITESPACE

$fatpacked{"PPI/Token/Word.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WORD';
  package PPI::Token::Word;use strict;use PPI::Token ();use PPI::Singletons qw'%OPERATOR %QUOTELIKE %KEYWORDS';our$VERSION='1.269';our@ISA="PPI::Token";sub literal {my$self=shift;my$word=$self->content;$word =~ s/\'/::/g;return$word}sub method_call {my$self=shift;my$previous=$self->sprevious_sibling;if ($previous and $previous->isa('PPI::Token::Operator')and $previous->content eq '->'){return 1}my$snext=$self->snext_sibling;return 0 unless$snext;if ($snext->isa('PPI::Structure::List')or $snext->isa('PPI::Token::Structure')or $snext->isa('PPI::Token::Operator')and ($snext->content eq ',' or $snext->content eq '=>')){return 0}if ($snext->isa('PPI::Token::Word')and $snext->content =~ m< \w :: \z >xms){return 1}return}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{token}->{content}.= $word;$t->{line_cursor}+= length$word}if (__current_token_is_attribute($t)){$t->{class}=$t->{token}->set_class('Attribute');return$t->{class}->__TOKENIZER__commit($t)}my$word=$t->{token}->{content};if ($KEYWORDS{$word}){if ($t->__current_token_is_forced_word){$t->{class}=$t->{token}->set_class('Word');return$t->{class}->__TOKENIZER__on_char($t)}if ($QUOTELIKE{$word}){$t->{class}=$t->{token}->set_class($QUOTELIKE{$word});return$t->{class}->__TOKENIZER__on_char($t)}if ($OPERATOR{$word}){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}}if ($word =~ /\:/){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$char=substr($t->{line},$t->{line_cursor},1);if ($char eq ':'){$t->{token}->{content}.= ':';$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Label')}elsif ($word eq '_'){$t->{class}=$t->{token}->set_class('Magic')}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my ($class,$t)=@_;pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ m/\G((?!\d)\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){die sprintf "Fatal error... regex failed to match in '%s' when expected",substr$t->{line},$t->{line_cursor}}my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{line_cursor}+= length$word;if (__current_token_is_attribute($t)){$t->_new_token('Attribute',$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}if ($word eq '__END__'){$t->_new_token('Separator',$1);$t->_finalize_token;$t->{zone}='PPI::Token::End';my$end_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($end_rest =~ /\n$/){chomp$end_rest;$t->_new_token('Comment',$end_rest)if length$end_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$end_rest)if length$end_rest}$t->_finalize_token;return 0}if ($word eq '__DATA__'){$t->_new_token('Separator',"$1");$t->_finalize_token;$t->{zone}='PPI::Token::Data';my$data_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($data_rest =~ /\n$/){chomp$data_rest;$t->_new_token('Comment',$data_rest)if length$data_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$data_rest)if length$data_rest}$t->_finalize_token;return 0}my$token_class;if ($word =~ /\:/){$token_class='Word'}elsif ($KEYWORDS{$word}and $t->__current_token_is_forced_word){$token_class='Word'}elsif ($QUOTELIKE{$word}){$t->_new_token($QUOTELIKE{$word},$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}elsif ($OPERATOR{$word}&& ($word ne 'x' || $t->_current_x_is_operator)){$token_class='Operator'}else {my@tokens=$t->_previous_significant_tokens(1);pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\s*:)(?!:)/gc){if ($tokens[0]and $tokens[0]->{content}eq 'sub'){$token_class='Word'}else {$word .= $1;$t->{line_cursor}+= length($1);$token_class='Label'}}elsif ($word eq '_'){$token_class='Magic'}else {$token_class='Word'}}$t->_new_token($token_class,$word);if ($t->{line_cursor}>= $t->{line_length}){$t->_finalize_token;return 0}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __current_token_is_attribute {my ($t)=@_;my@tokens=$t->_previous_significant_tokens(1);return ($tokens[0]and ($tokens[0]->{_attribute}or $tokens[0]->isa('PPI::Token::Attribute')))}1;
PPI_TOKEN_WORD

$fatpacked{"PPI/Token/_QuoteEngine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE';
  package PPI::Token::_QuoteEngine;use strict;use Carp ();our$VERSION='1.269';sub __TOKENIZER__on_char {my$class=shift;my$t=$_[0]->{token}? shift : return undef;my$rv=$t->{token}->_fill($t);return undef unless defined$rv;$t->_finalize_token;0}sub _scan_for_unescaped_character {my$class=shift;my$t=shift;my$char=(length $_[0]==1)? quotemeta shift : return undef;my$search=qr/(.*?(?<!\\)(?:\\\\)*$char)/;my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G$search/gc){$t->{line_cursor}+= length($1)- 1;return$string .$1}$string .= substr$t->{line},$t->{line_cursor};my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}sub _scan_for_brace_character {my$class=shift;my$t=shift;my$close_brace=$_[0]=~ /^(?:\>|\)|\}|\])$/ ? shift : Carp::confess('');my$open_brace=$close_brace;$open_brace =~ tr/\>\)\}\]/\<\(\{\[/;$close_brace=quotemeta$close_brace;$open_brace=quotemeta$open_brace;my$search=qr/\G(.*?(?<!\\)(?:\\\\)*(?:$open_brace|$close_brace))/;my$string='';my$depth=1;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /$search/gc){$string .= substr($t->{line},$t->{line_cursor});my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0;next}if (defined$rv){return \$string}return undef}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /$open_brace$/)? 1 : -1 and next;$t->{line_cursor}-= 1;return$string}\$string}sub _scan_quote_like_operator_gap {my$t=$_[1];my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};$t->{line}=~ /\G(\s*(?:\#.*)?)/gc or return undef;$string .= $1;unless ($t->{line_cursor}+ length $1==length$t->{line}){$t->{line_cursor}+= length $1;return$string}my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}1;
PPI_TOKEN__QUOTEENGINE

$fatpacked{"PPI/Token/_QuoteEngine/Full.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_FULL';
  package PPI::Token::_QuoteEngine::Full;use strict;use Clone ();use Carp ();use PPI::Token::_QuoteEngine ();our$VERSION='1.269';our@ISA='PPI::Token::_QuoteEngine';my%SECTIONS=('('=>{type=>'()',_close=>')' },'<'=>{type=>'<>',_close=>'>' },'['=>{type=>'[]',_close=>']' },'{'=>{type=>'{}',_close=>'}' },);my%QUOTES=('q'=>{operator=>'q',braced=>undef,separator=>undef,_sections=>1 },'qq'=>{operator=>'qq',braced=>undef,separator=>undef,_sections=>1 },'qx'=>{operator=>'qx',braced=>undef,separator=>undef,_sections=>1 },'qw'=>{operator=>'qw',braced=>undef,separator=>undef,_sections=>1 },'qr'=>{operator=>'qr',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'m'=>{operator=>'m',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'s'=>{operator=>'s',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'tr'=>{operator=>'tr',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'y'=>{operator=>'y',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'/'=>{operator=>undef,braced=>0,separator=>'/',_sections=>1,modifiers=>1 },'<'=>{operator=>undef,braced=>1,separator=>undef,_sections=>1,},'?'=>{operator=>undef,braced=>0,separator=>'?',_sections=>1,modifiers=>1 },);sub new {my$class=shift;my$init=defined $_[0]? shift : Carp::croak("::Full->new called without init string");my$self=PPI::Token::new($class,$init)or return undef;my$options=$QUOTES{$init}or return$self->_error("Unknown quote type '$init'");for (keys %$options){$self->{$_}=$options->{$_}}$self->{modifiers}={}if$self->{modifiers};if ($init eq '<'){$self->{sections}->[0]=Clone::clone($SECTIONS{'<'})}$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or Carp::croak("::Full->_fill called without current token");if ($self->{operator}){if (substr($t->{line},$t->{line_cursor},1)=~ /\s/){my$gap=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap;if (ref$gap){$self->{content}.= $$gap;return 0}$self->{content}.= $gap}my$sep=substr($t->{line},$t->{line_cursor}++,1);$self->{content}.= $sep;if (my$section=$SECTIONS{$sep}){$self->{braced}=1;$self->{sections}->[0]=Clone::clone($section)}else {$self->{braced}=0;$self->{separator}=$sep}}my$rv=$self->{braced}? $self->_fill_braced($t): $self->_fill_normal($t);return$rv if!$rv;return 1 unless$self->{modifiers};my$char;my$len=0;while (($char=substr($t->{line},$t->{line_cursor}+ 1,1))=~ /[^\W\d_]/){$len++;$self->{content}.= $char;$self->{modifiers}->{lc$char}=1;$t->{line_cursor}++}}sub _fill_normal {my$self=shift;my$t=shift;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$string;return 0}$self->{sections}->[0]={position=>length$self->{content},size=>length($string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{content}.= $string;return 1 if$self->{_sections}==1;$t->{line_cursor}++;$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1 };$self->{content}.= $string;1}sub _fill_braced {my$self=shift;my$t=shift;my$section=$self->{sections}->[0];my$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$brace_str;return 0}$section->{position}=length$self->{content};$section->{size}=length($brace_str)- 1;$self->{content}.= $brace_str;delete$section->{_close};return 1 if$self->{_sections}==1;my$char=substr($t->{line},++$t->{line_cursor},1);if ($char =~ /\s/){my$gap_str=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap_str;if (ref$gap_str){$self->{content}.= $$gap_str;return 0}$self->{content}.= $gap_str;$char=substr($t->{line},$t->{line_cursor},1)}$section=$SECTIONS{$char};if ($section){$self->{content}.= $char;$section={%$section };$t->{line_cursor}++;$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=2}else {$self->{_sections}=1}$self->{content}.= $$brace_str;return 0}else {$self->{sections}->[1]={position=>length($self->{content}),size=>length($brace_str)- 1,type=>$section->{type},};$self->{content}.= $brace_str}}elsif ($char =~ m/ \A [^\w\s] \z /smx){$self->{content}.= $char;$t->{line_cursor}++;my$string=$self->_scan_for_unescaped_character($t,$char);return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$char$char",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1,type=>"$char$char",};$self->{content}.= $string}else {$self->{sections}->[1]={position=>length($self->{content}),size=>0,type=>'',};$self->{_error}="No second section of regexp, or does not start with a balanced character";$t->{line_cursor}--;return 0}1}sub _sections {wantarray ? @{$_[0]->{sections}}: scalar @{$_[0]->{sections}}}sub _section_content {my$self=shift;my$i=shift;$self->{sections}or return;my$section=$self->{sections}->[$i]or return;return substr($self->content,$section->{position},$section->{size})}sub _modifiers {my$self=shift;$self->{modifiers}or return;wantarray and return %{$self->{modifiers}};return +{%{$self->{modifiers}}}}sub _delimiters {my$self=shift;$self->{sections}or return;my@delims;for my$sect (@{$self->{sections}}){if (exists$sect->{type}){push@delims,$sect->{type}}else {my$content=$self->content;push@delims,substr($content,$sect->{position}- 1,1).substr($content,$sect->{position}+ $sect->{size},1)}}return@delims}1;
PPI_TOKEN__QUOTEENGINE_FULL

$fatpacked{"PPI/Token/_QuoteEngine/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_SIMPLE';
  package PPI::Token::_QuoteEngine::Simple;use strict;use PPI::Token::_QuoteEngine ();our$VERSION='1.269';our@ISA='PPI::Token::_QuoteEngine';sub new {my$class=shift;my$separator=shift or return undef;my$self=PPI::Token::new($class,$separator)or return undef;$self->{separator}=$separator;$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or return undef;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){$self->{content}.= $$string;return 0}else {$self->{content}.= $string;return$self}}1;
PPI_TOKEN__QUOTEENGINE_SIMPLE

$fatpacked{"PPI/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKENIZER';
  package PPI::Tokenizer;use strict;use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};use List::Util 1.33 ();use PPI::Util ();use PPI::Element ();use PPI::Token ();use PPI::Exception ();use PPI::Exception::ParserRejection ();our$VERSION='1.269';my%X_CAN_FOLLOW_OPERATOR=map {$_=>1}qw(-- ++);my%X_CAN_FOLLOW_STRUCTURE=map {$_=>1}qw(} ] \));my%X_CAN_FOLLOW_WORD=map {$_=>1}qw(endgrent endhostent endnetent endprotoent endpwent endservent fork getgrent gethostent getlogin getnetent getppid getprotoent getpwent getservent setgrent setpwent time times wait wantarray __SUB__);sub new {my$class=ref($_[0])|| $_[0];my$self=bless {source=>undef,source_bytes=>undef,line=>undef,line_length=>undef,line_cursor=>undef,line_count=>0,token=>undef,class=>'PPI::Token::BOM',zone=>'PPI::Token::Whitespace',tokens=>[],token_cursor=>0,token_eof=>0,perl6=>[],},$class;if (!defined $_[1]){PPI::Exception->throw("No source provided to Tokenizer")}elsif (!ref $_[1]){my$source=PPI::Util::_slurp($_[1]);if (ref$source){$self->{source}=$$source}else {return($source)}}elsif (_SCALAR0($_[1])){$self->{source}=${$_[1]}}elsif (_ARRAY0($_[1])){$self->{source}=join '',map {"\n"}@{$_[1]}}else {PPI::Exception->throw(ref($_[1])." is not supported as a source provider")}$self->{source_bytes}=length$self->{source};if ($self->{source_bytes}){$self->{source}=~ s/(?:\015{1,2}\012|\015|\012)/\n/g;$self->{source}=[split /(?<=\n)/,$self->{source}]}else {$self->{source}=[]}if (List::Util::any {/^__(?:DATA|END)__\s*$/}@{$self->{source}}){$self->{source_eof_chop}=''}elsif (!defined$self->{source}->[0]){$self->{source_eof_chop}=''}elsif ($self->{source}->[-1]=~ /\s$/){$self->{source_eof_chop}=''}else {$self->{source_eof_chop}=1;$self->{source}->[-1].= ' '}$self}sub get_token {my$self=shift;if ($self->{token_eof}and $self->{token_cursor}> scalar @{$self->{tokens}}){return 0}if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}my$line_rv;my$rv=eval {while ($line_rv=$self->_process_next_line){if (defined(my$token=$self->{tokens}->[$self->{token_cursor}])){$self->{token_cursor}++;return$token}}return undef};if ($@){if (_INSTANCE($@,'PPI::Exception')){$@->throw}else {my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}}elsif ($rv){return$rv}if (defined$line_rv){if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}$self->{token_eof}=1;return 0}undef}sub all_tokens {my$self=shift;my$ok=eval {unless ($self->{token_eof}){my$rv;while ($rv=$self->_process_next_line){}unless (defined$rv){PPI::Exception->throw("Error while processing source")}$self->_clean_eof}1};if (!$ok){my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}return [@{$self->{tokens}}]}sub increment_cursor {$_[0]->get_token and 1}sub decrement_cursor {my$self=shift;return 0 unless$self->{token_cursor};$self->{token_eof}=0;--$self->{token_cursor}}sub _get_line {my$self=shift;return undef unless$self->{source};my$line=shift @{$self->{source}};$self->{source}=undef unless defined$line;return$line}sub _fill_line {my$self=shift;my$inscan=shift;my$line=$self->_get_line;unless (defined$line){unless ($inscan){delete$self->{line};delete$self->{line_cursor};delete$self->{line_length};return 0}$self->{line_cursor}=$self->{line_length};return 0}$self->{line}=$line;$self->{line_cursor}=-1;$self->{line_length}=length$line;$self->{line_count}++;1}sub _char {my$self=shift;substr($self->{line},$self->{line_cursor},1)}sub _process_next_line {my$self=shift;my$rv;unless ($rv=$self->_fill_line){return undef unless defined$rv;$self->_finalize_token;return 0}$rv=$self->{class}->__TOKENIZER__on_line_start($self);unless ($rv){if (ref$self->{source}eq 'ARRAY' and!@{$self->{source}}){$self->_clean_eof}return 1 if defined$rv;PPI::Exception->throw("Error at line $self->{line_count}")}while ($rv=$self->_process_next_char){}unless (defined$rv){PPI::Exception->throw("Error at line $self->{line_count}, character $self->{line_cursor}")}$self->{class}->__TOKENIZER__on_line_end($self);unless (ref($self->{source})eq 'ARRAY' and @{$self->{source}}){return$self->_clean_eof}return 1}sub _process_next_char {my$self=shift;if (!defined$self->{line_cursor}or!defined$self->{line_length}){return undef}return 0 if ++$self->{line_cursor}>= $self->{line_length};my$result;unless ($result=$self->{class}->__TOKENIZER__on_char($self)){return defined$result ? 1 : undef}my$char=substr($self->{line},$self->{line_cursor},1);if ($result eq '1'){if (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}return 1}if ($self->{class}ne "PPI::Token::$result"){$self->_new_token($result,$char)}elsif (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}1}sub _finalize_token {my$self=shift;return$self->{class}unless defined$self->{token};push @{$self->{tokens}},$self->{token};$self->{token}=undef;$self->{class}=$self->{zone}}sub _new_token {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;$self->_finalize_token if defined$self->{token};defined($self->{token}=$class->new($_[0]))or PPI::Exception->throw;$self->{class}=$class;1}sub _clean_eof {my$self=shift;$self->_finalize_token if$self->{token};my$last_token=$self->{tokens}->[-1 ];unless (length$last_token->{content}){pop @{$self->{tokens}}}if ($self->{source_eof_chop}){$last_token=$self->{tokens}->[-1 ];$last_token->{content}=~ s/ $//;unless (length$last_token->{content}){pop @{$self->{tokens}}}$self->{source_eof_chop}=''}1}sub _last_token {$_[0]->{tokens}->[-1]}sub _last_significant_token {my$self=shift;my$cursor=$#{$self->{tokens}};while ($cursor >= 0){my$token=$self->{tokens}->[$cursor--];return$token if$token->significant}return}sub _previous_significant_tokens {my$self=shift;my$count=shift || 1;my$cursor=$#{$self->{tokens}};my@tokens;while ($cursor >= 0){my$token=$self->{tokens}->[$cursor--];next if not $token->significant;push@tokens,$token;last if@tokens >= $count}return@tokens}my%OBVIOUS_CLASS=('PPI::Token::Symbol'=>'operator','PPI::Token::Magic'=>'operator','PPI::Token::Number'=>'operator','PPI::Token::ArrayIndex'=>'operator','PPI::Token::Quote::Double'=>'operator','PPI::Token::Quote::Interpolate'=>'operator','PPI::Token::Quote::Literal'=>'operator','PPI::Token::Quote::Single'=>'operator','PPI::Token::QuoteLike::Backtick'=>'operator','PPI::Token::QuoteLike::Command'=>'operator','PPI::Token::QuoteLike::Readline'=>'operator','PPI::Token::QuoteLike::Regexp'=>'operator','PPI::Token::QuoteLike::Words'=>'operator',);my%OBVIOUS_CONTENT=('('=>'operand','{'=>'operand','['=>'operand',';'=>'operand','}'=>'operator',);my%USUALLY_FORCES=map {$_=>1}qw(sub package use no);sub _opcontext {my$self=shift;my@tokens=$self->_previous_significant_tokens(1);my$p0=$tokens[0];return '' if not $p0;my$c0=ref$p0;return$OBVIOUS_CLASS{$c0}if defined$OBVIOUS_CLASS{$c0};return$OBVIOUS_CONTENT{$p0}if defined$OBVIOUS_CONTENT{$p0};return 'operand' if$p0->isa('PPI::Token::Operator');return 'operand' if$p0->content eq '';return ''}sub _current_x_is_operator {my ($self)=@_;return if!@{$self->{tokens}};my ($prev,$prevprev)=$self->_previous_significant_tokens(2);return if!$prev;return!$self->__current_token_is_forced_word if$prev->isa('PPI::Token::Word');return (!$prev->isa('PPI::Token::Operator')|| $X_CAN_FOLLOW_OPERATOR{$prev})&& (!$prev->isa('PPI::Token::Structure')|| $X_CAN_FOLLOW_STRUCTURE{$prev})&&!$prev->isa('PPI::Token::Label')}sub __current_token_is_forced_word {my ($t,$word)=@_;my ($prev,$prevprev)=$t->_previous_significant_tokens(2);if (!$prev){pos$t->{line}=$t->{line_cursor}}else {my$content=$prev->{content};return 1 if$content eq '->';pos$t->{line}=$t->{line_cursor};return 1 if$content eq '{' and $t->{line}=~ /\G\s*\}/gc;if($USUALLY_FORCES{$content}){return if defined$word and $word =~ /^v[0-9]+$/ and ($content eq "use" or $content eq "no");return 1 if not $prevprev;return 1 if not $USUALLY_FORCES{$prevprev->content}and $prevprev->content ne '->';return}}return 1 if$t->{line}=~ /\G\s*=>/gc;return ''}1;
PPI_TOKENIZER

$fatpacked{"PPI/Transform.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM';
  package PPI::Transform;use strict;use Carp ();use List::Util ();use PPI::Document ();use Params::Util qw{_INSTANCE _CLASS _CODE _SCALAR0};our$VERSION='1.269';my%HANDLER;my@ORDER;sub register_apply_handler {my$class=shift;my$handler=_CLASS(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$get=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$set=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");if ($HANDLER{$handler}){Carp::croak("PPI::Transform->apply handler '$handler' already exists")}$HANDLER{$handler}=[$get,$set ];unshift@ORDER,$handler}__PACKAGE__->register_apply_handler('SCALAR',\&_SCALAR_get,\&_SCALAR_set);__PACKAGE__->register_apply_handler('PPI::Document',sub {$_[0]},sub() {1});sub new {my$class=shift;bless {@_ },$class}sub document {my$class=shift;die "$class does not implement the required ->document method"}sub apply {my$self=_SELF(shift);my$it=defined $_[0]? shift : return undef;my$class=_SCALAR0($it)? 'SCALAR' : List::Util::first {_INSTANCE($it,$_)}@ORDER or return undef;my$handler=$HANDLER{$class}or die("->apply handler for $class missing! Panic");my$Document=_INSTANCE($handler->[0]->($it),'PPI::Document')or Carp::croak("->apply handler for $class failed to get a PPI::Document");$self->document($Document)or return undef;$handler->[1]->($it,$Document)or Carp::croak("->apply handler for $class failed to save the changed document");1}sub file {my$self=_SELF(shift);my$input=defined $_[0]? shift : return undef;my$output=@_ ? defined $_[0]? "$_[0]" : undef : $input or return undef;my$Document=PPI::Document->new("$input")or return undef;$self->document($Document)or return undef;$Document->save($output)}sub _SCALAR_get {PPI::Document->new($_[0])}sub _SCALAR_set {my$it=shift;$$it=$_[0]->serialize;1}sub _SELF {return shift if ref $_[0];my$self=$_[0]->new or Carp::croak("Failed to auto-instantiate new $_[0] object");$self}1;
PPI_TRANSFORM

$fatpacked{"PPI/Transform/UpdateCopyright.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM_UPDATECOPYRIGHT';
  package PPI::Transform::UpdateCopyright;use strict;use Params::Util qw{_STRING};use PPI::Transform ();our$VERSION='1.269';sub new {my$self=shift->SUPER::new(@_);unless (defined _STRING($self->name)){PPI::Exception->throw("Did not provide a valid name param")}return$self}sub name {$_[0]->{name}}sub document {my$self=shift;my$document=_INSTANCE(shift,'PPI::Document')or return undef;my$name=quotemeta$self->name;my$regexp=qr/\bcopyright\b.*$name/m;my$elements=$document->find(sub {$_[1]->isa('PPI::Token::Pod')or return '';$_[1]->content =~ $regexp or return '';return 1});return undef unless defined$elements;return 0 unless$elements;my$changes=0;my$change=sub {my$copyright=shift;my$thisyear=(localtime time)[5]+ 1900;my@year=$copyright =~ m/(\d{4})/g;if (@year==1){if ($year[0]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/(\d{4})/$1 - $thisyear/;return$copyright}}if (@year==2){if ($year[1]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/$year[1]/$thisyear/;return$copyright}}die "Invalid or unknown copyright line '$copyright'"};my$pattern=qr/\b(copyright.*\d)({4}(?:\s*-\s*\d{4})?)(.*$name)/mi;for my$element (@$elements){$element =~ s/$pattern/$1 . $change->($2) . $2/eg}return$changes}1;
PPI_TRANSFORM_UPDATECOPYRIGHT

$fatpacked{"PPI/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_UTIL';
  package PPI::Util;use strict;use Exporter ();use Digest::MD5 ();use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};our$VERSION='1.269';our@ISA='Exporter';our@EXPORT_OK=qw{_Document _slurp};use constant HAVE_UNICODE=>!!($] >= 5.008007);sub TRUE () {1}sub FALSE () {''}sub _Document {shift if @_ > 1;return undef unless defined $_[0];require PPI::Document;return PPI::Document->new(shift)unless ref $_[0];return PPI::Document->new(shift)if _SCALAR0($_[0]);return PPI::Document->new(shift)if _ARRAY0($_[0]);return shift if _INSTANCE($_[0],'PPI::Document');return undef}sub _slurp {my$file=shift;local $/=undef;local*FILE;open(FILE,'<',$file)or return "open($file) failed: $!";my$source=<FILE>;close(FILE)or return "close($file) failed: $!";return \$source}sub md5hex {my$string=shift;$string =~ s/(?:\015{1,2}\012|\015|\012)/\015/gs;Digest::MD5::md5_hex($string)}sub md5hex_file {my$file=shift;my$content=_slurp($file);return undef unless ref$content;$$content =~ s/(?:\015{1,2}\012|\015|\012)/\n/gs;md5hex($$content)}1;
PPI_UTIL

$fatpacked{"PPI/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_XSACCESSOR';
  package PPI::XSAccessor;use 5.006;use strict;use PPI ();our$VERSION='1.269';package PPI::Document;use Class::XSAccessor replace=>1,getters=>{readonly=>'readonly',},true=>['scope' ];package PPI::Document::File;use Class::XSAccessor replace=>1,getters=>{filename=>'filename',};package PPI::Document::Fragment;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Document::Normalized;use Class::XSAccessor replace=>1,getters=>{'_Document'=>'Document','version'=>'version','functions'=>'functions',};package PPI::Element;use Class::XSAccessor replace=>1,true=>['significant',];package PPI::Exception;use Class::XSAccessor replace=>1,getters=>{message=>'message',};package PPI::Node;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Normal;use Class::XSAccessor replace=>1,getters=>{'layer'=>'layer',};package PPI::Statement;use Class::XSAccessor replace=>1,true=>['__LEXER__normal',];package PPI::Statement::Compound;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Statement::Data;use Class::XSAccessor replace=>1,false=>['_complete',];package PPI::Statement::End;use Class::XSAccessor replace=>1,true=>['_complete',];package PPI::Statement::Given;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Token;use Class::XSAccessor replace=>1,getters=>{content=>'content',},setters=>{set_content=>'content',},true=>['__TOKENIZER__on_line_start','__TOKENIZER__on_line_end',];1;
PPI_XSACCESSOR

$fatpacked{"Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_UTIL';
  package Params::Util;use 5.00503;use strict;require overload;require Exporter;require Scalar::Util;require DynaLoader;use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};$VERSION='1.07';@ISA=qw{Exporter DynaLoader};@EXPORT_OK=qw{_STRING _IDENTIFIER _CLASS _CLASSISA _SUBCLASS _DRIVER _CLASSDOES _NUMBER _POSINT _NONNEGINT _SCALAR _SCALAR0 _ARRAY _ARRAY0 _ARRAYLIKE _HASH _HASH0 _HASHLIKE _CODE _CODELIKE _INVOCANT _REGEX _INSTANCE _INSTANCEDOES _SET _SET0 _HANDLE};%EXPORT_TAGS=(ALL=>\@EXPORT_OK);eval {local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};bootstrap Params::Util$VERSION;1}unless$ENV{PERL_PARAMS_UTIL_PP};my$SU=eval "$Scalar::Util::VERSION" || 0;if ($SU >= 1.18){Scalar::Util->import('looks_like_number')}else {eval <<'END_PERL'}eval <<'END_PERL' unless defined&_STRING;eval <<'END_PERL' unless defined&_IDENTIFIER;eval <<'END_PERL' unless defined&_CLASS;eval <<'END_PERL' unless defined&_CLASSISA;eval <<'END_PERL' unless defined&_CLASSDOES;eval <<'END_PERL' unless defined&_SUBCLASS;eval <<'END_PERL' unless defined&_NUMBER;eval <<'END_PERL' unless defined&_POSINT;eval <<'END_PERL' unless defined&_NONNEGINT;eval <<'END_PERL' unless defined&_SCALAR;eval <<'END_PERL' unless defined&_SCALAR0;eval <<'END_PERL' unless defined&_ARRAY;eval <<'END_PERL' unless defined&_ARRAY0;eval <<'END_PERL' unless defined&_ARRAYLIKE;eval <<'END_PERL' unless defined&_HASH;eval <<'END_PERL' unless defined&_HASH0;eval <<'END_PERL' unless defined&_HASHLIKE;eval <<'END_PERL' unless defined&_CODE;eval <<'END_PERL' unless defined&_CODELIKE;eval <<'END_PERL' unless defined&_INVOCANT;eval <<'END_PERL' unless defined&_INSTANCE;eval <<'END_PERL' unless defined&_INSTANCEDOES;eval <<'END_PERL' unless defined&_REGEX;eval <<'END_PERL' unless defined&_SET;eval <<'END_PERL' unless defined&_SET0;eval <<'END_PERL' unless defined&_HANDLE;eval <<'END_PERL' unless defined&_DRIVER;1;
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
PARAMS_UTIL

$fatpacked{"Parse/PMFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_PMFILE';
  package Parse::PMFile;sub __clean_eval {eval $_[0]}use strict;use warnings;use Safe;use JSON::PP ();use Dumpvalue;use version ();use File::Spec ();our$VERSION='0.41';our$VERBOSE=0;our$ALLOW_DEV_VERSION=0;our$FORK=0;our$UNSAFE=$] < 5.010000 ? 1 : 0;sub new {my ($class,$meta,$opts)=@_;bless {%{$opts || {}},META_CONTENT=>$meta},$class}sub parse {my ($self,$pmfile)=@_;$pmfile =~ s|\\|/|g;my($filemtime)=(stat$pmfile)[9];$self->{MTIME}=$filemtime;$self->{PMFILE}=$pmfile;unless ($self->_version_from_meta_ok){my$version;unless (eval {$version=$self->_parse_version;1}){$self->_verbose(1,"error with version in $pmfile: $@");return}$self->{VERSION}=$version;if ($self->{VERSION}=~ /^\{.*\}$/){}elsif ($self->{VERSION}=~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){return}}my($ppp)=$self->_packages_per_pmfile;my@keys_ppp=$self->_filter_ppps(sort keys %$ppp);$self->_verbose(1,"Will check keys_ppp[@keys_ppp]\n");my ($package,%errors);my%checked_in;DBPACK: foreach$package (@keys_ppp){if ($package !~ /^\w[\w\:\']*\w?\z/ || $package !~ /\w\z/ || $package =~ /:/ && $package !~ /::/ || $package =~ /\w:\w/ || $package =~ /:::/){$self->_verbose(1,"Package[$package] did not pass the ultimate sanity check");delete$ppp->{$package};next}if ($self->{USERID}&& $self->{PERMISSIONS}&&!$self->_perm_check($package)){delete$ppp->{$package};next}{my (undef,$module)=split m{/lib/},$self->{PMFILE},2;if ($module){$module =~ s{\.pm\z}{};$module =~ s{/}{::}g;if (lc$module eq lc$package && $module ne $package){$errors{$package}={indexing_warning=>"Capitalization of package ($package) does not match filename!",infile=>$self->{PMFILE},}}}}my$pp=$ppp->{$package};if ($pp->{version}&& $pp->{version}=~ /^\{.*\}$/){my$err=JSON::PP::decode_json($pp->{version});if ($err->{x_normalize}){$errors{$package}={normalize=>$err->{version},infile=>$pp->{infile},};$pp->{version}="undef"}elsif ($err->{openerr}){$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          read the file. It issued the following error: C< $err->{r} >},);$errors{$package}={open=>$err->{r},infile=>$pp->{infile},}}else {$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          parse the following line in that file: C< $err->{line} >
  
          Note: the indexer is running in a Safe compartement and cannot
          provide the full functionality of perl in the VERSION line. It
          is trying hard, but sometime it fails. As a workaround, please
          consider writing a META.yml that contains a 'provides'
          attribute or contact the CPAN admins to investigate (yet
          another) workaround against "Safe" limitations.)},);$errors{$package}={parse_version=>$err->{line},infile=>$err->{file},}}}for ($package,$pp->{version},){if (!defined || /^\s*$/ || /\s/){delete$ppp->{$package};next}}unless ($self->_version_ok($pp)){$errors{$package}={long_version=>qq{Version string exceeds maximum allowed length of 16b: "$pp->{version}"},infile=>$pp->{infile},};next}$checked_in{$package}=$ppp->{$package}}return (wantarray && %errors)? (\%checked_in,\%errors): \%checked_in}sub _version_ok {my ($self,$pp)=@_;return if length($pp->{version}|| 0)> 16;return 1}sub _perm_check {my ($self,$package)=@_;my$userid=$self->{USERID};my$module=$self->{PERMISSIONS}->module_permissions($package);return 1 if!$module;return 1 if defined$module->m && $module->m eq $userid;return 1 if defined$module->f && $module->f eq $userid;return 1 if defined$module->c && grep {$_ eq $userid}@{$module->c};return}sub _parse_version {my$self=shift;use strict;my$pmfile=$self->{PMFILE};my$tmpfile=File::Spec->catfile(File::Spec->tmpdir,"ParsePMFile$$" .rand(1000));my$pmcp=$pmfile;for ($pmcp){s/([^\\](\\\\)*)@/$1\\@/g}my($v);{package main;my$pid;if ($self->{FORK}|| $FORK){$pid=fork();die "Can't fork: $!" unless defined$pid}if ($pid){waitpid($pid,0);if (open my$fh,'<',$tmpfile){$v=<$fh>}}else {my($comp)=Safe->new;my$eval=qq{
                  local(\$^W) = 0;
                  Parse::PMFile::_parse_version_safely("$pmcp");
              };$comp->permit("entereval");$comp->share("*Parse::PMFile::_parse_version_safely");$comp->share("*version::new");$comp->share("*version::numify");$comp->share_from('main',['*version::','*charstar::','*Exporter::','*DynaLoader::']);$comp->share_from('version',['&qv']);$comp->permit(":base_math");$comp->deny(qw/enteriter iter unstack goto/);version->import('qv')if$self->{UNSAFE}|| $UNSAFE;{no strict;$v=($self->{UNSAFE}|| $UNSAFE)? eval$eval : $comp->reval($eval)}if ($@){my$err=$@;if (ref$err){if ($err->{line}=~ /([\$*])([\w\:\']*)\bVERSION\b.*?\=(.*)/){local($^W)=0;my ($sigil,$vstr)=($1,$3);$self->_restore_overloaded_stuff(1)if$err->{line}=~ /use\s+version\b|version\->|qv\(/;$v=($self->{UNSAFE}|| $UNSAFE)? eval$vstr : $comp->reval($vstr);$v=$$v if$sigil eq '*' && ref$v}if ($@ or!$v){$self->_verbose(1,sprintf("reval failed: err[%s] for eval[%s]",JSON::PP::encode_json($err),$eval,));$v=JSON::PP::encode_json($err)}}else {$v=JSON::PP::encode_json({openerr=>$err })}}if (defined$v){no warnings;$v=$v->numify if ref($v)=~ /^version(::vpp)?$/}else {$v=""}if ($self->{FORK}|| $FORK){open my$fh,'>:utf8',$tmpfile;print$fh $v;exit 0}else {utf8::encode($v);$v=undef if defined$v &&!length$v;$comp->erase;$self->_restore_overloaded_stuff}}}unlink$tmpfile if ($self->{FORK}|| $FORK)&& -e $tmpfile;return$self->_normalize_version($v)}sub _restore_overloaded_stuff {my ($self,$used_version_in_safe)=@_;return if$self->{UNSAFE}|| $UNSAFE;no strict 'refs';no warnings 'redefine';my$restored;if ($INC{'version/vxs.pm'}){*{'version::(""'}=\&version::vxs::stringify;*{'version::(0+'}=\&version::vxs::numify;*{'version::(cmp'}=\&version::vxs::VCMP;*{'version::(<=>'}=\&version::vxs::VCMP;*{'version::(bool'}=\&version::vxs::boolean;$restored=1}if ($INC{'version/vpp.pm'}){{package charstar;overload->import}if (!$used_version_in_safe){package version::vpp;overload->import}unless ($restored){*{'version::(""'}=\&version::vpp::stringify;*{'version::(0+'}=\&version::vpp::numify;*{'version::(cmp'}=\&version::vpp::vcmp;*{'version::(<=>'}=\&version::vpp::vcmp;*{'version::(bool'}=\&version::vpp::vbool}*{'version::vpp::(""'}=\&version::vpp::stringify;*{'version::vpp::(0+'}=\&version::vpp::numify;*{'version::vpp::(cmp'}=\&version::vpp::vcmp;*{'version::vpp::(<=>'}=\&version::vpp::vcmp;*{'version::vpp::(bool'}=\&version::vpp::vbool;*{'charstar::(""'}=\&charstar::thischar;*{'charstar::(0+'}=\&charstar::thischar;*{'charstar::(++'}=\&charstar::increment;*{'charstar::(--'}=\&charstar::decrement;*{'charstar::(+'}=\&charstar::plus;*{'charstar::(-'}=\&charstar::minus;*{'charstar::(*'}=\&charstar::multiply;*{'charstar::(cmp'}=\&charstar::cmp;*{'charstar::(<=>'}=\&charstar::spaceship;*{'charstar::(bool'}=\&charstar::thischar;*{'charstar::(='}=\&charstar::clone;$restored=1}if (!$restored){*{'version::(""'}=\&version::stringify;*{'version::(0+'}=\&version::numify;*{'version::(cmp'}=\&version::vcmp;*{'version::(<=>'}=\&version::vcmp;*{'version::(bool'}=\&version::boolean}}sub _packages_per_pmfile {my$self=shift;my$ppp={};my$pmfile=$self->{PMFILE};my$filemtime=$self->{MTIME};my$version=$self->{VERSION};open my$fh,"<","$pmfile" or return$ppp;local $/="\n";my$inpod=0;PLINE: while (<$fh>){chomp;my($pline)=$_;$inpod=$pline =~ /^=(?!cut)/ ? 1 : $pline =~ /^=cut/ ? 0 : $inpod;next if$inpod;next if substr($pline,0,4)eq "=cut";$pline =~ s/\#.*//;next if$pline =~ /^\s*$/;if ($pline =~ /^__(?:END|DATA)__\b/ and $pmfile !~ /\.PL$/){last PLINE}my$pkg;my$strict_version;if ($pline =~ m{
                        # (.*) # takes too much time if $pline is long
                        #(?<![*\$\\@%&]) # no sigils
                        ^[\s\{;]*
                        \bpackage\s+
                        ([\w\:\']+)
                        \s*
                        (?: $ | [\}\;] | \{ | \s+($version::STRICT) )
                      }x){$pkg=$1;$strict_version=$2;if ($pkg eq "DB"){next PLINE}}if ($pkg){$pkg =~ s/\'/::/g;next PLINE unless$pkg =~ /^[A-Za-z]/;next PLINE unless$pkg =~ /\w$/;next PLINE if$pkg eq "main";next PLINE if length($pkg)> 128;$ppp->{$pkg}{parsed}++;$ppp->{$pkg}{infile}=$pmfile;if ($self->_simile($pmfile,$pkg)){$ppp->{$pkg}{simile}=$pmfile;if ($self->_version_from_meta_ok){my$provides=$self->{META_CONTENT}{provides};if (exists$provides->{$pkg}){if (defined$provides->{$pkg}{version}){my$v=$provides->{$pkg}{version};if ($v =~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){next PLINE}unless (eval {$version=$self->_normalize_version($v);1}){$self->_verbose(1,"error with version in $pmfile: $@");next}$ppp->{$pkg}{version}=$version}else {$ppp->{$pkg}{version}="undef"}}}else {if (defined$strict_version){$ppp->{$pkg}{version}=$strict_version }else {$ppp->{$pkg}{version}=defined$version ? $version : ""}no warnings;if ($version eq 'undef'){$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}}else {$ppp->{$pkg}{version}=$version if$version > $ppp->{$pkg}{version}|| $version gt $ppp->{$pkg}{version}}}}else {$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}&& length($ppp->{$pkg}{version})}$ppp->{$pkg}{filemtime}=$filemtime}else {}}close$fh;$ppp}{no strict;sub _parse_version_safely {my($parsefile)=@_;my$result;local*FH;local $/="\n";open(FH,$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;while (<FH>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;last if /^__(?:END|DATA)__\b/;chop;if (my ($ver)=/package \s+ \S+ \s+ (\S+) \s* [;{]/x){return$ver if version::is_lax($ver)}next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*(?<![!><=])\=(?![=>])/;my$current_parsed_line=$_;my$eval=qq{
                  package #
                      ExtUtils::MakeMaker::_version;
  
                  local $1$2;
                  \$$2=undef; do {
                      $_
                  }; \$$2
              };local $^W=0;local$SIG{__WARN__}=sub {};$result=__clean_eval($eval);if ($@ or!defined$result){die +{eval=>$eval,line=>$current_parsed_line,file=>$parsefile,err=>$@,}}last}close FH;$result="undef" unless defined$result;if ((ref$result)=~ /^version(?:::vpp)?\b/){no warnings;$result=$result->numify}return$result}}sub _filter_ppps {my($self,@ppps)=@_;my@res;MANI: for my$ppp (@ppps){if ($self->{META_CONTENT}){my$no_index=$self->{META_CONTENT}{no_index}|| $self->{META_CONTENT}{private};if (ref($no_index)eq 'HASH'){my%map=(package=>qr{\z},namespace=>qr{::},);for my$k (qw(package namespace)){next unless my$v=$no_index->{$k};my$rest=$map{$k};if (ref$v eq "ARRAY"){for my$ve (@$v){$ve =~ s|::$||;if ($ppp =~ /^$ve$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to ve[$ve]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to ve[$ve]")}}}else {$v =~ s|::$||;if ($ppp =~ /^$v$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to v[$v]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to v[$v]")}}}}else {$self->_verbose(1,"No keyword 'no_index' or 'private' in META_CONTENT")}}else {}push@res,$ppp}$self->_verbose(1,"Result of filter_ppps: res[@res]");@res}sub _simile {my($self,$file,$package)=@_;$file =~ s|.*/||;$file =~ s|\.pm(?:\.PL)?||;my$ret=$package =~ m/\b\Q$file\E$/;$ret ||= 0;unless ($ret){$ret=1 if lc$file eq 'version'}$self->_verbose(1,"Result of simile(): file[$file] package[$package] ret[$ret]\n");$ret}sub _normalize_version {my($self,$v)=@_;$v="undef" unless defined$v;my$dv=Dumpvalue->new;my$sdv=$dv->stringify($v,1);$self->_verbose(1,"Result of normalize_version: sdv[$sdv]\n");return$v if$v eq "undef";return$v if$v =~ /^\{.*\}$/;$v =~ s/^\s+//;$v =~ s/\s+\z//;if ($v =~ /_/){return$v }if (!version::is_lax($v)){return JSON::PP::encode_json({x_normalize=>'version::is_lax failed',version=>$v })}my$vv=eval {no warnings;version->new($v)->numify};if ($@){return JSON::PP::encode_json({x_normalize=>$@,version=>$v })}if ($vv eq $v){}else {my$forced=$self->_force_numeric($v);if ($forced eq $vv){}elsif ($forced =~ /^v(.+)/){no warnings;$vv=version->new($1)->numify}else {if ($forced==$vv){$vv=$forced}}}return$vv}sub _force_numeric {my($self,$v)=@_;$v=$self->_readable($v);if ($v =~ /^(\+?)(\d*)(\.(\d*))?/ && (defined $2 && length $2 || defined $4 && length $4)){my$two=defined $2 ? $2 : "";my$three=defined $3 ? $3 : "";$v="$two$three"}$v}sub _version_from_meta_ok {my($self)=@_;return$self->{VERSION_FROM_META_OK}if exists$self->{VERSION_FROM_META_OK};my$c=$self->{META_CONTENT};return($self->{VERSION_FROM_META_OK}=0)unless$c->{provides};my ($mb_v)=(defined$c->{generated_by}? $c->{generated_by}: '')=~ /Module::Build version ([\d\.]+)/;return($self->{VERSION_FROM_META_OK}=1)unless$mb_v;return($self->{VERSION_FROM_META_OK}=1)if$mb_v eq '0.250.0';if ($mb_v >= 0.19 && $mb_v < 0.26 &&!keys %{$c->{provides}}){return($self->{VERSION_FROM_META_OK}=0)}return($self->{VERSION_FROM_META_OK}=1)}sub _verbose {my($self,$level,@what)=@_;warn@what if$level <= ((ref$self && $self->{VERBOSE})|| $VERBOSE)}sub _vcmp {my($self,$l,$r)=@_;local($^W)=0;$self->_verbose(9,"l[$l] r[$r]");return 0 if$l eq $r;for ($l,$r){s/_//g}$self->_verbose(9,"l[$l] r[$r]");for ($l,$r){next unless tr/.// > 1 || /^v/;s/^v?/v/;1 while s/\.0+(\d)/.$1/}$self->_verbose(9,"l[$l] r[$r]");if ($l=~/^v/ <=> $r=~/^v/){for ($l,$r){next if /^v/;$_=$self->_float2vv($_)}}$self->_verbose(9,"l[$l] r[$r]");my$lvstring="v0";my$rvstring="v0";if ($] >= 5.006 && $l =~ /^v/ && $r =~ /^v/){$lvstring=$self->_vstring($l);$rvstring=$self->_vstring($r);$self->_verbose(9,sprintf "lv[%vd] rv[%vd]",$lvstring,$rvstring)}return (($l ne "undef")<=> ($r ne "undef")|| $lvstring cmp $rvstring || $l <=> $r || $l cmp $r)}sub _vgt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)> 0}sub _vlt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)< 0}sub _vge {my($self,$l,$r)=@_;$self->_vcmp($l,$r)>= 0}sub _vle {my($self,$l,$r)=@_;$self->_vcmp($l,$r)<= 0}sub _vstring {my($self,$n)=@_;$n =~ s/^v// or die "Parse::PMFile::_vstring() called with invalid arg [$n]";pack "U*",split /\./,$n}sub _float2vv {my($self,$n)=@_;my($rev)=int($n);$rev ||= 0;my($mantissa)=$n =~ /\.(\d{1,12})/;$mantissa ||= 0;$mantissa .= "0" while length($mantissa)%3;my$ret="v" .$rev;while ($mantissa){$mantissa =~ s/(\d{1,3})// or die "Panic: length>0 but not a digit? mantissa[$mantissa]";$ret .= ".".int($1)}$ret =~ s/(\.0)+/.0/;$ret}sub _readable {my($self,$n)=@_;$n =~ /^([\w\-\+\.]+)/;return $1 if defined $1 && length($1)>0;if ($] < 5.006){$self->_verbose(9,"Suspicious version string seen [$n]\n");return$n}my$better=sprintf "v%vd",$n;$self->_verbose(9,"n[$n] better[$better]");return$better}1;
PARSE_PMFILE

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;use strict;use warnings;package Path::Tiny;our$VERSION='0.108';use Config;use Exporter 5.57 (qw/import/);use File::Spec 0.86 ();use Carp ();our@EXPORT=qw/path/;our@EXPORT_OK=qw/cwd rootdir tempfile tempdir/;use constant {PATH=>0,CANON=>1,VOL=>2,DIR=>3,FILE=>4,TEMP=>5,IS_WIN32=>($^O eq 'MSWin32'),};use overload (q{""}=>sub {$_[0]->[PATH]},bool=>sub () {1},fallback=>1,);sub FREEZE {return $_[0]->[PATH]}sub THAW {return path($_[2])}{no warnings 'once';*TO_JSON=*FREEZE};my$HAS_UU;sub _check_UU {local$SIG{__DIE__};!!eval {require Unicode::UTF8;Unicode::UTF8->VERSION(0.58);1}}my$HAS_PU;sub _check_PU {local$SIG{__DIE__};!!eval {require Encode;require PerlIO::utf8_strict;PerlIO::utf8_strict->VERSION(0.003);1}}my$HAS_FLOCK=$Config{d_flock}|| $Config{d_fcntl_can_lock}|| $Config{d_lockf};my$SLASH=qr{[\\/]};my$NOTSLASH=qr{[^\\/]};my$DRV_VOL=qr{[a-z]:}i;my$UNC_VOL=qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;my$WIN32_ROOT=qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;sub _win32_vol {my ($path,$drv)=@_;require Cwd;my$dcwd=eval {Cwd::getdcwd($drv)};$dcwd="$drv" unless defined$dcwd && length$dcwd;$dcwd =~ s{$SLASH?$}{/};$path =~ s{^$DRV_VOL}{$dcwd};return$path}sub _is_root {return IS_WIN32()? ($_[0]=~ /^$WIN32_ROOT$/): ($_[0]eq '/')}BEGIN {*_same=IS_WIN32()? sub {lc($_[0])eq lc($_[1])}: sub {$_[0]eq $_[1]}}my%MODEBITS=(om=>0007,gm=>0070,um=>0700);{my$m=0;$MODEBITS{$_}=(1 << $m++)for qw/ox ow or gx gw gr ux uw ur/};sub _symbolic_chmod {my ($mode,$symbolic)=@_;for my$clause (split /,\s*/,$symbolic){if ($clause =~ m{\A([augo]+)([=+-])([rwx]+)\z}){my ($who,$action,$perms)=($1,$2,$3);$who =~ s/a/ugo/g;for my$w (split //,$who){my$p=0;$p |= $MODEBITS{"$w$_"}for split //,$perms;if ($action eq '='){$mode=($mode & ~$MODEBITS{"${w}m"})| $p}else {$mode=$action eq "+" ? ($mode | $p): ($mode & ~$p)}}}else {Carp::croak("Invalid mode clause '$clause' for chmod()")}}return$mode}{package flock;use warnings::register}my$WARNED_NO_FLOCK=0;sub _throw {my ($self,$function,$file,$msg)=@_;if ($function =~ /^flock/ && $! =~ /operation not supported|function not implemented/i &&!warnings::fatal_enabled('flock')){if (!$WARNED_NO_FLOCK){warnings::warn(flock=>"Flock not available: '$!': continuing in unsafe mode");$WARNED_NO_FLOCK++}}else {$msg=$! unless defined$msg;Path::Tiny::Error->throw($function,(defined$file ? $file : $self->[PATH]),$msg)}return}sub _get_args {my ($raw,@valid)=@_;if (defined($raw)&& ref($raw)ne 'HASH'){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Options for $called_as must be a hash reference")}my$cooked={};for my$k (@valid){$cooked->{$k}=delete$raw->{$k}if exists$raw->{$k}}if (keys %$raw){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Invalid option(s) for $called_as: " .join(", ",keys %$raw))}return$cooked}sub path {my$path=shift;Carp::croak("Path::Tiny paths require defined, positive-length parts")unless 1 + @_==grep {defined && length}$path,@_;if (!@_ && ref($path)eq __PACKAGE__ &&!$path->[TEMP]){return$path}$path="$path";if (IS_WIN32()){$path=_win32_vol($path,$1)if$path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};$path .= "/" if$path =~ m{^$UNC_VOL$}}if (@_){$path .= (_is_root($path)? "" : "/").join("/",@_)}my$cpath=$path=File::Spec->canonpath($path);$path =~ tr[\\][/] if IS_WIN32();$path="/" if$path eq '/..';$path .= "/" if IS_WIN32()&& $path =~ m{^$UNC_VOL$};if (_is_root($path)){$path =~ s{/?$}{/}}else {$path =~ s{/$}{}}if ($path =~ m{^(~[^/]*).*}){require File::Glob;my ($homedir)=File::Glob::bsd_glob($1);$homedir =~ tr[\\][/] if IS_WIN32();$path =~ s{^(~[^/]*)}{$homedir}}bless [$path,$cpath ],__PACKAGE__}sub new {shift;path(@_)}sub cwd {require Cwd;return path(Cwd::getcwd())}sub rootdir {path(File::Spec->rootdir)}sub tempfile {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);$args->{TEMPLATE}=$maybe_template->[0]if @$maybe_template;require File::Temp;my$temp=File::Temp->new(TMPDIR=>1,%$args);close$temp;my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;return$self}sub tempdir {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);require File::Temp;my$temp=File::Temp->newdir(@$maybe_template,TMPDIR=>1,%$args);my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;$temp->{REALNAME}=$self->[CANON]if IS_WIN32;return$self}sub _parse_file_temp_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? delete$args{TEMPLATE}: $leading_template ? $leading_template : ());return (\@template,\%args)}sub _splitpath {my ($self)=@_;@{$self}[VOL,DIR,FILE ]=File::Spec->splitpath($self->[PATH])}sub _resolve_symlinks {my ($self)=@_;my$new=$self;my ($count,%seen)=0;while (-l $new->[PATH]){if ($seen{$new->[PATH]}++){$self->_throw('readlink',$self->[PATH],"symlink loop detected")}if (++$count > 100){$self->_throw('readlink',$self->[PATH],"maximum symlink depth exceeded")}my$resolved=readlink$new->[PATH]or $new->_throw('readlink',$new->[PATH]);$resolved=path($resolved);$new=$resolved->is_absolute ? $resolved : $new->sibling($resolved)}return$new}sub absolute {my ($self,$base)=@_;if (IS_WIN32){return$self if length$self->volume;if ($self->is_absolute){require Cwd;my ($drv)=Win32::GetCwd()=~ /^($DRV_VOL | $UNC_VOL)/x;return path($drv .$self->[PATH])}}else {return$self if$self->is_absolute}require Cwd;return path(Cwd::getcwd(),$_[0]->[PATH])unless defined$base;$base=path($base);return path(($base->is_absolute ? $base : $base->absolute),$_[0]->[PATH])}sub append {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$mode=$args->{truncate}? ">" : ">>";my$fh=$self->filehandle({locked=>1 },$mode,$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close')}sub append_raw {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);$args->{binmode}=':unix';append($self,$args,@data)}sub append_utf8 {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){$args->{binmode}=":unix";append($self,$args,map {Unicode::UTF8::encode_utf8($_)}@data)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";append($self,$args,@data)}else {$args->{binmode}=":unix:encoding(UTF-8)";append($self,$args,@data)}}sub assert {my ($self,$assertion)=@_;return$self unless$assertion;if (ref$assertion eq 'CODE'){local $_=$self;$assertion->()or Path::Tiny::Error->throw("assert",$self->[PATH],"failed assertion")}else {Carp::croak("argument to assert must be a code reference argument")}return$self}sub basename {my ($self,@suffixes)=@_;$self->_splitpath unless defined$self->[FILE];my$file=$self->[FILE];for my$s (@suffixes){my$re=ref($s)eq 'Regexp' ? qr/$s$/ : qr/\Q$s\E$/;last if$file =~ s/$re//}return$file}sub canonpath {$_[0]->[CANON]}sub cached_temp {my$self=shift;$self->_throw("cached_temp",$self,"has no cached File::Temp object")unless defined$self->[TEMP];return$self->[TEMP]}sub child {my ($self,@parts)=@_;return path($self->[PATH],@parts)}sub children {my ($self,$filter)=@_;my$dh;opendir$dh,$self->[PATH]or $self->_throw('opendir');my@children=readdir$dh;closedir$dh or $self->_throw('closedir');if (not defined$filter){@children=grep {$_ ne '.' && $_ ne '..'}@children}elsif ($filter && ref($filter)eq 'Regexp'){@children=grep {$_ ne '.' && $_ ne '..' && $_ =~ $filter}@children}else {Carp::croak("Invalid argument '$filter' for children()")}return map {path($self->[PATH],$_)}@children}sub chmod {my ($self,$new_mode)=@_;my$mode;if ($new_mode =~ /\d/){$mode=($new_mode =~ /^0/ ? oct($new_mode): $new_mode)}elsif ($new_mode =~ /[=+-]/){$mode=_symbolic_chmod($self->stat->mode & 07777,$new_mode)}else {Carp::croak("Invalid mode argument '$new_mode' for chmod()")}CORE::chmod($mode,$self->[PATH])or $self->_throw("chmod");return 1}sub copy {my ($self,$dest)=@_;require File::Copy;File::Copy::copy($self->[PATH],$dest)or Carp::croak("copy failed for $self to $dest: $!");return -d $dest ? path($dest,$self->basename): path($dest)}sub digest {my ($self,@opts)=@_;my$args=(@opts && ref$opts[0]eq 'HASH')? shift@opts : {};$args=_get_args($args,qw/chunk_size/);unshift@opts,'SHA-256' unless@opts;require Digest;my$digest=Digest->new(@opts);if ($args->{chunk_size}){my$fh=$self->filehandle({locked=>1 },"<",":unix");my$buf;$digest->add($buf)while read$fh,$buf,$args->{chunk_size}}else {$digest->add($self->slurp_raw)}return$digest->hexdigest}sub dirname {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return length$self->[DIR]? $self->[DIR]: "."}sub edit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp(exists($args->{binmode})? {binmode=>$args->{binmode}}: ());$cb->();$self->spew($args,$_);return}sub edit_utf8 {my ($self,$cb)=@_;Carp::croak("Callback for edit_utf8() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp_utf8;$cb->();$self->spew_utf8($_);return}sub edit_raw {$_[2]={binmode=>":unix" };goto&edit}sub edit_lines {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit_lines() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$temp_fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);my$in_fh=$self->filehandle({locked=>1 },'<',$binmode);local $_;while (<$in_fh>){$cb->();$temp_fh->print($_)}close$temp_fh or $self->_throw('close',$temp);close$in_fh or $self->_throw('close');return$temp->move($resolved_path)}sub edit_lines_raw {$_[2]={binmode=>":unix" };goto&edit_lines}sub edit_lines_utf8 {$_[2]={binmode=>":raw:encoding(UTF-8)" };goto&edit_lines}sub exists {-e $_[0]->[PATH]}sub is_file {-e $_[0]->[PATH]&&!-d _}sub is_dir {-d $_[0]->[PATH]}sub filehandle {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked exclusive/);$args->{locked}=1 if$args->{exclusive};my ($opentype,$binmode)=@args;$opentype="<" unless defined$opentype;Carp::croak("Invalid file mode '$opentype'")unless grep {$opentype eq $_}qw/< +< > +> >> +>>/;$binmode=((caller(0))[10]|| {})->{'open' .substr($opentype,-1,1)}unless defined$binmode;$binmode="" unless defined$binmode;my ($fh,$lock,$trunc);if ($HAS_FLOCK && $args->{locked}&&!$ENV{PERL_PATH_TINY_NO_FLOCK}){require Fcntl;if (grep {$opentype eq $_}qw(> +>)){my$flags=$opentype eq ">" ? Fcntl::O_WRONLY(): Fcntl::O_RDWR();$flags |= Fcntl::O_CREAT();$flags |= Fcntl::O_EXCL()if$args->{exclusive};sysopen($fh,$self->[PATH],$flags)or $self->_throw("sysopen");if ($binmode =~ s/^:unix//){binmode($fh,":raw")or $self->_throw("binmode (:raw)");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")or $self->_throw("binmode (:pop)")}}if (length$binmode){binmode($fh,$binmode)or $self->_throw("binmode ($binmode)")}$lock=Fcntl::LOCK_EX();$trunc=1}elsif ($^O eq 'aix' && $opentype eq "<"){if (-w $self->[PATH]){$opentype="+<";$lock=Fcntl::LOCK_EX()}}else {$lock=$opentype eq "<" ? Fcntl::LOCK_SH(): Fcntl::LOCK_EX()}}unless ($fh){my$mode=$opentype .$binmode;open$fh,$mode,$self->[PATH]or $self->_throw("open ($mode)")}do {flock($fh,$lock)or $self->_throw("flock ($lock)")}if$lock;do {truncate($fh,0)or $self->_throw("truncate")}if$trunc;return$fh}sub is_absolute {substr($_[0]->dirname,0,1)eq '/'}sub is_relative {substr($_[0]->dirname,0,1)ne '/'}sub is_rootdir {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return$self->[DIR]eq '/' && $self->[FILE]eq ''}sub iterator {my$self=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);my@dirs=$self;my$current;return sub {my$next;while (@dirs){if (ref$dirs[0]eq 'Path::Tiny'){if (!-r $dirs[0]){shift@dirs and next}$current=$dirs[0];my$dh;opendir($dh,$current->[PATH])or $self->_throw('opendir',$current->[PATH]);$dirs[0]=$dh;if (-l $current->[PATH]&&!$args->{follow_symlinks}){shift@dirs and next}}while (defined($next=readdir$dirs[0])){next if$next eq '.' || $next eq '..';my$path=$current->child($next);push@dirs,$path if$args->{recurse}&& -d $path &&!(!$args->{follow_symlinks}&& -l $path);return$path}shift@dirs}return}}sub lines {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);my$chomp=$args->{chomp};if ($args->{count}){my ($counter,$mod,@result)=(0,abs($args->{count}));while (my$line=<$fh>){$line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if$chomp;$result[$counter++ ]=$line;last if$counter==$args->{count};$counter %= $mod}splice(@result,0,0,splice(@result,$counter))if@result==$mod && $counter % $mod;return@result}elsif ($chomp){return map {s/(?:\x{0d}?\x{0a}|\x{0d})$//;$_}<$fh>}else {return wantarray ? <$fh> : (my$count=()=<$fh>)}}sub lines_raw {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ($args->{chomp}&&!$args->{count}){return split /\n/,slurp_raw($self)}else {$args->{binmode}=":raw";return lines($self,$args)}}my$CRLF=qr/(?:\x{0d}?\x{0a}|\x{0d})/;sub lines_utf8 {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ((defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU()))&& $args->{chomp}&&!$args->{count}){my$slurp=slurp_utf8($self);$slurp =~ s/$CRLF$//;return split$CRLF,$slurp,-1}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";return lines($self,$args)}else {$args->{binmode}=":raw:encoding(UTF-8)";return lines($self,$args)}}sub mkpath {my ($self,$args)=@_;$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};require File::Path;my@dirs=File::Path::make_path($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("mkpath failed for $file: $message")}return@dirs}sub move {my ($self,$dst)=@_;return rename($self->[PATH],$dst)|| $self->_throw('rename',$self->[PATH]."' -> '$dst")}my%opens=(opena=>">>",openr=>"<",openw=>">",openrw=>"+<");while (my ($k,$v)=each%opens){no strict 'refs';*{$k}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);my ($binmode)=@args;$binmode=((caller(0))[10]|| {})->{'open' .substr($v,-1,1)}unless defined$binmode;$self->filehandle($args,$v,$binmode)};*{$k ."_raw"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw")};*{$k ."_utf8"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw:encoding(UTF-8)")}}sub parent {my ($self,$level)=@_;$level=1 unless defined$level && $level > 0;$self->_splitpath unless defined$self->[FILE];my$parent;if (length$self->[FILE]){if ($self->[FILE]eq '.' || $self->[FILE]eq ".."){$parent=path($self->[PATH]."/..")}else {$parent=path(_non_empty($self->[VOL].$self->[DIR]))}}elsif (length$self->[DIR]){if ($self->[DIR]=~ m{(?:^\.\./|/\.\./|/\.\.$)}){$parent=path($self->[VOL].$self->[DIR]."/..")}else {(my$dir=$self->[DIR])=~ s{/[^\/]+/$}{/};$parent=path($self->[VOL].$dir)}}else {$parent=path(_non_empty($self->[VOL]))}return$level==1 ? $parent : $parent->parent($level - 1)}sub _non_empty {my ($string)=shift;return ((defined($string)&& length($string))? $string : ".")}sub realpath {my$self=shift;$self=$self->_resolve_symlinks;require Cwd;$self->_splitpath if!defined$self->[FILE];my$check_parent=length$self->[FILE]&& $self->[FILE]ne '.' && $self->[FILE]ne '..';my$realpath=eval {local$SIG{__WARN__}=sub {};Cwd::realpath($check_parent ? $self->parent->[PATH]: $self->[PATH])};$self->_throw("resolving realpath")unless defined$realpath && length$realpath && -e $realpath;return ($check_parent ? path($realpath,$self->[FILE]): path($realpath))}sub relative {my ($self,$base)=@_;$base=path(defined$base && length$base ? $base : '.');$self=$self->absolute if$self->is_relative;$base=$base->absolute if$base->is_relative;$self=$self->absolute if!length$self->volume && length$base->volume;$base=$base->absolute if length$self->volume &&!length$base->volume;if (!_same($self->volume,$base->volume)){Carp::croak("relative() can't cross volumes: '$self' vs '$base'")}return path(".")if _same($self->[PATH],$base->[PATH]);if ($base->subsumes($self)){$base="" if$base->is_rootdir;my$relative="$self";$relative =~ s{\A\Q$base/}{};return path($relative)}my (@common,@self_parts,@base_parts);@base_parts=split /\//,$base->_just_filepath;if ($self->is_rootdir){@common=("");shift@base_parts}else {@self_parts=split /\//,$self->_just_filepath;while (@self_parts && @base_parts && _same($self_parts[0],$base_parts[0])){push@common,shift@base_parts;shift@self_parts}}if (my$new_base=$self->_resolve_between(\@common,\@base_parts)){return$self->relative($new_base)}my@new_path=(("..")x (0+ @base_parts),@self_parts);return path(@new_path)}sub _just_filepath {my$self=shift;my$self_vol=$self->volume;return "$self" if!length$self_vol;(my$self_path="$self")=~ s{\A\Q$self_vol}{};return$self_path}sub _resolve_between {my ($self,$common,$base)=@_;my$path=$self->volume .join("/",@$common);my$changed=0;for my$p (@$base){$path .= "/$p";if ($p eq '..'){$changed=1;if (-e $path){$path=path($path)->realpath->[PATH]}else {$path =~ s{/[^/]+/..$}{/}}}if (-l $path){$changed=1;$path=path($path)->realpath->[PATH]}}return$changed ? path($path): undef}sub remove {my$self=shift;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];return unlink($self->[PATH])|| $self->_throw('unlink')}sub remove_tree {my ($self,$args)=@_;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};$args->{safe}=1 unless defined$args->{safe};require File::Path;my$count=File::Path::remove_tree($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("remove_tree failed for $file: $message")}return$count}sub sibling {my$self=shift;return path($self->parent->[PATH],@_)}sub slurp {my$self=shift;my$args=_get_args(shift,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);if ((defined($binmode)? $binmode : "")eq ":unix" and my$size=-s $fh){my$buf;read$fh,$buf,$size;return$buf}else {local $/;return scalar <$fh>}}sub slurp_raw {$_[1]={binmode=>":unix" };goto&slurp}sub slurp_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){return Unicode::UTF8::decode_utf8(slurp($_[0],{binmode=>":unix" }))}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$_[1]={binmode=>":unix:utf8_strict" };goto&slurp}else {$_[1]={binmode=>":raw:encoding(UTF-8)" };goto&slurp}}sub spew {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close',$temp->[PATH]);return$temp->move($resolved_path)}sub spew_raw {splice @_,1,0,{binmode=>":unix" };goto&spew}sub spew_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){my$self=shift;spew($self,{binmode=>":unix" },map {Unicode::UTF8::encode_utf8($_)}map {ref eq 'ARRAY' ? @$_ : $_}@_)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){splice @_,1,0,{binmode=>":unix:utf8_strict" };goto&spew}else {splice @_,1,0,{binmode=>":unix:encoding(UTF-8)" };goto&spew}}sub stat {my$self=shift;require File::stat;return File::stat::stat($self->[PATH])|| $self->_throw('stat')}sub lstat {my$self=shift;require File::stat;return File::stat::lstat($self->[PATH])|| $self->_throw('lstat')}sub stringify {$_[0]->[PATH]}sub subsumes {my$self=shift;Carp::croak("subsumes() requires a defined, positive-length argument")unless defined $_[0];my$other=path(shift);if ($self->is_absolute &&!$other->is_absolute){$other=$other->absolute}elsif ($other->is_absolute &&!$self->is_absolute){$self=$self->absolute}if (length$self->volume &&!length$other->volume){$other=$other->absolute}elsif (length$other->volume &&!length$self->volume){$self=$self->absolute}if ($self->[PATH]eq '.'){return!!1}elsif ($self->is_rootdir){return$other->[PATH]=~ m{^\Q$self->[PATH]\E}}else {return$other->[PATH]=~ m{^\Q$self->[PATH]\E(?:/|$)}}}sub touch {my ($self,$epoch)=@_;if (!-e $self->[PATH]){my$fh=$self->openw;close$fh or $self->_throw('close')}if (defined$epoch){utime$epoch,$epoch,$self->[PATH]or $self->_throw("utime ($epoch)")}else {utime undef,undef,$self->[PATH]or $self->_throw("utime ()")}return$self}sub touchpath {my ($self)=@_;my$parent=$self->parent;$parent->mkpath unless$parent->exists;$self->touch}sub visit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);Carp::croak("Callback for visit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$next=$self->iterator($args);my$state={};while (my$file=$next->()){local $_=$file;my$r=$cb->($file,$state);last if ref($r)eq 'SCALAR' &&!$$r}return$state}sub volume {my ($self)=@_;$self->_splitpath unless defined$self->[VOL];return$self->[VOL]}package Path::Tiny::Error;our@CARP_NOT=qw/Path::Tiny/;use overload (q{""}=>sub {(shift)->{msg}},fallback=>1);sub throw {my ($class,$op,$file,$err)=@_;chomp(my$trace=Carp::shortmess);my$msg="Error $op on '$file': $err$trace\n";die bless {op=>$op,file=>$file,err=>$err,msg=>$msg },$class}1;
PATH_TINY

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  package String::ShellQuote;use strict;use vars qw($VERSION @ISA @EXPORT);require Exporter;$VERSION='1.04';@ISA=qw(Exporter);@EXPORT=qw(shell_quote shell_quote_best_effort shell_comment_quote);sub croak {require Carp;goto&Carp::croak}sub _shell_quote_backend {my@in=@_;my@err=();if (0){require RS::Handy;print RS::Handy::data_dump(\@in)}return \@err,'' unless@in;my$ret='';my$saw_non_equal=0;for (@in){if (!defined $_ or $_ eq ''){$_="''";next}if (s/\x00//g){push@err,"No way to quote string containing null (\\000) bytes"}my$escape=0;if (/=/){if (!$saw_non_equal){$escape=1}}else {$saw_non_equal=1}if (m|[^\w!%+,\-./:=@^]|){$escape=1}if ($escape || (!$saw_non_equal && /=/)){s/'/'\\''/g;s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;$_="'$_'";s/^''//;s/''$//}}continue {$ret .= "$_ "}chop$ret;return \@err,$ret}sub shell_quote {my ($rerr,$s)=_shell_quote_backend @_;if (@$rerr){my%seen;@$rerr=grep {!$seen{$_}++}@$rerr;my$s=join '',map {"shell_quote(): $_\n"}@$rerr;chomp$s;croak$s}return$s}sub shell_quote_best_effort {my ($rerr,$s)=_shell_quote_backend @_;return$s}sub shell_comment_quote {return '' unless @_;unless (@_==1){croak "Too many arguments to shell_comment_quote " ."(got " .@_ ." expected 1)"}local $_=shift;s/\n/\n#/g;return $_}1;
STRING_SHELLQUOTE

$fatpacked{"Task/Weaken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TASK_WEAKEN';
  package Task::Weaken;use 5.005;use strict;our$VERSION='1.06';1;
TASK_WEAKEN

$fatpacked{"Test/CPAN/Changes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_CPAN_CHANGES';
  package Test::CPAN::Changes;use strict;use warnings;use CPAN::Changes;use Test::Builder;use version ();our$VERSION='0.400002';my$Test=Test::Builder->new;sub import {my$self=shift;my$caller=caller;no strict 'refs';*{$caller .'::changes_ok'}=\&changes_ok;*{$caller .'::changes_file_ok'}=\&changes_file_ok;$Test->exported_to($caller);$Test->plan(@_)}sub changes_ok {$Test->plan(tests=>4);return changes_file_ok(undef,@_)}sub changes_file_ok {my ($file,$arg)=@_;$file ||= 'Changes';$arg ||= {};my$changes=eval {CPAN::Changes->load($file)};if ($@){$Test->ok(0,"Unable to parse $file");$Test->diag("  ERR: $@");return}$Test->ok(1,"$file is loadable");my@releases=$changes->releases;if (!@releases){$Test->ok(0,"$file does not contain any releases");return}$Test->ok(1,"$file contains at least one release");for (@releases){if (!defined $_->date || $_->date eq ''){$Test->ok(0,"$file contains an invalid release date");$Test->diag('  ERR: No date at version ' .$_->version);return}my$d=$_->{_parsed_date };if ($d !~ m[^${CPAN::Changes::W3CDTF_REGEX}$] && $d !~ m[^(${CPAN::Changes::UNKNOWN_VALS})$]){$Test->carp('Date "' .$d .'" is not in the recommended format')}(my$version=$_->version)=~ s/-TRIAL$//;if (not version::is_lax($version)){$Test->ok(0,"$file contains an invalid version number");$Test->diag('  ERR: ' .$_->version);return}}$Test->ok(1,"$file contains valid release dates");$Test->ok(1,"$file contains valid version numbers");if (defined$arg->{version}){my$v=$arg->{version};if (my$release=$changes->release($v)){$Test->ok(1,"$file has an entry for the current version, $v");my$changes=$release->changes;if ($changes and grep {@$_ > 0}values %$changes){$Test->ok(1,"entry for the current version, $v, has content")}else {$Test->ok(0,"entry for the current version, $v, no content")}}else {$Test->ok(0,"$file has no entry for the current version, $v");$Test->ok(0,"$file has no entry for the current version, $v")}}return$changes}1;
TEST_CPAN_CHANGES

$fatpacked{"Tie/Handle/Offset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_OFFSET';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::Offset;our$VERSION='0.004';use Tie::Handle;our@ISA=qw/Tie::Handle/;sub offset {my$self=shift;if (@_){return ${*$self}{offset}=shift}else {return ${*$self}{offset}}}sub TIEHANDLE {my$class=shift;my$params;$params=pop if ref $_[-1]eq 'HASH';my$self=\do {no warnings 'once';local*HANDLE};bless$self,$class;$self->OPEN(@_)if (@_);if ($params->{offset}){seek($self,$self->offset($params->{offset}),0)}return$self}sub TELL {my$cur=tell($_[0])- $_[0]->offset;return$cur > 0 ? $cur : 0}sub SEEK {my ($self,$pos,$whence)=@_;my$rc;if ($whence==0 || $whence==1){$rc=seek($self,$pos + $self->offset,$whence)}elsif (_size($self)+ $pos < $self->offset){$rc=''}else {$rc=seek($self,$pos,$whence)}return$rc}sub OPEN {$_[0]->offset(0);$_[0]->CLOSE if defined($_[0]->FILENO);@_==2 ? open($_[0],$_[1]): open($_[0],$_[1],$_[2])}sub _size {my ($self)=@_;my$cur=tell($self);seek($self,0,2);my$size=tell($self);seek($self,$cur,0);return$size}sub EOF {eof($_[0])}sub FILENO {fileno($_[0])}sub CLOSE {close($_[0])}sub BINMODE {binmode($_[0])}sub READ {read($_[0],$_[1],$_[2])}sub READLINE {my$fh=$_[0];<$fh>}sub GETC {getc($_[0])}sub WRITE {my$fh=$_[0];print$fh substr($_[1],0,$_[2])}1;
TIE_HANDLE_OFFSET

$fatpacked{"Tie/Handle/SkipHeader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_SKIPHEADER';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::SkipHeader;our$VERSION='0.004';use Tie::Handle::Offset;our@ISA=qw/Tie::Handle::Offset/;sub TIEHANDLE {my$class=shift;pop if ref $_[-1]eq 'HASH';return$class->SUPER::TIEHANDLE(@_)}sub OPEN {my$self=shift;my$rc=$self->SUPER::OPEN(@_);while (my$line=<$self>){last if$line =~ /\A\s*\Z/}$self->offset(tell($self));return$rc}1;
TIE_HANDLE_SKIPHEADER

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.30';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}_subname(caller().'::try {...} '=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;_subname(caller().'::catch {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;_subname(caller().'::finally {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;use strict;use warnings;our$VERSION='1.76';our ($ABS_REMOTE_LEADING_DOTS,$ABS_ALLOW_RELATIVE_SCHEME,$DEFAULT_QUERY_FORM_DELIMITER);my%implements;our$reserved=q(;/?:@&=+$,[]);our$mark=q(-_.!~*'());our$unreserved="A-Za-z0-9\Q$mark\E";our$uric=quotemeta($reserved).$unreserved ."%";our$scheme_re='[a-zA-Z][a-zA-Z0-9.+\-]*';use Carp ();use URI::Escape ();use overload ('""'=>sub {${$_[0]}},'=='=>sub {_obj_eq(@_)},'!='=>sub {!_obj_eq(@_)},fallback=>1,);sub _obj_eq {return overload::StrVal($_[0])eq overload::StrVal($_[1])}sub new {my($class,$uri,$scheme)=@_;$uri=defined ($uri)? "$uri" : "";$uri =~ s/^<(?:URL:)?(.*)>$/$1/;$uri =~ s/^"(.*)"$/$1/;$uri =~ s/^\s+//;$uri =~ s/\s+$//;my$impclass;if ($uri =~ m/^($scheme_re):/so){$scheme=$1}else {if (($impclass=ref($scheme))){$scheme=$scheme->scheme}elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o){$scheme=$1}}$impclass ||= implementor($scheme)|| do {require URI::_foreign;$impclass='URI::_foreign'};return$impclass->_init($uri,$scheme)}sub new_abs {my($class,$uri,$base)=@_;$uri=$class->new($uri,$base);$uri->abs($base)}sub _init {my$class=shift;my($str,$scheme)=@_;$str=$class->_uric_escape($str);$str="$scheme:$str" unless$str =~ /^$scheme_re:/o || $class->_no_scheme_ok;my$self=bless \$str,$class;$self}sub _uric_escape {my($class,$str)=@_;$str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;utf8::downgrade($str);return$str}my%require_attempted;sub implementor {my($scheme,$impclass)=@_;if (!$scheme || $scheme !~ /\A$scheme_re\z/o){require URI::_generic;return "URI::_generic"}$scheme=lc($scheme);if ($impclass){my$old=$implements{$scheme};$impclass->_init_implementor($scheme);$implements{$scheme}=$impclass;return$old}my$ic=$implements{$scheme};return$ic if$ic;$ic="URI::$scheme";$ic =~ s/\+/_P/g;$ic =~ s/\./_O/g;$ic =~ s/\-/_/g;no strict 'refs';unless (@{"${ic}::ISA"}){if (not exists$require_attempted{$ic}){my$_old_error=$@;eval "require $ic";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}return undef unless @{"${ic}::ISA"}}$ic->_init_implementor($scheme);$implements{$scheme}=$ic;$ic}sub _init_implementor {my($class,$scheme)=@_}sub clone {my$self=shift;my$other=$$self;bless \$other,ref$self}sub TO_JSON {${$_[0]}}sub _no_scheme_ok {0}sub _scheme {my$self=shift;unless (@_){return undef unless $$self =~ /^($scheme_re):/o;return $1}my$old;my$new=shift;if (defined($new)&& length($new)){Carp::croak("Bad scheme '$new'")unless$new =~ /^$scheme_re$/o;$old=$1 if $$self =~ s/^($scheme_re)://o;my$newself=URI->new("$new:$$self");$$self=$$newself;bless$self,ref($newself)}else {if ($self->_no_scheme_ok){$old=$1 if $$self =~ s/^($scheme_re)://o;Carp::carp("Oops, opaque part now look like scheme")if $^W && $$self =~ m/^$scheme_re:/o}else {$old=$1 if $$self =~ m/^($scheme_re):/o}}return$old}sub scheme {my$scheme=shift->_scheme(@_);return undef unless defined$scheme;lc($scheme)}sub has_recognized_scheme {my$self=shift;return ref($self)!~ /^URI::_(?:foreign|generic)\z/}sub opaque {my$self=shift;unless (@_){$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;return $1}$$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;my$old_scheme=$1;my$old_opaque=$2;my$old_frag=$3;my$new_opaque=shift;$new_opaque="" unless defined$new_opaque;$new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_opaque);$$self=defined($old_scheme)? $old_scheme : "";$$self .= $new_opaque;$$self .= $old_frag if defined$old_frag;$old_opaque}sub path {goto&opaque}sub fragment {my$self=shift;unless (@_){return undef unless $$self =~ /\#(.*)/s;return $1}my$old;$old=$1 if $$self =~ s/\#(.*)//s;my$new_frag=shift;if (defined$new_frag){$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;utf8::downgrade($new_frag);$$self .= "#$new_frag"}$old}sub as_string {my$self=shift;$$self}sub as_iri {my$self=shift;my$str=$$self;if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg){require Encode;my$enc=Encode::find_encoding("UTF-8");my$u="";while (length$str){$u .= $enc->decode($str,Encode::FB_QUIET());if (length$str){$u .= URI::Escape::escape_char(substr($str,0,1,""))}}$str=$u}return$str}sub canonical {my$self=shift;my$scheme=$self->_scheme || "";my$uc_scheme=$scheme =~ /[A-Z]/;my$esc=$$self =~ /%[a-fA-F0-9]{2}/;return$self unless$uc_scheme || $esc;my$other=$self->clone;if ($uc_scheme){$other->_scheme(lc$scheme)}if ($esc){$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge}return$other}sub eq {my($self,$other)=@_;$self=URI->new($self,$other)unless ref$self;$other=URI->new($other,$self)unless ref$other;ref($self)eq ref($other)&& $self->canonical->as_string eq $other->canonical->as_string}sub abs {$_[0]}sub rel {$_[0]}sub secure {0}sub STORABLE_freeze {my($self,$cloning)=@_;return $$self}sub STORABLE_thaw {my($self,$cloning,$str)=@_;$$self=$str}1;
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;use strict;use warnings;use Exporter 5.57 'import';our%escapes;our@EXPORT=qw(uri_escape uri_unescape uri_escape_utf8);our@EXPORT_OK=qw(%escapes);our$VERSION="3.31";use Carp ();for (0..255){$escapes{chr($_)}=sprintf("%%%02X",$_)}my%subst;my%Unsafe=(RFC2732=>qr/[^A-Za-z0-9\-_.!~*'()]/,RFC3986=>qr/[^A-Za-z0-9\-\._~]/,);sub uri_escape {my($text,$patn)=@_;return undef unless defined$text;if (defined$patn){unless (exists$subst{$patn}){(my$tmp=$patn)=~ s,/,\\/,g;eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";Carp::croak("uri_escape: $@")if $@}&{$subst{$patn}}($text)}else {$text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge}$text}sub _fail_hi {my$chr=shift;Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead",ord($chr))}sub uri_escape_utf8 {my$text=shift;return undef unless defined$text;utf8::encode($text);return uri_escape($text,@_)}sub uri_unescape {my$str=shift;if (@_ && wantarray){my@str=($str,@_);for (@str){s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}return@str}$str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined$str;$str}sub escape_char {my$dummy=substr($_[0],0,0);if (utf8::is_utf8($_[0])){my$s=shift;utf8::encode($s);unshift(@_,$s)}return join '',@URI::Escape::escapes{split //,$_[0]}}1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;use strict;use warnings;use Exporter 5.57 'import';our@EXPORT_OK=qw(uf_uri uf_uristr uf_url uf_urlstr);our$VERSION="4.20";our ($MY_COUNTRY,$DEBUG);sub MY_COUNTRY() {for ($MY_COUNTRY){return $_ if defined;$_=$ENV{COUNTRY};return $_ if defined;my@srcs=($ENV{LC_ALL},$ENV{LANG});if (my$httplang=$ENV{HTTP_ACCEPT_LANGUAGE}){for$httplang (split(/\s*,\s*/,$httplang)){if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/){unshift(@srcs,"${1}_${2}");last}}}for (@srcs){next unless defined;return lc($1)if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/}require Net::Domain;my$fqdn=Net::Domain::hostfqdn();$_=lc($1)if$fqdn =~ /\.([a-zA-Z]{2})$/;return $_ if defined;return ($_=0)}}our%LOCAL_GUESSING=('us'=>[qw(www.ACME.gov www.ACME.mil)],'gb'=>[qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],'au'=>[qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],'il'=>[qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],);$LOCAL_GUESSING{uk}=$LOCAL_GUESSING{gb};sub uf_uristr ($) {local($_)=@_;print STDERR "uf_uristr: resolving $_\n" if$DEBUG;return unless defined;s/^\s+//;s/\s+$//;if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i){$_="http://$_"}elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i){$_=lc($1)."://$_"}elsif ($^O ne "MacOS" && (m,^/, || m,^\.\.?/, || m,^[a-zA-Z]:[/\\],)){$_="file:$_"}elsif ($^O eq "MacOS" && m/:/){unless (m/^(ftp|gopher|news|wais|http|https|mailto):/){require URI::file;my$a=URI::file->new($_)->as_string;$_=($a =~ m/^file:/)? $a : "file:$a"}}elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/){$_="mailto:$_"}elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/){if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/){my$host=$1;my$scheme="http";if (/^:(\d+)\b/){if ($1 =~ /^[56789]?443$/){$scheme="https"}elsif ($1 eq "21"){$scheme="ftp"}}if ($host !~ /\./ && $host ne "localhost"){my@guess;if (exists$ENV{URL_GUESS_PATTERN}){@guess=map {s/\bACME\b/$host/;$_}split(' ',$ENV{URL_GUESS_PATTERN})}else {if (MY_COUNTRY()){my$special=$LOCAL_GUESSING{MY_COUNTRY()};if ($special){my@special=@$special;push(@guess,map {s/\bACME\b/$host/;$_}@special)}else {push(@guess,"www.$host." .MY_COUNTRY())}}push(@guess,map "www.$host.$_","com","org","net","edu","int")}my$guess;for$guess (@guess){print STDERR "uf_uristr: gethostbyname('$guess.')..." if$DEBUG;if (gethostbyname("$guess.")){print STDERR "yes\n" if$DEBUG;$host=$guess;last}print STDERR "no\n" if$DEBUG}}$_="$scheme://$host$_"}else {}}print STDERR "uf_uristr: ==> $_\n" if$DEBUG;$_}sub uf_uri ($) {require URI;URI->new(uf_uristr($_[0]))}*uf_urlstr=\*uf_uristr;sub uf_url ($) {require URI::URL;URI::URL->new(uf_uristr($_[0]))}1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;use strict;use warnings;use URI ();use overload '""'=>sub {shift->as_string};our$VERSION='1.76';sub new {my($class,$uri,$scheme)=@_;utf8::upgrade($uri);return bless {uri=>URI->new($uri,$scheme),},$class}sub clone {my$self=shift;return bless {uri=>$self->{uri}->clone,},ref($self)}sub as_string {my$self=shift;return$self->{uri}->as_iri}our$AUTOLOAD;sub AUTOLOAD {my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);no strict 'refs';*$method=sub {shift->{uri}->$method(@_)};goto &$method}sub DESTROY {}1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;use strict;use warnings;our$VERSION='1.76';sub URI::_query::query_param {my$self=shift;my@old=$self->query_form;if (@_==0){my (%seen,$i);return grep!($i++ % 2 || $seen{$_}++),@old}my$key=shift;my@i=grep $_ % 2==0 && $old[$_]eq $key,0 .. $#old;if (@_){my@new=@old;my@new_i=@i;my@vals=map {ref($_)eq 'ARRAY' ? @$_ : $_}@_;while (@new_i > @vals){splice@new,pop@new_i,2}if (@vals > @new_i){my$i=@new_i ? $new_i[-1]+ 2 : @new;my@splice=splice@vals,@new_i,@vals - @new_i;splice@new,$i,0,map {$key=>$_}@splice}if (@vals){@new[map $_ + 1,@new_i ]=@vals}$self->query_form(\@new)}return wantarray ? @old[map $_+1,@i]: @i ? $old[$i[0]+1]: undef}sub URI::_query::query_param_append {my$self=shift;my$key=shift;my@vals=map {ref $_ eq 'ARRAY' ? @$_ : $_}@_;$self->query_form($self->query_form,$key=>\@vals);return}sub URI::_query::query_param_delete {my$self=shift;my$key=shift;my@old=$self->query_form;my@vals;for (my$i=@old - 2;$i >= 0;$i -= 2){next if$old[$i]ne $key;push(@vals,(splice(@old,$i,2))[1])}$self->query_form(\@old)if@vals;return wantarray ? reverse@vals : $vals[-1]}sub URI::_query::query_form_hash {my$self=shift;my@old=$self->query_form;if (@_){$self->query_form(@_==1 ? %{shift(@_)}: @_)}my%hash;while (my($k,$v)=splice(@old,0,2)){if (exists$hash{$k}){for ($hash{$k}){$_=[$_]unless ref($_)eq "ARRAY";push(@$_,$v)}}else {$hash{$k}=$v}}return \%hash}1;
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;use strict;use warnings;our$VERSION='1.76';use Exporter 5.57 'import';our@EXPORT_OK=qw(uri_split uri_join);use URI::Escape ();sub uri_split {return $_[0]=~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,}sub uri_join {my($scheme,$auth,$path,$query,$frag)=@_;my$uri=defined($scheme)? "$scheme:" : "";$path="" unless defined$path;if (defined$auth){$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$uri .= "//$auth";$path="/$path" if length($path)&& $path !~ m,^/,}elsif ($path =~ m,^//,){$uri .= "//"}unless (length$uri){$path =~ s,(:), URI::Escape::escape_char($1),e while$path =~ m,^[^:/?\#]+:,}$path =~ s,([?\#]), URI::Escape::escape_char($1),eg;$uri .= $path;if (defined$query){$query =~ s,(\#), URI::Escape::escape_char($1),eg;$uri .= "?$query"}$uri .= "#$frag" if defined$frag;$uri}1;
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;use strict;use warnings;use parent 'URI::WithBase';our$VERSION="5.04";use Exporter 5.57 'import';our@EXPORT=qw(url);sub url ($;$) {URI::URL->new(@_)}use URI::Escape qw(uri_unescape);sub new {my$class=shift;my$self=$class->SUPER::new(@_);$self->[0]=$self->[0]->canonical;$self}sub newlocal {my$class=shift;require URI::file;bless [URI::file->new_abs(shift)],$class}{package URI::_foreign;sub _init {my$class=shift;die "Unknown URI::URL scheme $_[1]:" if$URI::URL::STRICT;$class->SUPER::_init(@_)}}sub strict {my$old=$URI::URL::STRICT;$URI::URL::STRICT=shift if @_;$old}sub print_on {my$self=shift;require Data::Dumper;print STDERR Data::Dumper::Dumper($self)}sub _try {my$self=shift;my$method=shift;scalar(eval {$self->$method(@_)})}sub crack {my$self=shift;(scalar($self->scheme),$self->_try("user"),$self->_try("password"),$self->_try("host"),$self->_try("port"),$self->_try("path"),$self->_try("params"),$self->_try("query"),scalar($self->fragment),)}sub full_path {my$self=shift;my$path=$self->path_query;$path="/" unless length$path;$path}sub netloc {shift->authority(@_)}sub epath {my$path=shift->SUPER::path(@_);$path =~ s/;.*//;$path}sub eparams {my$self=shift;my@p=$self->path_segments;return undef unless ref($p[-1]);@p=@{$p[-1]};shift@p;join(";",@p)}sub params {shift->eparams(@_)}sub path {my$self=shift;my$old=$self->epath(@_);return unless defined wantarray;return '/' if!defined($old)||!length($old);Carp::croak("Path components contain '/' (you must call epath)")if$old =~ /%2[fF]/ and!@_;$old="/$old" if$old !~ m|^/| && defined$self->netloc;return uri_unescape($old)}sub path_components {shift->path_segments(@_)}sub query {my$self=shift;my$old=$self->equery(@_);if (defined(wantarray)&& defined($old)){if ($old =~ /%(?:26|2[bB]|3[dD])/){my$mess;for ($old){$mess="Query contains both '+' and '%2B'" if /\+/ && /%2[bB]/;$mess="Form query contains escaped '=' or '&'" if /=/ && /%(?:3[dD]|26)/}if ($mess){Carp::croak("$mess (you must call equery)")}}return uri_unescape($old)}undef}sub abs {my$self=shift;my$base=shift;my$allow_scheme=shift;$allow_scheme=$URI::URL::ABS_ALLOW_RELATIVE_SCHEME unless defined$allow_scheme;local$URI::ABS_ALLOW_RELATIVE_SCHEME=$allow_scheme;local$URI::ABS_REMOTE_LEADING_DOTS=$URI::URL::ABS_REMOTE_LEADING_DOTS;$self->SUPER::abs($base)}sub frag {shift->fragment(@_)}sub keywords {shift->query_keywords(@_)}sub local_path {shift->file}sub unix_path {shift->file("unix")}sub dos_path {shift->file("dos")}sub mac_path {shift->file("mac")}sub vms_path {shift->file("vms")}sub address {shift->to(@_)}sub encoded822addr {shift->to(@_)}sub URI::mailto::authority {shift->to(@_)}sub groupart {shift->_group(@_)}sub article {shift->message(@_)}1;
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;use strict;use warnings;use URI;use Scalar::Util 'blessed';our$VERSION="2.20";use overload '""'=>"as_string",fallback=>1;sub as_string;sub new {my($class,$uri,$base)=@_;my$ibase=$base;if ($base && blessed($base)&& $base->isa(__PACKAGE__)){$base=$base->abs;$ibase=$base->[0]}bless [URI->new($uri,$ibase),$base],$class}sub new_abs {my$class=shift;my$self=$class->new(@_);$self->abs}sub _init {my$class=shift;my($str,$scheme)=@_;bless [URI->new($str,$scheme),undef],$class}sub eq {my($self,$other)=@_;$other=$other->[0]if blessed($other)and $other->isa(__PACKAGE__);$self->[0]->eq($other)}our$AUTOLOAD;sub AUTOLOAD {my$self=shift;my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);return if$method eq "DESTROY";$self->[0]->$method(@_)}sub can {my$self=shift;$self->SUPER::can(@_)|| (ref($self)? $self->[0]->can(@_): undef)}sub base {my$self=shift;my$base=$self->[1];if (@_){my$new_base=shift;$new_base=$new_base->abs if ref($new_base)&& $new_base->isa(__PACKAGE__);$self->[1]=$new_base}return unless defined wantarray;if (defined($base)&&!ref($base)){$base=ref($self)->new($base);$self->[1]=$base unless @_}$base}sub clone {my$self=shift;my$base=$self->[1];$base=$base->clone if ref($base);bless [$self->[0]->clone,$base],ref($self)}sub abs {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->abs($base,@_),$base],ref($self)}sub rel {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->rel($base,@_),$base],ref($self)}1;
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;use strict;use warnings;use parent 'URI::_generic';our$VERSION='1.76';1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;use strict;use warnings;use parent qw(URI URI::_query);use URI::Escape qw(uri_unescape);use Carp ();our$VERSION='1.76';my$ACHAR=$URI::uric;$ACHAR =~ s,\\[/?],,g;my$PCHAR=$URI::uric;$PCHAR =~ s,\\[?],,g;sub _no_scheme_ok {1}sub authority {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;if (@_){my$auth=shift;$$self=$1;my$rest=$3;if (defined$auth){$auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($auth);$$self .= "//$auth"}_check_path($rest,$$self);$$self .= $rest}$2}sub path {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub path_query {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub _check_path {my($path,$pre)=@_;my$prefix;if ($pre =~ m,/,){$prefix="/" if length($path)&& $path !~ m,^[/?\#],}else {if ($path =~ m,^//,){Carp::carp("Path starting with double slash is confusing")if $^W}elsif (!length($pre)&& $path =~ m,^[^:/?\#]+:,){Carp::carp("Path might look like scheme, './' prepended")if $^W;$prefix="./"}}substr($_[0],0,0)=$prefix if defined$prefix}sub path_segments {my$self=shift;my$path=$self->path;if (@_){my@arg=@_;for (@arg){if (ref($_)){my@seg=@$_;$seg[0]=~ s/%/%25/g;for (@seg){s/;/%3B/g}$_=join(";",@seg)}else {s/%/%25/g;s/;/%3B/g}s,/,%2F,g}$self->path(join("/",@arg))}return$path unless wantarray;map {/;/ ? $self->_split_segment($_): uri_unescape($_)}split('/',$path,-1)}sub _split_segment {my$self=shift;require URI::_segment;URI::_segment->new(@_)}sub abs {my$self=shift;my$base=shift || Carp::croak("Missing base argument");if (my$scheme=$self->scheme){return$self unless$URI::ABS_ALLOW_RELATIVE_SCHEME;$base=URI->new($base)unless ref$base;return$self unless$scheme eq $base->scheme}$base=URI->new($base)unless ref$base;my$abs=$self->clone;$abs->scheme($base->scheme);return$abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;$abs->authority($base->authority);my$path=$self->path;return$abs if$path =~ m,^/,;if (!length($path)){my$abs=$base->clone;my$query=$self->query;$abs->query($query)if defined$query;my$fragment=$self->fragment;$abs->fragment($fragment)if defined$fragment;return$abs}my$p=$base->path;$p =~ s,[^/]+$,,;$p .= $path;my@p=split('/',$p,-1);shift(@p)if@p &&!length($p[0]);my$i=1;while ($i < @p){if ($p[$i-1]eq "."){splice(@p,$i-1,1);$i-- if$i > 1}elsif ($p[$i]eq ".." && $p[$i-1]ne ".."){splice(@p,$i-1,2);if ($i > 1){$i--;push(@p,"")if$i==@p}}else {$i++}}$p[-1]="" if@p && $p[-1]eq ".";if ($URI::ABS_REMOTE_LEADING_DOTS){shift@p while@p && $p[0]=~ /^\.\.?$/}$abs->path("/" .join("/",@p));$abs}sub rel {my$self=shift;my$base=shift || Carp::croak("Missing base argument");my$rel=$self->clone;$base=URI->new($base)unless ref$base;my$scheme=$rel->scheme;my$auth=$rel->canonical->authority;my$path=$rel->path;if (!defined($scheme)&&!defined($auth)){return$rel}my$bscheme=$base->scheme;my$bauth=$base->canonical->authority;my$bpath=$base->path;for ($bscheme,$bauth,$auth){$_='' unless defined}unless ($scheme eq $bscheme && $auth eq $bauth){return$rel}for ($path,$bpath){$_="/$_" unless m,^/,}$rel->scheme(undef);$rel->authority(undef);my$li=1;while (1){my$i=index($path,'/',$li);last if$i < 0 || $i!=index($bpath,'/',$li)|| substr($path,$li,$i-$li)ne substr($bpath,$li,$i-$li);$li=$i+1}substr($path,0,$li)='';substr($bpath,0,$li)='';if ($path eq $bpath && defined($rel->fragment)&& !defined($rel->query)){$rel->path("")}else {$path=('../' x $bpath =~ tr|/|/|).$path;$path="./" if$path eq "";$rel->path($path)}$rel}1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;use strict;use warnings;use URI::_punycode qw(encode_punycode decode_punycode);use Carp qw(croak);our$VERSION='1.76';BEGIN {*URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS="$]" < 5.008_003 ? sub () {1}: sub () {0}}my$ASCII=qr/^[\x00-\x7F]*\z/;sub encode {my$idomain=shift;my@labels=split(/\./,$idomain,-1);my@last_empty;push(@last_empty,pop@labels)if@labels > 1 && $labels[-1]eq "";for (@labels){$_=ToASCII($_)}return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;return join(".",@labels,@last_empty)}sub decode {my$domain=shift;return join(".",map ToUnicode($_),split(/\./,$domain,-1))}sub nameprep {my$label=shift;$label=lc($label);return$label}sub check_size {my$label=shift;croak "Label empty" if$label eq "";croak "Label too long" if length($label)> 63;return$label}sub ToASCII {my$label=shift;return check_size($label)if$label =~ $ASCII;$label=nameprep($label);return check_size($label)if$label =~ $ASCII;if ($label =~ /^xn--/){croak "Label starts with ACE prefix"}$label=encode_punycode($label);$label="xn--$label";return check_size($label)}sub ToUnicode {my$label=shift;$label=nameprep($label)unless$label =~ $ASCII;return$label unless$label =~ /^xn--/;my$result=decode_punycode(substr($label,4));my$label2=ToASCII($result);if (lc($label)ne $label2){croak "IDNA does not round-trip: '\L$label\E' vs '$label2'"}return$result}1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  package URI::_ldap;use strict;use warnings;our$VERSION='1.76';use URI::Escape qw(uri_unescape);sub _ldap_elem {my$self=shift;my$elem=shift;my$query=$self->query;my@bits=(split(/\?/,defined($query)? $query : ""),("")x4);my$old=$bits[$elem];if (@_){my$new=shift;$new =~ s/\?/%3F/g;$bits[$elem]=$new;$query=join("?",@bits);$query =~ s/\?+$//;$query=undef unless length($query);$self->query($query)}$old}sub dn {my$old=shift->path(@_);$old =~ s:^/::;uri_unescape($old)}sub attributes {my$self=shift;my$old=_ldap_elem($self,0,@_ ? join(",",map {my$tmp=$_;$tmp =~ s/,/%2C/g;$tmp}@_): ());return$old unless wantarray;map {uri_unescape($_)}split(/,/,$old)}sub _scope {my$self=shift;my$old=_ldap_elem($self,1,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub scope {my$old=&_scope;$old="base" unless length$old;$old}sub _filter {my$self=shift;my$old=_ldap_elem($self,2,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub filter {my$old=&_filter;$old="(objectClass=*)" unless length$old;$old}sub extensions {my$self=shift;my@ext;while (@_){my$key=shift;my$value=shift;push(@ext,join("=",map {$_="" unless defined;s/,/%2C/g;$_}$key,$value))}@ext=join(",",@ext)if@ext;my$old=_ldap_elem($self,3,@ext);return$old unless wantarray;map {uri_unescape($_)}map {/^([^=]+)=(.*)$/}split(/,/,$old)}sub canonical {my$self=shift;my$other=$self->_nonldap_canonical;$other=$other->clone if$other==$self;$other->dn(_normalize_dn($other->dn));$other->attributes(map lc,$other->attributes);my$old_scope=$other->scope;my$new_scope=lc($old_scope);$new_scope="" if$new_scope eq "base";$other->scope($new_scope)if$new_scope ne $old_scope;my$old_filter=$other->filter;$other->filter("")if lc($old_filter)eq "(objectclass=*)" || lc($old_filter)eq "objectclass=*";my@ext=$other->extensions;for (my$i=0;$i < @ext;$i += 2){my$etype=$ext[$i]=lc($ext[$i]);if ($etype =~ /^!?bindname$/){$ext[$i+1]=_normalize_dn($ext[$i+1])}}$other->extensions(@ext)if@ext;$other}sub _normalize_dn {my$dn=shift;return$dn;my@dn=split(/([+,])/,$dn);for (@dn){s/^([a-zA-Z]+=)/lc($1)/e}join("",@dn)}1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;use strict;use warnings;use parent qw(URI::_server URI::_userpass);our$VERSION='1.76';1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;use strict;use warnings;our$VERSION='1.76';use Exporter 'import';our@EXPORT=qw(encode_punycode decode_punycode);use integer;our$DEBUG=0;use constant BASE=>36;use constant TMIN=>1;use constant TMAX=>26;use constant SKEW=>38;use constant DAMP=>700;use constant INITIAL_BIAS=>72;use constant INITIAL_N=>128;my$Delimiter=chr 0x2D;my$BasicRE=qr/[\x00-\x7f]/;sub _croak {require Carp;Carp::croak(@_)}sub digit_value {my$code=shift;return ord($code)- ord("A")if$code =~ /[A-Z]/;return ord($code)- ord("a")if$code =~ /[a-z]/;return ord($code)- ord("0")+ 26 if$code =~ /[0-9]/;return}sub code_point {my$digit=shift;return$digit + ord('a')if 0 <= $digit && $digit <= 25;return$digit + ord('0')- 26 if 26 <= $digit && $digit <= 36;die 'NOT COME HERE'}sub adapt {my($delta,$numpoints,$firsttime)=@_;$delta=$firsttime ? $delta / DAMP : $delta / 2;$delta += $delta / $numpoints;my$k=0;while ($delta > ((BASE - TMIN)* TMAX)/ 2){$delta /= BASE - TMIN;$k += BASE}return$k + (((BASE - TMIN + 1)* $delta)/ ($delta + SKEW))}sub decode_punycode {my$code=shift;my$n=INITIAL_N;my$i=0;my$bias=INITIAL_BIAS;my@output;if ($code =~ s/(.*)$Delimiter//o){push@output,map ord,split //,$1;return _croak('non-basic code point')unless $1 =~ /^$BasicRE*$/o}while ($code){my$oldi=$i;my$w=1;LOOP: for (my$k=BASE;1;$k += BASE){my$cp=substr($code,0,1,'');my$digit=digit_value($cp);defined$digit or return _croak("invalid punycode input");$i += $digit * $w;my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$digit < $t;$w *= (BASE - $t)}$bias=adapt($i - $oldi,@output + 1,$oldi==0);warn "bias becomes $bias" if$DEBUG;$n += $i / (@output + 1);$i=$i % (@output + 1);splice(@output,$i,0,$n);warn join " ",map sprintf('%04x',$_),@output if$DEBUG;$i++}return join '',map chr,@output}sub encode_punycode {my$input=shift;my@input=split //,$input;my$n=INITIAL_N;my$delta=0;my$bias=INITIAL_BIAS;my@output;my@basic=grep /$BasicRE/,@input;my$h=my$b=@basic;push@output,@basic;push@output,$Delimiter if$b && $h < @input;warn "basic codepoints: (@output)" if$DEBUG;while ($h < @input){my$m=min(grep {$_ >= $n}map ord,@input);warn sprintf "next code point to insert is %04x",$m if$DEBUG;$delta += ($m - $n)* ($h + 1);$n=$m;for my$i (@input){my$c=ord($i);$delta++ if$c < $n;if ($c==$n){my$q=$delta;LOOP: for (my$k=BASE;1;$k += BASE){my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$q < $t;my$cp=code_point($t + (($q - $t)% (BASE - $t)));push@output,chr($cp);$q=($q - $t)/ (BASE - $t)}push@output,chr(code_point($q));$bias=adapt($delta,$h + 1,$h==$b);warn "bias becomes $bias" if$DEBUG;$delta=0;$h++}}$delta++;$n++}return join '',@output}sub min {my$min=shift;for (@_){$min=$_ if $_ <= $min}return$min}1;
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;use strict;use warnings;use URI ();use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub query {my$self=shift;$$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;if (@_){my$q=shift;$$self=$1;if (defined$q){$q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($q);$$self .= "?$q"}$$self .= $3}$2}sub query_form {my$self=shift;my$old=$self->query;if (@_){my$delim;my$r=$_[0];if (ref($r)eq "ARRAY"){$delim=$_[1];@_=@$r}elsif (ref($r)eq "HASH"){$delim=$_[1];@_=map {$_=>$r->{$_}}sort keys %$r}$delim=pop if @_ % 2;my@query;while (my($key,$vals)=splice(@_,0,2)){$key='' unless defined$key;$key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$key =~ s/ /+/g;$vals=[ref($vals)eq "ARRAY" ? @$vals : $vals];for my$val (@$vals){$val='' unless defined$val;$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$val =~ s/ /+/g;push(@query,"$key=$val")}}if (@query){unless ($delim){$delim=$1 if$old && $old =~ /([&;])/;$delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&"}$self->query(join($delim,@query))}else {$self->query(undef)}}return if!defined($old)||!length($old)||!defined(wantarray);return unless$old =~ /=/;map {s/\+/ /g;uri_unescape($_)}map {/=/ ? split(/=/,$_,2): ($_=>'')}split(/[&;]/,$old)}sub query_keywords {my$self=shift;my$old=$self->query;if (@_){my@copy=@_;@copy=@{$copy[0]}if@copy==1 && ref($copy[0])eq "ARRAY";for (@copy){s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg}$self->query(@copy ? join('+',@copy): undef)}return if!defined($old)||!defined(wantarray);return if$old =~ /=/;map {uri_unescape($_)}split(/\+/,$old,-1)}sub equery {goto&query}1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;use strict;use warnings;use URI::Escape qw(uri_unescape);use overload '""'=>sub {$_[0]->[0]},fallback=>1;our$VERSION='1.76';sub new {my$class=shift;my@segment=split(';',shift,-1);$segment[0]=uri_unescape($segment[0]);bless \@segment,$class}1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;use strict;use warnings;use parent 'URI::_generic';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _uric_escape {my($class,$str)=@_;if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";if (_host_escape($host)){$str="$scheme//$ui$host$port$rest"}}return$class->SUPER::_uric_escape($str)}sub _host_escape {return unless $_[0]=~ /[^$URI::uric]/;eval {require URI::_idna;$_[0]=URI::_idna::encode($_[0])};return 0 if $@;return 1}sub as_iri {my$self=shift;my$str=$self->SUPER::as_iri;if ($str =~ /\bxn--/){if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";require URI::_idna;$host=URI::_idna::decode($host);$str="$scheme//$ui$host$port$rest"}}return$str}sub userinfo {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/.*@//;my$ui=shift;if (defined$ui){$ui =~ s/@/%40/g;$new="$ui\@$new"}$self->authority($new)}return undef if!defined($old)|| $old !~ /(.*)@/;return $1}sub host {my$self=shift;my$old=$self->authority;if (@_){my$tmp=$old;$tmp="" unless defined$tmp;my$ui=($tmp =~ /(.*@)/)? $1 : "";my$port=($tmp =~ /(:\d+)$/)? $1 : "";my$new=shift;$new="" unless defined$new;if (length$new){$new =~ s/[@]/%40/g;if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/){$new =~ s/(:\d*)\z// || die "Assert";$port=$1}$new="[$new]" if$new =~ /:/ && $new !~ /^\[/;_host_escape($new)}$self->authority("$ui$new$port")}return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:\d+$//;$old =~ s{^\[(.*)\]$}{$1};return uri_unescape($old)}sub ihost {my$self=shift;my$old=$self->host(@_);if ($old =~ /(^|\.)xn--/){require URI::_idna;$old=URI::_idna::decode($old)}return$old}sub _port {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new =~ s/:\d*$//;my$port=shift;$new .= ":$port" if defined$port;$self->authority($new)}return $1 if defined($old)&& $old =~ /:(\d*)$/;return}sub port {my$self=shift;my$port=$self->_port(@_);$port=$self->default_port if!defined($port)|| $port eq "";$port}sub host_port {my$self=shift;my$old=$self->authority;$self->host(shift)if @_;return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:$//;$old .= ":" .$self->port unless$old =~ /:\d+$/;$old}sub default_port {undef}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$host=$other->host || "";my$port=$other->_port;my$uc_host=$host =~ /[A-Z]/;my$def_port=defined($port)&& ($port eq "" || $port==$self->default_port);if ($uc_host || $def_port){$other=$other->clone if$other==$self;$other->host(lc$host)if$uc_host;$other->port(undef)if$def_port}$other}1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;use strict;use warnings;use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub user {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$pass=defined($info)? $info : "";$pass =~ s/^[^:]*//;if (!defined($new)&&!length($pass)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$new =~ s/:/%3A/g;$self->userinfo("$new$pass")}}return undef unless defined$info;$info =~ s/:.*//;uri_unescape($info)}sub password {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$user=defined($info)? $info : "";$user =~ s/:.*//;if (!defined($new)&&!length($user)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$self->userinfo("$user:$new")}}return undef unless defined$info;return undef unless$info =~ s/^[^:]*://;uri_unescape($info)}1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;use strict;use warnings;use parent 'URI';our$VERSION='1.76';use MIME::Base64 qw(encode_base64 decode_base64);use URI::Escape qw(uri_unescape);sub media_type {my$self=shift;my$opaque=$self->opaque;$opaque =~ /^([^,]*),?/ or die;my$old=$1;my$base64;$base64=$1 if$old =~ s/(;base64)$//i;if (@_){my$new=shift;$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/,/%2C/g;$base64="" unless defined$base64;$opaque =~ s/^[^,]*,?/$new$base64,/;$self->opaque($opaque)}return uri_unescape($old)if$old;"text/plain;charset=US-ASCII"}sub data {my$self=shift;my($enc,$data)=split(",",$self->opaque,2);unless (defined$data){$data="";$enc="" unless defined$enc}my$base64=($enc =~ /;base64$/i);if (@_){$enc =~ s/;base64$//i if$base64;my$new=shift;$new="" unless defined$new;my$uric_count=_uric_count($new);my$urienc_len=$uric_count + (length($new)- $uric_count)* 3;my$base64_len=int((length($new)+2)/ 3)* 4;$base64_len += 7;if ($base64_len < $urienc_len || $_[0]){$enc .= ";base64";$new=encode_base64($new,"")}else {$new =~ s/%/%25/g}$self->opaque("$enc,$new")}return unless defined wantarray;$data=uri_unescape($data);return$base64 ? decode_base64($data): $data}my$ENC=$URI::uric;$ENC =~ s/%//;eval <<EOT;die $@ if $@;1;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;use strict;use warnings;use parent 'URI::_generic';our$VERSION="4.21";use URI::Escape qw(uri_unescape);our$DEFAULT_AUTHORITY="";our%OS_CLASS=(os2=>"OS2",mac=>"Mac",MacOS=>"Mac",MSWin32=>"Win32",win32=>"Win32",msdos=>"FAT",dos=>"FAT",qnx=>"QNX",);sub os_class {my($OS)=shift || $^O;my$class="URI::file::" .($OS_CLASS{$OS}|| "Unix");no strict 'refs';unless (%{"$class\::"}){eval "require $class";die $@ if $@}$class}sub host {uri_unescape(shift->authority(@_))}sub new {my($class,$path,$os)=@_;os_class($os)->new($path)}sub new_abs {my$class=shift;my$file=$class->new(@_);return$file->abs($class->cwd)unless $$file =~ /^file:/;$file}sub cwd {my$class=shift;require Cwd;my$cwd=Cwd::cwd();$cwd=VMS::Filespec::unixpath($cwd)if $^O eq 'VMS';$cwd=$class->new($cwd);$cwd .= "/" unless substr($cwd,-1,1)eq "/";$cwd}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$scheme=$other->scheme;my$auth=$other->authority;return$other if!defined($scheme)&&!defined($auth);if (!defined($auth)|| $auth eq "" || lc($auth)eq "localhost" || (defined($DEFAULT_AUTHORITY)&& lc($auth)eq lc($DEFAULT_AUTHORITY))){if ((defined($auth)|| defined($DEFAULT_AUTHORITY))&& (!defined($auth)||!defined($DEFAULT_AUTHORITY)|| $auth ne $DEFAULT_AUTHORITY)){$other=$other->clone if$self==$other;$other->authority($DEFAULT_AUTHORITY)}}$other}sub file {my($self,$os)=@_;os_class($os)->file($self)}sub dir {my($self,$os)=@_;os_class($os)->dir($self)}1;
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;use strict;use warnings;use URI::Escape qw();our$VERSION='1.76';sub new {my$class=shift;my$path=shift;$path="" unless defined$path;my($auth,$escaped_auth,$escaped_path);($auth,$escaped_auth)=$class->_file_extract_authority($path);($path,$escaped_path)=$class->_file_extract_path($path);if (defined$auth){$auth =~ s,%,%25,g unless$escaped_auth;$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$auth="//$auth";if (defined$path){$path="/$path" unless substr($path,0,1)eq "/"}else {$path=""}}else {return undef unless defined$path;$auth=""}$path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless$escaped_path;$path =~ s/\#/%23/g;my$uri=$auth .$path;$uri="file:$uri" if substr($uri,0,1)eq "/";URI->new($uri,"file")}sub _file_extract_authority {my($class,$path)=@_;return undef unless$class->_file_is_absolute($path);return$URI::file::DEFAULT_AUTHORITY}sub _file_extract_path {return undef}sub _file_is_absolute {return 0}sub _file_is_localhost {shift;my$host=lc(shift);return 1 if$host eq "localhost";eval {require Net::Domain;lc(Net::Domain::hostfqdn()|| '')eq $host || lc(Net::Domain::hostname()|| '')eq $host}}sub file {undef}sub dir {my$self=shift;$self->file(@_)}1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='1.76';sub fix_path {shift;for (@_){my@p=map uc,split(/\./,$_,-1);return if@p > 2;@p=("")unless@p;$_=substr($p[0],0,8);if (@p > 1){my$ext=substr($p[1],0,3);$_ .= ".$ext" if length$ext}}1}1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_path {my$class=shift;my$path=shift;my@pre;if ($path =~ s/^(:+)//){if (length($1)==1){@pre=(".")unless length($path)}else {@pre=("..")x (length($1)- 1)}}else {$pre[0]=""}my$isdir=($path =~ s/:$//);$path =~ s,([%/;]), URI::Escape::escape_char($1),eg;my@path=split(/:/,$path,-1);for (@path){if ($_ eq "." || $_ eq ".."){$_="%2E" x length($_)}$_=".." unless length($_)}push (@path,"")if$isdir;(join("/",@pre,@path),1)}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined$auth){if (lc($auth)ne "localhost" && $auth ne ""){my$u_auth=uri_unescape($auth);if (!$class->_file_is_localhost($u_auth)){@path=("",$auth)}}}my@ps=split("/",$uri->path,-1);shift@ps if@path;push(@path,@ps);my$pre="";if (!@path){return}elsif ($path[0]eq ""){shift(@path);if (@path==1){return if$path[0]eq "";push(@path,"")}@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}else {$pre=":";@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}return unless$pre || @path;for (@path){s/;.*//;$_=uri_unescape($_);return if /\0/;return if /:/}$pre .join(":",@path)}sub dir {my$class=shift;my$path=$class->file(@_);return unless defined$path;$path .= ":" unless$path =~ /:$/;$path}1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='1.76';sub _file_extract_authority {my$class=shift;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ m#^[a-zA-Z]{1,2}:#){return ""}return}sub file {my$p=&URI::file::Win32::file;return unless defined$p;$p =~ s,\\,/,g;$p}1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;use strict;use warnings;use parent 'URI::file::Unix';our$VERSION='1.76';sub _file_extract_path {my($class,$path)=@_;$path =~ s,(.)//+,$1/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;$path}1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_path {my($class,$path)=@_;$path =~ s,//+,/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^/,}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined($auth)){if (lc($auth)ne "localhost" && $auth ne ""){$auth=uri_unescape($auth);unless ($class->_file_is_localhost($auth)){push(@path,"","",$auth)}}}my@ps=$uri->path_segments;shift@ps if@path;push(@path,@ps);for (@path){return undef if /\0/;return undef if /\//}return join("/",@path)}1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_authority {my$class=shift;return$class->SUPER::_file_extract_authority($_[0])if defined$URI::file::DEFAULT_AUTHORITY;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ s,^([a-zA-Z]:),,){my$auth=$1;$auth .= "relative" if $_[0]!~ m,^[\\/],;return$auth}return undef}sub _file_extract_path {my($class,$path)=@_;$path =~ s,\\,/,g;$path =~ s,(/\.)+/,/,g;if (defined$URI::file::DEFAULT_AUTHORITY){$path =~ s,^([a-zA-Z]:),/$1,}return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],}sub file {my$class=shift;my$uri=shift;my$auth=$uri->authority;my$rel;if (defined$auth){$auth=uri_unescape($auth);if ($auth =~ /^([a-zA-Z])[:|](relative)?/){$auth=uc($1).":";$rel++ if $2}elsif (lc($auth)eq "localhost"){$auth=""}elsif (length$auth){$auth="\\\\" .$auth}}else {$auth=""}my@path=$uri->path_segments;for (@path){return undef if /\0/;return undef if /\//}return undef unless$class->fix_path(@path);my$path=join("\\",@path);$path =~ s/^\\// if$rel;$path=$auth .$path;$path =~ s,^\\([a-zA-Z])[:|],\u$1:,;return$path}sub fix_path {1}1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_server URI::_userpass);sub default_port {21}sub path {shift->path_query(@_)}sub _user {shift->SUPER::user(@_)}sub _password {shift->SUPER::password(@_)}sub user {my$self=shift;my$user=$self->_user(@_);$user="anonymous" unless defined$user;$user}sub password {my$self=shift;my$pass=$self->_password(@_);unless (defined$pass){my$user=$self->user;if ($user eq 'anonymous' || $user eq 'ftp'){$pass='anonymous@'}}$pass}1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {70}sub _gopher_type {my$self=shift;my$path=$self->path_query;$path =~ s,^/,,;my$gtype=$1 if$path =~ s/^(.)//s;if (@_){my$new_type=shift;if (defined($new_type)){Carp::croak("Bad gopher type '$new_type'")unless length($new_type)==1;substr($path,0,0)=$new_type;$self->path_query($path)}else {Carp::croak("Can't delete gopher type when selector is present")if length($path);$self->path_query(undef)}}return$gtype}sub gopher_type {my$self=shift;my$gtype=$self->_gopher_type(@_);$gtype="1" unless defined$gtype;$gtype}sub gtype {goto&gopher_type}sub selector {shift->_gfield(0,@_)}sub search {shift->_gfield(1,@_)}sub string {shift->_gfield(2,@_)}sub _gfield {my$self=shift;my$fno=shift;my$path=$self->path_query;$path =~ s/\?/\t/;$path=uri_unescape($path);$path =~ s,^/,,;my$gtype=$1 if$path =~ s,^(.),,s;my@path=split(/\t/,$path,3);if (@_){my$new=shift;$path[$fno]=$new;pop(@path)while@path &&!defined($path[-1]);for (@path){$_="" unless defined}$path=$gtype;$path="1" unless defined$path;$path .= join("\t",@path);$self->path_query($path)}$path[$fno]}1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';sub default_port {80}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$slash_path=defined($other->authority)&& !length($other->path)&&!defined($other->query);if ($slash_path){$other=$other->clone if$other==$self;$other->path("/")}$other}1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {443}sub secure {1}1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  package URI::ldap;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_ldap URI::_server);sub default_port {389}sub _nonldap_canonical {my$self=shift;$self->URI::_server::canonical(@_)}1;
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_ldap URI::_generic);require URI::Escape;sub un_path {my$self=shift;my$old=URI::Escape::uri_unescape($self->authority);if (@_){my$p=shift;$p =~ s/:/%3A/g;$p =~ s/\@/%40/g;$self->authority($p)}return$old}sub _nonldap_canonical {my$self=shift;$self->URI::_generic::canonical(@_)}1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;use strict;use warnings;our$VERSION='1.76';use parent 'URI::ldap';sub default_port {636}sub secure {1}1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;use strict;use warnings;our$VERSION='1.76';use parent qw(URI URI::_query);sub to {my$self=shift;my@old=$self->headers;if (@_){my@new=@old;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){splice(@new,$i,2);redo}}my$to=shift;$to="" unless defined$to;unshift(@new,"to"=>$to);$self->headers(@new)}return unless defined wantarray;my@to;while (@old){my$h=shift@old;my$v=shift@old;push(@to,$v)if lc($h)eq "to"}join(",",@to)}sub headers {my$self=shift;my$opaque="to=" .$self->opaque;$opaque =~ s/\?/&/;if (@_){my@new=@_;my@to;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){push(@to,(splice(@new,$i,2))[1]);redo}}my$new=join(",",@to);$new =~ s/%/%25/g;$new =~ s/\?/%3F/g;$self->opaque($new);$self->query_form(@new)if@new}return unless defined wantarray;URI->new("mailto:?$opaque")->query_form}1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {1755}1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);use Carp ();sub default_port {119}sub _group {my$self=shift;my$old=$self->path;if (@_){my($group,$from,$to)=@_;if ($group =~ /\@/){$group =~ s/^<(.*)>$/$1/}$group =~ s,%,%25,g;$group =~ s,/,%2F,g;my$path=$group;if (defined$from){$path .= "/$from";$path .= "-$to" if defined$to}$self->path($path)}$old =~ s,^/,,;if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray){my$extra=$1;return (uri_unescape($old),split(/-/,$extra))}uri_unescape($old)}sub group {my$self=shift;if (@_){Carp::croak("Group name can't contain '\@'")if $_[0]=~ /\@/}my@old=$self->_group(@_);return if$old[0]=~ /\@/;wantarray ? @old : $old[0]}sub message {my$self=shift;if (@_){Carp::croak("Message must contain '\@'")unless $_[0]=~ /\@/}my$old=$self->_group(@_);return undef unless$old =~ /\@/;return$old}1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;use strict;use warnings;our$VERSION='1.76';use parent 'URI::news';1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {110}sub user {my$self=shift;my$old=$self->userinfo;if (@_){my$new_info=$old;$new_info="" unless defined$new_info;$new_info =~ s/^[^;]*//;my$new=shift;if (!defined($new)&&!length($new_info)){$self->userinfo(undef)}else {$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/;/%3B/g;$self->userinfo("$new$new_info")}}return undef unless defined$old;$old =~ s/;.*//;return uri_unescape($old)}sub auth {my$self=shift;my$old=$self->userinfo;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/(^[^;]*)//;my$user=$1;$new =~ s/;auth=[^;]*//i;my$auth=shift;if (defined$auth){$auth =~ s/%/%25/g;$auth =~ s/;/%3B/g;$new=";AUTH=$auth$new"}$self->userinfo("$user$new")}return undef unless defined$old;$old =~ s/^[^;]*//;return uri_unescape($1)if$old =~ /;auth=(.*)/i;return}1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {513}1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_server URI::_userpass);sub default_port {873}1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {554}1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;use strict;use warnings;our$VERSION='1.76';use parent 'URI::rtsp';sub default_port {554}1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;use strict;use warnings;use parent 'URI::ssh';our$VERSION='1.76';1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  package URI::sip;use strict;use warnings;use parent qw(URI::_server URI::_userpass);use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub default_port {5060}sub authority {my$self=shift;$$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;my$old=$2;if (@_){my$auth=shift;$$self=defined($1)? $1 : "";my$rest=$3;if (defined$auth){$auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;$$self .= "$auth"}$$self .= $rest}$old}sub params_form {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my@args=@_;$$self=$1 .$2;my$rest=$4;my@new;for (my$i=0;$i < @args;$i += 2){push(@new,"$args[$i]=$args[$i+1]")}$paramstr=join(";",@new);$$self .= ";" .$paramstr .$rest}$paramstr =~ s/^;//o;return split(/[;=]/,$paramstr)}sub params {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my$new=shift;$$self=$1 .$2;my$rest=$4;$$self .= $paramstr .$rest}$paramstr =~ s/^;//o;return$paramstr}sub path {}sub path_query {}sub path_segments {}sub abs {shift}sub rel {shift}sub query_keywords {}1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;use strict;use warnings;our$VERSION='1.76';use parent 'URI::sip';sub default_port {5061}sub secure {1}1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;use strict;use warnings;our$VERSION='1.76';use parent 'URI::news';sub default_port {563}sub secure {1}1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {22}sub secure {1}1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {23}1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {23}1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;use strict;use warnings;our$VERSION='1.76';use parent 'URI';use Carp qw(carp);my%implementor;my%require_attempted;sub _init {my$class=shift;my$self=$class->SUPER::_init(@_);my$nid=$self->nid;my$impclass=$implementor{$nid};return$impclass->_urn_init($self,$nid)if$impclass;$impclass="URI::urn";if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/){my$id=$nid;$id =~ s/-/_/g;$id="_$id" if$id =~ /^\d/;$impclass="URI::urn::$id";no strict 'refs';unless (@{"${impclass}::ISA"}){if (not exists$require_attempted{$impclass}){my$_old_error=$@;eval "require $impclass";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}$impclass="URI::urn" unless @{"${impclass}::ISA"}}}else {carp("Illegal namespace identifier '$nid' for URN '$self'")if $^W}$implementor{$nid}=$impclass;return$impclass->_urn_init($self,$nid)}sub _urn_init {my($class,$self,$nid)=@_;bless$self,$class}sub _nid {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;$v =~ s/[^:]*/$new/;$self->opaque($v)}$opaque =~ s/:.*//s;return$opaque}sub nid {my$self=shift;my$nid=$self->_nid(@_);$nid=lc($nid)if defined($nid);return$nid}sub nss {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;if (defined$new){$v =~ s/(:|\z).*/:$new/}else {$v =~ s/:.*//s}$self->opaque($v)}return undef unless$opaque =~ s/^[^:]*://;return$opaque}sub canonical {my$self=shift;my$nid=$self->_nid;my$new=$self->SUPER::canonical;return$new if$nid !~ /[A-Z]/ || $nid =~ /%/;$new=$new->clone if$new==$self;$new->nid(lc($nid));return$new}1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;use strict;use warnings;our$VERSION='1.76';use parent 'URI::urn';use Carp qw(carp);BEGIN {require Business::ISBN;local $^W=0;warn "Using Business::ISBN version " .Business::ISBN->VERSION ." which is deprecated.\nUpgrade to Business::ISBN version 2\n" if Business::ISBN->VERSION < 2}sub _isbn {my$nss=shift;$nss=$nss->nss if ref($nss);my$isbn=Business::ISBN->new($nss);$isbn=undef if$isbn &&!$isbn->is_valid;return$isbn}sub _nss_isbn {my$self=shift;my$nss=$self->nss(@_);my$isbn=_isbn($nss);$isbn=$isbn->as_string if$isbn;return($nss,$isbn)}sub isbn {my$self=shift;my$isbn;(undef,$isbn)=$self->_nss_isbn(@_);return$isbn}sub isbn_publisher_code {my$isbn=shift->_isbn || return undef;return$isbn->publisher_code}BEGIN {my$group_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code'};sub isbn_group_code {my$isbn=shift->_isbn || return undef;return$isbn->$group_method}}sub isbn_country_code {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn_group_code instead";no strict 'refs';&isbn_group_code}BEGIN {my$isbn13_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean'};sub isbn13 {my$isbn=shift->_isbn || return undef;my$thingy=$isbn->$isbn13_method;return eval {$thingy->can('as_string')}? $thingy->as_string([]): $thingy}}sub isbn_as_ean {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn13 instead";no strict 'refs';&isbn13}sub canonical {my$self=shift;my($nss,$isbn)=$self->_nss_isbn;my$new=$self->SUPER::canonical;return$new unless$nss && $isbn && $nss ne $isbn;$new=$new->clone if$new==$self;$new->nss($isbn);return$new}1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;use strict;use warnings;our$VERSION='1.76';use parent 'URI::urn';sub oid {my$self=shift;my$old=$self->nss;if (@_){$self->nss(join(".",@_))}return split(/\./,$old)if wantarray;return$old}1;
URI_URN_OID

$fatpacked{"Win32/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WIN32_SHELLQUOTE';
  package Win32::ShellQuote;use strict;use warnings FATAL=>'all';use base 'Exporter';use Carp;our$VERSION='0.003001';$VERSION=eval$VERSION;our@EXPORT_OK=qw(quote_native quote_cmd quote_system_list quote_system_string quote_system quote_system_cmd quote_literal cmd_escape unquote_native cmd_unescape);our%EXPORT_TAGS=(all=>[@EXPORT_OK]);sub quote_native {return join q{ },quote_system_list(@_)}sub quote_cmd {return cmd_escape(quote_native(@_))}sub quote_system_list {return map {quote_literal($_,1)}@_}sub quote_system_string {my$args=quote_native(@_);if (_has_shell_metachars($args)){$args=cmd_escape($args)}return$args}sub quote_system {if (@_ > 1){return quote_system_list(@_)}else {return quote_system_string(@_)}}sub quote_system_cmd {my$args=quote_native(@_);if (!_has_shell_metachars($args)){return '%PATH:~0,0%' .cmd_escape($args)}return cmd_escape($args)}sub cmd_escape {my$string=shift;if ($string =~ /[\r\n\0]/){croak "can't quote newlines to pass through cmd.exe"}$string =~ s/([()%!^"<>&|])/^$1/g;return$string}sub quote_literal {my ($text,$force)=@_;if (!$force && $text ne '' && $text !~ /[ \t\n\x0b"]/){}else {$text =~ s{(\\*)(?="|\z)}{$1$1}g;$text =~ s{"}{\\"}g;$text=qq{"$text"}}return$text}sub _has_shell_metachars {my$string=shift;return 1 if$string =~ /%/;$string =~ s/(['"]).*?(\1|\z)//sg;return$string =~ /[<>|]/}sub unquote_native {local ($_)=@_;my@argv;my$length=length or return@argv;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub cmd_unescape {my ($string)=@_;no warnings 'uninitialized';$string =~ s/\^(.?)|([^^"]+)|("[^"]*(?:"|\z))/$1$2$3/gs;return$string}1;
WIN32_SHELLQUOTE

$fatpacked{"auto/Clone/autosplit.ix"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTO_CLONE_AUTOSPLIT.IX';
  1;
AUTO_CLONE_AUTOSPLIT.IX

$fatpacked{"lib/core/only.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_CORE_ONLY';
  package lib::core::only;use strict;use warnings FATAL=>'all';use Config;sub import {@INC=@Config{qw(privlibexp archlibexp)};return}1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCAL_LIB';
  package local::lib;use 5.006;BEGIN {if ($ENV{RELEASE_TESTING}){require strict;strict->import;require warnings;warnings->import}}use Config ();our$VERSION='2.000024';$VERSION=eval$VERSION;BEGIN {*_WIN32=($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'symbian')? sub(){1}: sub(){0};*_USE_FSPEC=($^O eq 'MacOS' || $^O eq 'VMS' || $INC{'File/Spec.pm'})? sub(){1}: sub(){0}}my$_archname=$Config::Config{archname};my$_version=$Config::Config{version};my@_inc_version_list=reverse split / /,$Config::Config{inc_version_list};my$_path_sep=$Config::Config{path_sep};our$_DIR_JOIN=_WIN32 ? '\\' : '/';our$_DIR_SPLIT=(_WIN32 || $^O eq 'cygwin')? qr{[\\/]} : qr{/};our$_ROOT=_WIN32 ? do {my$UNC=qr{[\\/]{2}[^\\/]+[\\/][^\\/]+};qr{^(?:$UNC|[A-Za-z]:|)$_DIR_SPLIT}}: qr{^/};our$_PERL;sub _perl {if (!$_PERL){($_PERL,my$exe)=$^X =~ /((?:.*$_DIR_SPLIT)?(.+))/;$_PERL='perl' if$exe !~ /perl/;if (_is_abs($_PERL)){}elsif (-x $Config::Config{perlpath}){$_PERL=$Config::Config{perlpath}}elsif ($_PERL =~ $_DIR_SPLIT && -x $_PERL){$_PERL=_rel2abs($_PERL)}else {($_PERL)=map {/(.*)/}grep {-x $_}map {($_,_WIN32 ? ("$_.exe"): ())}map {join($_DIR_JOIN,$_,$_PERL)}split /\Q$_path_sep\E/,$ENV{PATH}}}$_PERL}sub _cwd {if (my$cwd =defined&Cwd::sys_cwd ? \&Cwd::sys_cwd : defined&Cwd::cwd ? \&Cwd::cwd : undef){no warnings 'redefine';*_cwd=$cwd;goto &$cwd}my$drive=shift;return Win32::Cwd()if _WIN32 && defined&Win32::Cwd &&!$drive;local@ENV{qw(PATH IFS CDPATH ENV BASH_ENV)};my$cmd=$drive ? "eval { Cwd::getdcwd(q($drive)) }" : 'getcwd';my$perl=_perl;my$cwd=`"$perl" -MCwd -le "print $cmd"`;chomp$cwd;if (!length$cwd && $drive){$cwd=$drive}$cwd =~ s/$_DIR_SPLIT?$/$_DIR_JOIN/;$cwd}sub _catdir {if (_USE_FSPEC){require File::Spec;File::Spec->catdir(@_)}else {my$dir=join($_DIR_JOIN,@_);$dir =~ s{($_DIR_SPLIT)(?:\.?$_DIR_SPLIT)+}{$1}g;$dir}}sub _is_abs {if (_USE_FSPEC){require File::Spec;File::Spec->file_name_is_absolute($_[0])}else {$_[0]=~ $_ROOT}}sub _rel2abs {my ($dir,$base)=@_;return$dir if _is_abs($dir);$base=_WIN32 && $dir =~ s/^([A-Za-z]:)// ? _cwd("$1"): $base ? _rel2abs($base): _cwd;return _catdir($base,$dir)}our$_DEVNULL;sub _devnull {return$_DEVNULL ||= _USE_FSPEC ? (require File::Spec,File::Spec->devnull): _WIN32 ? 'nul' : $^O eq 'os2' ? '/dev/nul' : '/dev/null'}sub import {my ($class,@args)=@_;if ($0 eq '-'){push@args,@ARGV;require Cwd}my@steps;my%opts;my%attr;my$shelltype;while (@args){my$arg=shift@args;if ($arg =~ /\xE2\x88\x92/){die <<'DEATH'}elsif ($arg eq '--self-contained'){die <<'DEATH'}elsif($arg =~ /^--deactivate(?:=(.*))?$/){my$path=defined $1 ? $1 : shift@args;push@steps,['deactivate',$path]}elsif ($arg eq '--deactivate-all'){push@steps,['deactivate_all']}elsif ($arg =~ /^--shelltype(?:=(.*))?$/){$shelltype=defined $1 ? $1 : shift@args}elsif ($arg eq '--no-create'){$opts{no_create}=1}elsif ($arg eq '--quiet'){$attr{quiet}=1}elsif ($arg =~ /^--/){die "Unknown import argument: $arg"}else {push@steps,['activate',$arg,\%opts]}}if (!@steps){push@steps,['activate',undef,\%opts]}my$self=$class->new(%attr);for (@steps){my ($method,@args)=@$_;$self=$self->$method(@args)}if ($0 eq '-'){print$self->environment_vars_string($shelltype);exit 0}else {$self->setup_local_lib}}sub new {my$class=shift;bless {@_},$class}sub clone {my$self=shift;bless {%$self,@_},ref$self}sub inc {$_[0]->{inc}||= \@INC}sub libs {$_[0]->{libs}||= [\'PERL5LIB' ]}sub bins {$_[0]->{bins}||= [\'PATH' ]}sub roots {$_[0]->{roots}||= [\'PERL_LOCAL_LIB_ROOT' ]}sub extra {$_[0]->{extra}||= {}}sub quiet {$_[0]->{quiet}}sub _as_list {my$list=shift;grep length,map {!(ref $_ && ref $_ eq 'SCALAR')? $_ : (defined$ENV{$$_}? split(/\Q$_path_sep/,$ENV{$$_}): ())}ref$list ? @$list : $list}sub _remove_from {my ($list,@remove)=@_;return @$list if!@remove;my%remove=map {$_=>1}@remove;grep!$remove{$_},_as_list($list)}my@_lib_subdirs=([$_version,$_archname],[$_version],[$_archname],(map [$_],@_inc_version_list),[],);sub install_base_bin_path {my ($class,$path)=@_;return _catdir($path,'bin')}sub install_base_perl_path {my ($class,$path)=@_;return _catdir($path,'lib','perl5')}sub install_base_arch_path {my ($class,$path)=@_;_catdir($class->install_base_perl_path($path),$_archname)}sub lib_paths_for {my ($class,$path)=@_;my$base=$class->install_base_perl_path($path);return map {_catdir($base,@$_)}@_lib_subdirs}sub _mm_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;if ($path =~ s/ /\\ /g){$path=qq{"$path"}}return$path}sub _mb_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;return qq{"$path"}}sub installer_options_for {my ($class,$path)=@_;return (PERL_MM_OPT=>defined$path ? "INSTALL_BASE="._mm_escape_path($path): undef,PERL_MB_OPT=>defined$path ? "--install_base "._mb_escape_path($path): undef,)}sub active_paths {my ($self)=@_;$self=ref$self ? $self : $self->new;return grep {my$active_ll=$self->install_base_perl_path($_);grep {$_ eq $active_ll}@{$self->inc}}_as_list($self->roots)}sub deactivate {my ($self,$path)=@_;$self=$self->new unless ref$self;$path=$self->resolve_path($path);$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (!grep {$_ eq $path}@active_lls){warn "Tried to deactivate inactive local::lib '$path'\n";return$self}my%args=(bins=>[_remove_from($self->bins,$self->install_base_bin_path($path))],libs=>[_remove_from($self->libs,$self->install_base_perl_path($path))],inc=>[_remove_from($self->inc,$self->lib_paths_for($path))],roots=>[_remove_from($self->roots,$path)],);$args{extra}={$self->installer_options_for($args{roots}[0])};$self->clone(%args)}sub deactivate_all {my ($self)=@_;$self=$self->new unless ref$self;my@active_lls=$self->active_paths;my%args;if (@active_lls){%args=(bins=>[_remove_from($self->bins,map$self->install_base_bin_path($_),@active_lls)],libs=>[_remove_from($self->libs,map$self->install_base_perl_path($_),@active_lls)],inc=>[_remove_from($self->inc,map$self->lib_paths_for($_),@active_lls)],roots=>[_remove_from($self->roots,@active_lls)],)}$args{extra}={$self->installer_options_for(undef)};$self->clone(%args)}sub activate {my ($self,$path,$opts)=@_;$opts ||= {};$self=$self->new unless ref$self;$path=$self->resolve_path($path);$self->ensure_dir_structure_for($path,{quiet=>$self->quiet })unless$opts->{no_create};$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (grep {$_ eq $path}@active_lls[1 .. $#active_lls]){$self=$self->deactivate($path)}my%args;if ($opts->{always}||!@active_lls || $active_lls[0]ne $path){%args=(bins=>[$self->install_base_bin_path($path),@{$self->bins}],libs=>[$self->install_base_perl_path($path),@{$self->libs}],inc=>[$self->lib_paths_for($path),@{$self->inc}],roots=>[$path,@{$self->roots}],)}$args{extra}={$self->installer_options_for($path)};$self->clone(%args)}sub normalize_path {my ($self,$path)=@_;$path=(Win32::GetShortPathName($path)|| $path)if $^O eq 'MSWin32';return$path}sub build_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_activate_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_deactivate_environment_vars_for {my$self=$_[0]->new->deactivate($_[1]);$self->build_environment_vars}sub build_deact_all_environment_vars_for {my$self=$_[0]->new->deactivate_all;$self->build_environment_vars}sub build_environment_vars {my$self=shift;(PATH=>join($_path_sep,_as_list($self->bins)),PERL5LIB=>join($_path_sep,_as_list($self->libs)),PERL_LOCAL_LIB_ROOT=>join($_path_sep,_as_list($self->roots)),%{$self->extra},)}sub setup_local_lib_for {my$self=$_[0]->new->activate($_[1]);$self->setup_local_lib}sub setup_local_lib {my$self=shift;require Carp::Heavy if$INC{'Carp.pm'};$self->setup_env_hash;@INC=@{$self->inc}}sub setup_env_hash_for {my$self=$_[0]->new->activate($_[1]);$self->setup_env_hash}sub setup_env_hash {my$self=shift;my%env=$self->build_environment_vars;for my$key (keys%env){if (defined$env{$key}){$ENV{$key}=$env{$key}}else {delete$ENV{$key}}}}sub print_environment_vars_for {print $_[0]->environment_vars_string_for(@_[1..$#_])}sub environment_vars_string_for {my$self=$_[0]->new->activate($_[1],{always=>1});$self->environment_vars_string}sub environment_vars_string {my ($self,$shelltype)=@_;$shelltype ||= $self->guess_shelltype;my$extra=$self->extra;my@envs=(PATH=>$self->bins,PERL5LIB=>$self->libs,PERL_LOCAL_LIB_ROOT=>$self->roots,map {$_=>$extra->{$_}}sort keys %$extra,);$self->_build_env_string($shelltype,\@envs)}sub _build_env_string {my ($self,$shelltype,$envs)=@_;my@envs=@$envs;my$build_method="build_${shelltype}_env_declaration";my$out='';while (@envs){my ($name,$value)=(shift(@envs),shift(@envs));if (ref$value && @$value==1 && ref$value->[0]&& ref$value->[0]eq 'SCALAR' && ${$value->[0]}eq $name){next}$out .= $self->$build_method($name,$value)}my$wrap_method="wrap_${shelltype}_output";if ($self->can($wrap_method)){return$self->$wrap_method($out)}return$out}sub build_bourne_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'${%s:-}',qr/["\\\$!`]/,'\\%s');if (!defined$value){return qq{unset $name;\n}}$value =~ s/(^|\G|$_path_sep)\$\{$name:-\}$_path_sep/$1\${$name}\${$name:+$_path_sep}/g;$value =~ s/$_path_sep\$\{$name:-\}$/\${$name:+$_path_sep\${$name}}/;qq{${name}="$value"; export ${name};\n}}sub build_csh_env_declaration {my ($class,$name,$args)=@_;my ($value,@vars)=$class->_interpolate($args,'${%s}',qr/["\$]/,'"\\%s"');if (!defined$value){return qq{unsetenv $name;\n}}my$out='';for my$var (@vars){$out .= qq{if ! \$?$name setenv $name '';\n}}my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$\{$name\}(?:$_path_sep|$)//g){$out .= qq{if "\${$name}" != '' setenv $name "$value";\n};$out .= qq{if "\${$name}" == '' }}$out .= qq{setenv $name "$value_without";\n};return$out}sub build_cmd_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'%%%s%%',qr(%),'%s');if (!$value){return qq{\@set $name=\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)%$name%(?:$_path_sep|$)//g){$out .= qq{\@if not "%$name%"=="" set "$name=$value"\n};$out .= qq{\@if "%$name%"=="" }}$out .= qq{\@set "$name=$value_without"\n};return$out}sub build_powershell_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$env:%s',qr/["\$]/,'`%s');if (!$value){return qq{Remove-Item -ErrorAction 0 Env:\\$name;\n}}my$maybe_path_sep=qq{\$(if("\$env:$name"-eq""){""}else{"$_path_sep"})};$value =~ s/(^|\G|$_path_sep)\$env:$name$_path_sep/$1\$env:$name"+$maybe_path_sep+"/g;$value =~ s/$_path_sep\$env:$name$/"+$maybe_path_sep+\$env:$name+"/;qq{\$env:$name = \$("$value");\n}}sub wrap_powershell_output {my ($class,$out)=@_;return$out || " \n"}sub build_fish_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$%s',qr/[\\"'$ ]/,'\\%s');if (!defined$value){return qq{set -e $name;\n}}if ($name =~ /^(?:CD|MAN)?PATH$/){$value =~ s/$_path_sep/ /g;my$silent=$name =~ /^(?:CD)?PATH$/ ? " ^"._devnull : '';return qq{set -x $name $value$silent;\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$$name(?:$_path_sep|$)//g){$out .= qq{set -q $name; and set -x $name $value;\n};$out .= qq{set -q $name; or }}$out .= qq{set -x $name $value_without;\n};$out}sub _interpolate {my ($class,$args,$var_pat,$escape,$escape_pat)=@_;return unless defined$args;my@args=ref$args ? @$args : $args;return unless@args;my@vars=map {$$_}grep {ref $_ eq 'SCALAR'}@args;my$string=join$_path_sep,map {ref $_ eq 'SCALAR' ? sprintf($var_pat,$$_): do {s/($escape)/sprintf($escape_pat, $1)/ge;$_}}@args;return wantarray ? ($string,\@vars): $string}sub pipeline;sub pipeline {my@methods=@_;my$last=pop(@methods);if (@methods){\sub {my ($obj,@args)=@_;$obj->${pipeline@methods}($obj->$last(@args))}}else {\sub {shift->$last(@_)}}}sub resolve_path {my ($class,$path)=@_;$path=$class->${pipeline qw(resolve_relative_path resolve_home_path resolve_empty_path)}($path);$path}sub resolve_empty_path {my ($class,$path)=@_;if (defined$path){$path}else {'~/perl5'}}sub resolve_home_path {my ($class,$path)=@_;$path =~ /^~([^\/]*)/ or return$path;my$user=$1;my$homedir=do {if (!length($user)&& defined$ENV{HOME}){$ENV{HOME}}else {require File::Glob;File::Glob::bsd_glob("~$user",File::Glob::GLOB_TILDE())}};unless (defined$homedir){require Carp;require Carp::Heavy;Carp::croak("Couldn't resolve homedir for " .(defined$user ? $user : 'current user'))}$path =~ s/^~[^\/]*/$homedir/;$path}sub resolve_relative_path {my ($class,$path)=@_;_rel2abs($path)}sub ensure_dir_structure_for {my ($class,$path,$opts)=@_;$opts ||= {};my@dirs;for my$dir ($class->lib_paths_for($path),$class->install_base_bin_path($path),){my$d=$dir;while (!-d $d){push@dirs,$d;require File::Basename;$d=File::Basename::dirname($d)}}warn "Attempting to create directory ${path}\n" if!$opts->{quiet}&& @dirs;my%seen;for my$dir (reverse@dirs){next if$seen{$dir}++;mkdir$dir or -d $dir or die "Unable to create $dir: $!"}return}sub guess_shelltype {my$shellbin =defined$ENV{SHELL}&& length$ENV{SHELL}? ($ENV{SHELL}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' && exists$ENV{'!EXITCODE'})? 'bash' : ($^O eq 'MSWin32' && $ENV{PROMPT}&& $ENV{COMSPEC})? ($ENV{COMSPEC}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' &&!$ENV{PROMPT})? 'powershell.exe' : 'sh';for ($shellbin){return /csh$/ ? 'csh' : /fish$/ ? 'fish' : /command(?:\.com)?$/i ? 'cmd' : /cmd(?:\.exe)?$/i ? 'cmd' : /4nt(?:\.exe)?$/i ? 'cmd' : /powershell(?:\.exe)?$/i ? 'powershell' : 'bourne'}}1;
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
  FATAL: The local::lib --self-contained flag has never worked reliably and the
  original author, Mark Stosberg, was unable or unwilling to maintain it. As
  such, this flag has been removed from the local::lib codebase in order to
  prevent misunderstandings and potentially broken builds. The local::lib authors
  recommend that you look at the lib::core::only module shipped with this
  distribution in order to create a more robust environment that is equivalent to
  what --self-contained provided (although quite possibly not what you originally
  thought it provided due to the poor quality of the documentation, for which we
  apologise).
  DEATH
LOCAL_LIB

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;

use App::ccu;
$App::ccu::GIT_DESCRIBE = 'no tags';
$App::ccu::GIT_URL = 'https://github.com/akiym/cpanfile-check-updates/tree/eca44b2';

use App::ccu::CLI;

exit(App::ccu::CLI->new->run(@ARGV));
