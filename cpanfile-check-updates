#!/usr/bin/env perl
use 5.8.1;

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/ccu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU';
  package App::ccu;use strict;use warnings;use Module::CPANfile::Writer;use App::ccu::CPANfile;use App::ccu::ModuleDetails;use App::ccu::PAUSEPackages;use Class::Tiny {cpanfile=>'cpanfile',snapshot=>'cpanfile.snapshot',phase=>undef,relationship=>undef,module_details=>sub {App::ccu::ModuleDetails->new},pause_packages=>sub {App::ccu::PAUSEPackages->new},};our$VERSION="0.01";our ($GIT_DESCRIBE,$GIT_URL);sub run {my ($self,@modules)=@_;my$modules=App::ccu::CPANfile->load($self->cpanfile,$self->snapshot,);my$writer=Module::CPANfile::Writer->new($self->cpanfile);for my$module_name (sort keys %$modules){my$module=$modules->{$module_name};next if$self->phase && $self->phase ne $module->{phase};next if$self->relationship && $self->relationship ne $module->{relationship};next if@modules && not grep {$_ eq $module_name}@modules;my$release=$self->pause_packages->find_release($module->{dist},$module_name);next unless$release;next unless App::ccu::Version->in_range($release->version,$module->{version_range});next if$release->dist eq 'perl';if ($release && $release->version ne $module->{version}){$self->module_details->show($module,{dist=>$release->dist,version=>$release->version,author_release=>$release->cpanid .'/' .$release->distvname,});$writer->add_prereq($module_name,$release->version,relationship=>$self->relationship)}}$writer->save($self->cpanfile)}1;
APP_CCU

$fatpacked{"App/ccu/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_CLI';
  package App::ccu::CLI;use strict;use warnings;use Getopt::Long ();use App::ccu;binmode STDOUT,':encoding(utf8)';sub new {bless {},shift}sub run {my ($self,@argv)=@_;my%opt=(cpanfile=>'cpanfile',snapshot=>'cpanfile.snapshot',phase=>undef,relationship=>undef,);my$exitcode;my$p=Getopt::Long::Parser->new(config=>['gnu_getopt'],);my$parsed=$p->getoptionsfromarray(\@argv,'cpanfile=s'=>\$opt{cpanfile},'snapshot=s'=>\$opt{snapshot},'phase=s'=>\$opt{phase},'relationship=s'=>\$opt{relationship},'version'=>sub {$exitcode=0;version()},'help'=>sub {$exitcode=0;usage()},);if (!$parsed){usage(1);$exitcode=1}return$exitcode if defined$exitcode;my$app=App::ccu->new(%opt);$app->run(@argv);return 0}sub usage {my$fh=$_[0]? *STDERR : *STDOUT;print$fh <<'...'}sub version {my$fh=$_[0]? *STDERR : *STDOUT;print$fh "cpanfile-check-updates version $App::ccu::VERSION\n";if (defined$App::ccu::GIT_DESCRIBE){print$fh "This is a self-contained version, $App::ccu::GIT_DESCRIBE ($App::ccu::GIT_URL)\n"}}1;
  usage: cpanfile-check-updates [--cpanfile FILE] [--snapshot FILE]
                                [--phase PHASE] [--relationship RELATIONSHIP] [--version] [--help]
                                [<modules>]
  
  Options
  
      --cpanfile FILE                         (default: cpanfile)
      --snapshot FILE                         (default: cpanfile.snapshot)
      --phase PHASE                           Target modules in the phase from cpanfile
      configure|build|test|runtime|develop
      --relationship RELATIONSHIP             Target modules in the relationship from cpanfile
      requires|recommends|suggests|conflicts
  
      --version                               Show version
      --help                                  Show help
  
      <modules>                               Target modules
  ...
APP_CCU_CLI

$fatpacked{"App/ccu/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_CPANFILE';
  package App::ccu::CPANfile;use strict;use warnings;use Carton::Snapshot;use CPAN::DistnameInfo;use Module::CPANfile;sub load {my ($class,$cpanfile,$snapshot)=@_;$cpanfile=Module::CPANfile->load($cpanfile);$snapshot=Carton::Snapshot->new(path=>$snapshot);$snapshot->load;my%modules;my$prereqs=$cpanfile->prereqs->as_string_hash;for my$phase (keys %$prereqs){for my$relationship (keys %{$prereqs->{$phase}}){for my$module (keys %{$prereqs->{$phase}{$relationship}}){my$version_range=$prereqs->{$phase}{$relationship}{$module};next if$module eq 'perl';my$dist=$snapshot->find_or_core($module)or next;if ($dist->is_core){$modules{$module}={module=>$module,dist=>undef,version=>$dist->version_for,author_release=>undef,phase=>$phase,relationship=>$relationship,version_range=>$version_range,}}else {my$di=CPAN::DistnameInfo->new($dist->pathname);$modules{$module}={module=>$module,dist=>$di->dist,version=>$di->version,author_release=>$di->cpanid .'/' .$di->distvname,phase=>$phase,relationship=>$relationship,version_range=>$version_range,}}}}}return \%modules}1;
APP_CCU_CPANFILE

$fatpacked{"App/ccu/ChangesParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_CHANGESPARSER';
  package App::ccu::ChangesParser;use strict;use warnings;use CPAN::Changes;my%months;my$m=0;$months{$_}=++$m for qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);sub load {my ($class,$file)=@_;open my$fh,'<',$file or die "can't open $file: $!";my$content=do {local $/;<$fh>};$class->parse($content)}sub parse {my ($class,$string)=@_;my@lines=split /\r\n?|\n/,$string;my$preamble=q{};my@releases;my$release;my@indents;for my$linenr (0 .. $#lines){my$line=$lines[$linenr];if ($line =~ /^(?:version\s+)?($version::LAX(?:-TRIAL)?)(\s+(.*))?$/i){my$version=$1;my$note=$3;if ($note){$note =~ s/^[\W\s]+//;$note =~ s/\s+$//}my$date;if ($note){if ($note =~ s{^($CPAN::Changes::UNKNOWN_VALS)}{}i){$date=$1}elsif ($note =~ s{^\D{3}\s+(\D{3})\s+(\d{1,2})\s+([\d:]+)?\D*(\d{4})}{}){if ($3){$date=sprintf('%d-%02d-%02dT%sZ',$4,$months{$1},$2,$3)}else {$date =sprintf('%d-%02d-%02d',$4,$months{$1},$2)}}elsif ($note =~ s{^\D{3}, (\d{1,2}) (\D{3}) (\d{4}) (\d\d:\d\d:\d\d) ([+-])(\d{2})(\d{2})}{}){$date=sprintf('%d-%02d-%02dT%s%s%02d:%02d',$3,$months{$2},$1,$4,$5,$6,$7)}elsif ($note =~ s{^(\d{4}-\d\d-\d\d)\s+(\d\d:\d\d(?::\d\d)?)(?:\s+[A-Za-z]+/[A-Za-z_-]+)}{}){$date=sprintf('%sT%sZ',$1,$2)}elsif ($note =~ m{^($CPAN::Changes::W3CDTF_REGEX)}){$date=$1;$date =~ s{ }{T};$date .= 'Z' if length($date)==16 || length($date)==19 || $date =~ m{\.\d+$}}$note =~ s{^\s+}{}}$release={version=>$version,date=>$date,note=>$note,entries=>[],line=>$linenr,};push@releases,$release;@indents=($release)}elsif (@indents){if ($line =~ /^[-_*+~#=\s]*$/){$indents[-1]{done}++ if@indents > 1;next}$line =~ s/\s+$//;$line =~ s/^(\s*)//;my$indent=1 + length _expand_tab($1);my$change;my$done;my$nest;if ($line =~ /^\[\s*([^\[\]]*)\]$/){$done=1;$nest=1;$change=$1;$change =~ s/\s+$//}elsif ($line =~ /^[-*+=#]+\s+(.*)/){$change=$1}else {$change=$line;if ($indent >= $#indents && $indents[-1]{text}&&!$indents[-1]{done}){$indents[-1]{text}.= " $change";next}}my$group;my$nested;if (!$nest && $indents[$indent]{nested}){$nested=$group=$indents[$indent]{nested}}elsif (!$nest && $indents[$indent]{nest}){$nested=$group=$indents[$indent]}else {($group)=grep {defined}reverse@indents[0 .. $indent - 1 ]}my$entry={text=>$change,line=>$linenr,done=>$done,nest=>$nest,nested=>$nested,};push @{$group->{entries}||= []},$entry;if ($indent <= $#indents){$#indents=$indent}$indents[$indent]=$entry}elsif (@releases){}else {$preamble .= "$line\n"}}$preamble =~ s/^\s*\n//;$preamble =~ s/\s+$//;my@entries=@releases;while (my$entry=shift@entries){push@entries,@{$entry->{entries}}if$entry->{entries};delete @{$entry}{qw(done nest nested)}}return {preamble=>$preamble,releases=>[reverse@releases ],}}sub _expand_tab {my$string="$_[0]";$string =~ s/([^\t]*)\t/$1 . (" " x (8 - (length $1) % 8))/eg;return$string}my$rt_cpan_base='https://rt.cpan.org/Ticket/Display.html?id=';my$rt_perl_base='https://rt.perl.org/Ticket/Display.html?id=';my$sep=qr{[-:]|\s*[#]?};sub _link_issues {my ($class,$change,$gh_base,$rt_base)=@_;$change =~ s{(
          (?:
          (
          \b(?:blead)?perl\s+(?:RT|bug)$sep
          |
          (?<=\[)(?:blead)?perl\s+$sep
          |
          \brt\.perl\.org\s+\#
          |
          \bP5\#
          )
          |
          (
          \bCPAN\s+(?:RT|bug)$sep
          |
          (?<=\[)CPAN\s+$sep
          |
          \brt\.cpan\.org\s+\#
          )
          |
          (\bRT$sep)
          |
          (\b(?:GH|PR)$sep)
          |
          ((?:\bbug\s*)?\#)
          )
          (\d+)\b
          )}{
              my $text = $1;
          my $issue = $7;
          my $base
              = $2 ? $rt_perl_base
              : $3 ? $rt_cpan_base
              : $4 ? $rt_base
              : $5 ? $gh_base
              # this form is non-specific, so guess based on issue number
              : ($gh_base && $issue < 10000)
              ? $gh_base
              : $rt_base;
          $base ? qq{[$text]($base$issue)} : $text;
      }xgei;return$change}sub filter_release_changes {my ($class,$changelog,$release)=@_;my$gh_base;my$rt_base;my$bt=$release->{resources}{bugtracker}&& $release->{resources}{bugtracker}{web};my$repo=$release->{resources}{repository};$repo=ref$repo ? $repo->{url}: $repo;if ($bt && $bt =~ m|^https?://github\.com/|){$gh_base=$bt;$gh_base =~ s{/*$}{/}}elsif ($repo && $repo =~ m|\bgithub\.com/([^/]+/[^/]+)|){my$name=$1;$name =~ s/\.git$//;$gh_base="https://github.com/$name/issues/"}if ($bt && $bt =~ m|\brt\.perl\.org\b|){$rt_base=$rt_perl_base}else {$rt_base=$rt_cpan_base}my@entries_list=$changelog->{entries};while (my$entries=shift@entries_list){for my$entry (@$entries){for ($entry->{text}){s/&/&amp;/g;s/</&lt;/g;s/>/&gt;/g;s/"/&quot;/g}$entry->{text}=$class->_link_issues($entry->{text},$gh_base,$rt_base);push@entries_list,$entry->{entries}if$entry->{entries}}}return$changelog}1;
APP_CCU_CHANGESPARSER

$fatpacked{"App/ccu/MetaCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_METACPAN';
  package App::ccu::MetaCPAN;use strict;use warnings;use HTTP::Tinyish;use JSON::PP qw/decode_json encode_json/;use Class::Tiny {http=>sub {HTTP::Tinyish->new},};sub author_release {my ($self,$module,$version)=@_;my$res=$self->http->post("https://fastapi.metacpan.org/v1/module/_search?size=1",{content=>encode_json({_source=>[qw/author release/],query=>{bool=>{must=>[{term=>{'module.name'=>$module}},{term=>{version=>$version}},],},},}),});unless ($res->{success}){die "$res->{status} $res->{reason}"}my$r=decode_json($res->{content});if ($r->{hits}{total}> 0){my$m=$r->{hits}{hits}[0]{_source};return$m->{author}.'/' .$m->{release}}return}sub release {my ($self,$author_release)=@_;my$res=$self->http->get("https://fastapi.metacpan.org/v1/release/$author_release");unless ($res->{success}){die "$res->{status} $res->{reason}"}return decode_json($res->{content})->{release}}sub changes {my ($self,$author_release)=@_;my$res=$self->http->get("https://fastapi.metacpan.org/v1/changes/$author_release");unless ($res->{success}){die "$res->{status} $res->{reason}"}return decode_json($res->{content})->{content}}1;
APP_CCU_METACPAN

$fatpacked{"App/ccu/ModuleDetails.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_MODULEDETAILS';
  package App::ccu::ModuleDetails;use strict;use warnings;use CPAN::Audit::DB;use URI;use App::ccu::ChangesParser;use App::ccu::MetaCPAN;use App::ccu::Version;use Class::Tiny {audit_db=>sub {CPAN::Audit::DB->db},metacpan=>sub {App::ccu::MetaCPAN->new},};sub show {my ($self,$source,$target)=@_;my$source_author_release=$source->{author_release}|| $self->metacpan->author_release($source->{module},$source->{version});printf "## %s\n",$source->{module};printf "[`%s` -> `%s`](%s)\n",$source->{version},$target->{version},$self->_diff_file_url($source_author_release,$target->{author_release});$self->print_advisory($target->{dist},$source->{version});$self->print_changes($target->{author_release},$source->{version},$target->{version})}sub _diff_file_url {my ($self,$source_author_release,$target_author_release)=@_;my$metacpan_diff_uri=URI->new('https://metacpan.org/diff/file');$metacpan_diff_uri->query_form(source=>$source_author_release,target=>$target_author_release,);return$metacpan_diff_uri->as_string}sub print_advisory {my ($self,$dist,$version)=@_;my$db=$self->audit_db->{dists}{$dist}or return;my@affected_advisories=grep {App::ccu::Version->in_range($version,$_->{affected_versions})}@{$db->{advisories}};return unless@affected_advisories;printf "### :warning: Affected security updates\n";for my$advisory (@affected_advisories){my$description=$advisory->{description};$description =~ s/\s+$//;$description =~ s/\s+/ /g;my$cves='';if (exists$advisory->{cves}){$cves=join(', ',@{$advisory->{cves}}).': '}printf "- %s%s\n",$cves,$description;if (exists$advisory->{references}){printf "  - %s\n",$_ for @{$advisory->{references}}}}}sub print_changes {my ($self,$author_release,$version,$latest_version)=@_;my$release=$self->metacpan->release($author_release);my$changes_text=$self->metacpan->changes($author_release);my$changes=eval {App::ccu::ChangesParser->parse($changes_text)}or return;my@changelogs;my$skip=1;for my$changelog (reverse @{$changes->{releases}}){my$v=$changelog->{version};if ($v eq $latest_version){$skip=0}elsif ($v eq $version){last}unless ($skip){push@changelogs,App::ccu::ChangesParser->filter_release_changes($changelog,$release)}}return unless@changelogs;print "### Changes\n";my$collapse=$self->count_entries(@changelogs)> 10;print "<details>\n" if$collapse;my$first=1;for my$i (0..$#changelogs){my$changelog=$changelogs[$i];print "<summary>\n\n" if$collapse && $first;printf "#### %s: %s\n",$changelog->{version},$changelog->{date}|| '';my@entries=$self->expand_entries(@{$changelog->{entries}});for my$j (0..$#entries){my$entry=$entries[$j];printf "%s- %s\n",'  ' x $entry->[0],$entry->[1];if ($i==$#changelogs && $j + 1 >= 10){printf "...\n";last}}print "</summary>\n\n" if$collapse && $first;$first=0}print "</details>\n\n" if$collapse}sub expand_entries {my ($self,@entries)=@_;my@expanded;for my$entry (@entries){push@expanded,[0,$entry->{text}];push@expanded,map {[$_->[0]+ 1,$_->[1]]}$self->expand_entries(@{$entry->{entries}})}return@expanded}sub count_entries {my ($self,@entries)=@_;my$count=0;for my$entry (@entries){$count += 1 + $self->count_entries(@{$entry->{entries}})}return$count}1;
APP_CCU_MODULEDETAILS

$fatpacked{"App/ccu/PAUSEPackages.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_PAUSEPACKAGES';
  package App::ccu::PAUSEPackages;use strict;use warnings;use CPAN::DistnameInfo;use HTTP::Tinyish;use IO::Uncompress::Gunzip qw/$GunzipError/;use Class::Tiny {releases=>sub {$_[0]->_build_releases},};sub _build_releases {my$self=shift;my%releases;my$inheader=1;my$z=$self->_fetch_packages;while (defined(my$line=$z->getline)){if ($line =~ /^$/ && $inheader){$inheader=0;next}next if$inheader;my ($module,$version,$path)=split(/\s+/,$line);my$di=CPAN::DistnameInfo->new($path);if ($di && defined$di->dist && defined$di->version){if (!exists$releases{$di->dist}){$releases{$di->dist}={distinfo=>$di,modules=>[],}}elsif ($releases{$di->dist}->{distinfo}->version lt $di->version){$releases{$di->dist}{distinfo}=$di}push @{$releases{$di->dist}{modules}},$module}}return \%releases}sub _fetch_packages {my$res=HTTP::Tinyish->new->get('http://www.cpan.org/modules/02packages.details.txt.gz');unless ($res->{success}){die "$res->{status} $res->{reason}"}my$z=IO::Uncompress::Gunzip->new(\$res->{content})or die "gunzip failed: $GunzipError";return$z}sub find_release {my ($self,$dist,$module)=@_;if (defined$dist){my$release=$self->releases->{$dist};if ($release){return$release->{distinfo}}}my$releases=$self->releases;for my$release (values %$releases){for my$m (@{$release->{modules}}){if ($m eq $module){return$release->{distinfo}}}}return undef}1;
APP_CCU_PAUSEPACKAGES

$fatpacked{"App/ccu/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CCU_VERSION';
  package App::ccu::Version;use strict;use warnings;use version;sub in_range {my$class=shift;my ($version,$range)=@_;return unless defined$version && defined$range;my@ands=split /\s*,\s*/,$range;return unless defined($version=eval {version->parse($version)});for my$and (@ands){my ($op,$range_version)=$and =~ m/^(<=|<|>=|>|==|!=)?\s*([^\s]+)$/;return unless defined($range_version=eval {version->parse($range_version)});$op='>=' unless defined$op;if ($op eq '<'){return unless$version < $range_version}elsif ($op eq '<='){return unless$version <= $range_version}elsif ($op eq '>'){return unless$version > $range_version}elsif ($op eq '>='){return unless$version >= $range_version}elsif ($op eq '=='){return unless$version==$range_version}elsif ($op eq '!='){return unless$version!=$range_version}else {return 0}}return 1}1;
APP_CCU_VERSION

$fatpacked{"App/sigfix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SIGFIX';
  package App::sigfix;use strictures 2;use Babble::Plugin::CoreSignatures;use Babble::Match;use Getopt::Long;our$VERSION='0.001001';sub stripspace {my ($text)=@_;$text =~ /^(\s+)/ && $text =~ s/^$1//mg;$text}sub usage {print <<'USAGE';exit(255)}{my$cs=Babble::Plugin::CoreSignatures->new;my@target_selectors=(['signatures','($] >= 5.020 and $] < 5.022) or $] >= 5.028' ],['oldsignatures','$] >= 5.022 and $] < 5.028' ],['plain' ],);sub process_source {my ($source,$opt)=@_;if (my$target=$opt->{target}){my$top=Babble::Match->new(top_rule=>'Document',text=>$source,);my$transform="transform_to_${target}";unless ($cs->can($transform)){print STDERR "Invalid transform target ${target}";usage}$cs->$transform($top);return$top->text}my$preamble=stripspace <<'    PREAMBLE';my@segments;for my$target (map $_->[0],@target_selectors){my$top=Babble::Match->new(top_rule=>'Document',text=>$source,);$cs->${\"transform_to_${target}"}($top);my$data=$top->text;s/^/    /mg,s/(?<!\n)\z/\n/ for$data;my$doc_name=uc join '_','CODE_FOR',$target;push@segments,join '',qq{  \$options{'${target}'} = '#line '.(1+__LINE__).' "'.__FILE__."\\"\\n".<<'$doc_name';\n},$data,$doc_name,"\n"}my$select=join "\n",'  my $chosen =',(map {my ($choice,$cond)=@$_;if ($cond){"    $cond ? '$choice' :"}else {"    '$choice';"}}@target_selectors),'';my$postamble=stripspace <<'    POSTAMBLE';$postamble =~ s/^/  /mg;return join '',$preamble,@segments,$select,$postamble,"}\n0; # should never get here\n"}}sub process_file {my ($file,$opt)=@_;my$source=do {open my$in,'<',$file or die "Couldn't open ${file} for read: $!\n";local $/;<$in>};my$processed=process_source$source,$opt;my$out_file=$file.($opt->{pmc}? 'c' : '');open my$out,'>',$out_file or die "Couldn't open ${out_file} for write: $!\n";print$out $processed;return}sub options {my%opt;GetOptions('t|target=s',\$opt{target},'i|inplace',\$opt{inplace},'pmc',\$opt{pmc},'help',\$opt{help});if ($opt{help}){usage}if (not $opt{target}and not $opt{pmc}){print STDERR "Must supply at least one of -t/--target or --pmc\n";usage}if ($opt{inplace}and not @ARGV){print STDERR "In-place operation requires a list of files\n";usage}if ($opt{inplace}and $opt{pmc}and grep!/\.pm$/,@ARGV){print STDERR "In-place pmc generation requires a list of .pm files\n";usage}return \%opt}sub main {my$opt=options;if ($opt->{inplace}){for my$file (@ARGV){process_file$file,$opt}return}(my$source=do {local $/;<>})||= '';print process_source$source,$opt;return}1;
  sigfix [OPTIONS] [FILES]
  
    sigfix -t signatures perl526file >perl528file
    sigfix -t oldsignatures perl528file >perl526file
    sigfix -t plain perlfile >perl58file
  
    sigfix -i -t signatures upgradethisfile
  
    sigfix -t signatures --pmc lib/My/Module.pm >lib/My/Module.pmc
    sigfix -i -t signatures --pmc lib/My/Module.pm
  
    sigfix -i --pmc eval $(find lib -name '*.pm') # multi-target fat pmc
  
  Options:
  
    -t, --target     Target: 'signatures', 'oldsignatures', 'plain'
    -i, --inplace    Modify target file(s) in place
    --pmc            Generate .pmc (without -t, triple target pmc)
    -h               This usage message
  USAGE
        # This code generated by App::sigfix
        BEGIN {
          my %options;
      PREAMBLE
        require Filter::Util::Call;
        Filter::Util::Call::filter_add(sub {
          Filter::Util::Call::filter_del();
          1 while Filter::Util::Call::filter_read();
          $_ = $options{$chosen};
        });
      POSTAMBLE
APP_SIGFIX

$fatpacked{"Babble.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE';
  package Babble;use strictures 2;our$VERSION='0.090007';1;
BABBLE

$fatpacked{"Babble/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_FILTER';
  package Babble::Filter;use Babble::PluginChain;use Filter::Util::Call;use strictures 2;sub import {my ($class,@plugins)=@_;my$pc=Babble::PluginChain->new;$pc->add_plugin($_)for@plugins;filter_add(sub {filter_del();1 while filter_read();$_=$pc->transform_document($_);return 1});if ($0 eq '-e'){eval 'sub main::babble { $_ = $pc->transform_document($_) }'}}1;
BABBLE_FILTER

$fatpacked{"Babble/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_GRAMMAR';
  package Babble::Grammar;use PPR::X;use Mu;use strictures 2;lazy base_grammar_regexp=>sub {$PPR::X::GRAMMAR};lazy base_rule_names=>sub {my$g=$_[0]->base_grammar_regexp;+{map +($_=>1),$g =~ /\(\?<PerlStd(\w+)>/g }};lazy rules=>sub {+{map +($_=>[undef ]),keys %{$_[0]->base_rule_names}}};lazy grammar_regexp=>sub {my ($self)=@_;my@parts;for my$name (sort keys %{$self->rules}){my@layers=@{$self->rules->{$name}};for my$idx (0..$#layers){next unless defined(my$rule=$layers[$idx]);my$layer_name=$self->_rule_name($name,$idx);my$define='(?<'.$layer_name.'>'.$rule.')';$define='(?<Perl'.$name.'>'.$define.')' if$idx==$#layers;unshift@parts,$define}}my$base_re=$self->base_grammar_regexp;return$base_re unless@parts;my$define_block=join "\n",'(?(DEFINE)','',@parts,'',')';use re 'eval';my$final_re="${define_block} ${base_re}";return qr{$final_re}x};sub _rule_name {my ($self,$name,$index)=@_;return 'PerlStd'.$name unless$index;return 'PerlWrapper'.$name.'_'.sprintf("%03i",$index)}sub add_rule {my ($self,$name,$rule)=@_;die "Rule ${name} already exists" if exists$self->rules->{$name};$self->rules->{$name}=[$rule ];return$self}sub replace_rule {my ($self,$name,$rule)=@_;die "Rule ${name} does not exist" unless exists$self->rules->{$name};$self->rules->{$name}=[$rule ];return$self}sub extend_rule {my ($self,$name,$cb)=@_;die "Rule ${name} does not exist" unless my$r=$self->rules->{$name};my$inner_name=$self->_rule_name($name,$#{$r});$self->rules->{$name}=[@$r,$cb->('(?&'.$inner_name.')')];return$self}sub augment_rule {my ($self,$name,$extra)=@_;$self->extend_rule($name,sub {join '|',$extra,$_[0]});return$self}sub clone {my ($self)=@_;return ref($self)->new(base_grammar_regexp=>$self->base_grammar_regexp,rules=>{%{$self->rules}},)}sub match {my ($self,$as,$text)=@_;require Babble::Match;Babble::Match->new(top_rule=>$as,text=>$text,grammar=>$self)}1;
BABBLE_GRAMMAR

$fatpacked{"Babble/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_MATCH';
  package Babble::Match;use Babble::Grammar;use Babble::SymbolGenerator;use Mu;use re 'eval';ro 'top_rule';rwp 'text';lazy 'grammar'=>sub {Babble::Grammar->new}=>handles=>['grammar_regexp' ];lazy 'symbol_generator'=>sub {$_[0]->can('parent')? $_[0]->parent->symbol_generator : Babble::SymbolGenerator->new}=>handles=>['gensym' ];lazy top_re=>sub {my ($self)=@_;my$top=$self->_rule_to_re($self->top_rule);return "\\A${top}\\Z"};lazy submatches=>sub {my ($self)=@_;return {}unless ref(my$top=$self->top_rule);my@subrules;my$re=join '',map {ref($_)? do {push@subrules,$_;my ($name,$rule)=@$_;"(${rule})"}: $_}@$top;return {}unless@subrules;my@values=$self->text =~ /\A${re}\Z ${\$self->grammar_regexp}/x;die "Match failed" unless@values;my%submatches;require Babble::SubMatch;for my$idx (0 .. $#subrules){next unless defined$values[$idx];my ($name,$rule)=@{$subrules[$idx]};$submatches{$name}=Babble::SubMatch->new(top_rule=>[$rule ],start=>$-[$idx+1],text=>$values[$idx],parent=>$self,)}return \%submatches};sub subtexts {my ($self,@names)=@_;unless (@names){my%s=%{$self->submatches};return +{map +($_=>$s{$_}->text),keys%s }}map +($_ ? $_->text : undef),@{$self->submatches}{@names}}sub _rule_to_re {my$re=$_[1];return "(?&Perl${re})" unless ref($re);return join '',map +(ref($_)? $_->[1]: $_),@$re}sub is_valid {my ($self)=@_;return!!$self->text =~ /${\$self->top_re} ${\$self->grammar_regexp}/x}sub match_positions_of {my ($self,$of)=@_;our@F;my$wrapped=$self->grammar->clone->extend_rule($of=>sub {'('.$_[0].')'.'(?{ push @Babble::Match::F, [ pos() - length($^N), length($^N) ] })'})->grammar_regexp;my@found=do {local@F;local $_=$self->text;/${\$self->top_re} ${wrapped}/x;@F};return@found}sub each_match_of {my ($self,$of,$call)=@_;my@found=$self->match_positions_of($of);return unless@found;require Babble::SubMatch;while (my$f=shift@found){my$match=substr($self->text,$f->[0],$f->[1]);my$obj=Babble::SubMatch->new(top_rule=>$of,start=>$f->[0],text=>$match,parent=>$self,);$call->($obj);if (my$len_diff=length($obj->text)- $f->[1]){for my$later (@found){if ($later->[0]<= $f->[0]){$later->[1]+= $len_diff}else {$later->[0]+= $len_diff}}}}return$self}sub each_match_within {my ($self,$within,$rule,$call)=@_;my$match_re=$self->_rule_to_re($rule);my$extend_grammar=$self->grammar->clone;$extend_grammar->add_rule(BabbleInnerMatch=>$match_re,)->augment_rule($within=>'(?&PerlBabbleInnerMatch)');local$self->{grammar}=$extend_grammar;$self->each_match_of(BabbleInnerMatch=>sub {$_[0]->{top_rule}=$rule;$call->($_[0])});return$self}sub replace_substring {my ($self,$start,$length,$replace)=@_;my$text=$self->text;substr($text,$start,$length,$replace);$self->_set_text($text);for my$submatch (values %{$self->submatches}){next unless defined$submatch;if ($submatch->start > $start){$submatch->{start}+= length($replace)- $length}}return$self}sub remove_use_argument {my ($self,$use,$argument,$keep_empty)=@_;$self->each_match_within(UseStatement=>["use\\s+${use}\\s+",[explist=>'.*?' ],';' ],sub {my ($m)=@_;my$explist=$m->submatches->{explist};return unless my@explist_names=eval$explist->text;my@remain=grep $_ ne $argument,@explist_names;return unless@remain < @explist_names;unless (@remain){($keep_empty ? $explist : $m)->replace_text('');return}$explist->replace_text('qw('.join(' ',@remain).')')})}sub remove_use_statement {my ($self,$use)=@_;$self->each_match_within(UseStatement=>["use\\s+${use}.*?;" ],sub {shift->replace_text('')},)}1;
BABBLE_MATCH

$fatpacked{"Babble/Plugin/CoreSignatures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_PLUGIN_CORESIGNATURES';
  package Babble::Plugin::CoreSignatures;use strictures 2;use Moo;sub extend_grammar {}sub transform_to_signatures {my ($self,$top)=@_;my$tf=sub {my$s=(my$m=shift)->submatches;if ((my$after=$s->{after}->text)=~ /\S/){$s->{after}->replace_text('');$s->{before}->replace_text($s->{before}->text.$after)}};$self->_transform_signatures($top,$tf)}sub transform_to_oldsignatures {my ($self,$top)=@_;my$tf=sub {my$s=(my$m=shift)->submatches;if ((my$before=$s->{before}->text)=~ /\S/){$s->{before}->replace_text('');$s->{after}->replace_text($before.$s->{after}->text)}};$self->_transform_signatures($top,$tf)}sub transform_to_plain {my ($self,$top)=@_;$top->remove_use_argument(experimental=>'signatures');$top->remove_use_argument('Mojo::Base'=>'-signatures',1);my$tf=sub {my$s=(my$m=shift)->submatches;if ((my$before=$s->{before}->text)=~ /\S/){$s->{before}->replace_text('');$s->{after}->replace_text($before.$s->{after}->text)}my$proto='';{my$try=$s->{after};local$try->{top_rule}='Attributes';my$grammar=$m->grammar->clone;$grammar->add_rule(Attribute=>'(?&PerlOWS) :? (?&PerlOWS)
           (?&PerlIdentifier)
           (?: (?= \( ) (?&PPR_X_quotelike_body) )?+')->replace_rule(Attributes=>'(?=(?&PerlOWS):)(?&PerlAttribute)
           (?&PerlAttribute)*');local$try->{grammar}=$grammar;my$each;$each=sub {my ($attr)=@_;if ($attr->text =~ /prototype(\(.*?\))/){$proto=$1;$attr->replace_text('');$each=sub {my ($attr)=@_;$attr->transform_text(sub {s/^(\s*)/${1}:/})unless$attr->text =~ /^\s*:/;$each=sub {}}}};$try->each_match_of(Attribute=>sub {$each->(@_)});undef($each)}s/\A\s*\(//,s/\)\s*\Z// for my$sig_orig=$s->{sig}->text;my$grammar_re=$m->grammar_regexp;my@sig_parts=grep defined($_),$sig_orig =~ /((?&PerlAssignment)) ${grammar_re}/xg;my (@sig_text,@defaults);for my$idx (0..$#sig_parts){my$part=$sig_parts[$idx];if ($part =~ s/^(\S+?)\s*=\s*(.*?)(,$|$)/$1$3/){push@defaults,"$1 = $2 if \@_ <= $idx;"}push@sig_text,$part}my$sig_text='my ('.(join ', ',@sig_text).') = @_;';my$code=join ' ',$sig_text,@defaults;$s->{body}->transform_text(sub {s/^{/{ ${code}/});if ($proto){$s->{sig}->transform_text(sub {s/\A(\s*)\(.*\)(\s*)\Z/${1}${proto}${2}/})}else {$s->{sig}->replace_text('')}};$self->_transform_signatures($top,$tf)}sub _transform_signatures {my ($self,$top,$tf)=@_;my@common=('(?:',[before=>'(?: (?&PerlOWS) (?>(?&PerlAttributes)) )?+' ],[sig=>'(?&PerlOWS) (?&PerlParenthesesList)' ],[after=>'(?&PerlOWS)' ],'|',[before=>'(?&PerlOWS)' ],[sig=>'(?&PerlParenthesesList) (?&PerlOWS)' ],[after=>'(?: (?>(?&PerlAttributes)) (?&PerlOWS) )?+' ],')',[body=>'(?&PerlBlock)' ],);$top->each_match_within('SubroutineDeclaration'=>['sub \b (?&PerlOWS) (?&PerlOldQualifiedIdentifier)',@common,],$tf);$top->each_match_within('AnonymousSubroutine'=>['sub \b',@common,],$tf)}1;
BABBLE_PLUGIN_CORESIGNATURES

$fatpacked{"Babble/Plugin/DefinedOr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_PLUGIN_DEFINEDOR';
  package Babble::Plugin::DefinedOr;use Moo;sub transform_to_plain {my ($self,$top)=@_;$top->each_match_within(Statement=>[[before=>'(?>(?&PerlPrefixPostfixTerm))' ],[op=>'(?>(?&PerlOWS) //=)' ],'(?>(?&PerlOWS))',[after=>'(?>(?&PerlPrefixPostfixTerm))' ],'(?>(?&PerlOWS))',[trail=>'
          (?&PerlStatementModifier)?+
          (?>(?&PerlOWS))
          (?> ; | (?= \} | \z ))
        ' ],]=>sub {my ($m)=@_;my ($before,$after,$trail)=$m->subtexts(qw(before after trail));s/^\s+//,s/\s+$// for ($before,$after);my$assign='defined($_) or $_ = '.$after.' for '.$before;if (length($trail)> 1){$assign='do { '.$assign.' } '}$m->replace_text($assign.$trail)});my$tf=sub {my ($m)=@_;my ($before,$after)=$m->subtexts(qw(before after));s/^\s+//,s/\s+$// for ($before,$after);if ($m->submatches->{op}->text =~ /=$/){$after='$_ = '.$after}$m->replace_text('(map +(defined($_) ? $_ : '.$after.'), '.$before.')[0]')};$top->each_match_within(BinaryExpression=>[[before=>'(?>(?&PerlPrefixPostfixTerm))' ],[op=>'(?>(?&PerlOWS) //)' ],'(?>(?&PerlOWS))',[after=>'(?>(?&PerlPrefixPostfixTerm))' ],]=>$tf);$top->each_match_within(Assignment=>[[before=>'(?>(?&PerlPrefixPostfixTerm))' ],[op=>'(?>(?&PerlOWS) //=)' ],'(?>(?&PerlOWS))',[after=>'(?>(?&PerlPrefixPostfixTerm))' ],]=>$tf)}1;
BABBLE_PLUGIN_DEFINEDOR

$fatpacked{"Babble/Plugin/PostfixDeref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_PLUGIN_POSTFIXDEREF';
  package Babble::Plugin::PostfixDeref;use Moo;my$scalar_post=q{
    (?:
      (?>(?&PerlOWS))
      (?:
        (?:
          (?>(?&PerlOWS))      -> (?>(?&PerlOWS))
          (?&PerlParenthesesList)
        |
          (?>(?&PerlOWS))  (?: ->    (?&PerlOWS)  )?+
          (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
        )
        (?:
          (?>(?&PerlOWS))  (?: ->    (?&PerlOWS)  )?+
                     (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
        )*+
      )?+
      (?:
        (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
        [\@%]
        (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
      )?+
    )
  };sub transform_to_plain {my ($self,$top)=@_;$top->remove_use_argument(experimental=>'postderef');$top->remove_use_argument(feature=>'postderef');my$tf=sub {my ($m)=@_;my ($term,$postfix)=$m->subtexts(qw(term postfix));my$grammar=$m->grammar_regexp;my$strip_re=qr{
        ( (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
          (?>
             (?> (?&PerlQualifiedIdentifier) | (?&PerlVariableScalar) )
             (?: (?>(?&PerlOWS)) (?&PerlParenthesesList) )?+
             | (?&PerlParenthesesList)
             | (?&PerlArrayIndexer)
             | (?&PerlHashIndexer)
             | \$\*
          )
        )
        ${grammar}
      }x;while ($postfix =~ s/^${strip_re}//){my$stripped=$1;if ($stripped =~ /\$\*$/){$term='(map $$_, '.$term.')[0]'}else {$term .= $stripped}}if ($postfix){my ($sigil,$rest)=($postfix =~ /^\s*->\s*([\@%])(.*)$/);$rest='' if$rest eq '*';$term='(map '.$sigil.'{$_}'.$rest.', '.$term.')'}$m->submatches->{term}->replace_text($term);$m->submatches->{postfix}->replace_text('')};$top->each_match_within(PrefixPostfixTerm=>['(?: (?>(?&PerlPrefixUnaryOperator))  (?&PerlOWS) )*+',[term=>'(?>(?&PerlTerm))' ],[postfix=>'(?&PerlTermPostfixDereference)' ],'(?: (?>(?&PerlOWS)) (?&PerlPostfixUnaryOperator) )?+' ]=>$tf);$top->each_match_within(ScalarAccess=>[[term=>'(?>(?&PerlVariableScalar))' ],[postfix=>$scalar_post ],]=>$tf)}1;
BABBLE_PLUGIN_POSTFIXDEREF

$fatpacked{"Babble/Plugin/SKT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_PLUGIN_SKT';
  package Babble::Plugin::SKT;use Moo;sub extend_grammar {my ($self,$g)=@_;$g->add_rule(TryCatch=>'try(?&PerlOWS)(?&PerlBlock)' .'(?:(?&PerlOWS)catch(?&PerlOWS)(?&PerlBlock))?+');$g->augment_rule(Statement=>'(?&PerlTryCatch)')}sub transform_to_plain {my ($self,$top)=@_;$top->remove_use_statement('Syntax::Keyword::Try');$top->each_match_within(TryCatch=>['try(?&PerlOWS)',[try_block=>'(?&PerlBlock)' ],'(?:(?&PerlOWS)catch(?&PerlOWS)',[catch_block=>'(?&PerlBlock)' ],')?+' ]=>sub {my ($m)=@_;my ($try,$catch)=$m->subtexts(qw(try_block catch_block));my$text=do {if ($catch){$try =~ s/\s*}$/; 1 }/;'unless (eval '.$try.') '.$catch}else {'eval '.$try}};$m->replace_text('{ local $@; '.$text.' }')})}1;
BABBLE_PLUGIN_SKT

$fatpacked{"Babble/Plugin/Sigify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_PLUGIN_SIGIFY';
  package Babble::Plugin::Sigify;use strictures 2;use Moo;sub transform_to_plain {my ($self,$top)=@_;my$tf=sub {my ($m)=@_;my$body=$m->submatches->{body}->text;$body =~ s/^\s+//;if ($body =~ s/^\{\s*my\s*(\([^\)]+\))\s*=\s*\@_\s*;/{/sm){my$sig=$1;$body =~ s/^{\n\n/{\n/;$m->submatches->{body}->replace_text($sig.' '.$body)}};$top->each_match_within('SubroutineDeclaration'=>['sub \b (?&PerlOWS) (?&PerlOldQualifiedIdentifier) (?&PerlOWS)','(?: (?>(?&PerlAttributes)) (?&PerlOWS) )?+',[body=>'(?&PerlBlock)' ],'(?&PerlOWS)' ]=>$tf);$top->each_match_within('AnonymousSubroutine'=>['sub \b (?&PerlOWS)','(?: (?>(?&PerlAttributes)) (?&PerlOWS) )?+',[body=>'(?&PerlBlock)' ],'(?&PerlOWS)' ]=>$tf)}1;
BABBLE_PLUGIN_SIGIFY

$fatpacked{"Babble/Plugin/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_PLUGIN_STATE';
  package Babble::Plugin::State;use Moo;sub transform_to_plain {my ($self,$top)=@_;$top->remove_use_argument(feature=>'state');my$make_tf=sub {my ($lead)=@_;sub {my ($m)=@_;my@states;my@gensym;$m->each_match_within(Assignment=>['state \b (?>(?&PerlOWS))',[type=>'(?: (?&PerlQualifiedIdentifier) (?&PerlOWS) )?+' ],[declares=>'(?>(?&PerlLvalue))' ],'(?>(?&PerlOWS))',[attributes=>'(?&PerlAttributes)?+' ],'(?: (?>(?&PerlOWS)) = (?>(?&PerlOWS))',[assigns=>'(?&PerlConditionalExpression)' ],')*+',]=>sub {my ($m)=@_;my$st=$m->subtexts;push@states,$st;if (my$assigns=$st->{assigns}){my$genlex='$'.$m->gensym;my$text='(' .$genlex .' ? '.$st->{declares}.' : ++'.$genlex.' and '.$st->{declares}.' = '.$assigns .')';push@gensym,$genlex;$m->replace_text($text);return}$m->replace_text('do { no warnings qw(void); '.$st->{declares}.' }')});if (@states){my$state_statements=join ' ',(@gensym ? 'my ('.join(', ',@gensym).');' : ()),(map {'my '.$_->{type}.$_->{declares}.($_->{attributes}? ' '.$_->{attributes}: '').';'}@states);$m->transform_text(sub {s/\A/${lead}{ ${state_statements} /;s/\Z/ }/})}}};$top->each_match_of(AnonymousSubroutine=>$make_tf->('do '));$top->each_match_of(SubroutineDeclaration=>$make_tf->(''))}1;
BABBLE_PLUGIN_STATE

$fatpacked{"Babble/Plugin/SubstituteAndReturn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_PLUGIN_SUBSTITUTEANDRETURN';
  package Babble::Plugin::SubstituteAndReturn;use Moo;sub transform_to_plain {my ($self,$top)=@_;$top->each_match_within(BinaryExpression=>[['left'=>'(?>(?&PerlPrefixPostfixTerm))' ],'(?>(?&PerlOWS)) =~ (?>(?&PerlOWS))',['right'=>'(?>(?&PerlSubstitution))' ],]=>sub {my ($m)=@_;my ($left,$right)=$m->subtexts(qw(left right));my ($flags)=$right =~ /([msixpodualgcern]*+)$/;return unless (my$newflags=$flags)=~ s/r//g;$right =~ s/\Q${flags}\E$/${newflags}/;$left =~ s/\s+$//;my$genlex='$'.$m->gensym;$m->replace_text('(map { (my '.$genlex.' = $_) =~ '.$right.'; '.$genlex.' }' .' '.$left.')[0]')})}1;
BABBLE_PLUGIN_SUBSTITUTEANDRETURN

$fatpacked{"Babble/PluginChain.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_PLUGINCHAIN';
  package Babble::PluginChain;use Babble::Grammar;use Module::Runtime qw(use_module);use Mu;lazy plugins=>sub {[]};lazy grammar=>sub {Babble::Grammar->new};sub add_plugin {my ($self,$plugin)=@_;$plugin =~ s/^::/Babble::Plugin::/;my$p=use_module($plugin)->new;$p->extend_grammar($self->grammar)if$p->can('extend_grammar');push @{$self->plugins},$p;return$self}sub transform_document {my ($self,$document)=@_;my$top=$self->grammar->match(Document=>$document);$_->transform_to_plain($top)for @{$self->plugins};return$top->text}1;
BABBLE_PLUGINCHAIN

$fatpacked{"Babble/SubMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_SUBMATCH';
  package Babble::SubMatch;use Mu;extends 'Babble::Match';ro 'parent';ro 'start';sub replace_text {my ($self,$new_text)=@_;$self->replace_substring(0,length($self->text),$new_text)}sub transform_text {my ($self,$code)=@_;local $_=my$text=$self->text;$code->($_);if ($_ ne $text){$self->replace_text($_)}return$self}before replace_substring=>sub {my ($self,$start,$length,$new_text)=@_;$self->parent ->replace_substring($self->start + $start,$length,$new_text)};1;
BABBLE_SUBMATCH

$fatpacked{"Babble/SymbolGenerator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BABBLE_SYMBOLGENERATOR';
  package Babble::SymbolGenerator;use Mu;ro count=>(default=>'001');sub gensym {my ($self)=@_;my$sym='__B_'.$self->{count}++;return$sym}1;
BABBLE_SYMBOLGENERATOR

$fatpacked{"CPAN/Audit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT';
  package CPAN::Audit;use 5.008001;use strict;use warnings;use version;use CPAN::Audit::Installed;use CPAN::Audit::Discover;use CPAN::Audit::Version;use CPAN::Audit::Query;use CPAN::Audit::DB;use Module::CoreList;our$VERSION="0.15";sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{ascii}=$params{ascii};$self->{verbose}=$params{verbose};$self->{quiet}=$params{quiet};$self->{no_color}=$params{no_color};$self->{no_corelist}=$params{no_corelist};$self->{interactive}=$params{interactive};if (!$self->{interactive}){$self->{ascii}=1;$self->{no_color}=1}$self->{db}=CPAN::Audit::DB->db;$self->{query}=CPAN::Audit::Query->new(db=>$self->{db});$self->{discover}=CPAN::Audit::Discover->new(db=>$self->{db});return$self}sub command {my$self=shift;my ($command,@args)=@_;my%dists;if (!$self->{no_corelist}&& ($command eq 'dependencies' || $command eq 'deps' || $command eq 'installed')){if (my$core=$Module::CoreList::version{$]}){while (my ($mod,$ver)=each %$core){my$dist=$self->{db}{module2dist}{$mod}or next;$dists{$dist}=$ver if version->parse($ver)> $dists{$dist}}}}if ($command eq 'module'){my ($module,$version_range)=@args;$self->fatal("Usage: module <module> [version-range]")unless$module;my$distname=$self->{db}->{module2dist}->{$module};if (!$distname){$self->message("__GREEN__Module '$module' is not in database");return 0}$dists{$distname}=$version_range || ''}elsif ($command eq 'release' || $command eq 'dist'){my ($distname,$version_range)=@args;$self->fatal("Usage: dist|release <module> [version-range]")unless$distname;if (!$self->{db}->{dists}->{$distname}){$self->message("__GREEN__Distribution '$distname' is not in database");return 0}$dists{$distname}=$version_range || ''}elsif ($command eq 'show'){my ($advisory_id)=@args;$self->fatal("Usage: show <advisory-id>")unless$advisory_id;my ($release)=$advisory_id =~ m/^CPANSA-(.*?)-(\d+)-(\d+)$/;$self->fatal("Invalid advisory id")unless$release;my$dist=$self->{db}->{dists}->{$release};$self->fatal("Unknown advisory id")unless$dist;my ($advisory)=grep {$_->{id}eq $advisory_id}@{$dist->{advisories}};$self->fatal("Unknown advisory id")unless$advisory;$self->print_advisory($advisory);return 0}elsif ($command eq 'dependencies' || $command eq 'deps'){my ($path)=@args;$path='.' unless defined$path;$self->fatal("Usage: deps <path>")unless -d $path;my@deps=$self->{discover}->discover($path);$self->message('Discovered %d dependencies',scalar(@deps));for my$dep (@deps){my$dist=$dep->{dist}|| $self->{db}->{module2dist}->{$dep->{module}};next unless$dist;$dists{$dist}=$dep->{version}}}elsif ($command eq 'installed'){$self->message_info('Collecting all installed modules. This can take a while...');my@deps=CPAN::Audit::Installed->new(db=>$self->{db},$self->{verbose}? (cb=>sub {my ($info)=@_;$self->message('%s: %s-%s',$info->{path},$info->{distname},$info->{version})}): ())->find(@ARGV);for my$dep (@deps){my$dist=$dep->{dist}|| $self->{db}->{module2dist}->{$dep->{module}};next unless$dist;$dists{$dep->{dist}}=$dep->{version}}}else {$self->fatal("Error: unknown command: $command. See -h")}my$total_advisories=0;if (%dists){my$query=$self->{query};for my$distname (sort keys%dists){my$version_range=$dists{$distname};my@advisories=$query->advisories_for($distname,$version_range);$version_range='Any' if$version_range eq '' || $version_range eq '0';if (@advisories){$self->message('__RED__%s (requires %s) has %d advisories__RESET__',$distname,$version_range,scalar(@advisories));for my$advisory (@advisories){$self->print_advisory($advisory)}}$total_advisories += @advisories}}if ($total_advisories){$self->message('__RED__Total advisories found: %d__RESET__',$total_advisories);return$total_advisories}else {$self->message_info('__GREEN__No advisories found__RESET__');return 0}}sub message_info {my$self=shift;return if$self->{quiet};$self->message(@_)}sub message {my$self=shift;$self->_print(*STDOUT,@_)}sub fatal {my$self=shift;my ($msg,@args)=@_;$self->_print(*STDERR,"Error: $msg",@args);exit 255}sub print_advisory {my$self=shift;my ($advisory)=@_;$self->message("  __BOLD__* $advisory->{id}");print "    $advisory->{description}\n";if ($advisory->{affected_versions}){print "    Affected range: $advisory->{affected_versions}\n"}if ($advisory->{fixed_versions}){print "    Fixed range: $advisory->{fixed_versions}\n"}if ($advisory->{cves}){print "\n    CVEs: ";print join ', ',@{$advisory->{cves}};print "\n"}if ($advisory->{references}){print "\n    References:\n";for my$reference (@{$advisory->{references}|| []}){print "    $reference\n"}}print "\n"}sub _print {my$self=shift;my ($fh,$format,@params)=@_;my$msg=@params ? (sprintf($format,@params)): ($format);if ($self->{no_color}){$msg =~ s{__BOLD__}{}g;$msg =~ s{__GREEN__}{}g;$msg =~ s{__RED__}{}g;$msg =~ s{__RESET__}{}g}else {$msg =~ s{__BOLD__}{\e[39;1m}g;$msg =~ s{__GREEN__}{\e[32m}g;$msg =~ s{__RED__}{\e[31m}g;$msg =~ s{__RESET__}{\e[0m}g;$msg .= "\e[0m"}print$fh "$msg\n"}1;
CPAN_AUDIT

$fatpacked{"CPAN/Audit/DB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_DB';
  package CPAN::Audit::DB;use strict;use warnings;sub db {{'dists'=>{'Apache-AuthCAS'=>{'advisories'=>[{'affected_versions'=>'<0.5','cves'=>['CVE-2007-6342' ],'description'=>'A tainted cookie could be sent by a malicious user and it would be used in an SQL query without protection against SQL injection.
  ','distribution'=>'Apache-AuthCAS','fixed_versions'=>'>=0.5','id'=>'CPANSA-Apache-AuthCAS-2007-01','references'=>['https://metacpan.org/changes/distribution/Apache-AuthCAS','https://cxsecurity.com/issue/WLB-2007120031' ],'reported'=>'2007-12-13','severity'=>'high' }],'main_module'=>'Apache::AuthCAS','versions'=>[{'date'=>'2004-09-15T19:17:43','version'=>'0.1' },{'date'=>'2004-09-15T20:11:40','version'=>'0.2' },{'date'=>'2004-10-05T22:51:50','version'=>'0.3' },{'date'=>'2004-10-13T00:45:52','version'=>'0.4' },{'date'=>'2008-03-23T23:03:16','version'=>'0.5' }]},'Apache-SessionX'=>{'advisories'=>[{'affected_versions'=>'<2.01','description'=>'Problem in session_id validation, which allows createtion of session with invalid ids.
  ','distribution'=>'Apache-SessionX','fixed_versions'=>'>=2.01','id'=>'CPANSA-Apache-SessionX-2005-01','references'=>['https://metacpan.org/changes/distribution/Apache-SessionX' ],'reported'=>'2005-11-15' }],'main_module'=>'Apache::SessionX','versions'=>[{'date'=>'2001-11-20T15:36:53','version'=>'2.00' },{'date'=>'2003-03-02T14:18:57','version'=>'2.00' },{'date'=>'2005-11-15T05:21:49','version'=>'2.01' }]},'App-Github-Email'=>{'advisories'=>[{'affected_versions'=>'<0.3.3','cves'=>['CVE-2015-7686' ],'description'=>'Insecure dependency on Email::Address.
  ','distribution'=>'App-Github-Email','fixed_versions'=>'>=0.3.3','id'=>'CPANSA-App-Github-Email-2018-01','references'=>['https://metacpan.org/changes/distribution/App-Github-Email','https://github.com/faraco/App-Github-Email/commit/b7f052280d1c8ae97bdefc106ca3cbba4aea7213' ],'reported'=>'2018-01-20' }],'main_module'=>'App::Github::Email','versions'=>[{'date'=>'2017-01-16T08:03:02','version'=>'0.0.1' },{'date'=>'2017-01-16T12:56:51','version'=>'0.0.2' },{'date'=>'2017-01-16T17:38:16','version'=>'0.0.3' },{'date'=>'2017-03-11T10:45:23','version'=>'0.0.4' },{'date'=>'2017-04-05T11:19:02','version'=>'0.0.5' },{'date'=>'2017-04-15T17:35:18','version'=>'0.0.6' },{'date'=>'2017-05-19T05:05:24','version'=>'0.0.7' },{'date'=>'2017-12-18T14:11:19','version'=>'0.1.0' },{'date'=>'2017-12-21T08:24:12','version'=>'0.1.1' },{'date'=>'2018-01-15T03:18:05','version'=>'0.2.0' },{'date'=>'2018-01-20T12:55:34','version'=>'0.2.1' },{'date'=>'2018-08-30T16:07:18','version'=>'0.3.1' },{'date'=>'2018-08-30T16:13:54','version'=>'0.3.2' },{'date'=>'2018-08-31T03:49:31','version'=>'0.3.3' }]},'Archive-Tar'=>{'advisories'=>[{'affected_versions'=>'<2.28','cves'=>['CVE-2018-12015' ],'description'=>'In Perl through 5.26.2, the Archive::Tar module allows remote attackers to bypass a directory-traversal protection mechanism, and overwrite arbitrary files, via an archive file containing a symlink and a regular file with the same name.
  ','distribution'=>'Archive-Tar','id'=>'CPANSA-Archive-Tar-2018-01','references'=>['https://security-tracker.debian.org/tracker/CVE-2018-12015','https://github.com/jib/archive-tar-new/commit/ae65651eab053fc6dc4590dbb863a268215c1fc5' ],'reported'=>'2018-06-12','severity'=>'medium' }],'main_module'=>'Archive::Tar','versions'=>[{'date'=>'1998-02-02T06:13:59','version'=>'0.071' },{'date'=>'1998-04-10T17:07:35','version'=>'0.072' },{'date'=>'1998-07-30T00:56:03','version'=>'0.08' },{'date'=>'1999-01-10T02:22:23','version'=>'0.20' },{'date'=>'1999-02-02T19:01:41','version'=>'0.21' },{'date'=>'2000-04-28T00:37:46','version'=>'0.22' },{'date'=>'2003-01-21T23:07:30','version'=>'0.23' },{'date'=>'2003-03-18T17:08:50','version'=>'0.99_01' },{'date'=>'2003-03-26T14:57:35','version'=>'0.99_02' },{'date'=>'2003-04-28T16:01:24','version'=>'0.99_03' },{'date'=>'2003-04-28T16:57:58','version'=>'0.99_04' },{'date'=>'2003-04-30T12:52:19','version'=>'0.99_05' },{'date'=>'2003-05-05T12:06:35','version'=>'0.99_06' },{'date'=>'2003-05-31T09:27:33','version'=>'1.00' },{'date'=>'2003-06-08T10:46:56','version'=>'1.01' },{'date'=>'2003-06-12T09:47:58','version'=>'1.02' },{'date'=>'2003-06-26T12:52:19','version'=>'1.03' },{'date'=>'2003-07-27T17:07:50','version'=>'1.04' },{'date'=>'2003-08-25T13:38:44','version'=>'1.05' },{'date'=>'2003-10-15T14:35:12','version'=>'1.06' },{'date'=>'2003-10-17T11:42:14','version'=>'1.07' },{'date'=>'2004-01-05T12:59:23','version'=>'1.08' },{'date'=>'2004-05-22T12:32:02','version'=>'1.09' },{'date'=>'2004-06-11T19:24:06','version'=>'1.10' },{'date'=>'2004-11-09T16:12:40','version'=>'1.20' },{'date'=>'2004-11-10T16:04:13','version'=>'1.21' },{'date'=>'2004-11-21T10:09:52','version'=>'1.22' },{'date'=>'2004-12-03T15:53:06','version'=>'1.23' },{'date'=>'2005-05-03T13:11:19','version'=>'1.24' },{'date'=>'2005-08-20T10:14:40','version'=>'1.25' },{'date'=>'2005-08-22T09:29:53','version'=>'1.26' },{'date'=>'2006-01-19T13:31:53','version'=>'1.28' },{'date'=>'2006-03-03T13:56:20','version'=>'1.29' },{'date'=>'2006-08-02T15:00:41','version'=>'1.30' },{'date'=>'2007-05-18T12:18:49','version'=>'1.31' },{'date'=>'2007-05-25T09:32:48','version'=>'1.32' },{'date'=>'2007-08-15T14:20:33','version'=>'1.34' },{'date'=>'2007-09-16T09:13:21','version'=>'1.36' },{'date'=>'2007-11-11T11:59:00','version'=>'1.37_01' },{'date'=>'2007-12-24T11:02:07','version'=>'1.38' },{'date'=>'2008-08-22T16:33:49','version'=>'1.39_01' },{'date'=>'2008-08-25T03:56:58','version'=>'1.39_02' },{'date'=>'2008-08-25T22:07:56','version'=>'1.39_03' },{'date'=>'2008-09-08T12:14:37','version'=>'1.39_04' },{'date'=>'2008-10-13T13:42:10','version'=>'1.40' },{'date'=>'2008-12-13T17:10:15','version'=>'1.42' },{'date'=>'2009-01-19T17:08:08','version'=>'1.44' },{'date'=>'2009-03-05T16:10:06','version'=>'1.46' },{'date'=>'2009-04-20T17:07:30','version'=>'1.48' },{'date'=>'2009-06-12T12:01:54','version'=>'1.50' },{'date'=>'2009-06-13T11:29:50','version'=>'1.52' },{'date'=>'2009-09-10T12:13:03','version'=>'1.54' },{'date'=>'2010-02-03T14:40:15','version'=>'1.56' },{'date'=>'2010-02-17T21:47:16','version'=>'1.58' },{'date'=>'2010-04-23T14:12:31','version'=>'1.60' },{'date'=>'2010-06-28T21:02:59','version'=>'1.62' },{'date'=>'2010-07-09T11:04:45','version'=>'1.64' },{'date'=>'2010-07-26T08:44:00','version'=>'1.66' },{'date'=>'2010-08-17T16:06:19','version'=>'1.68' },{'date'=>'2010-11-15T22:02:53','version'=>'1.70' },{'date'=>'2010-11-18T19:22:01','version'=>'1.72' },{'date'=>'2010-12-18T21:19:51','version'=>'1.74' },{'date'=>'2011-01-07T22:27:40','version'=>'1.76' },{'date'=>'2011-09-08T22:13:33','version'=>'1.78' },{'date'=>'2011-10-13T10:25:39','version'=>'1.80' },{'date'=>'2011-11-21T12:14:43','version'=>'1.82' },{'date'=>'2012-03-03T00:00:05','version'=>'1.84' },{'date'=>'2012-05-24T11:38:09','version'=>'1.86' },{'date'=>'2012-06-01T11:06:25','version'=>'1.88' },{'date'=>'2012-09-05T18:19:00','version'=>'1.90' },{'date'=>'2013-06-18T15:13:27','version'=>'1.92' },{'date'=>'2013-10-22T14:28:22','version'=>'0.93_01' },{'date'=>'2013-10-22T14:36:08','version'=>'1.93_02' },{'date'=>'2013-10-24T18:02:48','version'=>'1.94' },{'date'=>'2013-10-24T19:10:34','version'=>'1.96' },{'date'=>'2014-06-14T17:12:02','version'=>'1.98' },{'date'=>'2014-06-15T14:59:24','version'=>'2.00' },{'date'=>'2014-09-14T18:03:23','version'=>'2.02' },{'date'=>'2014-12-14T20:13:33','version'=>'2.04' },{'date'=>'2016-04-24T14:05:11','version'=>'2.06' },{'date'=>'2016-05-12T08:57:35','version'=>'2.08' },{'date'=>'2016-07-27T12:40:29','version'=>'2.10' },{'date'=>'2016-10-16T11:27:58','version'=>'2.12' },{'date'=>'2016-10-20T12:38:57','version'=>'2.14' },{'date'=>'2016-11-01T19:19:36','version'=>'2.16' },{'date'=>'2016-11-07T13:36:15','version'=>'2.18' },{'date'=>'2016-12-15T10:54:40','version'=>'2.20' },{'date'=>'2016-12-16T09:46:28','version'=>'2.22' },{'date'=>'2016-12-16T15:27:38','version'=>'2.24' },{'date'=>'2017-05-12T12:46:05','version'=>'2.26' },{'date'=>'2018-06-08T10:57:04','version'=>'2.28' },{'date'=>'2018-06-19T11:55:28','version'=>'2.30' },{'date'=>'2018-09-13T07:17:10','version'=>'2.32' }]},'Archive-Zip'=>{'advisories'=>[{'affected_versions'=>'<1.61','cves'=>['CVE-2018-10860' ],'description'=>'perl-archive-zip is vulnerable to a directory traversal in Archive::Zip. It was found that the Archive::Zip module did not properly sanitize paths while extracting zip files. An attacker able to provide a specially crafted archive for processing could use this flaw to write or overwrite arbitrary files in the context of the perl interpreter.
  ','distribution'=>'Archive-Zip','id'=>'CPANSA-Archive-Zip-2018-01','references'=>['https://security-tracker.debian.org/tracker/CVE-2018-10860','https://github.com/redhotpenguin/perl-Archive-Zip/pull/33' ],'reported'=>'2018-06-28','severity'=>'medium' }],'main_module'=>'Archive::Zip','versions'=>[{'date'=>'2000-03-22T00:10:21','version'=>'0.06' },{'date'=>'2000-03-29T17:03:46','version'=>'0.07' },{'date'=>'2000-06-16T16:48:41','version'=>'0.09' },{'date'=>'2000-08-08T20:56:31','version'=>'0.10' },{'date'=>'2001-01-17T08:06:58','version'=>'0.11' },{'date'=>'2002-04-22T15:32:49','version'=>'1.00' },{'date'=>'2002-05-11T02:45:20','version'=>'1.01' },{'date'=>'2002-08-24T00:19:19','version'=>'1.02' },{'date'=>'2002-09-03T04:40:33','version'=>'1.03' },{'date'=>'2002-09-11T15:17:37','version'=>'1.04' },{'date'=>'2002-09-11T19:35:26','version'=>'1.05' },{'date'=>'2003-07-17T18:18:14','version'=>'1.06' },{'date'=>'2003-10-20T13:59:00','version'=>'1.07' },{'date'=>'2003-10-21T17:04:03','version'=>'1.08' },{'date'=>'2003-11-27T18:02:03','version'=>'1.09' },{'date'=>'2004-03-25T14:39:05','version'=>'1.10' },{'date'=>'2004-07-05T23:25:19','version'=>'1_11' },{'date'=>'2004-07-08T17:31:27','version'=>'1.11' },{'date'=>'2004-07-08T19:14:46','version'=>'1.12' },{'date'=>'2004-07-27T22:50:39','version'=>'1.12_02' },{'date'=>'2004-07-29T15:15:49','version'=>'1.12_03' },{'date'=>'2004-08-23T15:39:23','version'=>'1.13' },{'date'=>'2004-10-21T15:28:12','version'=>'1.14' },{'date'=>'2005-03-10T04:34:04','version'=>'1.15_01' },{'date'=>'2005-03-12T15:29:48','version'=>'1.15_02' },{'date'=>'2005-06-22T18:29:34','version'=>'1.15' },{'date'=>'2005-07-04T17:55:17','version'=>'1.16' },{'date'=>'2006-04-30T03:53:15','version'=>'1.17_01' },{'date'=>'2006-05-07T02:49:30','version'=>'1.17_02' },{'date'=>'2006-09-15T15:56:10','version'=>'1.17_03' },{'date'=>'2006-10-24T15:06:32','version'=>'1.17_05' },{'date'=>'2006-10-25T12:24:52','version'=>'1.18' },{'date'=>'2007-06-05T01:50:42','version'=>'1.20' },{'date'=>'2007-11-01T02:59:20','version'=>'1.21' },{'date'=>'2007-11-02T01:52:47','version'=>'1.22' },{'date'=>'2007-11-07T13:04:41','version'=>'1.23' },{'date'=>'2008-08-23T23:35:50','version'=>'1.24' },{'date'=>'2008-10-10T05:28:17','version'=>'1.25' },{'date'=>'2008-10-12T14:13:05','version'=>'1.26' },{'date'=>'2008-12-16T13:23:21','version'=>'1.27_01' },{'date'=>'2009-06-16T10:09:03','version'=>'1.28' },{'date'=>'2009-06-29T13:27:17','version'=>'1.29' },{'date'=>'2009-06-30T14:13:29','version'=>'1.30' },{'date'=>'2010-03-05T05:11:20','version'=>'1.31_01' },{'date'=>'2011-03-08T15:52:02','version'=>'1.31_02' },{'date'=>'2011-08-23T03:42:14','version'=>'1.31_03' },{'date'=>'2012-01-23T06:28:16','version'=>'1.31_04' },{'date'=>'2013-11-09T00:05:06','version'=>'1.32' },{'date'=>'2013-11-10T03:50:45','version'=>'1.33' },{'date'=>'2013-12-02T22:16:54','version'=>'1.34' },{'date'=>'2013-12-30T19:16:52','version'=>'1.35' },{'date'=>'2013-12-30T22:12:14','version'=>'1.36' },{'date'=>'2014-01-13T18:32:19','version'=>'1.37' },{'date'=>'2014-09-02T23:23:11','version'=>'1.38' },{'date'=>'2014-10-22T04:17:15','version'=>'1.39' },{'date'=>'2015-01-05T05:58:46','version'=>'1.40' },{'date'=>'2015-01-10T02:47:42','version'=>'1.41' },{'date'=>'2015-01-12T00:46:36','version'=>'1.42' },{'date'=>'2015-01-15T06:37:32','version'=>'1.43' },{'date'=>'2015-01-24T06:12:21','version'=>'1.44' },{'date'=>'2015-01-27T07:51:17','version'=>'1.45' },{'date'=>'2015-03-25T05:19:23','version'=>'1.46' },{'date'=>'2015-06-17T18:26:02','version'=>'1.47' },{'date'=>'2015-06-18T21:13:37','version'=>'1.48' },{'date'=>'2015-07-31T19:01:40','version'=>'1.49' },{'date'=>'2015-08-26T00:11:35','version'=>'1.50' },{'date'=>'2015-09-22T06:03:54','version'=>'1.51' },{'date'=>'2015-09-23T17:43:44','version'=>'1.53' },{'date'=>'2015-12-04T19:36:41','version'=>'1.55' },{'date'=>'2015-12-17T18:29:06','version'=>'1.56' },{'date'=>'2016-04-01T18:06:36','version'=>'1.57' },{'date'=>'2016-08-02T17:50:20','version'=>'1.58' },{'date'=>'2016-08-11T20:09:16','version'=>'1.59' },{'date'=>'2017-12-19T18:44:16','version'=>'1.60' },{'date'=>'2018-08-19T03:35:10','version'=>'1.61' },{'date'=>'2018-08-20T03:29:01','version'=>'1.62' },{'date'=>'2018-08-22T15:42:15','version'=>'1.63' },{'date'=>'2018-09-12T15:50:29','version'=>'1.64' }]},'CGI'=>{'advisories'=>[{'affected_versions'=>'<3.63','description'=>'CR escaping for Set-Cookie and P3P headers, a potential for newline injection.
  ','distribution'=>'CGI','fixed_versions'=>'>=3.63','id'=>'CPANSA-CGI-2012-01','reported'=>'2012-11-12' },{'affected_versions'=>'<3.56','cves'=>['CVE-2011-2766' ],'description'=>'Usage of deprecated FCGI.pm API.
  ','distribution'=>'CGI','fixed_versions'=>'>=3.56','id'=>'CPANSA-CGI-2011-01','references'=>['https://rt.cpan.org/Public/Bug/Display.html?id=68380','http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-2766' ],'reported'=>'2011-11-08' },{'affected_versions'=>'<3.50','description'=>'Non-random MIME boundary.
  ','distribution'=>'CGI','fixed_versions'=>'>=3.50','id'=>'CPANSA-CGI-2010-02','reported'=>'2010-11-08' },{'affected_versions'=>'<3.49','description'=>'Newlines in headers.
  ','distribution'=>'CGI','fixed_versions'=>'>=3.49','id'=>'CPANSA-CGI-2010-01','reported'=>'2010-02-05' }],'main_module'=>'CGI','versions'=>[{'date'=>'1995-11-25T09:21:00','version'=>'2.10' },{'date'=>'1995-12-28T09:08:00','version'=>'2.13' },{'date'=>'1996-05-22T22:30:00','version'=>'2.20' },{'date'=>'1996-05-31T05:31:00','version'=>'2.21' },{'date'=>'1996-08-07T09:24:00','version'=>'2.22' },{'date'=>'1996-08-14T08:17:00','version'=>'2.23' },{'date'=>'1996-08-21T09:09:00','version'=>'2.24' },{'date'=>'1996-09-10T14:23:00','version'=>'2.25' },{'date'=>'1996-10-22T11:17:00','version'=>'2.26' },{'date'=>'1996-10-24T18:21:00','version'=>'2.27' },{'date'=>'1996-12-02T11:48:00','version'=>'2.28' },{'date'=>'1996-12-09T13:39:00','version'=>'2.29' },{'date'=>'1997-01-02T16:40:00','version'=>'2.30' },{'date'=>'1997-02-15T15:36:00','version'=>'2.31' },{'date'=>'1997-03-25T08:58:00','version'=>'2.32' },{'date'=>'1997-04-04T20:45:00','version'=>'2.33' },{'date'=>'1997-04-10T15:41:00','version'=>'2.34' },{'date'=>'1997-04-20T18:29:00','version'=>'2.35' },{'date'=>'1997-05-09T09:33:00','version'=>'2.36' },{'date'=>'1997-08-29T04:42:00','version'=>'2.37' },{'date'=>'1997-09-15T17:51:00','version'=>'2.37' },{'date'=>'1997-10-01T04:15:00','version'=>'2.37' },{'date'=>'1997-10-12T07:10:00','version'=>'2.37' },{'date'=>'1997-11-23T11:37:00','version'=>'2.37' },{'date'=>'1997-12-20T09:57:00','version'=>'2.37' },{'date'=>'1998-01-16T12:22:00','version'=>'2.37' },{'date'=>'1998-01-19T11:34:00','version'=>'2.37' },{'date'=>'1998-01-26T11:00:00','version'=>'2.37' },{'date'=>'1998-01-29T19:48:00','version'=>'2.37' },{'date'=>'1998-02-02T13:37:00','version'=>'2.37' },{'date'=>'1998-02-05T08:25:00','version'=>'2.37' },{'date'=>'1998-02-09T13:58:00','version'=>'2.37' },{'date'=>'1998-02-16T16:21:00','version'=>'2.37' },{'date'=>'1998-02-23T08:33:00','version'=>'2.37' },{'date'=>'1998-02-24T16:52:00','version'=>'2.37' },{'date'=>'1998-03-13T15:33:00','version'=>'2.37' },{'date'=>'1998-03-22T21:12:00','version'=>'2.38' },{'date'=>'1998-03-24T22:37:08','version'=>'2.39' },{'date'=>'1998-05-20T09:17:00','version'=>'2.40' },{'date'=>'1998-05-28T15:03:00','version'=>'2.41' },{'date'=>'1998-06-09T09:00:00','version'=>'2.42' },{'date'=>'1998-10-14T19:06:31','version'=>'2.43' },{'date'=>'1998-11-24T19:41:41','version'=>'2.44' },{'date'=>'1998-11-26T11:07:27','version'=>'2.45' },{'date'=>'1998-12-06T10:22:46','version'=>'2.46' },{'date'=>'1999-02-18T03:50:16','version'=>'2.47' },{'date'=>'1999-02-19T14:10:25','version'=>'2.48' },{'date'=>'1999-02-23T22:00:33','version'=>'2.49' },{'date'=>'1999-06-08T15:13:15','version'=>'2.52' },{'date'=>'1999-06-09T14:56:06','version'=>'2.53' },{'date'=>'1999-08-09T14:18:33','version'=>'2.54' },{'date'=>'1999-08-31T17:11:00','version'=>'2.55' },{'date'=>'1999-09-13T21:11:51','version'=>'2.56' },{'date'=>'2000-03-23T23:00:12','version'=>'2.58' },{'date'=>'2000-03-24T12:31:52','version'=>'2.59' },{'date'=>'2000-03-27T22:11:34','version'=>'2.60' },{'date'=>'2000-03-28T02:50:18','version'=>'2.61' },{'date'=>'2000-03-28T21:38:03','version'=>'2.62' },{'date'=>'2000-04-10T15:19:54','version'=>'2.63' },{'date'=>'2000-04-11T15:25:13','version'=>'2.64' },{'date'=>'2000-04-11T15:55:40','version'=>'2.65' },{'date'=>'2000-04-12T20:16:46','version'=>'2.66' },{'date'=>'2000-05-16T01:38:08','version'=>'2.67' },{'date'=>'2000-05-18T17:55:55','version'=>'2.68' },{'date'=>'2000-07-28T03:06:11','version'=>'2.69' },{'date'=>'2000-08-04T19:37:27','version'=>'2.70' },{'date'=>'2000-08-13T16:09:25','version'=>'2.71' },{'date'=>'2000-08-20T17:35:50','version'=>'2.72' },{'date'=>'2000-08-24T13:33:37','version'=>'3.' },{'date'=>'2000-09-13T02:55:51','version'=>'2.73' },{'date'=>'2000-09-13T16:35:14','version'=>'2.74' },{'date'=>'2001-02-02T15:43:07','version'=>'2.75' },{'date'=>'2001-02-02T15:50:53','version'=>'2.751' },{'date'=>'2001-02-04T23:49:27','version'=>'2.752' },{'date'=>'2001-03-12T17:00:13','version'=>'2.753' },{'date'=>'2001-06-15T15:33:28','version'=>'3.02' },{'date'=>'2001-06-29T14:47:39','version'=>'3.02_' },{'date'=>'2001-07-05T16:13:55','version'=>'3.03_01' },{'date'=>'2001-07-26T21:29:22','version'=>'2.76' },{'date'=>'2001-08-07T12:33:22','version'=>'2.77' },{'date'=>'2001-09-26T02:26:36','version'=>'2.78' },{'date'=>'2001-12-09T21:39:11','version'=>'2.79' },{'date'=>'2002-01-12T02:47:17','version'=>'2.80' },{'date'=>'2002-04-10T19:39:49','version'=>'2.81' },{'date'=>'2002-09-11T12:27:48','version'=>'2.84' },{'date'=>'2002-09-11T14:01:02','version'=>'2.85' },{'date'=>'2002-09-12T03:58:40','version'=>'2.86' },{'date'=>'2002-10-07T02:00:58','version'=>'2.87' },{'date'=>'2002-10-14T13:58:09','version'=>'2.88' },{'date'=>'2002-10-16T17:50:26','version'=>'2.89' },{'date'=>'2002-11-22T23:03:39','version'=>0 },{'date'=>'2003-02-10T20:11:57','version'=>'2.90' },{'date'=>'2003-02-11T14:15:15','version'=>'2.91' },{'date'=>'2003-04-28T00:44:10','version'=>'2.92' },{'date'=>'2003-04-28T13:37:43','version'=>'2.93' },{'date'=>'2003-06-09T12:15:29','version'=>'2.94' },{'date'=>'2003-06-13T02:35:42','version'=>'2.95' },{'date'=>'2003-06-16T18:42:38','version'=>'2.96' },{'date'=>'2003-06-17T23:32:52','version'=>'2.97' },{'date'=>'2003-07-16T17:06:29','version'=>'2.98' },{'date'=>'2003-08-01T14:43:54','version'=>'2.99' },{'date'=>'2003-08-18T17:51:48','version'=>'3.00' },{'date'=>'2003-12-10T17:05:47','version'=>'3.01' },{'date'=>'2004-01-13T16:34:47','version'=>'3.03' },{'date'=>'2004-01-19T12:44:30','version'=>'3.04' },{'date'=>'2004-04-12T20:39:57','version'=>'3.05' },{'date'=>'2005-03-09T21:06:46','version'=>'3.06' },{'date'=>'2005-03-14T16:34:03','version'=>'3.07' },{'date'=>'2005-04-20T15:31:11','version'=>'3.08' },{'date'=>'2005-05-05T20:16:55','version'=>'3.09' },{'date'=>'2005-05-13T21:48:46','version'=>'3.10' },{'date'=>'2005-08-03T21:17:14','version'=>'3.11' },{'date'=>'2005-12-04T16:46:53','version'=>'3.12' },{'date'=>'2005-12-05T13:54:26','version'=>'3.13' },{'date'=>'2005-12-06T22:14:19','version'=>'3.14' },{'date'=>'2005-12-07T20:16:49','version'=>'3.15' },{'date'=>'2006-02-08T18:50:56','version'=>'3.16' },{'date'=>'2006-02-24T19:04:58','version'=>'3.17' },{'date'=>'2006-04-17T13:56:06','version'=>'3.19' },{'date'=>'2006-04-23T14:27:55','version'=>'3.20' },{'date'=>'2006-08-21T19:12:36','version'=>'3.21' },{'date'=>'2006-08-23T15:24:41','version'=>'3.22' },{'date'=>'2006-08-24T11:53:26','version'=>'3.23' },{'date'=>'2006-09-28T17:09:45','version'=>'3.25' },{'date'=>'2007-02-27T15:42:54','version'=>'3.27' },{'date'=>'2007-03-29T15:38:01','version'=>'3.28' },{'date'=>'2007-04-16T17:00:18','version'=>'3.29' },{'date'=>'2007-11-30T19:06:19','version'=>'3.31' },{'date'=>'2007-12-27T18:41:32','version'=>'3.32' },{'date'=>'2008-01-03T15:03:17','version'=>'3.33' },{'date'=>'2008-03-18T16:04:41','version'=>'3.34' },{'date'=>'2008-03-27T14:26:48','version'=>'3.35' },{'date'=>'2008-04-23T13:09:44','version'=>'3.37' },{'date'=>'2008-06-25T14:58:32','version'=>'3.38' },{'date'=>'2008-07-29T15:01:52','version'=>'3.39' },{'date'=>'2008-08-06T18:21:51','version'=>'3.40' },{'date'=>'2008-08-26T13:56:27','version'=>'3.41' },{'date'=>'2008-09-08T14:15:41','version'=>'3.42' },{'date'=>'2009-04-06T18:35:19','version'=>'3.43' },{'date'=>'2009-07-30T16:34:17','version'=>'3.44' },{'date'=>'2009-08-14T13:37:12','version'=>'3.45' },{'date'=>'2009-09-09T15:39:42','version'=>'3.46' },{'date'=>'2009-09-09T20:03:01','version'=>'3.47' },{'date'=>'2009-09-25T15:07:03','version'=>'3.48' },{'date'=>'2010-02-05T16:24:53','version'=>'3.49' },{'date'=>'2010-11-08T21:53:26','version'=>'3.50' },{'date'=>'2011-01-05T18:28:41','version'=>'3.51' },{'date'=>'2011-01-25T04:30:05','version'=>'3.52' },{'date'=>'2011-04-25T23:01:21','version'=>'3.53' },{'date'=>'2011-04-28T14:36:41','version'=>'3.54' },{'date'=>'2011-06-03T15:39:16','version'=>'3.55' },{'date'=>'2011-11-09T02:00:20','version'=>'3.56' },{'date'=>'2011-11-09T15:59:18','version'=>'3.57' },{'date'=>'2011-11-12T03:36:07','version'=>'3.58' },{'date'=>'2011-12-30T13:35:35','version'=>'3.59' },{'date'=>'2012-08-16T03:21:13','version'=>'3.60' },{'date'=>'2012-11-03T02:10:42','version'=>'3.61' },{'date'=>'2012-11-10T01:40:50','version'=>'3.62' },{'date'=>'2012-11-14T23:45:29','version'=>'3.63' },{'date'=>'2013-11-24T01:22:00','version'=>'3.64' },{'date'=>'2014-02-12T03:13:58','version'=>'3.65' },{'date'=>'2014-05-15T12:59:58','version'=>'3.65_01' },{'date'=>'2014-05-16T11:43:33','version'=>'3.65_02' },{'date'=>'2014-05-20T12:31:46','version'=>'3.65_03' },{'date'=>'2014-05-22T19:58:14','version'=>'4.00' },{'date'=>'2014-05-27T13:13:51','version'=>'4.01' },{'date'=>'2014-06-09T13:55:49','version'=>'4.02' },{'date'=>'2014-07-02T14:53:06','version'=>'4.03' },{'date'=>'2014-07-28T18:30:34','version'=>'4.03_01' },{'date'=>'2014-07-30T14:26:40','version'=>'4.03_02' },{'date'=>'2014-08-13T11:40:14','version'=>'4.03_03' },{'date'=>'2014-09-04T14:42:14','version'=>'4.04' },{'date'=>'2014-09-20T16:08:55','version'=>'4.04_01' },{'date'=>'2014-09-28T19:57:05','version'=>'4.04_02' },{'date'=>'2014-09-29T09:50:07','version'=>'4.04_03' },{'date'=>'2014-10-06T12:01:14','version'=>'4.04_04' },{'date'=>'2014-10-06T12:24:10','version'=>'4.04_05' },{'date'=>'2014-10-08T07:42:49','version'=>'4.05' },{'date'=>'2014-10-10T11:35:49','version'=>'4.06' },{'date'=>'2014-10-12T16:29:35','version'=>'4.07' },{'date'=>'2014-10-18T11:00:38','version'=>'4.08' },{'date'=>'2014-10-21T07:33:36','version'=>'4.09' },{'date'=>'2014-11-25T21:06:50','version'=>'4.09_01' },{'date'=>'2014-11-27T12:53:51','version'=>'4.10' },{'date'=>'2014-11-30T12:12:26','version'=>'4.10_01' },{'date'=>'2014-12-03T07:25:15','version'=>'4.11' },{'date'=>'2014-12-18T08:35:52','version'=>'4.12' },{'date'=>'2014-12-18T09:21:52','version'=>'4.13' },{'date'=>'2015-02-12T14:19:13','version'=>'4.13_01' },{'date'=>'2015-02-13T08:01:29','version'=>'4.13_02' },{'date'=>'2015-03-01T13:28:25','version'=>'4.13_03' },{'date'=>'2015-03-08T16:09:21','version'=>'4.13_04' },{'date'=>'2015-03-25T17:55:15','version'=>'4.13_05' },{'date'=>'2015-04-01T06:51:57','version'=>'4.14' },{'date'=>'2015-04-17T14:27:39','version'=>'4.14_01' },{'date'=>'2015-04-20T07:15:45','version'=>'4.15' },{'date'=>'2015-05-29T14:48:42','version'=>'4.20' },{'date'=>'2015-06-22T07:50:02','version'=>'4.21' },{'date'=>'2015-10-16T09:46:31','version'=>'4.22' },{'date'=>'2015-12-20T18:33:35','version'=>'4.24' },{'date'=>'2015-12-21T09:29:19','version'=>'4.25' },{'date'=>'2016-02-04T16:37:12','version'=>'4.26' },{'date'=>'2016-03-02T08:03:46','version'=>'4.27' },{'date'=>'2016-03-14T07:21:48','version'=>'4.28' },{'date'=>'2016-05-22T12:23:19','version'=>'4.28_01' },{'date'=>'2016-05-22T12:54:23','version'=>'4.28_02' },{'date'=>'2016-05-23T08:25:25','version'=>'4.28_03' },{'date'=>'2016-06-09T12:01:20','version'=>'4.29' },{'date'=>'2016-06-09T12:11:54','version'=>'4.30' },{'date'=>'2016-06-14T07:14:00','version'=>'4.31' },{'date'=>'2016-07-19T07:05:46','version'=>'4.32' },{'date'=>'2016-09-16T09:47:49','version'=>'4.33' },{'date'=>'2016-10-13T11:58:55','version'=>'4.34' },{'date'=>'2016-10-13T13:56:21','version'=>'4.35' },{'date'=>'2017-03-29T08:56:26','version'=>'4.35_01' },{'date'=>'2017-04-06T14:42:12','version'=>'4.36' },{'date'=>'2017-11-01T10:17:40','version'=>'4.37' },{'date'=>'2017-12-01T08:41:02','version'=>'4.38' },{'date'=>'2018-08-13T15:57:52','version'=>'4.39' },{'date'=>'2018-08-15T08:39:39','version'=>'4.40' }]},'CGI-Application-Dispatch'=>{'advisories'=>[{'affected_versions'=>'<1.02','description'=>'Untainted module names.
  ','distribution'=>'CGI-Application-Dispatch','fixed_versions'=>'>=1.02','id'=>'CPANSA-CGI-Application-Dispatch-2005-001','references'=>['https://metacpan.org/changes/distribution/CGI-Application-Dispatch' ],'reported'=>'2005-01-20' }],'main_module'=>'CGI::Application::Dispatch','versions'=>[{'date'=>'2004-09-13T01:35:58','version'=>'0.01' },{'date'=>'2004-10-19T18:26:01','version'=>'0.02' },{'date'=>'2004-10-29T16:53:40','version'=>'0.03' },{'date'=>'2005-01-06T15:34:49','version'=>'1.00' },{'date'=>'2005-01-08T12:42:00','version'=>'1.01' },{'date'=>'2005-01-20T14:43:28','version'=>'1.02' },{'date'=>'2005-03-04T16:28:16','version'=>'1.03' },{'date'=>'2005-07-12T21:44:54','version'=>'1.04' },{'date'=>'2006-01-12T15:56:53','version'=>'2.00_02' },{'date'=>'2006-02-06T15:50:52','version'=>'2.00_03' },{'date'=>'2006-02-14T15:41:25','version'=>'2.00_04' },{'date'=>'2006-04-12T14:18:22','version'=>'2.00_05' },{'date'=>'2006-06-27T04:29:04','version'=>'2.00_06' },{'date'=>'2006-07-03T15:52:12','version'=>'2.00' },{'date'=>'2006-08-14T14:14:10','version'=>'2.01' },{'date'=>'2006-08-17T14:57:55','version'=>'2.02' },{'date'=>'2006-09-30T02:13:40','version'=>'2.03' },{'date'=>'2007-01-03T18:12:57','version'=>'2.10_01' },{'date'=>'2007-01-11T18:55:41','version'=>'2.10_02' },{'date'=>'2007-01-15T14:08:30','version'=>'2.10' },{'date'=>'2007-12-28T20:23:49','version'=>'2.11' },{'date'=>'2007-12-31T20:43:51','version'=>'2.12_01' },{'date'=>'2008-01-03T14:39:57','version'=>'2.12' },{'date'=>'2008-03-08T18:33:34','version'=>'2.13_01' },{'date'=>'2008-03-11T16:41:27','version'=>'2.13_02' },{'date'=>'2008-09-17T00:44:02','version'=>'2.13' },{'date'=>'2008-11-03T01:33:21','version'=>'2.14' },{'date'=>'2008-12-04T16:00:05','version'=>'2.15' },{'date'=>'2009-03-24T02:03:51','version'=>'2.16' },{'date'=>'2009-12-30T19:06:27','version'=>'2.17' },{'date'=>'2011-01-05T03:42:59','version'=>'2.18' },{'date'=>'2011-06-16T17:42:14','version'=>'3.00' },{'date'=>'2011-06-24T02:53:20','version'=>'3.01' },{'date'=>'2011-06-24T22:33:01','version'=>'3.02' },{'date'=>'2011-06-26T03:52:14','version'=>'3.03' },{'date'=>'2011-06-29T13:45:53','version'=>'3.04' },{'date'=>'2011-09-07T22:21:15','version'=>'3.05' },{'date'=>'2011-09-09T15:29:58','version'=>'3.06' },{'date'=>'2011-09-09T17:32:11','version'=>'3.07' },{'date'=>'2012-09-03T04:04:19','version'=>'3.10' },{'date'=>'2012-09-14T01:02:58','version'=>'3.11' },{'date'=>'2012-09-14T01:19:52','version'=>'3.12' }]},'CGI-Application-Plugin-AutoRunmode'=>{'advisories'=>[{'affected_versions'=>'<0.04','description'=>'Non-word characters are allowed in runmode name.
  ','distribution'=>'CGI-Application-Plugin-AutoRunmode','fixed_versions'=>'>=0.04','id'=>'CPANSA-CGI-Application-Plugin-AutoRunmode-2005-01','references'=>['https://metacpan.org/changes/distribution/CGI-Application-Plugin-AutoRunmode' ],'reported'=>'2005-03-04' }],'main_module'=>'CGI::Application::Plugin::AutoRunmode','versions'=>[{'date'=>'2005-03-04T06:59:51','version'=>'0.04' },{'date'=>'2005-03-10T07:22:55','version'=>'0.05' },{'date'=>'2005-06-15T10:20:17','version'=>'0.06' },{'date'=>'2005-06-18T02:09:08','version'=>'0.07' },{'date'=>'2005-07-17T00:49:10','version'=>'0.08' },{'date'=>'2005-09-22T12:31:22','version'=>'0.09' },{'date'=>'2005-10-16T00:17:47','version'=>'0.10' },{'date'=>'2005-10-18T13:23:50','version'=>'0.11' },{'date'=>'2005-11-03T01:10:37','version'=>'0.12' },{'date'=>'2006-04-08T07:18:44','version'=>'0.13' },{'date'=>'2006-05-21T05:04:48','version'=>'0.14' },{'date'=>'2006-12-17T07:46:24','version'=>'0.15' },{'date'=>'2009-02-14T09:16:39','version'=>'0.16' },{'date'=>'2010-05-21T04:24:45','version'=>'0.17' },{'date'=>'2011-02-18T09:23:15','version'=>'0.18' }]},'CGI-Application-Plugin-RunmodeDeclare'=>{'advisories'=>[{'affected_versions'=>'<0.03','description'=>'Wrong order of arguments.
  ','distribution'=>'CGI-Application-Plugin-RunmodeDeclare','fixed_versions'=>'>=0.03','id'=>'CPANSA-CGI-Application-Plugin-RunmodeDeclare-2008-01','references'=>['https://metacpan.org/changes/distribution/CGI-Application-Plugin-RunmodeDeclare' ],'reported'=>'2008-10-20' }],'main_module'=>'CGI::Application::Plugin::RunmodeDeclare','versions'=>[{'date'=>'2008-09-26T19:59:14','version'=>'0.01' },{'date'=>'2008-09-26T21:37:11','version'=>'0.02' },{'date'=>'2008-10-19T23:22:06','version'=>'0.03' },{'date'=>'2008-10-23T14:18:23','version'=>'0.03_01' },{'date'=>'2008-10-24T13:32:43','version'=>'0.03_02' },{'date'=>'2008-10-24T16:20:27','version'=>'0.03_03' },{'date'=>'2008-10-25T10:54:25','version'=>'0.04' },{'date'=>'2008-10-25T11:46:28','version'=>'0.05' },{'date'=>'2008-10-25T16:39:34','version'=>'0.06' },{'date'=>'2009-01-10T02:32:39','version'=>'0.07' },{'date'=>'2009-05-17T22:29:18','version'=>'0.08' },{'date'=>'2010-01-07T13:24:09','version'=>'0.09' },{'date'=>'2012-02-10T00:53:54','version'=>'0.10' }]},'CGI-Auth-Basic'=>{'advisories'=>[{'affected_versions'=>'<1.11','description'=>'TBD
  ','distribution'=>'CGI-Auth-Basic','fixed_versions'=>'>=1.11','id'=>'CPANSA-CGI-Auth-Basic-2007-01','references'=>['https://metacpan.org/changes/distribution/CGI-Auth-Basic' ],'reported'=>'2007-12-30' }],'main_module'=>'CGI::Auth::Basic','versions'=>[{'date'=>'2004-02-21T14:58:09','version'=>'1.0' },{'date'=>'2004-08-31T13:29:28','version'=>'1.01' },{'date'=>'2004-11-07T03:34:32','version'=>'1.02' },{'date'=>'2006-06-18T01:12:15','version'=>'1.10' },{'date'=>'2007-12-30T20:53:33','version'=>'1.11' },{'date'=>'2009-04-18T04:22:51','version'=>'1.20' },{'date'=>'2009-04-23T17:00:50','version'=>'1.21' },{'date'=>'2009-04-24T15:07:48','version'=>'1.21' },{'date'=>'2012-08-27T01:50:53','version'=>'1.22' },{'date'=>'2015-01-21T00:26:01','version'=>'1.23' },{'date'=>'2018-12-23T21:03:03','version'=>'1.24' }]},'CGI-Simple'=>{'advisories'=>[{'affected_versions'=>'<1.113','cves'=>['CVE-2010-4410' ],'description'=>'Newlines in headers, which could lead to header injection attacks.
  ','distribution'=>'CGI-Simple','fixed_versions'=>'>=1.113','id'=>'CPANSA-CGI-Simple-2010-02','references'=>['https://metacpan.org/changes/distribution/CGI-Simple' ],'reported'=>'2010-12-27' },{'affected_versions'=>'<1.113','description'=>'Non-random multipart boundary.
  ','distribution'=>'CGI-Simple','fixed_versions'=>'>=1.113','id'=>'CPANSA-CGI-Simple-2010-01','references'=>['https://metacpan.org/changes/distribution/CGI-Simple' ],'reported'=>'2010-12-27' }],'main_module'=>'CGI::Simple','versions'=>[{'date'=>'2007-01-09T22:31:27','version'=>'0.078' },{'date'=>'2007-02-23T16:22:19','version'=>'0.079' },{'date'=>'2007-03-30T20:15:35','version'=>'0.080' },{'date'=>'2007-05-20T19:19:40','version'=>'0.081' },{'date'=>'2007-05-22T18:43:01','version'=>'0.082' },{'date'=>'2007-05-22T18:54:06','version'=>'0.83' },{'date'=>'2007-05-24T03:15:01','version'=>'1.0' },{'date'=>'2007-07-13T18:58:16','version'=>'1.1' },{'date'=>'2007-07-31T01:57:01','version'=>'1.1.1' },{'date'=>'2007-07-31T02:04:25','version'=>'1.1.2' },{'date'=>'2007-07-31T02:10:47','version'=>'1.103' },{'date'=>'2008-05-13T15:46:18','version'=>'1.104' },{'date'=>'2008-05-16T14:37:31','version'=>'1.105' },{'date'=>'2008-09-14T13:29:51','version'=>'1.106' },{'date'=>'2009-03-07T21:24:59','version'=>'1.107' },{'date'=>'2009-03-13T14:06:24','version'=>'1.108' },{'date'=>'2009-04-16T17:54:13','version'=>'1.109' },{'date'=>'2009-05-24T21:25:22','version'=>'1.110' },{'date'=>'2009-05-28T18:02:08','version'=>'1.111' },{'date'=>'2009-05-31T10:43:56','version'=>'1.112' },{'date'=>'2010-12-27T13:11:56','version'=>'1.113' },{'date'=>'2014-10-19T12:53:24','version'=>'1.115' },{'date'=>'2018-03-01T15:09:42','version'=>'1.13' },{'date'=>'2018-03-03T10:42:06','version'=>'1.14' },{'date'=>'2018-03-04T03:42:20','version'=>'1.15' },{'date'=>'2018-07-25T15:17:39','version'=>'1.16' },{'date'=>'2018-10-02T09:48:08','version'=>'1.17' },{'date'=>'2018-10-03T14:21:12','version'=>'1.18' },{'date'=>'2018-10-04T12:05:58','version'=>'1.19' },{'date'=>'2018-10-05T11:30:05','version'=>'1.20' },{'date'=>'2018-10-06T07:21:31','version'=>'1.21' }]},'CGI-apacheSSI'=>{'advisories'=>[{'affected_versions'=>'<0.95','description'=>'Security and parsing problems with "include" calls.
  ','distribution'=>'CGI-apacheSSI','fixed_versions'=>'>=0.95','id'=>'CPANSA-CGI-apacheSSI-2016-01','references'=>['https://metacpan.org/changes/distribution/CGI-apacheSSI' ],'reported'=>'2016-01-31' }],'main_module'=>'CGI::apacheSSI','versions'=>[{'date'=>'2014-08-20T22:55:20','version'=>'0.93' },{'date'=>'2016-01-30T12:57:47','version'=>'0.94' },{'date'=>'2016-01-31T22:48:55','version'=>'0.95' },{'date'=>'2016-02-01T00:36:49','version'=>'0.96' }]},'CPAN'=>{'advisories'=>[{'affected_versions'=>'<1.93','description'=>'Archive::Tar preserves permissions in the tarball; extracted file permissions will be set from users umask instead.
  ','distribution'=>'CPAN','fixed_versions'=>'>=1.93','id'=>'CPANSA-CPAN-2009-01','references'=>['https://github.com/andk/cpanpm/commit/079fa2e7ee77d626eab8bb06d0465c6a05f6c8b6' ],'reported'=>'2009-09-23' }],'main_module'=>'CPAN','versions'=>[{'date'=>'1996-09-10T17:13:59','version'=>'0.17' },{'date'=>'1996-09-10T20:51:00','version'=>'0.20' },{'date'=>'1996-09-12T05:53:35','version'=>'0.26' },{'date'=>'1996-09-12T14:01:39','version'=>'0.27' },{'date'=>'1996-09-16T20:18:59','version'=>'0.28' },{'date'=>'1996-09-17T17:14:51','version'=>'0.29' },{'date'=>'1996-09-19T05:24:17','version'=>'0.30' },{'date'=>'1996-09-20T10:40:01','version'=>'0.31' },{'date'=>'1996-09-22T19:30:33','version'=>'0.35' },{'date'=>'1996-09-23T12:55:23','version'=>'0.36' },{'date'=>'1996-09-23T14:05:44','version'=>'0.37' },{'date'=>'1996-09-27T12:52:07','version'=>'0.39' },{'date'=>'1996-09-28T20:51:31','version'=>'0.40' },{'date'=>'1996-10-01T21:14:27','version'=>'0.41' },{'date'=>'1996-11-17T07:56:02','version'=>'0.42' },{'date'=>'1996-11-17T14:51:59','version'=>'0.43' },{'date'=>'1996-11-30T17:04:28','version'=>'0.44' },{'date'=>'1996-12-01T12:19:19','version'=>'0.45' },{'date'=>'1996-12-01T18:24:17','version'=>'0.46' },{'date'=>'1996-12-10T00:58:25','version'=>'1.00' },{'date'=>'1996-12-10T10:17:15','version'=>'1.01' },{'date'=>'1996-12-11T01:31:55','version'=>'1.02' },{'date'=>'1996-12-21T03:10:23','version'=>'1.03' },{'date'=>'1996-12-21T20:08:49','version'=>'1.04' },{'date'=>'1996-12-22T13:04:58','version'=>'1.05' },{'date'=>'1996-12-22T14:16:08','version'=>'1.06' },{'date'=>'1996-12-23T04:05:01','version'=>'1.07' },{'date'=>'1996-12-23T13:18:01','version'=>'1.08' },{'date'=>'1996-12-24T00:46:19','version'=>'1.09' },{'date'=>'1997-01-17T02:29:49','version'=>'1.09_01' },{'date'=>'1997-01-21T01:06:40','version'=>'1.10' },{'date'=>'1997-01-22T18:50:00','version'=>'1.11' },{'date'=>'1997-01-23T00:07:58','version'=>'1.12' },{'date'=>'1997-01-24T01:07:44','version'=>'1.14' },{'date'=>'1997-01-24T12:32:12','version'=>'1.15' },{'date'=>'1997-02-02T13:51:48','version'=>'1.16_01' },{'date'=>'1997-02-02T21:05:12','version'=>'1.17' },{'date'=>'1997-02-03T00:38:36','version'=>'1.18' },{'date'=>'1997-02-03T09:13:48','version'=>'1.19' },{'date'=>'1997-02-05T09:38:00','version'=>'1.20' },{'date'=>'1997-02-11T06:32:42','version'=>'1.21' },{'date'=>'1997-03-13T23:14:59','version'=>'1.22_01' },{'date'=>'1997-03-31T12:03:55','version'=>'1.23' },{'date'=>'1997-03-31T22:47:11','version'=>'1.24' },{'date'=>'1997-06-30T18:13:23','version'=>'1.25' },{'date'=>'1997-07-28T13:58:09','version'=>'1.27' },{'date'=>'1997-08-04T06:09:33','version'=>'1.28' },{'date'=>'1997-08-11T23:33:58','version'=>'1.29' },{'date'=>'1997-08-29T14:34:37','version'=>'1.30' },{'date'=>'1997-09-21T08:53:03','version'=>'1.31' },{'date'=>'1997-09-23T18:45:50','version'=>'1.3101' },{'date'=>'1998-01-02T18:22:35','version'=>'1.32' },{'date'=>'1998-01-10T18:24:23','version'=>'1.33' },{'date'=>'1998-02-03T18:06:41','version'=>'1.35' },{'date'=>'1998-02-08T08:55:55','version'=>'1.36' },{'date'=>'1998-06-12T06:51:25','version'=>'1.37' },{'date'=>'1998-06-14T20:18:08','version'=>'1.38' },{'date'=>'1998-07-24T20:13:41','version'=>'1.40' },{'date'=>'1998-12-01T02:20:32','version'=>'1.41' },{'date'=>'1998-12-01T07:58:35','version'=>'1.42' },{'date'=>'1998-12-01T22:16:27','version'=>'1.43' },{'date'=>'1998-12-03T17:07:54','version'=>'1.43' },{'date'=>'1999-01-09T18:38:33','version'=>'1.44' },{'date'=>'1999-01-10T19:38:27','version'=>'1.44_51' },{'date'=>'1999-01-13T12:15:42','version'=>'1.44_52' },{'date'=>'1999-01-15T09:26:40','version'=>'1.44_53' },{'date'=>'1999-01-15T09:27:45','version'=>'1.44_54' },{'date'=>'1999-01-23T14:56:16','version'=>'1.45' },{'date'=>'1999-01-25T01:43:42','version'=>'1.46' },{'date'=>'1999-01-25T13:11:23','version'=>'1.47' },{'date'=>'1999-03-06T19:34:54','version'=>'1.48' },{'date'=>'1999-05-22T16:45:00','version'=>'1.49' },{'date'=>'1999-05-23T14:32:20','version'=>'1.50' },{'date'=>'1999-10-23T03:06:39','version'=>'1.50_01' },{'date'=>'1999-12-29T22:30:22','version'=>'1.51' },{'date'=>'2000-01-08T15:32:55','version'=>'1.52' },{'date'=>'2000-03-23T23:39:41','version'=>'1.53' },{'date'=>'2000-03-25T22:51:15','version'=>'1.54' },{'date'=>'2000-07-30T11:15:04','version'=>'1.55' },{'date'=>'2000-08-01T20:47:09','version'=>'1.56' },{'date'=>'2000-08-16T12:54:07','version'=>'1.57' },{'date'=>'2000-08-21T19:44:18','version'=>'1.57_51' },{'date'=>'2000-08-27T22:09:36','version'=>'1.57_53' },{'date'=>'2000-08-30T16:54:50','version'=>'1.57_54' },{'date'=>'2000-08-31T08:11:01','version'=>'1.57_55' },{'date'=>'2000-08-31T22:16:21','version'=>'1.57_56' },{'date'=>'2000-09-01T12:18:43','version'=>'1.57_57' },{'date'=>'2000-09-03T22:19:20','version'=>'1.57_58' },{'date'=>'2000-09-05T09:44:05','version'=>'1.57_59' },{'date'=>'2000-09-05T19:55:34','version'=>'1.57_60' },{'date'=>'2000-09-06T10:54:07','version'=>'1.57_61' },{'date'=>'2000-09-08T02:19:06','version'=>'1.57_62' },{'date'=>'2000-09-10T08:54:37','version'=>'1.57_65' },{'date'=>'2000-09-12T08:46:40','version'=>'1.57_66' },{'date'=>'2000-09-17T10:24:31','version'=>'1.57_67' },{'date'=>'2000-10-08T14:25:04','version'=>'1.57_68' },{'date'=>'2000-10-18T14:53:45','version'=>'1.58' },{'date'=>'2000-10-21T14:21:06','version'=>'1.58_51' },{'date'=>'2000-10-25T07:05:38','version'=>'1.58_52' },{'date'=>'2000-10-26T11:03:29','version'=>'1.58_53' },{'date'=>'2000-10-26T15:34:21','version'=>'1.58_54' },{'date'=>'2000-10-27T07:59:03','version'=>'1.58_55' },{'date'=>'2000-11-04T09:36:53','version'=>'1.58_56' },{'date'=>'2000-11-06T19:30:27','version'=>'1.58_57' },{'date'=>'2000-11-08T08:10:51','version'=>'1.58_90' },{'date'=>'2000-11-13T10:26:38','version'=>'1.58_91' },{'date'=>'2000-11-14T18:24:18','version'=>'1.58_92' },{'date'=>'2000-11-15T07:19:56','version'=>'1.58_93' },{'date'=>'2000-12-01T06:05:58','version'=>'1.59' },{'date'=>'2000-12-01T08:19:58','version'=>'1.59_51' },{'date'=>'2000-12-26T13:54:06','version'=>'1.59_52' },{'date'=>'2001-01-02T16:37:24','version'=>'1.59_53' },{'date'=>'2001-02-09T21:44:55','version'=>'1.59_54' },{'date'=>'2002-04-19T13:29:54','version'=>'1.60' },{'date'=>'2002-04-20T02:18:41','version'=>'1.60' },{'date'=>'2002-04-21T11:31:25','version'=>'1.60' },{'date'=>'2002-05-07T10:38:54','version'=>'1.61' },{'date'=>'2002-07-28T10:51:47','version'=>'1.62' },{'date'=>'2002-08-30T08:58:10','version'=>'1.63' },{'date'=>'2003-02-06T10:04:06','version'=>'1.64' },{'date'=>'2003-02-08T17:10:13','version'=>'1.65' },{'date'=>'2003-03-04T19:38:21','version'=>'1.70' },{'date'=>'2003-04-11T04:33:18','version'=>'1.70_52' },{'date'=>'2003-04-13T12:43:40','version'=>'1.70_53' },{'date'=>'2003-05-15T21:04:52','version'=>'1.70_54' },{'date'=>'2003-07-04T09:48:08','version'=>'1.71' },{'date'=>'2003-07-27T20:35:05','version'=>'1.72' },{'date'=>'2003-07-28T08:21:47','version'=>'1.73' },{'date'=>'2003-07-28T22:58:08','version'=>'1.74' },{'date'=>'2003-07-29T15:14:13','version'=>'1.75' },{'date'=>'2003-07-31T15:14:02','version'=>'1.76' },{'date'=>'2003-09-21T21:25:41','version'=>'1.76_01' },{'date'=>'2005-09-19T06:37:38','version'=>'1.76_51' },{'date'=>'2005-09-22T07:02:02','version'=>'1.76_52' },{'date'=>'2005-09-22T07:09:48','version'=>'1.76_53' },{'date'=>'2005-10-01T08:23:38','version'=>'1.76_54' },{'date'=>'2005-10-19T06:10:58','version'=>'1.76_55' },{'date'=>'2005-10-21T04:59:36','version'=>'1.76_56' },{'date'=>'2005-10-27T07:08:29','version'=>'1.76_57' },{'date'=>'2005-11-02T04:03:28','version'=>'1.76_58' },{'date'=>'2005-11-03T06:37:52','version'=>'1.76_59' },{'date'=>'2005-11-03T07:38:40','version'=>'1.76_60' },{'date'=>'2005-11-06T10:36:53','version'=>'1.76_61' },{'date'=>'2005-11-07T04:22:19','version'=>'1.76_62' },{'date'=>'2005-11-07T04:47:05','version'=>'1.76_63' },{'date'=>'2005-11-07T21:58:06','version'=>'1.76_64' },{'date'=>'2005-11-07T22:18:44','version'=>'1.76_65' },{'date'=>'2005-12-03T10:12:08','version'=>'1.80' },{'date'=>'2005-12-18T11:29:26','version'=>'1.80_51' },{'date'=>'2005-12-21T12:13:15','version'=>'1.80_53' },{'date'=>'2005-12-22T08:42:59','version'=>'1.80_54' },{'date'=>'2005-12-24T07:25:34','version'=>'1.80_55' },{'date'=>'2005-12-24T09:59:47','version'=>'1.80_56' },{'date'=>'2005-12-31T11:58:10','version'=>'1.80_57' },{'date'=>'2006-01-01T09:01:43','version'=>'1.80_58' },{'date'=>'2006-01-02T23:15:15','version'=>'1.81' },{'date'=>'2006-01-04T07:47:25','version'=>'1.82' },{'date'=>'2006-01-05T08:03:36','version'=>'1.83' },{'date'=>'2006-01-08T13:35:16','version'=>'1.83_51' },{'date'=>'2006-01-10T05:00:26','version'=>'1.83_52' },{'date'=>'2006-01-12T07:54:36','version'=>'1.83_53' },{'date'=>'2006-01-13T08:20:42','version'=>'1.83_54' },{'date'=>'2006-01-14T11:34:47','version'=>'1.83_55' },{'date'=>'2006-01-18T06:03:44','version'=>'1.83_56' },{'date'=>'2006-01-19T08:00:02','version'=>'1.83_57' },{'date'=>'2006-01-22T12:05:01','version'=>'1.83_58' },{'date'=>'2006-01-25T13:10:20','version'=>'1.83_59' },{'date'=>'2006-01-30T10:35:47','version'=>'1.83_60' },{'date'=>'2006-01-30T23:18:09','version'=>'1.83_61' },{'date'=>'2006-01-31T10:28:57','version'=>'1.83_62' },{'date'=>'2006-02-01T07:49:36','version'=>'1.83_63' },{'date'=>'2006-02-02T09:17:39','version'=>'1.83_64' },{'date'=>'2006-02-04T11:20:05','version'=>'1.83_65' },{'date'=>'2006-02-04T17:05:00','version'=>'1.83_66' },{'date'=>'2006-02-06T00:46:27','version'=>'1.83_67' },{'date'=>'2006-02-08T07:43:36','version'=>'1.83_68' },{'date'=>'2006-02-14T08:17:55','version'=>'1.83_69' },{'date'=>'2006-02-15T07:01:02','version'=>'1.84' },{'date'=>'2006-02-19T17:05:36','version'=>'1.85' },{'date'=>'2006-02-20T08:36:51','version'=>'1.86' },{'date'=>'2006-02-21T06:05:05','version'=>'1.86_51' },{'date'=>'2006-02-22T22:29:54','version'=>'1.86_52' },{'date'=>'2006-02-24T08:24:09','version'=>'1.86_53' },{'date'=>'2006-02-27T07:01:10','version'=>'1.87' },{'date'=>'2006-03-06T08:02:28','version'=>'1.87_51' },{'date'=>'2006-07-21T22:33:11','version'=>'1.87_52' },{'date'=>'2006-07-22T18:55:13','version'=>'1.87_53' },{'date'=>'2006-07-23T21:37:11','version'=>'1.87_54' },{'date'=>'2006-07-29T19:36:50','version'=>'1.87_55' },{'date'=>'2006-08-24T05:57:41','version'=>'1.87_56' },{'date'=>'2006-08-26T17:05:56','version'=>'1.87_57' },{'date'=>'2006-08-31T06:50:49','version'=>'1.87_58' },{'date'=>'2006-09-03T21:05:29','version'=>'1.87_59' },{'date'=>'2006-09-10T11:57:33','version'=>'1.87_61' },{'date'=>'2006-09-11T21:24:18','version'=>'1.87_62' },{'date'=>'2006-09-13T05:44:15','version'=>'1.87_63' },{'date'=>'2006-09-16T11:02:25','version'=>'1.87_64' },{'date'=>'2006-09-19T03:44:51','version'=>'1.87_65' },{'date'=>'2006-09-21T20:30:41','version'=>'1.88' },{'date'=>'2006-09-22T20:40:40','version'=>'1.8801' },{'date'=>'2006-09-30T10:41:20','version'=>'1.88_51' },{'date'=>'2006-10-03T09:51:49','version'=>'1.88_52' },{'date'=>'2006-10-09T19:31:56','version'=>'1.88_53' },{'date'=>'2006-10-14T09:37:15','version'=>'1.88_54' },{'date'=>'2006-10-16T06:59:27','version'=>'1.88_55' },{'date'=>'2006-10-22T10:34:16','version'=>'1.88_56' },{'date'=>'2006-10-23T07:17:30','version'=>'1.8802' },{'date'=>'2006-10-24T07:18:16','version'=>'1.88_57' },{'date'=>'2006-10-28T15:00:07','version'=>'1.88_58' },{'date'=>'2006-11-05T21:24:52','version'=>'1.88_59' },{'date'=>'2006-11-10T08:39:55','version'=>'1.88_61' },{'date'=>'2006-11-13T07:44:27','version'=>'1.88_62' },{'date'=>'2006-11-29T08:11:50','version'=>'1.88_63' },{'date'=>'2006-12-04T07:53:37','version'=>'1.88_64' },{'date'=>'2006-12-11T21:36:04','version'=>'1.88_65' },{'date'=>'2006-12-19T08:21:17','version'=>'1.88_66' },{'date'=>'2006-12-31T17:18:53','version'=>'1.88_67' },{'date'=>'2007-01-07T21:22:12','version'=>'1.88_68' },{'date'=>'2007-01-08T03:42:56','version'=>'1.88_69' },{'date'=>'2007-01-27T16:57:49','version'=>'1.88_71' },{'date'=>'2007-01-31T07:11:33','version'=>'1.88_72' },{'date'=>'2007-02-13T05:24:13','version'=>'1.88_73' },{'date'=>'2007-02-15T07:12:17','version'=>'1.88_74' },{'date'=>'2007-02-18T16:52:49','version'=>'1.88_75' },{'date'=>'2007-02-19T06:20:20','version'=>'1.88_76' },{'date'=>'2007-02-19T21:26:47','version'=>'1.88_77' },{'date'=>'2007-03-05T23:26:57','version'=>'1.88_78' },{'date'=>'2007-03-16T01:54:55','version'=>'1.88_79' },{'date'=>'2007-04-07T07:41:18','version'=>'1.90' },{'date'=>'2007-04-19T07:03:03','version'=>'1.91' },{'date'=>'2007-04-23T00:09:11','version'=>'1.9101' },{'date'=>'2007-05-08T20:35:04','version'=>'1.9102' },{'date'=>'2007-07-07T16:15:40','version'=>'1.91_51' },{'date'=>'2007-07-14T18:45:58','version'=>'1.91_52' },{'date'=>'2007-08-09T06:49:38','version'=>'1.91_53' },{'date'=>'2007-09-14T21:18:33','version'=>'1.91_54' },{'date'=>'2007-09-15T07:14:26','version'=>'1.91_55' },{'date'=>'2007-09-23T11:15:08','version'=>'1.92' },{'date'=>'2007-09-27T07:11:10','version'=>'1.9201' },{'date'=>'2007-09-28T06:58:04','version'=>'1.9202' },{'date'=>'2007-09-28T07:13:26','version'=>'1.9203' },{'date'=>'2007-11-04T23:04:18','version'=>'1.92_51' },{'date'=>'2007-11-05T23:30:06','version'=>'1.9204' },{'date'=>'2007-11-11T11:27:20','version'=>'1.92_52' },{'date'=>'2007-11-11T18:49:37','version'=>'1.9205' },{'date'=>'2007-12-09T23:27:18','version'=>'1.92_53' },{'date'=>'2007-12-27T04:57:34','version'=>'1.92_54' },{'date'=>'2007-12-30T15:24:13','version'=>'1.92_55' },{'date'=>'2008-02-04T21:56:28','version'=>'1.92_56' },{'date'=>'2008-02-27T05:13:49','version'=>'1.92_57' },{'date'=>'2008-03-12T07:56:18','version'=>'1.92_58' },{'date'=>'2008-03-16T18:57:04','version'=>'1.92_59' },{'date'=>'2008-03-26T07:53:08','version'=>'1.92_60' },{'date'=>'2008-04-25T04:47:52','version'=>'1.92_61' },{'date'=>'2008-05-23T04:07:04','version'=>'1.92_62' },{'date'=>'2008-06-19T06:42:18','version'=>'1.92_63' },{'date'=>'2008-09-03T05:27:35','version'=>'1.92_64' },{'date'=>'2008-09-14T09:54:03','version'=>'1.92_65' },{'date'=>'2008-09-29T23:15:10','version'=>'1.92_66' },{'date'=>'2008-10-12T16:07:51','version'=>'1.93' },{'date'=>'2008-10-13T19:37:43','version'=>'1.9301' },{'date'=>'2009-01-11T22:07:01','version'=>'1.93_02' },{'date'=>'2009-02-01T12:38:23','version'=>'1.93_03' },{'date'=>'2009-02-01T21:06:21','version'=>'1.93_51' },{'date'=>'2009-02-28T15:58:39','version'=>'1.9304' },{'date'=>'2009-04-13T19:24:43','version'=>'1.93_52' },{'date'=>'2009-05-04T06:11:28','version'=>'1.93_53' },{'date'=>'2009-05-07T20:13:16','version'=>'1.93_54' },{'date'=>'2009-05-24T05:37:28','version'=>'1.94' },{'date'=>'2009-06-14T19:53:52','version'=>'1.94_01' },{'date'=>'2009-06-27T02:55:22','version'=>'1.9402' },{'date'=>'2009-09-14T02:47:24','version'=>'1.94_51' },{'date'=>'2009-10-15T19:33:19','version'=>'1.94_52' },{'date'=>'2009-12-18T07:00:09','version'=>'1.94_53' },{'date'=>'2010-01-14T08:01:42','version'=>'1.94_54' },{'date'=>'2010-02-03T03:43:49','version'=>'1.94_55' },{'date'=>'2010-02-17T13:39:33','version'=>'1.94_56' },{'date'=>'2010-05-24T19:33:41','version'=>'1.94_57' },{'date'=>'2010-06-24T06:34:13','version'=>'1.94_58' },{'date'=>'2010-09-26T20:23:30','version'=>'1.94_59' },{'date'=>'2010-09-28T20:44:58','version'=>'1.94_60' },{'date'=>'2010-10-03T17:29:37','version'=>'1.94_61' },{'date'=>'2010-10-26T06:43:51','version'=>'1.94_62' },{'date'=>'2011-01-16T17:58:10','version'=>'1.94_63' },{'date'=>'2011-01-21T04:58:35','version'=>'1.94_64' },{'date'=>'2011-02-14T12:10:12','version'=>'1.94_65' },{'date'=>'2011-03-12T11:30:03','version'=>'1.9600' },{'date'=>'2011-06-27T06:56:01','version'=>'1.97_51' },{'date'=>'2011-08-07T09:40:33','version'=>'1.9800' },{'date'=>'2012-10-16T21:42:49','version'=>'1.99_51' },{'date'=>'2013-02-06T07:41:54','version'=>'2.00-TRIAL' },{'date'=>'2013-04-12T16:57:44','version'=>'2.00' },{'date'=>'2013-06-22T20:27:32','version'=>'2.01-TRIAL' },{'date'=>'2013-06-23T07:33:40','version'=>'2.02-TRIAL' },{'date'=>'2013-09-15T09:42:33','version'=>'2.03-TRIAL' },{'date'=>'2014-03-18T22:33:22','version'=>'2.04-TRIAL' },{'date'=>'2014-03-31T20:55:24','version'=>'2.05-TRIAL' },{'date'=>'2014-04-04T02:07:20','version'=>'2.05-TRIAL2' },{'date'=>'2014-04-18T13:35:51','version'=>'2.05' },{'date'=>'2014-08-06T19:32:53','version'=>'2.06-TRIAL' },{'date'=>'2015-01-04T18:54:54','version'=>'2.06-TRIAL' },{'date'=>'2015-01-05T06:31:55','version'=>'2.08-TRIAL' },{'date'=>'2015-02-02T04:41:02','version'=>'2.09-TRIAL' },{'date'=>'2015-02-22T15:57:42','version'=>'2.10-TRIAL' },{'date'=>'2015-03-13T07:45:04','version'=>'2.10' },{'date'=>'2015-12-31T11:00:08','version'=>'2.12-TRIAL' },{'date'=>'2016-05-16T09:56:01','version'=>'2.13-TRIAL' },{'date'=>'2016-06-04T14:41:28','version'=>'2.14-TRIAL' },{'date'=>'2016-06-25T04:32:45','version'=>'2.14' },{'date'=>'2016-07-17T12:10:30','version'=>'2.15-TRIAL' },{'date'=>'2017-01-16T16:20:27','version'=>'2.16-TRIAL' },{'date'=>'2017-01-16T21:27:06','version'=>'2.16-TRIAL2' },{'date'=>'2017-02-14T16:22:20','version'=>'2.16' },{'date'=>'2017-02-15T09:37:10','version'=>'2.17-TRIAL' },{'date'=>'2017-02-16T09:48:46','version'=>'2.17-TRIAL2' },{'date'=>'2017-03-30T21:38:23','version'=>'2.18-TRIAL' },{'date'=>'2017-11-04T23:27:47','version'=>'2.19-TRIAL' },{'date'=>'2017-11-26T22:10:39','version'=>'2.20-TRIAL' },{'date'=>'2018-09-22T20:46:35','version'=>'2.21-TRIAL' },{'date'=>'2018-12-16T10:35:04','version'=>'2.22-TRIAL' },{'date'=>'2018-12-23T09:11:29','version'=>'2.22' },{'date'=>'2019-02-10T20:28:53','version'=>'2.23-TRIAL' },{'date'=>'2019-02-14T21:21:03','version'=>'2.24-TRIAL' },{'date'=>'2019-02-16T05:56:23','version'=>'2.25-TRIAL' },{'date'=>'2019-03-03T06:27:10','version'=>'2.25' }]},'Catalyst-Authentication-Store-LDAP'=>{'advisories'=>[{'affected_versions'=>'<1.013','description'=>'Incorrect password check binds to the unauthenticated user.
  ','distribution'=>'Catalyst-Authentication-Store-LDAP','fixed_versions'=>'>=1.013','id'=>'CPANSA-Catalyst-Authentication-Store-LDAP-2012-01','references'=>['https://rt.cpan.org/Public/Bug/Display.html?id=81908' ],'reported'=>'2012-12-11','severity'=>'high' }],'main_module'=>'Catalyst::Authentication::Store::LDAP','versions'=>[{'date'=>'2008-02-05T18:18:24','version'=>'0.1000' },{'date'=>'2008-04-10T02:06:58','version'=>'0.1001' },{'date'=>'2008-07-09T20:45:43','version'=>'0.1002' },{'date'=>'2008-09-10T13:21:33','version'=>'0.1003' },{'date'=>'2008-10-22T01:57:27','version'=>'0.1003' },{'date'=>'2009-05-01T02:34:18','version'=>'0.1005' },{'date'=>'2009-12-11T18:54:26','version'=>'1.006' },{'date'=>'2010-03-19T10:07:13','version'=>'1.007' },{'date'=>'2010-04-03T03:04:13','version'=>'1.008' },{'date'=>'2010-05-15T07:14:41','version'=>'1.009' },{'date'=>'2010-07-06T21:39:55','version'=>'1.010' },{'date'=>'2010-07-07T20:41:22','version'=>'1.011' },{'date'=>'2010-10-05T08:11:56','version'=>'1.012' },{'date'=>'2013-01-09T14:58:46','version'=>'1.013' },{'date'=>'2013-04-26T19:51:28','version'=>'1.014' },{'date'=>'2015-02-20T18:07:31','version'=>'1.015' },{'date'=>'2016-02-11T17:50:52','version'=>'1.016' }]},'Catalyst-Controller-Combine'=>{'advisories'=>[{'affected_versions'=>'<0.12','description'=>'Allows to use url-encoded path-parts to crawl along the file system and read files outside the intended directory.
  ','distribution'=>'Catalyst-Controller-Combine','fixed_versions'=>'>=0.12','id'=>'CPANSA-Catalyst-Controller-Combine-2010-01','references'=>['https://metacpan.org/changes/distribution/Catalyst-Controller-Combine' ],'reported'=>'2010-05-21' }],'main_module'=>'Catalyst::Controller::Combine','versions'=>[{'date'=>'2009-07-11T17:58:25','version'=>'0.06' },{'date'=>'2009-07-13T06:49:00','version'=>'0.07' },{'date'=>'2009-10-24T12:48:21','version'=>'0.08' },{'date'=>'2010-03-13T19:31:13','version'=>'0.09' },{'date'=>'2010-03-27T18:44:05','version'=>'0.10' },{'date'=>'2010-06-21T20:47:02','version'=>'0.12' },{'date'=>'2011-07-28T19:53:12','version'=>'0.13' },{'date'=>'2012-02-20T20:59:00','version'=>'0.14' },{'date'=>'2012-05-04T10:43:12','version'=>'0.15' }]},'Catalyst-Plugin-Static'=>{'advisories'=>[{'affected_versions'=>'<0.10','description'=>'Serving files outside of $config->{root} directory.
  ','distribution'=>'Catalyst-Plugin-Static','fixed_versions'=>'>=0.10','id'=>'CPANSA-Catalyst-Plugin-Static-2005-01','reported'=>'2005-11-14' }],'main_module'=>'Catalyst::Plugin::Static','versions'=>[{'date'=>'2005-01-29T00:00:20','version'=>'0.01' },{'date'=>'2005-02-19T20:28:50','version'=>'0.02' },{'date'=>'2005-03-17T01:01:03','version'=>'0.03' },{'date'=>'2005-03-17T19:10:36','version'=>'0.04' },{'date'=>'2005-03-21T13:34:27','version'=>'0.05' },{'date'=>'2005-03-23T06:48:05','version'=>'0.05' },{'date'=>'2005-04-15T16:58:18','version'=>'0.06' },{'date'=>'2005-04-17T14:50:45','version'=>'0.07' },{'date'=>'2005-09-06T13:42:42','version'=>'0.08' },{'date'=>'2005-11-14T08:38:35','version'=>'0.09' },{'date'=>'2005-11-14T10:26:31','version'=>'0.10' },{'date'=>'2009-10-18T18:13:00','version'=>'0.11' }]},'Catalyst-Runtime'=>{'advisories'=>[{'affected_versions'=>'<5.90020','description'=>'Passing a special host to the redirect page link makes it vulnerable to XSS attack.
  ','distribution'=>'Catalyst-Runtime','fixed_versions'=>'>=5.90020','id'=>'CPANSA-Catalyst-Runtime-2013-01','references'=>['http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=catagits/Catalyst-Runtime.git;a=commitdiff;h=7af54927870a7c6f89323ac1876d49f92e7841f5' ],'reported'=>'2013-01-23' },{'affected_versions'=>'<5.58','description'=>'Path traversal in Static::Simple plugin.
  ','distribution'=>'Catalyst-Runtime','fixed_versions'=>'>=5.58','id'=>'CPANSA-Catalyst-Runtime-2005-01','reported'=>'2005-11-24' }],'main_module'=>'Catalyst::Runtime','versions'=>[{'date'=>'2006-06-25T19:20:53','version'=>'5.70_01' },{'date'=>'2006-06-27T18:10:20','version'=>'5.70_02' },{'date'=>'2006-06-28T21:50:30','version'=>'5.70_03' },{'date'=>'2006-07-07T22:47:30','version'=>'5.7000' },{'date'=>'2006-07-20T06:00:58','version'=>'5.7001' },{'date'=>'2006-09-19T07:36:29','version'=>'5.7002' },{'date'=>'2006-09-23T17:43:12','version'=>'5.7003' },{'date'=>'2006-11-06T23:28:40','version'=>'5.7004' },{'date'=>'2006-11-07T19:43:56','version'=>'5.7005' },{'date'=>'2006-11-15T08:27:59','version'=>'5.7006' },{'date'=>'2007-03-14T11:13:37','version'=>'5.7007' },{'date'=>'2007-08-13T06:36:11','version'=>'5.7008' },{'date'=>'2007-08-21T22:23:53','version'=>'5.7009' },{'date'=>'2007-08-22T05:51:41','version'=>'5.7010' },{'date'=>'2007-10-18T18:11:24','version'=>'5.7011' },{'date'=>'2007-12-17T08:19:28','version'=>'5.7012' },{'date'=>'2008-05-17T12:41:13','version'=>'5.7013' },{'date'=>'2008-05-25T21:16:45','version'=>'5.7013' },{'date'=>'2008-06-25T20:43:41','version'=>'5.7099_01' },{'date'=>'2008-07-18T11:41:25','version'=>'5.7099_02' },{'date'=>'2008-07-20T08:15:02','version'=>'5.7099_02' },{'date'=>'2008-10-13T20:55:41','version'=>'5.7099_02' },{'date'=>'2008-10-14T06:06:06','version'=>'5.7099_02' },{'date'=>'2008-10-15T21:44:15','version'=>'5.7015' },{'date'=>'2008-10-17T12:42:53','version'=>'5.8000_03' },{'date'=>'2008-12-05T15:11:14','version'=>'5.8000_04' },{'date'=>'2009-01-12T15:46:59','version'=>'5.7099_04' },{'date'=>'2009-01-19T17:36:04','version'=>'5.71000' },{'date'=>'2009-01-29T08:56:09','version'=>'5.8000_05' },{'date'=>'2009-02-04T20:08:22','version'=>'5.8000_06' },{'date'=>'2009-03-27T09:21:12','version'=>'5.71001' },{'date'=>'2009-04-13T19:03:36','version'=>'5.8000_07' },{'date'=>'2009-04-18T20:26:00','version'=>'5.80001' },{'date'=>'2009-04-21T23:45:45','version'=>'5.80002' },{'date'=>'2009-04-29T14:39:21','version'=>'5.80003' },{'date'=>'2009-05-18T15:16:38','version'=>'5.80004' },{'date'=>'2009-06-06T12:49:15','version'=>'5.80005' },{'date'=>'2009-06-29T22:11:48','version'=>'5.80006' },{'date'=>'2009-06-30T22:11:36','version'=>'5.80007' },{'date'=>'2009-08-21T16:14:33','version'=>'5.80008' },{'date'=>'2009-08-21T20:29:33','version'=>'5.80009' },{'date'=>'2009-08-21T21:42:08','version'=>'5.80010' },{'date'=>'2009-08-23T11:57:26','version'=>'5.80011' },{'date'=>'2009-09-09T18:01:32','version'=>'5.80012' },{'date'=>'2009-09-17T09:35:20','version'=>'5.80013' },{'date'=>'2009-11-21T02:32:20','version'=>'5.80014' },{'date'=>'2009-11-22T20:24:47','version'=>'5.80014_01' },{'date'=>'2009-12-01T01:14:00','version'=>'5.80014_02' },{'date'=>'2009-12-02T15:42:50','version'=>'5.80015' },{'date'=>'2009-12-11T23:37:44','version'=>'5.80016' },{'date'=>'2010-01-10T02:01:50','version'=>'5.80017' },{'date'=>'2010-01-12T21:39:47','version'=>'5.80018' },{'date'=>'2010-01-29T00:18:07','version'=>'5.80019' },{'date'=>'2010-02-04T06:19:31','version'=>'5.80020' },{'date'=>'2010-03-03T23:16:29','version'=>'5.80021' },{'date'=>'2010-03-28T19:25:48','version'=>'5.80022' },{'date'=>'2010-05-07T22:07:08','version'=>'5.80023' },{'date'=>'2010-05-15T09:57:52','version'=>'5.80024' },{'date'=>'2010-07-29T00:59:16','version'=>'5.80025' },{'date'=>'2010-09-01T15:10:42','version'=>'5.80026' },{'date'=>'2010-09-02T11:33:03','version'=>'5.80027' },{'date'=>'2010-09-28T20:14:11','version'=>'5.80028' },{'date'=>'2010-10-03T16:24:08','version'=>'5.80029' },{'date'=>'2011-01-04T12:56:30','version'=>'5.80030' },{'date'=>'2011-01-24T10:50:27','version'=>'5.89000' },{'date'=>'2011-01-31T08:25:21','version'=>'5.80031' },{'date'=>'2011-02-23T08:28:58','version'=>'5.80032' },{'date'=>'2011-03-01T14:56:37','version'=>'5.89001' },{'date'=>'2011-03-02T10:37:42','version'=>'5.89002' },{'date'=>'2011-07-24T15:58:37','version'=>'5.80033' },{'date'=>'2011-07-28T20:05:01','version'=>'5.89003' },{'date'=>'2011-08-15T21:35:34','version'=>'5.9000' },{'date'=>'2011-08-15T21:59:58','version'=>'5.90001' },{'date'=>'2011-08-22T20:55:10','version'=>'5.90002' },{'date'=>'2011-10-05T07:48:57','version'=>'5.90003' },{'date'=>'2011-10-11T15:19:05','version'=>'5.90004' },{'date'=>'2011-10-22T21:01:24','version'=>'5.90005' },{'date'=>'2011-10-25T17:54:34','version'=>'5.90006' },{'date'=>'2011-11-22T20:40:44','version'=>'5.90007' },{'date'=>'2012-02-06T21:08:28','version'=>'5.90008' },{'date'=>'2012-02-16T09:29:44','version'=>'5.90009' },{'date'=>'2012-02-18T00:49:30','version'=>'5.90010' },{'date'=>'2012-03-08T21:53:00','version'=>'5.90011' },{'date'=>'2012-05-19T07:13:21','version'=>'5.90012' },{'date'=>'2012-06-08T00:37:40','version'=>'5.90013' },{'date'=>'2012-06-21T20:41:41','version'=>'5.90013' },{'date'=>'2012-06-26T14:34:56','version'=>'5.90014' },{'date'=>'2012-06-30T18:00:53','version'=>'5.90015' },{'date'=>'2012-08-17T01:39:42','version'=>'5.90016' },{'date'=>'2012-10-19T21:51:54','version'=>'5.90017' },{'date'=>'2012-10-24T01:01:44','version'=>'5.90018' },{'date'=>'2012-12-04T22:04:19','version'=>'5.90019' },{'date'=>'2013-02-22T14:05:39','version'=>'5.90020' },{'date'=>'2013-04-12T17:09:27','version'=>'5.90030' },{'date'=>'2013-06-12T21:26:14','version'=>'5.90040' },{'date'=>'2013-06-15T02:10:17','version'=>'5.90041' },{'date'=>'2013-06-16T01:57:47','version'=>'5.90042' },{'date'=>'2013-07-26T19:13:01','version'=>'5.90049_001' },{'date'=>'2013-08-21T02:39:45','version'=>'5.90049_002' },{'date'=>'2013-09-20T19:03:54','version'=>'5.90049_003' },{'date'=>'2013-10-18T22:19:33','version'=>'5.90049_004' },{'date'=>'2013-10-31T20:48:42','version'=>'5.90049_005' },{'date'=>'2013-11-05T03:25:31','version'=>'5.90049_006' },{'date'=>'2013-11-05T22:35:22','version'=>'5.90050' },{'date'=>'2013-11-07T17:14:35','version'=>'5.90051' },{'date'=>'2013-12-18T20:03:22','version'=>'5.90052' },{'date'=>'2013-12-19T14:33:08','version'=>'5.90059_001' },{'date'=>'2013-12-22T16:18:16','version'=>'5.90053' },{'date'=>'2013-12-22T16:34:11','version'=>'5.90059_002' },{'date'=>'2013-12-27T02:27:08','version'=>'5.90059_003' },{'date'=>'2014-01-27T17:20:51','version'=>'5.90059_004' },{'date'=>'2014-01-28T19:36:58','version'=>'5.90059_005' },{'date'=>'2014-02-06T20:41:25','version'=>'5.90059_006' },{'date'=>'2014-02-08T03:11:11','version'=>'5.90060' },{'date'=>'2014-03-10T14:46:10','version'=>'5.90061' },{'date'=>'2014-04-14T18:53:26','version'=>'5.90062' },{'date'=>'2014-05-02T00:15:16','version'=>'5.90063' },{'date'=>'2014-05-05T14:55:25','version'=>'5.90064' },{'date'=>'2014-05-27T18:08:08','version'=>'5.90069_001' },{'date'=>'2014-06-05T12:44:59','version'=>'5.90065' },{'date'=>'2014-06-10T00:22:42','version'=>'5.90069_002' },{'date'=>'2014-08-06T15:09:29','version'=>'5.90069_003' },{'date'=>'2014-08-07T15:59:15','version'=>'5.90069_004' },{'date'=>'2014-08-07T21:49:59','version'=>'5.90070' },{'date'=>'2014-08-10T13:15:52','version'=>'5.90071' },{'date'=>'2014-09-15T16:30:58','version'=>'5.90072' },{'date'=>'2014-09-23T17:24:54','version'=>'5.90073' },{'date'=>'2014-10-01T21:45:12','version'=>'5.90074' },{'date'=>'2014-10-07T00:07:51','version'=>'5.90075' },{'date'=>'2014-11-14T00:20:16','version'=>'5.90076' },{'date'=>'2014-11-19T00:28:27','version'=>'5.90077' },{'date'=>'2014-12-02T21:50:30','version'=>'5.90079_001' },{'date'=>'2014-12-02T23:22:07','version'=>'5.90079_002' },{'date'=>'2014-12-03T19:45:16','version'=>'5.90079_003' },{'date'=>'2014-12-26T23:05:46','version'=>'5.90079_004' },{'date'=>'2014-12-31T16:26:20','version'=>'5.90078' },{'date'=>'2014-12-31T21:04:56','version'=>'5.90079_005' },{'date'=>'2015-01-02T15:11:55','version'=>'5.90079_006' },{'date'=>'2015-01-02T18:11:38','version'=>'5.90079' },{'date'=>'2015-01-07T20:01:40','version'=>'5.90079_007' },{'date'=>'2015-01-07T23:26:17','version'=>'5.90079_008' },{'date'=>'2015-01-09T17:04:47','version'=>'5.90080' },{'date'=>'2015-01-10T22:39:56','version'=>'5.90081' },{'date'=>'2015-01-10T23:33:56','version'=>'5.90082' },{'date'=>'2015-02-17T02:29:50','version'=>'5.90083' },{'date'=>'2015-02-23T22:24:50','version'=>'5.90084' },{'date'=>'2015-03-25T18:58:11','version'=>'5.90085' },{'date'=>'2015-03-26T21:30:15','version'=>'5.90089_001' },{'date'=>'2015-04-17T21:32:30','version'=>'5.90089_002' },{'date'=>'2015-04-27T20:20:40','version'=>'5.90089_003' },{'date'=>'2015-04-28T18:24:12','version'=>'5.90089_004' },{'date'=>'2015-04-29T14:04:24','version'=>'5.90090' },{'date'=>'2015-05-08T20:36:59','version'=>'5.90091' },{'date'=>'2015-05-19T16:48:30','version'=>'5.90092' },{'date'=>'2015-05-29T17:06:23','version'=>'5.90093' },{'date'=>'2015-07-24T20:17:46','version'=>'5.90094' },{'date'=>'2015-07-27T14:32:30','version'=>'5.90095' },{'date'=>'2015-07-27T15:44:59','version'=>'5.90096' },{'date'=>'2015-07-28T20:33:41','version'=>'5.90097' },{'date'=>'2015-08-24T16:30:12','version'=>'5.90100' },{'date'=>'2015-09-04T22:57:40','version'=>'5.90101' },{'date'=>'2015-10-29T19:39:24','version'=>'5.90102' },{'date'=>'2015-11-12T10:19:42','version'=>'5.90103' },{'date'=>'2016-04-04T17:18:38','version'=>'5.90104' },{'date'=>'2016-06-08T20:06:53','version'=>'5.90105' },{'date'=>'2016-07-06T01:21:42','version'=>'5.90106' },{'date'=>'2016-07-20T19:12:32','version'=>'5.90110' },{'date'=>'2016-07-20T20:07:16','version'=>'5.90111' },{'date'=>'2016-07-25T21:03:05','version'=>'5.90112' },{'date'=>'2016-12-15T21:35:30','version'=>'5.90113' },{'date'=>'2016-12-19T16:54:08','version'=>'5.90114' },{'date'=>'2017-05-01T16:42:46','version'=>'5.90115' },{'date'=>'2018-01-19T20:55:15','version'=>'5.90116' },{'date'=>'2018-01-21T23:47:21','version'=>'5.90117' },{'date'=>'2018-05-01T09:59:20','version'=>'5.90118' },{'date'=>'2018-09-24T00:25:48','version'=>'5.90119' },{'date'=>'2018-10-19T06:13:58','version'=>'5.90120' },{'date'=>'2018-10-22T20:39:48','version'=>'5.90_121' },{'date'=>'2018-11-03T14:52:06','version'=>'5.90122' },{'date'=>'2018-11-27T15:39:35','version'=>'5.90123' },{'date'=>'2019-01-18T22:36:07','version'=>'5.90124' }]},'Cmd-Dwarf'=>{'advisories'=>[{'affected_versions'=>'<1.20','description'=>'JSON highjacking possibility.
  ','distribution'=>'Cmd-Dwarf','fixed_versions'=>'>=1.20','id'=>'CPANSA-Cmd-Dwarf-2014-01','references'=>['https://github.com/seagirl/dwarf/commit/14cf7a1d55db635a07f4838e16f3d9a28e63f529','https://metacpan.org/changes/distribution/Cmd-Dwarf' ],'reported'=>'2014-12-03' }],'main_module'=>'Cmd::Dwarf','versions'=>[{'date'=>'2015-07-30T06:48:35','version'=>'1.27' },{'date'=>'2015-08-26T13:27:51','version'=>'1.28' },{'date'=>'2015-08-28T08:58:33','version'=>'1.29' },{'date'=>'2015-09-17T08:17:32','version'=>'1.30' },{'date'=>'2016-01-20T06:39:15','version'=>'1.31' },{'date'=>'2016-10-25T05:56:33','version'=>'1.41' },{'date'=>'2017-03-29T04:42:05','version'=>'1.42' },{'date'=>'2017-06-21T07:06:05','version'=>'1.50' },{'date'=>'2017-10-05T08:08:01','version'=>'1.60' },{'date'=>'2018-03-17T07:35:19','version'=>'1.70' },{'date'=>'2018-08-18T11:43:10','version'=>'1.80' }]},'Compress-LZ4'=>{'advisories'=>[{'affected_versions'=>'<0.20','description'=>'Outdated LZ4 source code with security issue on 32bit systems.
  ','distribution'=>'Compress-LZ4','fixed_versions'=>'>=0.20','id'=>'CPANSA-Compress-LZ4-2014-01','references'=>['https://metacpan.org/changes/distribution/Compress-LZ4','https://github.com/gray/compress-lz4/commit/fc503812b4cbba16429658e1dfe20ad8bbfd77a0' ],'reported'=>'2014-07-07' }],'main_module'=>'Compress::LZ4','versions'=>[{'date'=>'2012-02-11T16:33:26','version'=>'0.01' },{'date'=>'2012-02-20T21:26:48','version'=>'0.02' },{'date'=>'2012-03-02T04:47:50','version'=>'0.03' },{'date'=>'2012-03-18T07:09:30','version'=>'0.04' },{'date'=>'2012-03-18T19:45:25','version'=>'0.05' },{'date'=>'2012-03-22T09:23:45','version'=>'0.06' },{'date'=>'2012-03-22T16:12:43','version'=>'0.07' },{'date'=>'2012-03-23T16:29:14','version'=>'0.08' },{'date'=>'2012-03-23T17:27:12','version'=>'0.09' },{'date'=>'2012-03-26T11:28:24','version'=>'0.10' },{'date'=>'2012-04-03T21:36:24','version'=>'0.11' },{'date'=>'2012-04-04T12:55:22','version'=>'0.12' },{'date'=>'2012-06-01T18:55:41','version'=>'0.13' },{'date'=>'2012-08-10T00:21:56','version'=>'0.14' },{'date'=>'2012-08-11T16:37:53','version'=>'0.15' },{'date'=>'2012-09-08T18:18:41','version'=>'0.16' },{'date'=>'2013-03-19T00:39:07','version'=>'0.17' },{'date'=>'2013-11-19T00:56:57','version'=>'0.18' },{'date'=>'2014-02-08T00:35:09','version'=>'0.19' },{'date'=>'2014-07-07T21:08:49','version'=>'0.20' },{'date'=>'2015-05-12T19:01:36','version'=>'0.21' },{'date'=>'2015-05-20T06:16:53','version'=>'0.22' },{'date'=>'2016-07-25T20:45:05','version'=>'0.23' },{'date'=>'2017-03-23T04:34:45','version'=>'0.24' },{'date'=>'2017-04-06T16:38:31','version'=>'0.25' }]},'Compress-Raw-Bzip2'=>{'advisories'=>[{'affected_versions'=>'<2.031','cves'=>['VE-2010-0405' ],'description'=>'Integer overflow in the BZ2_decompress function in decompress.c in bzip2 and libbzip2 before 1.0.6 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted compressed file.
  ','distribution'=>'Compress-Raw-Bzip2','fixed_versions'=>'>=2.031','id'=>'CPANSA-Compress-Raw-Bzip2-2010-01','references'=>['https://metacpan.org/changes/distribution/Compress-Raw-Bzip2' ],'reported'=>'2010-01-27' }],'main_module'=>'Compress::Raw::Bzip2','versions'=>[{'date'=>'2006-03-13T16:14:00','version'=>'2.000_10' },{'date'=>'2006-04-15T21:23:09','version'=>'2.000_11' },{'date'=>'2006-05-17T12:43:30','version'=>'2.000_12' },{'date'=>'2006-06-20T12:43:47','version'=>'2.000_13' },{'date'=>'2006-10-26T14:15:45','version'=>'2.000_14' },{'date'=>'2006-11-01T10:35:27','version'=>'2.001' },{'date'=>'2006-12-29T20:40:23','version'=>'2.002' },{'date'=>'2007-01-02T13:03:45','version'=>'2.003' },{'date'=>'2007-03-03T15:50:04','version'=>'2.004' },{'date'=>'2007-07-01T00:06:51','version'=>'2.005' },{'date'=>'2007-09-01T19:44:48','version'=>'2.006' },{'date'=>'2007-11-10T11:59:25','version'=>'2.008' },{'date'=>'2008-04-20T14:41:25','version'=>'2.009' },{'date'=>'2008-05-05T17:18:15','version'=>'2.010' },{'date'=>'2008-05-17T11:16:17','version'=>'2.011' },{'date'=>'2008-07-15T22:23:56','version'=>'2.012' },{'date'=>'2008-09-02T20:20:05','version'=>'2.014' },{'date'=>'2008-09-03T20:47:15','version'=>'2.015' },{'date'=>'2009-04-04T09:47:36','version'=>'2.017' },{'date'=>'2009-05-03T16:26:57','version'=>'2.018' },{'date'=>'2009-05-04T09:42:06','version'=>'2.019' },{'date'=>'2009-06-03T17:48:18','version'=>'2.020' },{'date'=>'2009-08-30T20:25:24','version'=>'2.021' },{'date'=>'2009-11-09T23:25:19','version'=>'2.023' },{'date'=>'2010-01-09T17:56:12','version'=>'2.024' },{'date'=>'2010-03-28T12:56:33','version'=>'2.025' },{'date'=>'2010-04-07T19:49:29','version'=>'2.026' },{'date'=>'2010-04-24T19:15:32','version'=>'2.027' },{'date'=>'2010-07-24T14:29:17','version'=>'2.030' },{'date'=>'2010-09-21T19:44:52','version'=>'2.031' },{'date'=>'2011-01-06T11:26:00','version'=>'2.032' },{'date'=>'2011-01-11T14:02:05','version'=>'2.033' },{'date'=>'2011-05-02T21:50:15','version'=>'2.034' },{'date'=>'2011-05-07T08:30:09','version'=>'2.035' },{'date'=>'2011-06-18T21:45:13','version'=>'2.036' },{'date'=>'2011-06-22T07:17:56','version'=>'2.037' },{'date'=>'2011-10-28T14:27:59','version'=>'2.039' },{'date'=>'2011-10-28T22:18:59','version'=>'2.040' },{'date'=>'2011-11-17T23:44:58','version'=>'2.042' },{'date'=>'2011-11-20T21:31:34','version'=>'2.043' },{'date'=>'2011-12-03T22:48:47','version'=>'2.044' },{'date'=>'2011-12-04T19:19:58','version'=>'2.045' },{'date'=>'2012-01-28T23:26:44','version'=>'2.047' },{'date'=>'2012-01-29T16:58:55','version'=>'2.048' },{'date'=>'2012-02-18T15:56:34','version'=>'2.049' },{'date'=>'2012-04-29T12:40:06','version'=>'2.052' },{'date'=>'2012-08-05T20:35:37','version'=>'2.055' },{'date'=>'2012-11-10T19:08:29','version'=>'2.057' },{'date'=>'2012-11-12T22:14:16','version'=>'2.058' },{'date'=>'2012-11-25T13:38:19','version'=>'2.059' },{'date'=>'2013-01-07T20:02:08','version'=>'2.060' },{'date'=>'2013-05-27T09:54:30','version'=>'2.061' },{'date'=>'2013-08-12T19:06:20','version'=>'2.062' },{'date'=>'2013-11-02T17:14:54','version'=>'2.063' },{'date'=>'2014-02-01T23:19:50','version'=>'2.064' },{'date'=>'2014-09-21T12:40:58','version'=>'2.066' },{'date'=>'2014-12-08T15:12:21','version'=>'2.067' },{'date'=>'2014-12-23T17:44:34','version'=>'2.068' },{'date'=>'2015-09-27T14:33:57','version'=>'2.069' },{'date'=>'2016-12-28T23:07:42','version'=>'2.070' },{'date'=>'2017-02-12T20:39:20','version'=>'2.072' },{'date'=>'2017-02-19T20:35:17','version'=>'2.073' },{'date'=>'2017-02-19T22:11:17','version'=>'2.074' },{'date'=>'2018-04-03T18:20:04','version'=>'2.080' },{'date'=>'2018-04-08T15:01:21','version'=>'2.081' },{'date'=>'2018-12-30T22:38:05','version'=>'2.083' },{'date'=>'2019-01-06T08:56:52','version'=>'2.084' }]},'Compress-Raw-Zlib'=>{'advisories'=>[{'affected_versions'=>'<2.075','cves'=>['CVE-2016-9843','CVE-2016-9841','CVE-2016-9840','CVE-2016-9842' ],'description'=>'Zlib vulnerabilities.
  ','distribution'=>'Compress-Raw-Zlib','fixed_versions'=>'>=2.075','id'=>'CPANSA-Compress-Raw-Zlib-2017-01','references'=>['https://metacpan.org/changes/distribution/Compress-Raw-Zlib' ],'reported'=>'2017-11-14' }],'main_module'=>'Compress::Raw::Zlib','versions'=>[{'date'=>'2006-03-03T23:06:38','version'=>'2.000_09' },{'date'=>'2006-03-13T16:14:20','version'=>'2.000_10' },{'date'=>'2006-04-15T21:23:24','version'=>'2.000_11' },{'date'=>'2006-05-17T12:43:41','version'=>'2.000_12' },{'date'=>'2006-06-20T12:45:30','version'=>'2.000_13' },{'date'=>'2006-10-26T14:15:34','version'=>'2.000_09' },{'date'=>'2006-11-01T10:35:38','version'=>'2.001' },{'date'=>'2006-12-29T20:40:35','version'=>'2.002' },{'date'=>'2007-01-02T13:03:57','version'=>'2.003' },{'date'=>'2007-03-03T15:50:15','version'=>'2.004' },{'date'=>'2007-07-01T00:07:02','version'=>'2.005' },{'date'=>'2007-09-01T19:44:59','version'=>'2.006' },{'date'=>'2007-11-10T11:59:36','version'=>'2.008' },{'date'=>'2008-04-20T14:42:52','version'=>'2.009' },{'date'=>'2008-05-05T17:18:27','version'=>'2.010' },{'date'=>'2008-05-17T11:16:28','version'=>'2.011' },{'date'=>'2008-07-15T22:24:07','version'=>'2.012' },{'date'=>'2008-09-02T20:20:16','version'=>'2.014' },{'date'=>'2008-09-03T20:47:27','version'=>'2.015' },{'date'=>'2009-04-04T09:49:03','version'=>'2.017' },{'date'=>'2009-05-03T16:27:08','version'=>'2.018' },{'date'=>'2009-05-04T09:42:17','version'=>'2.019' },{'date'=>'2009-06-03T17:48:30','version'=>'2.020' },{'date'=>'2009-08-30T20:25:35','version'=>'2.021' },{'date'=>'2009-11-09T23:26:59','version'=>'2.023' },{'date'=>'2010-01-09T17:56:35','version'=>'2.024' },{'date'=>'2010-03-28T12:57:08','version'=>'2.025' },{'date'=>'2010-04-07T19:51:09','version'=>'2.026' },{'date'=>'2010-04-24T19:15:54','version'=>'2.027' },{'date'=>'2010-07-24T14:31:01','version'=>'2.030' },{'date'=>'2011-01-06T11:23:45','version'=>'2.032' },{'date'=>'2011-01-11T14:03:45','version'=>'2.033' },{'date'=>'2011-05-02T22:05:37','version'=>'2.034' },{'date'=>'2011-05-07T08:31:57','version'=>'2.035' },{'date'=>'2011-06-18T21:45:36','version'=>'2.036' },{'date'=>'2011-06-22T07:18:22','version'=>'2.037' },{'date'=>'2011-10-28T14:28:35','version'=>'2.039' },{'date'=>'2011-10-28T22:20:38','version'=>'2.040' },{'date'=>'2011-11-17T23:45:21','version'=>'2.042' },{'date'=>'2011-11-20T21:33:33','version'=>'2.043' },{'date'=>'2011-12-03T22:49:10','version'=>'2.044' },{'date'=>'2011-12-04T19:21:36','version'=>'2.045' },{'date'=>'2012-01-28T23:28:28','version'=>'2.047' },{'date'=>'2012-01-29T17:00:33','version'=>'2.048' },{'date'=>'2012-02-18T15:58:12','version'=>'2.049' },{'date'=>'2012-02-21T19:35:18','version'=>'2.050' },{'date'=>'2012-02-22T20:43:23','version'=>'2.051' },{'date'=>'2012-04-29T12:41:57','version'=>'2.052' },{'date'=>'2012-05-06T08:40:06','version'=>'2.053' },{'date'=>'2012-05-08T19:22:47','version'=>'2.054' },{'date'=>'2012-08-05T20:36:06','version'=>'2.055' },{'date'=>'2012-08-10T22:20:09','version'=>'2.056' },{'date'=>'2012-11-10T19:08:56','version'=>'2.057' },{'date'=>'2012-11-12T22:14:42','version'=>'2.058' },{'date'=>'2012-11-25T13:38:42','version'=>'2.059' },{'date'=>'2013-01-07T20:02:22','version'=>'2.060' },{'date'=>'2013-05-27T09:54:54','version'=>'2.061' },{'date'=>'2013-08-12T19:08:05','version'=>'2.062' },{'date'=>'2013-11-02T17:15:17','version'=>'2.063' },{'date'=>'2014-02-01T23:21:28','version'=>'2.064' },{'date'=>'2014-02-03T20:23:00','version'=>'2.065' },{'date'=>'2014-09-21T12:42:35','version'=>'2.066' },{'date'=>'2014-12-08T15:14:00','version'=>'2.067' },{'date'=>'2014-12-23T17:44:57','version'=>'2.068' },{'date'=>'2015-09-26T18:41:58','version'=>'2.069' },{'date'=>'2016-12-28T23:09:21','version'=>'2.070' },{'date'=>'2016-12-30T22:58:08','version'=>'2.071' },{'date'=>'2017-02-12T20:41:25','version'=>'2.072' },{'date'=>'2017-02-19T20:37:20','version'=>'2.073' },{'date'=>'2017-02-19T22:11:41','version'=>'2.074' },{'date'=>'2017-11-14T15:43:26','version'=>'2.075' },{'date'=>'2017-11-21T22:29:23','version'=>'2.076' },{'date'=>'2018-04-03T18:22:06','version'=>'2.080' },{'date'=>'2018-04-08T15:02:55','version'=>'2.081' },{'date'=>'2018-12-30T22:40:08','version'=>'2.083' },{'date'=>'2019-01-06T08:57:15','version'=>'2.084' }]},'Config-Model'=>{'advisories'=>[{'affected_versions'=>'<2.102','cves'=>['CVE-2017-0373' ],'description'=>'The gen_class_pod implementation in lib/Config/Model/Utils/GenClassPod.pm in Config-Model (aka libconfig-model-perl) before 2.102 has a dangerous "use lib" line, which allows remote attackers to have an unspecified impact via a crafted Debian package file.
  ','distribution'=>'Config-Model','fixed_versions'=>'>=2.102','id'=>'CPANSA-Config-Model-2017-03','references'=>['https://metacpan.org/changes/distribution/Config-Model','https://github.com/dod38fr/config-model/commit/9bd64d9ec6c0939166a2216a37d58dd19a725951' ],'reported'=>'2017-05-10' },{'affected_versions'=>'<2.102','cves'=>['CVE-2017-0374' ],'description'=>'Loads models from a local directory, making it possible to substitute the model.
  ','distribution'=>'Config-Model','fixed_versions'=>'>=2.102','id'=>'CPANSA-Config-Model-2017-02','references'=>['https://metacpan.org/changes/distribution/Config-Model','https://github.com/dod38fr/config-model/commit/4d37c75b0c4f9633b67999f8260b08027a6bc524' ],'reported'=>'2017-05-10' },{'affected_versions'=>'<2.102','description'=>'YAML or YAML::XS can be loaded automatically making it possible to run arbitrary code loading a specially crafted YAML file.
  ','distribution'=>'Config-Model','fixed_versions'=>'>=2.102','id'=>'CPANSA-Config-Model-2017-01','references'=>['https://metacpan.org/changes/distribution/Config-Model','https://github.com/dod38fr/config-model/commit/01d212348bfbadf31bd74aadd26b1e391ff2fd92' ],'reported'=>'2017-05-10' }],'main_module'=>'Config::Model','versions'=>[{'date'=>'2006-04-21T12:27:44','version'=>'0.505' },{'date'=>'2006-05-19T13:32:14','version'=>'0.506' },{'date'=>'2006-06-15T12:10:38','version'=>'0.507' },{'date'=>'2006-07-20T12:28:36','version'=>'0.601' },{'date'=>'2006-09-07T12:06:17','version'=>'0.602' },{'date'=>'2006-10-19T11:24:40','version'=>'0.603' },{'date'=>'2006-12-06T12:58:35','version'=>'0.604' },{'date'=>'2007-01-08T13:16:42','version'=>'0.605' },{'date'=>'2007-01-11T12:42:09','version'=>'0.606' },{'date'=>'2007-01-12T13:06:38','version'=>'0.607' },{'date'=>'2007-02-23T13:00:34','version'=>'0.608' },{'date'=>'2007-05-14T11:41:18','version'=>'0.609' },{'date'=>'2007-06-06T12:28:06','version'=>'0.610' },{'date'=>'2007-07-03T15:35:21','version'=>'0.611' },{'date'=>'2007-07-27T11:38:57','version'=>'0.612' },{'date'=>'2007-10-01T15:52:56','version'=>'0.613' },{'date'=>'2007-10-23T16:10:29','version'=>'0.614' },{'date'=>'2007-11-15T12:36:18','version'=>'0.615' },{'date'=>'2007-12-04T12:41:22','version'=>'0.616' },{'date'=>'2008-01-28T11:55:50','version'=>'0.617' },{'date'=>'2008-02-14T12:56:25','version'=>'0.618' },{'date'=>'2008-02-29T12:08:41','version'=>'0.619' },{'date'=>'2008-03-18T17:40:57','version'=>'0.620' },{'date'=>'2008-03-20T07:49:00','version'=>'0.6201' },{'date'=>'2008-04-04T11:38:49','version'=>'0.621' },{'date'=>'2008-04-25T16:23:31','version'=>'0.622' },{'date'=>'2008-05-19T11:47:46','version'=>'0.623' },{'date'=>'2008-07-25T11:35:07','version'=>'0.624' },{'date'=>'2008-07-30T12:02:43','version'=>'0.625' },{'date'=>'2008-09-22T12:20:00','version'=>'0.626' },{'date'=>'2008-09-23T11:05:58','version'=>'0.627' },{'date'=>'2008-09-29T12:35:05','version'=>'0.628' },{'date'=>'2008-10-13T15:09:27','version'=>'0.629' },{'date'=>'2008-10-21T11:59:27','version'=>'0.630' },{'date'=>'2008-11-10T14:37:44','version'=>'0.631' },{'date'=>'2008-12-16T13:32:26','version'=>'0.632' },{'date'=>'2008-12-23T15:36:48','version'=>'0.633' },{'date'=>'2009-03-05T13:06:32','version'=>'0.634' },{'date'=>'2009-04-20T12:21:46','version'=>'0.635' },{'date'=>'2009-05-30T16:19:54','version'=>'0.636' },{'date'=>'2009-06-23T12:07:41','version'=>'0.637' },{'date'=>'2009-06-30T11:31:35','version'=>'0.638' },{'date'=>'2009-09-08T11:35:25','version'=>'0.639' },{'date'=>'2009-09-09T16:10:41','version'=>'0.640' },{'date'=>'2010-01-20T17:30:14','version'=>'0.641' },{'date'=>'2010-01-21T17:17:34','version'=>'0.642' },{'date'=>'2010-02-25T13:04:52','version'=>'0.643' },{'date'=>'2010-03-12T15:24:45','version'=>'0.644' },{'date'=>'2010-03-28T14:53:46','version'=>'1.001' },{'date'=>'2010-04-22T12:22:00','version'=>'1.202' },{'date'=>'2010-06-03T11:09:45','version'=>'1.203' },{'date'=>'2010-06-03T11:20:09','version'=>'1.204' },{'date'=>'2010-06-07T16:04:03','version'=>'1.205' },{'date'=>'2010-08-13T10:53:09','version'=>'1.206' },{'date'=>'2010-09-14T16:14:40','version'=>'1.207' },{'date'=>'2010-09-16T11:46:11','version'=>'1.208' },{'date'=>'2010-09-20T12:29:12','version'=>'1.209' },{'date'=>'2010-09-30T16:34:27','version'=>'1.210' },{'date'=>'2010-10-08T10:46:45','version'=>'1.211' },{'date'=>'2010-10-15T11:08:52','version'=>'1.212' },{'date'=>'2010-10-19T12:29:03','version'=>'1.213' },{'date'=>'2010-10-19T15:17:01','version'=>'1.214' },{'date'=>'2010-10-19T15:28:56','version'=>'1.215' },{'date'=>'2010-10-26T12:16:51','version'=>'1.216' },{'date'=>'2010-10-30T12:44:11','version'=>'1.217' },{'date'=>'2010-11-05T11:53:14','version'=>'1.218' },{'date'=>'2010-11-09T13:20:51','version'=>'1.219' },{'date'=>'2010-11-10T08:41:22','version'=>'1.220' },{'date'=>'2010-11-21T17:40:10','version'=>'1.221' },{'date'=>'2010-11-22T14:01:55','version'=>'1.222' },{'date'=>'2010-11-28T17:34:03','version'=>'1.223' },{'date'=>'2010-12-06T13:18:53','version'=>'1.224' },{'date'=>'2010-12-07T08:01:43','version'=>'1.225' },{'date'=>'2010-12-08T18:48:08','version'=>'1.226' },{'date'=>'2011-01-07T18:12:45','version'=>'1.227' },{'date'=>'2011-01-09T12:27:15','version'=>'1.228' },{'date'=>'2011-01-10T19:57:53','version'=>'1.229' },{'date'=>'2011-01-20T16:47:27','version'=>'1.230' },{'date'=>'2011-01-30T11:30:23','version'=>'1.231' },{'date'=>'2011-01-30T13:51:34','version'=>'1.232' },{'date'=>'2011-02-11T12:25:32','version'=>'1.233' },{'date'=>'2011-02-21T17:11:22','version'=>'1.234' },{'date'=>'2011-03-01T13:06:28','version'=>'1.235' },{'date'=>'2011-04-01T14:09:03','version'=>'1.236' },{'date'=>'2011-04-04T12:57:04','version'=>'1.237' },{'date'=>'2011-04-05T14:45:45','version'=>'1.238' },{'date'=>'2011-04-05T17:40:17','version'=>'1.240' },{'date'=>'2011-04-07T18:09:49','version'=>'1.241' },{'date'=>'2011-04-25T15:28:14','version'=>'1.242' },{'date'=>'2011-05-02T12:33:33','version'=>'1.243' },{'date'=>'2011-05-16T15:52:46','version'=>'1.244' },{'date'=>'2011-06-17T12:10:22','version'=>'1.245' },{'date'=>'2011-06-20T12:32:24','version'=>'1.246' },{'date'=>'2011-06-27T14:14:52','version'=>'1.247' },{'date'=>'2011-07-05T15:48:52','version'=>'1.248' },{'date'=>'2011-07-12T09:54:39','version'=>'1.249' },{'date'=>'2011-07-22T12:40:47','version'=>'1.250' },{'date'=>'2011-08-30T12:16:32','version'=>'1.251' },{'date'=>'2011-09-01T16:06:19','version'=>'1.252' },{'date'=>'2011-09-02T16:03:35','version'=>'1.253' },{'date'=>'2011-09-04T15:21:52','version'=>'1.254' },{'date'=>'2011-09-15T15:23:39','version'=>'1.255' },{'date'=>'2011-09-16T12:28:51','version'=>'1.256' },{'date'=>'2011-09-23T10:52:00','version'=>'1.257' },{'date'=>'2011-10-14T14:45:06','version'=>'1.258' },{'date'=>'2011-10-16T10:17:53','version'=>'1.259' },{'date'=>'2011-10-28T13:28:02','version'=>'1.260' },{'date'=>'2011-11-18T17:02:26','version'=>'1.261' },{'date'=>'2011-11-19T11:55:30','version'=>'1.262' },{'date'=>'2011-11-29T15:43:38','version'=>'1.263' },{'date'=>'2011-11-30T07:50:25','version'=>'1.264' },{'date'=>'2011-12-06T18:26:54','version'=>'1.265' },{'date'=>'2012-02-06T11:55:29','version'=>'2.001' },{'date'=>'2012-02-08T09:49:49','version'=>'2.002' },{'date'=>'2012-02-08T13:14:22','version'=>'2.003' },{'date'=>'2012-02-09T11:28:18','version'=>'2.004' },{'date'=>'2012-02-23T18:25:32','version'=>'2.005' },{'date'=>'2012-02-25T11:30:41','version'=>'2.006' },{'date'=>'2012-02-26T16:34:50','version'=>'2.007' },{'date'=>'2012-03-01T12:40:23','version'=>'2.008' },{'date'=>'2012-03-13T13:11:49','version'=>'2.009' },{'date'=>'2012-03-13T13:15:03','version'=>'2.010' },{'date'=>'2012-03-19T21:41:44','version'=>'2.011' },{'date'=>'2012-04-05T11:41:54','version'=>'2.012' },{'date'=>'2012-04-06T12:10:46','version'=>'2.013' },{'date'=>'2012-05-04T13:57:13','version'=>'2.014' },{'date'=>'2012-05-14T10:06:13','version'=>'2.015' },{'date'=>'2012-05-20T08:38:36','version'=>'2.016' },{'date'=>'2012-05-21T10:56:35','version'=>'2.017' },{'date'=>'2012-05-29T13:53:06','version'=>'2.018' },{'date'=>'2012-06-05T12:34:15','version'=>'2.019' },{'date'=>'2012-06-18T08:34:26','version'=>'2.020' },{'date'=>'2012-06-27T14:44:55','version'=>'2.021_01' },{'date'=>'2012-06-28T15:30:52','version'=>'2.021' },{'date'=>'2012-07-03T14:47:31','version'=>'2.022' },{'date'=>'2012-07-04T13:50:37','version'=>'2.023' },{'date'=>'2012-09-04T11:30:02','version'=>'2.024' },{'date'=>'2012-09-10T10:52:02','version'=>'2.025' },{'date'=>'2012-09-20T17:12:09','version'=>'2.026_1' },{'date'=>'2012-09-21T10:38:47','version'=>'2.026_2' },{'date'=>'2012-09-27T11:53:42','version'=>'2.026' },{'date'=>'2012-10-30T12:48:16','version'=>'2.027' },{'date'=>'2012-11-27T12:44:55','version'=>'2.028' },{'date'=>'2012-11-28T13:31:04','version'=>'2.029' },{'date'=>'2013-02-27T18:37:05','version'=>'2.030_01' },{'date'=>'2013-03-23T09:47:53','version'=>'2.030' },{'date'=>'2013-04-03T17:22:28','version'=>'2.031' },{'date'=>'2013-04-15T11:28:33','version'=>'2.032' },{'date'=>'2013-04-15T19:27:14','version'=>'2.033' },{'date'=>'2013-04-17T19:29:52','version'=>'2.034' },{'date'=>'2013-04-27T15:05:09','version'=>'2.035' },{'date'=>'2013-05-25T17:53:04','version'=>'2.036' },{'date'=>'2013-06-15T17:46:45','version'=>'2.037' },{'date'=>'2013-07-03T19:30:32','version'=>'2.038' },{'date'=>'2013-07-18T18:12:07','version'=>'2.039' },{'date'=>'2013-07-20T09:46:11','version'=>'2.040' },{'date'=>'2013-08-14T17:58:40','version'=>'2.041' },{'date'=>'2013-09-15T17:41:45','version'=>'2.042' },{'date'=>'2013-09-20T17:35:06','version'=>'2.043' },{'date'=>'2013-10-13T16:02:40','version'=>'2.044' },{'date'=>'2013-10-18T17:48:15','version'=>'2.045' },{'date'=>'2013-12-15T13:07:37','version'=>'2.046' },{'date'=>'2014-01-25T15:54:37','version'=>'2.047' },{'date'=>'2014-02-23T18:02:19','version'=>'2.048' },{'date'=>'2014-02-26T19:45:44','version'=>'2.049' },{'date'=>'2014-02-27T18:12:32','version'=>'2.050' },{'date'=>'2014-03-06T18:23:11','version'=>'2.051' },{'date'=>'2014-03-23T16:20:43','version'=>'2.052' },{'date'=>'2014-03-25T19:11:57','version'=>'2.053' },{'date'=>'2014-04-01T17:51:50','version'=>'2.054' },{'date'=>'2014-05-02T11:33:28','version'=>'2.055' },{'date'=>'2014-05-18T19:34:53','version'=>'2.056' },{'date'=>'2014-06-12T19:32:47','version'=>'2.057' },{'date'=>'2014-06-19T19:43:18','version'=>'2.058' },{'date'=>'2014-06-29T15:08:02','version'=>'2.059' },{'date'=>'2014-08-19T12:43:59','version'=>'2.060' },{'date'=>'2014-09-23T19:21:04','version'=>'2.061' },{'date'=>'2014-11-23T19:45:05','version'=>'2.062' },{'date'=>'2014-11-28T17:55:21','version'=>'2.063' },{'date'=>'2014-12-04T18:47:05','version'=>'2.064' },{'date'=>'2015-01-06T20:16:15','version'=>'2.065' },{'date'=>'2015-02-15T16:13:00','version'=>'2.066' },{'date'=>'2015-03-01T18:38:28','version'=>'2.067' },{'date'=>'2015-03-29T13:39:56','version'=>'2.068' },{'date'=>'2015-04-25T19:29:15','version'=>'2.069' },{'date'=>'2015-05-03T14:00:52','version'=>'2.070' },{'date'=>'2015-05-23T11:15:16','version'=>'2.071' },{'date'=>'2015-07-18T19:31:43','version'=>'2.072' },{'date'=>'2015-07-19T07:35:51','version'=>'2.073' },{'date'=>'2015-09-30T18:56:39','version'=>'2.074' },{'date'=>'2015-11-22T20:11:19','version'=>'2.075' },{'date'=>'2016-01-14T18:13:20','version'=>'2.076' },{'date'=>'2016-01-20T19:55:36','version'=>'2.077' },{'date'=>'2016-01-24T18:48:46','version'=>'2.078' },{'date'=>'2016-02-12T20:44:28','version'=>'2.079' },{'date'=>'2016-02-27T17:59:55','version'=>'2.080' },{'date'=>'2016-02-29T19:01:45','version'=>'2.081' },{'date'=>'2016-03-29T18:22:30','version'=>'2.082' },{'date'=>'2016-04-20T18:32:29','version'=>'2.083' },{'date'=>'2016-05-26T17:35:53','version'=>'2.084' },{'date'=>'2016-05-29T17:13:14','version'=>'2.085' },{'date'=>'2016-06-04T19:28:08','version'=>'2.086' },{'date'=>'2016-06-29T17:35:35','version'=>'2.087' },{'date'=>'2016-07-09T18:06:03','version'=>'2.088' },{'date'=>'2016-09-04T13:17:52','version'=>'2.089' },{'date'=>'2016-09-10T16:07:07','version'=>'2.090' },{'date'=>'2016-09-13T17:05:56','version'=>'2.091' },{'date'=>'2016-09-23T17:46:04','version'=>'2.092' },{'date'=>'2016-11-08T18:33:39','version'=>'2.093' },{'date'=>'2016-11-09T18:23:05','version'=>'2.094' },{'date'=>'2016-12-06T18:01:00','version'=>'2.095' },{'date'=>'2016-12-11T20:28:14','version'=>'2.096' },{'date'=>'2016-12-22T17:35:34','version'=>'2.097' },{'date'=>'2017-02-26T18:58:23','version'=>'2.098' },{'date'=>'2017-03-05T17:09:37','version'=>'2.099' },{'date'=>'2017-03-18T12:06:34','version'=>'2.100' },{'date'=>'2017-04-28T17:40:56','version'=>'2.101' },{'date'=>'2017-05-14T19:10:40','version'=>'2.102' },{'date'=>'2017-05-25T08:15:17','version'=>'2.103' },{'date'=>'2017-06-03T13:23:33','version'=>'2.104' },{'date'=>'2017-06-09T17:26:55','version'=>'2.105' },{'date'=>'2017-07-16T14:07:23','version'=>'2.106' },{'date'=>'2017-08-30T19:12:10','version'=>'2.107' },{'date'=>'2017-08-31T17:23:43','version'=>'2.108' },{'date'=>'2017-09-18T17:52:57','version'=>'2.109' },{'date'=>'2017-09-21T19:12:32','version'=>'2.110' },{'date'=>'2017-09-22T18:41:04','version'=>'2.111' },{'date'=>'2017-10-01T09:12:45','version'=>'2.112' },{'date'=>'2017-10-12T19:07:46','version'=>'2.113' },{'date'=>'2017-11-11T16:35:03','version'=>'2.114' },{'date'=>'2017-12-14T18:03:18','version'=>'2.115' },{'date'=>'2017-12-16T09:52:09','version'=>'2.116' },{'date'=>'2018-02-03T18:09:35','version'=>'2.117' },{'date'=>'2018-03-26T18:33:19','version'=>'2.118' },{'date'=>'2018-04-02T16:55:50','version'=>'2.119' },{'date'=>'2018-04-08T07:56:03','version'=>'2.120' },{'date'=>'2018-04-15T17:08:18','version'=>'2.121' },{'date'=>'2018-04-17T17:20:14','version'=>'2.122' },{'date'=>'2018-05-01T17:18:09','version'=>'2.123' },{'date'=>'2018-06-09T17:16:59','version'=>'2.124' },{'date'=>'2018-06-24T12:47:24','version'=>'2.125' },{'date'=>'2018-08-20T13:10:09','version'=>'2.126' },{'date'=>'2018-09-30T16:44:13','version'=>'2.127' },{'date'=>'2018-11-21T19:33:41','version'=>'2.128' },{'date'=>'2018-12-05T18:44:58','version'=>'2.129' },{'date'=>'2018-12-07T19:02:10','version'=>'2.130' },{'date'=>'2018-12-16T18:32:58','version'=>'2.131' },{'date'=>'2018-12-22T17:50:27','version'=>'2.132' },{'date'=>'2019-01-13T20:17:07','version'=>'2.133' }]},'Cpanel-JSON-XS'=>{'advisories'=>[{'affected_versions'=>'<3.0225','description'=>'Overflow during processing of ill-formed UTF-8 strings.
  ','distribution'=>'Cpanel-JSON-XS','fixed_versions'=>'>=3.0225','id'=>'CPANSA-Cpanel-JSON-XS-2016-02','references'=>['https://metacpan.org/changes/distribution/Cpanel-JSON-XS','https://github.com/rurban/Cpanel-JSON-XS/commit/f71768984ba7f50b0476c17a4f3b3f2ca88a6951','https://github.com/dankogai/p5-encode/issues/64' ],'reported'=>'2016-11-23' },{'affected_versions'=>'<3.0218','description'=>'Possible overflows in av and hv length types.
  ','distribution'=>'Cpanel-JSON-XS','fixed_versions'=>'>=3.0218','id'=>'CPANSA-Cpanel-JSON-XS-2016-01','references'=>['https://metacpan.org/changes/distribution/Cpanel-JSON-XS','https://github.com/rurban/Cpanel-JSON-XS/commit/6554531b39fac236321d8601d35eaaa75ae45e20' ],'reported'=>'2016-10-06' }],'main_module'=>'Cpanel::JSON::XS','versions'=>[{'date'=>'2013-03-01T00:52:41','version'=>'2.33_03' },{'date'=>'2013-03-01T22:07:06','version'=>'2.33_04' },{'date'=>'2013-03-27T16:53:34','version'=>'2.3305' },{'date'=>'2013-03-27T17:17:51','version'=>'2.3306' },{'date'=>'2013-03-27T22:58:47','version'=>'2.3307' },{'date'=>'2013-03-28T14:28:56','version'=>'2.3308' },{'date'=>'2013-03-28T15:12:42','version'=>'2.3309' },{'date'=>'2013-03-28T17:33:21','version'=>'2.3310' },{'date'=>'2013-06-26T16:24:40','version'=>'2.3313' },{'date'=>'2013-09-09T05:54:40','version'=>'2.3314' },{'date'=>'2013-10-02T20:06:47','version'=>'2.3401' },{'date'=>'2013-11-02T14:42:20','version'=>'2.3402' },{'date'=>'2013-11-02T15:17:41','version'=>'2.3403' },{'date'=>'2014-01-30T15:58:58','version'=>'2.3404' },{'date'=>'2014-04-15T21:17:11','version'=>'3.0101' },{'date'=>'2014-04-17T18:37:34','version'=>'3.0102' },{'date'=>'2014-04-21T17:49:09','version'=>'3.0103' },{'date'=>'2014-04-26T16:04:39','version'=>'3.0104' },{'date'=>'2014-11-06T10:38:31','version'=>'3.0105' },{'date'=>'2014-11-11T21:57:49','version'=>'3.0106' },{'date'=>'2014-11-28T12:16:29','version'=>'3.0107' },{'date'=>'2014-12-11T17:02:07','version'=>'3.0108' },{'date'=>'2014-12-12T10:24:33','version'=>'3.0109' },{'date'=>'2014-12-12T22:35:37','version'=>'3.0110' },{'date'=>'2014-12-13T18:40:06','version'=>'3.0111' },{'date'=>'2014-12-14T16:34:01','version'=>'3.0112' },{'date'=>'2014-12-15T12:23:32','version'=>'3.0113' },{'date'=>'2015-01-04T14:06:03','version'=>'3.0114' },{'date'=>'2015-01-31T21:42:51','version'=>'3.0115' },{'date'=>'2015-11-26T08:58:33','version'=>'3.0201' },{'date'=>'2015-11-26T13:16:40','version'=>'3.0202' },{'date'=>'2015-11-26T13:42:02','version'=>'3.0203' },{'date'=>'2015-11-26T22:30:26','version'=>'3.0204' },{'date'=>'2015-11-29T14:09:00','version'=>'3.0205' },{'date'=>'2015-11-30T16:16:48','version'=>'3.0206' },{'date'=>'2015-12-02T16:34:35','version'=>'3.0207' },{'date'=>'2015-12-02T22:46:58','version'=>'3.0208' },{'date'=>'2015-12-03T09:45:04','version'=>'3.0209' },{'date'=>'2015-12-03T11:59:24','version'=>'3.0210' },{'date'=>'2016-01-10T17:38:25','version'=>'3.0211' },{'date'=>'2016-02-27T13:30:04','version'=>'3.0212' },{'date'=>'2016-03-02T10:28:37','version'=>'3.0213' },{'date'=>'2016-04-12T08:40:05','version'=>'3.0213_01' },{'date'=>'2016-04-13T10:40:03','version'=>'3.0213_02' },{'date'=>'2016-06-02T16:18:51','version'=>'3.0214' },{'date'=>'2016-06-06T13:28:49','version'=>'3.0215' },{'date'=>'2016-06-12T12:14:20','version'=>'3.0216' },{'date'=>'2016-06-18T09:59:27','version'=>'3.0217' },{'date'=>'2016-10-04T10:11:33','version'=>'3.0217_01' },{'date'=>'2016-10-04T14:47:29','version'=>'3.0217_02' },{'date'=>'2016-10-06T08:46:17','version'=>'3.0217_03' },{'date'=>'2016-10-07T12:11:03','version'=>'3.0217_04' },{'date'=>'2016-10-07T17:22:48','version'=>'3.0217_05' },{'date'=>'2016-10-08T08:01:50','version'=>'3.0217_06' },{'date'=>'2016-10-13T12:47:31','version'=>'3.0218' },{'date'=>'2016-10-26T11:45:35','version'=>'3.0219' },{'date'=>'2016-10-28T08:34:28','version'=>'3.0220' },{'date'=>'2016-10-30T12:27:36','version'=>'3.0221' },{'date'=>'2016-10-30T15:04:32','version'=>'3.0222' },{'date'=>'2016-11-16T11:47:38','version'=>'3.0223' },{'date'=>'2016-11-20T11:31:34','version'=>'3.0224' },{'date'=>'2016-11-23T18:43:00','version'=>'3.0225' },{'date'=>'2017-02-11T13:24:48','version'=>'3.0226' },{'date'=>'2017-02-13T10:57:06','version'=>'3.0227' },{'date'=>'2017-03-07T23:57:39','version'=>'3.0228' },{'date'=>'2017-03-10T14:08:07','version'=>'3.0229' },{'date'=>'2017-03-12T09:52:13','version'=>'3.0230' },{'date'=>'2017-03-29T09:51:51','version'=>'3.0231' },{'date'=>'2017-05-01T05:35:12','version'=>'3.0232' },{'date'=>'2017-05-01T14:54:56','version'=>'3.0233' },{'date'=>'2017-07-27T15:43:41','version'=>'3.0234' },{'date'=>'2017-07-27T16:21:47','version'=>'3.0235' },{'date'=>'2017-07-27T20:15:25','version'=>'3.0236' },{'date'=>'2017-07-28T11:15:05','version'=>'3.0237' },{'date'=>'2017-08-25T20:53:56','version'=>'3.0238' },{'date'=>'2017-08-28T20:48:37','version'=>'3.0239' },{'date'=>'2018-01-30T11:52:27','version'=>'3.99_01' },{'date'=>'2018-01-31T12:58:24','version'=>'3.99_02' },{'date'=>'2018-01-31T17:18:58','version'=>'3.99_03' },{'date'=>'2018-02-02T01:57:54','version'=>'4.00' },{'date'=>'2018-02-03T11:50:36','version'=>'4.01' },{'date'=>'2018-02-27T16:08:55','version'=>'4.02' },{'date'=>'2018-06-21T11:16:14','version'=>'4.03' },{'date'=>'2018-06-22T17:37:07','version'=>'4.04' },{'date'=>'2018-08-19T16:55:22','version'=>'4.05' },{'date'=>'2018-08-23T07:50:22','version'=>'4.06' },{'date'=>'2018-11-02T09:51:34','version'=>'4.07' },{'date'=>'2018-11-28T14:26:40','version'=>'4.08' },{'date'=>'2019-02-15T10:09:53','version'=>'4.09' }]},'Crypt-CBC'=>{'advisories'=>[{'affected_versions'=>'<2.17','description'=>'Incorrect use of using 8 byte IVs when generating the old-style RandomIV style header. This affects data encrypted using the Rijndael algorithm, which has a 16 byte blocksize, and is a significant security issue.
  ','distribution'=>'Crypt-CBC','fixed_versions'=>'>=2.17','id'=>'CPANSA-Crypt-CBC-2006-01','references'=>['https://metacpan.org/changes/distribution/Crypt-CBC' ],'reported'=>'2006-01-09','severity'=>'high' }],'main_module'=>'Crypt::CBC','versions'=>[{'date'=>'1998-06-19T19:48:52','version'=>'1.00' },{'date'=>'1998-09-22T18:30:35','version'=>'1.10' },{'date'=>'1998-12-20T23:36:49','version'=>'1.20' },{'date'=>'2000-01-27T00:27:56','version'=>'1.22' },{'date'=>'2000-02-22T15:20:56','version'=>'1.23' },{'date'=>'2000-06-07T18:55:59','version'=>'1.24' },{'date'=>'2000-06-08T15:59:07','version'=>'1.25' },{'date'=>'2001-12-10T17:16:25','version'=>'2.01' },{'date'=>'2002-01-24T05:30:16','version'=>'2.02' },{'date'=>'2002-06-02T18:40:15','version'=>'2.03' },{'date'=>'2002-06-12T02:20:51','version'=>'2.04' },{'date'=>'2002-06-22T13:02:09','version'=>'2.05' },{'date'=>'2002-08-08T18:47:49','version'=>'2.07' },{'date'=>'2002-09-11T12:17:23','version'=>'2.08' },{'date'=>'2004-05-27T15:20:52','version'=>'2.09' },{'date'=>'2004-05-29T17:29:19','version'=>'2.10' },{'date'=>'2004-06-03T16:22:32','version'=>'2.11' },{'date'=>'2004-06-17T15:55:19','version'=>'2.11' },{'date'=>'2005-05-05T20:11:50','version'=>'2.14' },{'date'=>'2005-08-01T14:02:45','version'=>'2.15' },{'date'=>'2006-02-16T14:08:57','version'=>'2.17' },{'date'=>'2006-06-06T23:22:02','version'=>'2.18' },{'date'=>'2006-08-12T19:52:11','version'=>'2.19' },{'date'=>'2006-10-16T23:40:13','version'=>'2.21' },{'date'=>'2006-10-29T21:55:34','version'=>'2.22' },{'date'=>'2007-09-28T15:25:53','version'=>'2.24' },{'date'=>'2008-03-28T14:17:29','version'=>'2.27' },{'date'=>'2008-03-31T14:56:52','version'=>'2.28' },{'date'=>'2008-04-22T14:27:07','version'=>'2.29' },{'date'=>'2008-09-30T15:17:58','version'=>'2.30' },{'date'=>'2012-10-30T11:08:06','version'=>'2.31' },{'date'=>'2012-12-14T19:30:14','version'=>'2.32' },{'date'=>'2013-07-30T20:03:53','version'=>'2.33' }]},'Crypt-OpenSSL-DSA'=>{'advisories'=>[{'affected_versions'=>'<0.14','cves'=>['CVE-2009-0129' ],'description'=>'Missing error check in do_verify, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature.
  ','distribution'=>'Crypt-OpenSSL-DSA','fixed_versions'=>'>=0.14','id'=>'CPANSA-Crypt-OpenSSL-DSA-2009-01','references'=>['https://metacpan.org/changes/distribution/Crypt-OpenSSL-DSA','https://www.openwall.com/lists/oss-security/2009/01/12/4','https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=511519' ],'reported'=>'2009-01-15' }],'main_module'=>'Crypt::OpenSSL::DSA','versions'=>[{'date'=>'2001-09-19T04:45:14','version'=>'0.01' },{'date'=>'2001-09-24T17:32:49','version'=>'0.02' },{'date'=>'2002-02-07T05:57:36','version'=>'0.03' },{'date'=>'2002-09-24T04:52:06','version'=>'0.04' },{'date'=>'2002-09-26T00:21:17','version'=>'0.10' },{'date'=>'2003-01-06T19:08:08','version'=>'0.11' },{'date'=>'2005-05-23T01:44:36','version'=>'0.12' },{'date'=>'2005-10-15T21:37:10','version'=>'0.13' },{'date'=>'2012-10-16T22:55:16','version'=>'0.14' },{'date'=>'2015-02-03T21:57:37','version'=>'0.15' },{'date'=>'2016-10-27T11:25:18','version'=>'0.16' },{'date'=>'2016-10-27T18:54:42','version'=>'0.17' },{'date'=>'2016-11-17T10:33:35','version'=>'0.18' },{'date'=>'2017-01-13T08:24:56','version'=>'0.19' }]},'Crypt-Passwd-XS'=>{'advisories'=>[{'affected_versions'=>'<0.601','cves'=>['CVE-2012-2143' ],'description'=>'The crypt_des (aka DES-based crypt) function does not process the complete cleartext password if this password contains a 0x80 character, which makes it easier for context-dependent attackers to obtain access via an authentication attempt with an initial substring of the intended password, as demonstrated by a Unicode password.
  ','distribution'=>'Crypt-Passwd-XS','fixed_versions'=>'>=0.601','id'=>'CPANSA-Crypt-Passwd-XS-2012-01','references'=>['https://metacpan.org/changes/distribution/Crypt-Passwd-XS' ],'reported'=>'2012-05-07' }],'main_module'=>'Crypt::Passwd::XS','versions'=>[{'date'=>'2010-11-14T21:18:18','version'=>'0.4' },{'date'=>'2010-11-17T02:03:54','version'=>'0.501' },{'date'=>'2010-11-17T23:25:17','version'=>'0.503' },{'date'=>'2010-11-20T00:37:33','version'=>'0.504' },{'date'=>'2010-11-24T00:59:34','version'=>'0.505' },{'date'=>'2011-03-09T16:18:01','version'=>'0.506' },{'date'=>'2011-03-09T21:40:38','version'=>'0.507' },{'date'=>'2011-07-26T16:37:20','version'=>'0.600' },{'date'=>'2012-12-06T19:57:57','version'=>'0.601' }]},'DBD-MariaDB'=>{'advisories'=>[{'affected_versions'=>'<1.00','cves'=>['CVE-2018-2767' ],'description'=>'SSL problems of MySQL and MariaDB clients.
  ','distribution'=>'DBD-MariaDB','fixed_versions'=>'>=1.00','id'=>'CPANSA-DBD-MariaDB-2018-01','references'=>['https://metacpan.org/changes/distribution/DBD-MariaDB' ],'reported'=>'2017-07-01' },{'affected_versions'=>'<1.00','cves'=>['CVE-2017-10788' ],'description'=>'Use-after-free after calling mysql_stmt_close().
  ','distribution'=>'DBD-MariaDB','fixed_versions'=>'>=1.00','id'=>'CPANSA-DBD-MariaDB-2017-02','references'=>['https://metacpan.org/changes/distribution/DBD-MariaDB' ],'reported'=>'2017-07-01' },{'affected_versions'=>'<1.00','cves'=>['CVE-2017-3302' ],'description'=>'Leaking dangling pointers.
  ','distribution'=>'DBD-MariaDB','fixed_versions'=>'>=1.00','id'=>'CPANSA-DBD-MariaDB-2017-01','references'=>['https://metacpan.org/changes/distribution/DBD-MariaDB' ],'reported'=>'2017-07-01' }],'main_module'=>'DBD::MariaDB','versions'=>[{'date'=>'2018-06-26T14:23:29','version'=>'0.90_01' },{'date'=>'2018-07-12T13:36:05','version'=>'1.00' },{'date'=>'2018-12-05T12:21:26','version'=>'1.10' },{'date'=>'2019-01-02T15:38:57','version'=>'1.11' },{'date'=>'2019-02-22T16:31:33','version'=>'1.20' },{'date'=>'2019-02-27T11:08:40','version'=>'1.21' }]},'DBD-mysql'=>{'advisories'=>[{'affected_versions'=>'<4.044','cves'=>['CVE-2017-10788' ],'description'=>'The DBD::mysql module through 4.043 for Perl allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact by triggering (1) certain error responses from a MySQL server or (2) a loss of a network connection to a MySQL server. The use-after-free defect was introduced by relying on incorrect Oracle mysql_stmt_close documentation and code examples.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.044','id'=>'CPANSA-DBD-mysql-2017-02','references'=>['https://github.com/perl5-dbi/DBD-mysql/issues/120' ],'reported'=>'2017-04-13' },{'affected_versions'=>'<4.044','cves'=>['CVE-2017-10789' ],'description'=>'The DBD::mysql module through 4.043 for Perl uses the mysql_ssl=1 setting to mean that SSL is optional (even though this setting\'s documentation has a "your communication with the server will be encrypted" statement), which allows man-in-the-middle attackers to spoof servers via a cleartext-downgrade attack, a related issue to CVE-2015-3152.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.044','id'=>'CPANSA-DBD-mysql-2017-01','references'=>['https://github.com/perl5-dbi/DBD-mysql/pull/114' ],'reported'=>'2017-03-23' },{'affected_versions'=>'>=2.9003, <4.039','cves'=>['CVE-2016-1249' ],'description'=>'Out-of-bounds read.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'<2.9003, >=4.039','id'=>'CPANSA-DBD-mysql-2016-03','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe' ],'reported'=>'2016-11-16' },{'affected_versions'=>'<4.037','cves'=>['CVE-2016-1246' ],'description'=>'Buffer overflow in the DBD::mysql module before 4.037 for Perl allows context-dependent attackers to cause a denial of service (crash) via vectors related to an error message.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.037','id'=>'CPANSA-DBD-mysql-2016-02','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/7c164a0c86cec6ee95df1d141e67b0e85dfdefd2','http://blogs.perl.org/users/mike_b/2016/10/security-release---buffer-overflow-in-dbdmysql-perl-library.html' ],'reported'=>'2016-10-02' },{'affected_versions'=>'<4.034','cves'=>['CVE-2015-8949' ],'description'=>'Use-after-free vulnerability in the my_login function in DBD::mysql before 4.033_01 allows attackers to have unspecified impact by leveraging a call to mysql_errno after a failure of my_login.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.034','id'=>'CPANSA-DBD-mysql-2016-01','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/cf0aa7751f6ef8445e9310a64b14dc81460ca156' ],'reported'=>'2016-08-19' },{'affected_versions'=>'<4.041','cves'=>['CVE-2016-1251' ],'description'=>'There is a vulnerability of type use-after-free affecting DBD::mysql (aka DBD-mysql or the Database Interface (DBI) MySQL driver for Perl) 3.x and 4.x before 4.041 when used with mysql_server_prepare=1.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.041','id'=>'CPANSA-DBD-mysql-2015-01','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/3619c170461a3107a258d1fd2d00ed4832adb1b1' ],'reported'=>'2015-12-27' },{'affected_versions'=>'<4.028','cves'=>['CVE-2014-9906' ],'description'=>'Use-after-free vulnerability in DBD::mysql before 4.029 allows attackers to cause a denial of service (program crash) or possibly execute arbitrary code via vectors related to a lost server connection.
  ','distribution'=>'DBD-mysql','fixed_versions'=>'>=4.028','id'=>'CPANSA-DBD-mysql-2014-01','references'=>['https://github.com/perl5-dbi/DBD-mysql/commit/a56ae87a4c1c1fead7d09c3653905841ccccf1cc','https://rt.cpan.org/Public/Bug/Display.html?id=97625' ],'reported'=>'2014-07-30' }],'main_module'=>'DBD::mysql','versions'=>[{'date'=>'2000-04-15T20:17:36','version'=>'v1.2212.' },{'date'=>'2001-05-06T21:47:46','version'=>'2.0900' },{'date'=>'2001-05-25T21:24:45','version'=>'2.0901' },{'date'=>'2001-07-09T21:10:17','version'=>'2.0902' },{'date'=>'2001-10-28T22:53:19','version'=>'2.0903' },{'date'=>'2001-10-31T04:01:07','version'=>'2.1000' },{'date'=>'2001-11-04T17:55:04','version'=>'2.1001' },{'date'=>'2001-11-04T18:22:30','version'=>'2.1002' },{'date'=>'2001-11-05T20:14:34','version'=>'2.1003' },{'date'=>'2001-11-13T01:24:26','version'=>'2.1004' },{'date'=>'2001-12-13T09:07:53','version'=>'2.1005' },{'date'=>'2001-12-27T18:10:04','version'=>'2.1007' },{'date'=>'2001-12-27T18:10:21','version'=>'2.1006' },{'date'=>'2001-12-28T17:06:05','version'=>'2.1008' },{'date'=>'2002-01-01T20:02:26','version'=>'2.1009' },{'date'=>'2002-01-07T21:33:21','version'=>'2.1010' },{'date'=>'2002-02-12T11:09:53','version'=>'2.1011' },{'date'=>'2002-04-12T07:21:06','version'=>'2.1012' },{'date'=>'2002-04-15T07:49:36','version'=>'2.1013' },{'date'=>'2002-04-17T21:24:26','version'=>'2.1014' },{'date'=>'2002-04-29T20:53:41','version'=>'2.1015' },{'date'=>'2002-05-01T20:07:05','version'=>'2.1016' },{'date'=>'2002-05-02T20:59:04','version'=>'2.1017' },{'date'=>'2002-08-13T17:52:25','version'=>'2.1018' },{'date'=>'2002-09-16T18:42:20','version'=>'2.1019' },{'date'=>'2002-09-23T20:42:50','version'=>'2.1020' },{'date'=>'2002-12-17T20:46:14','version'=>'2.1021' },{'date'=>'2003-01-03T02:46:24','version'=>'2.1022' },{'date'=>'2003-01-19T21:19:03','version'=>'2.1023' },{'date'=>'2003-01-20T12:08:27','version'=>'2.1024' },{'date'=>'2003-02-07T21:09:44','version'=>'2.1025' },{'date'=>'2003-03-03T20:46:27','version'=>'2.1026' },{'date'=>'2003-05-31T18:08:15','version'=>'2.1027' },{'date'=>'2003-06-25T16:12:36','version'=>'2.1028' },{'date'=>'2003-06-27T04:32:05','version'=>'2.9002' },{'date'=>'2003-09-12T17:04:42','version'=>'2.9003_1' },{'date'=>'2003-10-27T03:39:04','version'=>'2.9003' },{'date'=>'2004-07-01T03:24:14','version'=>'2.9004_2' },{'date'=>'2004-07-14T03:07:34','version'=>'2.9004' },{'date'=>'2004-10-20T17:27:25','version'=>'2.9005_1' },{'date'=>'2004-10-28T00:39:25','version'=>'2.9005_3' },{'date'=>'2005-03-29T02:43:14','version'=>'2.9005' },{'date'=>'2005-04-04T04:27:00','version'=>'2.9006' },{'date'=>'2005-04-27T00:13:49','version'=>'2.9015_3' },{'date'=>'2005-04-27T00:14:06','version'=>'2.9007' },{'date'=>'2005-06-06T01:39:20','version'=>'2.9008' },{'date'=>'2005-07-01T01:48:20','version'=>'3.0000' },{'date'=>'2005-07-03T21:56:11','version'=>'3.0000_0' },{'date'=>'2005-07-04T15:53:40','version'=>'3.0001_0' },{'date'=>'2005-07-04T16:16:00','version'=>'3.0001_1' },{'date'=>'2005-07-07T01:14:17','version'=>'3.0001' },{'date'=>'2005-07-07T01:22:39','version'=>'3.0001_2' },{'date'=>'2005-07-08T05:37:13','version'=>'3.0001_3' },{'date'=>'2005-07-11T16:49:47','version'=>'3.0002' },{'date'=>'2005-08-04T02:50:35','version'=>'3.0002_1' },{'date'=>'2005-09-26T23:22:57','version'=>'3.0002_2' },{'date'=>'2005-09-28T18:58:55','version'=>'3.0002_3' },{'date'=>'2005-11-06T21:47:29','version'=>'3.0002_4' },{'date'=>'2006-02-01T23:20:01','version'=>'3.0002_5' },{'date'=>'2006-05-04T17:49:06','version'=>'3.0003' },{'date'=>'2006-05-04T17:49:23','version'=>'3.0003_1' },{'date'=>'2006-05-21T17:28:22','version'=>'3.0004' },{'date'=>'2006-05-21T17:28:33','version'=>'3.0004_1' },{'date'=>'2006-06-10T01:21:49','version'=>'3.0005_1' },{'date'=>'2006-06-10T01:22:01','version'=>'3.0005' },{'date'=>'2006-06-11T17:05:25','version'=>'3.0006' },{'date'=>'2006-06-11T17:05:36','version'=>'3.0006_1' },{'date'=>'2006-09-08T23:12:02','version'=>'3.0007' },{'date'=>'2006-09-08T23:13:45','version'=>'3.0007_1' },{'date'=>'2006-10-07T12:59:23','version'=>'3.0007_2' },{'date'=>'2006-10-16T13:42:13','version'=>'3.0008' },{'date'=>'2006-10-16T13:42:24','version'=>'3.0008_1' },{'date'=>'2006-12-24T14:11:04','version'=>'4.00' },{'date'=>'2007-01-08T01:11:12','version'=>'4.001' },{'date'=>'2007-03-02T03:32:59','version'=>'4.002' },{'date'=>'2007-03-02T14:13:37','version'=>'4.003' },{'date'=>'2007-03-22T22:31:22','version'=>'4.004' },{'date'=>'2007-06-08T15:33:34','version'=>'4.005' },{'date'=>'2007-12-26T22:50:48','version'=>'4.006' },{'date'=>'2008-05-11T15:56:07','version'=>'4.007' },{'date'=>'2008-08-15T14:06:50','version'=>'4.008' },{'date'=>'2008-10-22T01:05:54','version'=>'4.009' },{'date'=>'2008-10-24T14:00:41','version'=>'4.010' },{'date'=>'2009-04-14T02:40:31','version'=>'4.011' },{'date'=>'2009-06-19T02:08:06','version'=>'4.012' },{'date'=>'2009-09-16T18:37:29','version'=>'4.013' },{'date'=>'2010-04-15T03:17:58','version'=>'4.014' },{'date'=>'2010-07-09T19:48:58','version'=>'4.015' },{'date'=>'2010-07-10T16:50:49','version'=>'4.016' },{'date'=>'2010-08-12T05:50:17','version'=>'4.017' },{'date'=>'2010-10-26T16:59:27','version'=>'4.018' },{'date'=>'2011-05-09T01:28:25','version'=>'4.019' },{'date'=>'2011-08-20T18:45:49','version'=>'4.020' },{'date'=>'2012-04-28T14:18:16','version'=>'4.021' },{'date'=>'2012-08-30T02:00:19','version'=>'4.022' },{'date'=>'2013-04-12T21:48:10','version'=>'4.023' },{'date'=>'2013-09-17T16:04:11','version'=>'4.024' },{'date'=>'2013-11-04T18:29:18','version'=>'4.025' },{'date'=>'2014-01-16T01:33:03','version'=>'4.026' },{'date'=>'2014-03-19T14:25:36','version'=>'4.027' },{'date'=>'2014-08-01T19:59:28','version'=>'4.028' },{'date'=>'2014-12-09T02:39:44','version'=>'4.029' },{'date'=>'2015-01-28T03:53:42','version'=>'4.030_01' },{'date'=>'2015-03-02T20:44:31','version'=>'4.030_02' },{'date'=>'2015-03-06T20:12:05','version'=>'4.031' },{'date'=>'2015-04-16T22:28:43','version'=>'4.032_01' },{'date'=>'2015-07-21T12:15:24','version'=>'4.032' },{'date'=>'2015-10-25T19:59:17','version'=>'4.032_03' },{'date'=>'2015-10-27T03:37:29','version'=>'4.033' },{'date'=>'2015-12-15T07:16:36','version'=>'4.033_01' },{'date'=>'2015-12-18T07:00:41','version'=>'4.033_02' },{'date'=>'2016-07-04T19:32:50','version'=>'4.033_03' },{'date'=>'2016-07-06T06:32:05','version'=>'4.034' },{'date'=>'2016-07-09T05:50:13','version'=>'4.035' },{'date'=>'2016-08-01T06:29:25','version'=>'4.035_01' },{'date'=>'2016-08-11T08:11:18','version'=>'4.035_02' },{'date'=>'2016-08-19T15:52:10','version'=>'4.035_03' },{'date'=>'2016-08-23T05:59:26','version'=>'4.036' },{'date'=>'2016-10-03T07:00:29','version'=>'4.037' },{'date'=>'2016-10-14T20:56:49','version'=>'4.037_01' },{'date'=>'2016-10-19T19:37:55','version'=>'4.037_02' },{'date'=>'2016-10-20T02:33:04','version'=>'4.038' },{'date'=>'2016-10-30T08:45:31','version'=>'4.038_01' },{'date'=>'2016-11-16T03:57:57','version'=>'4.039' },{'date'=>'2016-11-19T19:56:51','version'=>'4.040' },{'date'=>'2016-11-28T20:40:41','version'=>'4.041' },{'date'=>'2016-12-13T06:59:09','version'=>'4.041_01' },{'date'=>'2017-02-28T20:57:20','version'=>'4.041_02' },{'date'=>'2017-03-08T20:32:52','version'=>'4.042' },{'date'=>'2017-06-29T21:12:09','version'=>'4.043' },{'date'=>'2018-01-23T01:53:30','version'=>'4.044' },{'date'=>'2018-02-07T21:43:00','version'=>'4.044' },{'date'=>'2018-02-08T20:30:55','version'=>'4.045' },{'date'=>'2018-02-08T20:48:11','version'=>'4.046' },{'date'=>'2018-03-09T20:27:44','version'=>'4.046_01' },{'date'=>'2018-09-09T03:02:20','version'=>'4.047' },{'date'=>'2018-09-15T12:46:51','version'=>'4.048' },{'date'=>'2018-11-17T18:58:09','version'=>'4.049' },{'date'=>'2019-01-09T09:07:15','version'=>'4.050' }]},'DBD-mysqlPP'=>{'advisories'=>[{'affected_versions'=>'<0.93','description'=>'SQL injection.
  ','distribution'=>'DBD-mysqlPP','fixed_versions'=>'>=0.03','id'=>'CPANSA-DBD-mysqlPP-2011-01','references'=>['https://metacpan.org/changes/distribution/DBD-mysqlPP','https://jvn.jp/en/jp/JVN51216285/index.html' ],'reported'=>'2011-10-14','severity'=>'high' }],'main_module'=>'DBD::mysqlPP','versions'=>[{'date'=>'2002-04-04T07:20:36','version'=>'0.02' },{'date'=>'2002-04-15T10:26:39','version'=>'0.03' },{'date'=>'2003-01-24T11:14:14','version'=>'0.04' },{'date'=>'2011-10-21T23:07:07','version'=>'0.05' },{'date'=>'2011-10-26T22:17:22','version'=>'0.06' },{'date'=>'2011-11-17T22:24:50','version'=>'0.07' }]},'DBI'=>{'advisories'=>[{'affected_versions'=>'<1.632','description'=>'DBD::File drivers open files from folders other than specifically passed using the f_dir attribute.
  ','distribution'=>'DBI','fixed_versions'=>'>=1.632','id'=>'CPANSA-DBI-2014-01','references'=>['https://metacpan.org/changes/distribution/DBI','https://rt.cpan.org/Public/Bug/Display.html?id=99508' ],'reported'=>'2014-10-15','severity'=>'high' },{'affected_versions'=>'<1.47','cves'=>['CVE-2005-0077' ],'description'=>'Allows local users to overwrite arbitrary files via a symlink attack on a temporary PID file.
  ','distribution'=>'DBI','fixed_versions'=>'>=1.47','id'=>'CPANSA-DBI-2005-01','references'=>['https://metacpan.org/changes/distribution/DBI' ],'reported'=>'2005-05-02' }],'main_module'=>'DBI','versions'=>[{'date'=>'1995-10-27T08:14:00','version'=>'0.64' },{'date'=>'1996-02-15T22:07:00','version'=>'0.67' },{'date'=>'1996-04-22T10:22:00','version'=>'0.68' },{'date'=>'1996-05-07T19:46:00','version'=>'0.69' },{'date'=>'1996-06-16T21:08:00','version'=>'0.70' },{'date'=>'1996-07-10T00:49:00','version'=>'0.71' },{'date'=>'1996-09-23T16:33:00','version'=>'0.72' },{'date'=>'1996-10-15T00:58:00','version'=>'0.73' },{'date'=>'1997-01-14T16:59:00','version'=>'0.74' },{'date'=>'1997-01-27T21:59:00','version'=>'0.75' },{'date'=>'1997-02-03T18:54:00','version'=>'0.76' },{'date'=>'1997-02-21T14:27:00','version'=>'0.77' },{'date'=>'1997-03-28T14:36:00','version'=>'0.78' },{'date'=>'1997-04-07T18:28:00','version'=>'0.79' },{'date'=>'1997-05-07T11:45:00','version'=>'0.80' },{'date'=>'1997-05-07T14:05:00','version'=>'0.81' },{'date'=>'1997-05-23T15:56:00','version'=>'0.82' },{'date'=>'1997-06-11T21:40:00','version'=>'0.83' },{'date'=>'1997-06-20T15:36:00','version'=>'0.84' },{'date'=>'1997-06-25T10:25:00','version'=>'0.85' },{'date'=>'1997-07-16T16:38:00','version'=>'0.001' },{'date'=>'1997-07-18T11:27:00','version'=>'0.87' },{'date'=>'1997-07-22T21:27:00','version'=>'0.88' },{'date'=>'1997-07-25T13:46:55','version'=>'0.89' },{'date'=>'1997-09-05T19:38:52','version'=>'0.90' },{'date'=>'1997-12-10T17:15:14','version'=>'0.91' },{'date'=>'1998-02-05T20:45:45','version'=>'0.92' },{'date'=>'1998-02-13T15:21:52','version'=>'0.93' },{'date'=>'1998-08-10T03:23:46','version'=>'0.94' },{'date'=>'1998-08-11T13:21:19','version'=>'0.95' },{'date'=>'1998-08-14T20:38:42','version'=>'1.00' },{'date'=>'1998-09-02T14:59:47','version'=>'1.01' },{'date'=>'1998-09-04T12:29:52','version'=>'1.02' },{'date'=>'1999-01-18T21:52:15','version'=>'1.06' },{'date'=>'1999-05-13T01:49:11','version'=>'1.08' },{'date'=>'1999-06-02T13:44:40','version'=>'1.08' },{'date'=>'1999-06-09T20:57:59','version'=>'1.09' },{'date'=>'1999-06-13T23:52:03','version'=>'1.10' },{'date'=>'1999-06-17T13:22:36','version'=>'1.11' },{'date'=>'1999-06-29T23:07:41','version'=>'1.12' },{'date'=>'1999-07-12T03:28:41','version'=>'1.13' },{'date'=>'2000-06-11T02:39:59','version'=>'1.03_80' },{'date'=>'2000-06-14T20:30:57','version'=>'1.14' },{'date'=>'2001-03-30T15:03:31','version'=>'1.15' },{'date'=>'2001-05-29T23:25:57','version'=>'1.16' },{'date'=>'2001-06-04T17:12:30','version'=>'1.17' },{'date'=>'2001-06-04T19:00:37','version'=>'1.18' },{'date'=>'2001-07-20T22:29:24','version'=>'1.19' },{'date'=>'2001-08-24T23:32:10','version'=>'1.20' },{'date'=>'2002-01-10T15:25:45','version'=>'1.201' },{'date'=>'2002-02-07T03:30:16','version'=>'1.21' },{'date'=>'2002-03-13T14:18:00','version'=>'1.21' },{'date'=>'2002-05-22T13:42:15','version'=>'1.22' },{'date'=>'2002-05-25T17:38:03','version'=>'1.23' },{'date'=>'2002-06-05T03:32:38','version'=>'1.24' },{'date'=>'2002-06-05T22:42:04','version'=>'1.25' },{'date'=>'2002-06-13T12:30:47','version'=>'1.26' },{'date'=>'2002-06-13T15:19:06','version'=>'1.27' },{'date'=>'2002-06-14T13:13:53','version'=>'1.28' },{'date'=>'2002-06-26T09:34:24','version'=>'1.28' },{'date'=>'2002-07-15T11:24:40','version'=>'1.29' },{'date'=>'2002-07-18T14:27:25','version'=>'1.30' },{'date'=>'2002-11-30T00:49:54','version'=>'1.31' },{'date'=>'2002-12-01T23:01:26','version'=>'1.32' },{'date'=>'2002-12-20T16:23:29','version'=>'1.32' },{'date'=>'2003-02-26T18:01:24','version'=>'1.32_90' },{'date'=>'2003-02-27T00:25:32','version'=>'1.33' },{'date'=>'2003-02-28T17:53:35','version'=>'1.34' },{'date'=>'2003-03-07T22:02:20','version'=>'1.35' },{'date'=>'2003-05-14T11:13:39','version'=>'1.36' },{'date'=>'2003-05-15T18:02:26','version'=>'1.37' },{'date'=>'2003-08-25T20:36:26','version'=>'1.38' },{'date'=>'2003-11-27T23:46:40','version'=>'1.39' },{'date'=>'2004-01-08T14:04:59','version'=>'1.39' },{'date'=>'2004-02-23T14:54:21','version'=>'1.41' },{'date'=>'2004-03-12T16:40:08','version'=>'1.41' },{'date'=>'2004-07-05T10:02:05','version'=>'1.43' },{'date'=>'2004-10-05T21:27:23','version'=>'1.44' },{'date'=>'2004-10-06T13:49:20','version'=>'1.45' },{'date'=>'2004-11-16T12:38:32','version'=>'1.46' },{'date'=>'2005-02-02T11:28:46','version'=>'1.47' },{'date'=>'2005-03-14T17:03:33','version'=>'1.48' },{'date'=>'2005-11-29T19:59:40','version'=>'1.49' },{'date'=>'2005-12-14T16:55:16','version'=>'1.50' },{'date'=>'2006-04-19T15:56:38','version'=>'1.45' },{'date'=>'2006-06-06T12:08:36','version'=>'1.51' },{'date'=>'2006-08-08T21:13:32','version'=>'1.52' },{'date'=>'2006-11-02T00:38:01','version'=>'1.53' },{'date'=>'2007-02-23T17:15:23','version'=>'1.54' },{'date'=>'2007-05-04T14:56:38','version'=>'1.55' },{'date'=>'2007-05-10T14:04:04','version'=>'1.56' },{'date'=>'2007-05-13T22:00:58','version'=>'1.56' },{'date'=>'2007-06-13T16:45:34','version'=>'1.57' },{'date'=>'2007-06-15T17:06:42','version'=>'1.57' },{'date'=>'2007-06-18T15:15:31','version'=>'1.57' },{'date'=>'2007-06-25T22:11:47','version'=>'1.58' },{'date'=>'2007-08-22T17:02:10','version'=>'1.59' },{'date'=>'2007-08-23T12:22:26','version'=>'1.59' },{'date'=>'2007-08-23T13:59:53','version'=>'1.59' },{'date'=>'2007-08-24T09:19:29','version'=>'1.59' },{'date'=>'2007-10-16T13:12:55','version'=>'1.601' },{'date'=>'2007-10-21T22:12:52','version'=>'1.601' },{'date'=>'2008-02-09T22:06:13','version'=>'1.602' },{'date'=>'2008-03-22T00:11:03','version'=>'1.603' },{'date'=>'2008-03-24T14:11:41','version'=>'1.604' },{'date'=>'2008-06-16T19:19:43','version'=>'1.605' },{'date'=>'2008-07-22T21:01:09','version'=>'1.606' },{'date'=>'2008-07-22T21:50:54','version'=>'1.607' },{'date'=>'2009-05-02T22:58:48','version'=>'1.608' },{'date'=>'2009-05-05T12:05:19','version'=>'1.608' },{'date'=>'2009-06-05T22:57:34','version'=>'1.609' },{'date'=>'2009-06-08T10:29:18','version'=>'1.609' },{'date'=>'2010-03-02T21:26:39','version'=>'1.611' },{'date'=>'2010-04-22T11:06:31','version'=>'1.611' },{'date'=>'2010-04-27T15:13:32','version'=>'1.611' },{'date'=>'2010-04-29T19:54:44','version'=>'1.611' },{'date'=>'2010-05-28T10:29:17','version'=>'1.612' },{'date'=>'2010-06-15T22:47:23','version'=>'1.612' },{'date'=>'2010-06-16T19:18:05','version'=>'1.612' },{'date'=>'2010-07-02T14:26:03','version'=>'1.612' },{'date'=>'2010-07-15T15:00:53','version'=>'1.612' },{'date'=>'2010-07-16T19:36:42','version'=>'1.612' },{'date'=>'2010-07-22T17:34:16','version'=>'1.613' },{'date'=>'2010-07-25T15:50:15','version'=>'1.613' },{'date'=>'2010-07-30T14:17:33','version'=>'1.614' },{'date'=>'2010-08-16T16:34:58','version'=>'1.614' },{'date'=>'2010-08-30T20:11:00','version'=>'1.614' },{'date'=>'2010-08-30T20:26:37','version'=>'1.614' },{'date'=>'2010-08-30T20:56:09','version'=>'1.614' },{'date'=>'2010-09-02T15:44:21','version'=>'1.614' },{'date'=>'2010-09-09T10:24:11','version'=>'1.614' },{'date'=>'2010-09-16T16:23:50','version'=>'1.614' },{'date'=>'2010-09-17T09:48:02','version'=>'1.614' },{'date'=>'2010-09-21T10:14:29','version'=>'1.615' },{'date'=>'2010-09-22T12:28:20','version'=>'1.615' },{'date'=>'2010-12-18T21:51:52','version'=>'1.616' },{'date'=>'2010-12-21T23:26:46','version'=>'1.616' },{'date'=>'2010-12-29T14:39:48','version'=>'1.616' },{'date'=>'2010-12-30T10:26:51','version'=>'1.616' },{'date'=>'2012-01-02T17:12:53','version'=>'1.617' },{'date'=>'2012-01-28T09:34:18','version'=>'1.617' },{'date'=>'2012-01-30T10:06:49','version'=>'1.617' },{'date'=>'2012-02-07T22:54:02','version'=>'1.618' },{'date'=>'2012-02-13T18:24:33','version'=>'1.618' },{'date'=>'2012-02-23T11:05:45','version'=>'1.618' },{'date'=>'2012-02-25T14:24:39','version'=>'1.618' },{'date'=>'2012-04-18T11:57:55','version'=>'1.619' },{'date'=>'2012-04-20T20:21:54','version'=>'1.619' },{'date'=>'2012-04-23T22:09:14','version'=>'1.619' },{'date'=>'2012-04-25T12:46:54','version'=>'1.620' },{'date'=>'2012-05-21T13:06:09','version'=>'1.621' },{'date'=>'2012-05-22T22:17:06','version'=>'1.621' },{'date'=>'2012-06-06T16:51:00','version'=>'1.622' },{'date'=>'2012-07-13T15:24:35','version'=>'1.623' },{'date'=>'2012-10-30T13:01:14','version'=>'1.623' },{'date'=>'2012-11-19T23:27:04','version'=>'1.623' },{'date'=>'2012-12-13T16:26:23','version'=>'1.623' },{'date'=>'2012-12-21T17:22:01','version'=>'1.623' },{'date'=>'2013-01-02T10:09:42','version'=>'1.623' },{'date'=>'2013-03-22T20:41:50','version'=>'1.624' },{'date'=>'2013-03-28T21:59:38','version'=>'1.625' },{'date'=>'2013-05-15T11:28:03','version'=>'1.626' },{'date'=>'2013-05-16T20:30:50','version'=>'1.627' },{'date'=>'2013-06-24T21:56:27','version'=>'1.628' },{'date'=>'2013-06-24T22:12:23','version'=>'1.628' },{'date'=>'2013-06-30T19:08:08','version'=>'1.628' },{'date'=>'2013-07-02T11:27:23','version'=>'1.628' },{'date'=>'2013-07-22T13:22:40','version'=>'1.628' },{'date'=>'2013-10-11T12:28:12','version'=>'1.629' },{'date'=>'2013-10-13T16:02:52','version'=>'1.629' },{'date'=>'2013-10-15T12:24:53','version'=>'1.629' },{'date'=>'2013-10-22T11:58:53','version'=>'1.629_50' },{'date'=>'2013-10-28T12:51:39','version'=>'1.630' },{'date'=>'2014-01-13T13:51:01','version'=>'1.631' },{'date'=>'2014-01-16T11:34:34','version'=>'1.631' },{'date'=>'2014-01-20T11:12:44','version'=>'1.631' },{'date'=>'2014-10-23T14:08:22','version'=>'1.631' },{'date'=>'2014-11-05T11:15:07','version'=>'1.632' },{'date'=>'2015-01-08T14:31:52','version'=>'1.632' },{'date'=>'2015-01-11T13:26:05','version'=>'1.633' },{'date'=>'2015-07-18T13:16:07','version'=>'1.633' },{'date'=>'2015-07-19T14:34:22','version'=>'1.633_91' },{'date'=>'2015-07-22T15:27:59','version'=>'1.633_92' },{'date'=>'2015-08-02T16:52:48','version'=>'1.633_93' },{'date'=>'2015-08-03T14:52:56','version'=>'1.634' },{'date'=>'2016-04-23T15:28:02','version'=>'1.634' },{'date'=>'2016-04-24T11:57:03','version'=>'1.635' },{'date'=>'2016-04-24T22:20:56','version'=>'1.636' },{'date'=>'2017-08-14T10:10:55','version'=>'1.637' },{'date'=>'2017-08-16T09:02:40','version'=>'1.637' },{'date'=>'2017-12-28T14:40:44','version'=>'1.639' },{'date'=>'2018-01-28T20:50:53','version'=>'1.640' },{'date'=>'2018-03-19T18:06:08','version'=>'1.641' },{'date'=>'2018-10-28T15:08:54','version'=>'1.641_90' },{'date'=>'2018-10-29T10:43:41','version'=>'1.642' }]},'DBIx-Custom'=>{'advisories'=>[{'affected_versions'=>'<0.1641','description'=>'SQL injection when passing special column names.
  ','distribution'=>'DBIx-Custom','fixed_versions'=>'>=0.1641','id'=>'CPANSA-DBIx-Custom-2011-01','references'=>['https://metacpan.org/changes/distribution/DBIx-Custom','https://github.com/yuki-kimoto/DBIx-Custom/commit/5b00b9f9a966e7abecabd91710c8fa893784d919' ],'reported'=>'2011-01-27','severity'=>'high' }],'main_module'=>'DBIx::Custom','versions'=>[{'date'=>'2009-11-08T04:18:19','version'=>'0.0101' },{'date'=>'2009-11-09T10:46:44','version'=>'0.0201' },{'date'=>'2009-11-12T14:12:47','version'=>'0.0301' },{'date'=>'2009-11-15T11:43:40','version'=>'0.0401' },{'date'=>'2009-11-16T11:10:52','version'=>'0.0501' },{'date'=>'2009-11-17T12:37:33','version'=>'0.0502' },{'date'=>'2009-11-19T12:05:50','version'=>'0.0601' },{'date'=>'2009-11-19T13:37:39','version'=>'0.0602' },{'date'=>'2009-11-20T12:08:31','version'=>'0.0603' },{'date'=>'2009-11-23T13:39:53','version'=>'0.0604' },{'date'=>'2009-11-23T14:45:46','version'=>'0.0605' },{'date'=>'2009-11-25T13:57:52','version'=>'0.0701' },{'date'=>'2009-12-01T07:30:25','version'=>'0.0702' },{'date'=>'2009-12-02T13:59:36','version'=>'0.0801' },{'date'=>'2009-12-09T14:27:53','version'=>'0.0901' },{'date'=>'2009-12-22T13:40:07','version'=>'0.0902' },{'date'=>'2010-01-18T12:42:57','version'=>'0.0903' },{'date'=>'2010-01-21T14:29:12','version'=>'0.0904' },{'date'=>'2010-01-22T12:51:23','version'=>'0.0905' },{'date'=>'2010-01-24T09:49:30','version'=>'0.0906' },{'date'=>'2010-01-30T00:15:17','version'=>'0.1001' },{'date'=>'2010-01-30T03:51:04','version'=>'0.1101' },{'date'=>'2010-05-01T13:02:19','version'=>'0.1301' },{'date'=>'2010-05-01T23:29:22','version'=>'0.1401' },{'date'=>'2010-05-02T06:04:57','version'=>'0.1402' },{'date'=>'2010-05-26T15:13:04','version'=>'0.1501' },{'date'=>'2010-05-27T14:00:04','version'=>'0.1502' },{'date'=>'2010-05-28T13:28:16','version'=>'0.1503' },{'date'=>'2010-06-25T12:11:33','version'=>'0.1602' },{'date'=>'2010-07-14T13:55:33','version'=>'0.1603' },{'date'=>'2010-08-03T14:43:14','version'=>'0.1604' },{'date'=>'2010-08-05T15:17:49','version'=>'0.1605' },{'date'=>'2010-08-05T15:24:36','version'=>'0.1606' },{'date'=>'2010-08-06T14:57:35','version'=>'0.1607' },{'date'=>'2010-08-07T05:49:19','version'=>'0.1608' },{'date'=>'2010-08-08T04:45:12','version'=>'0.1609' },{'date'=>'2010-08-08T12:44:43','version'=>'0.1610' },{'date'=>'2010-08-09T12:08:31','version'=>'0.1611' },{'date'=>'2010-08-10T11:19:41','version'=>'0.1612' },{'date'=>'2010-08-10T12:35:17','version'=>'0.1613' },{'date'=>'2010-08-12T15:01:01','version'=>'0.1614' },{'date'=>'2010-08-15T04:00:44','version'=>'0.1615' },{'date'=>'2010-08-24T10:18:06','version'=>'0.1616' },{'date'=>'2010-09-07T12:12:04','version'=>'0.1617' },{'date'=>'2010-10-17T05:44:56','version'=>'0.1618' },{'date'=>'2010-10-20T15:01:35','version'=>'0.1619' },{'date'=>'2010-10-21T14:38:05','version'=>'0.1620' },{'date'=>'2010-11-10T06:54:46','version'=>'0.1621' },{'date'=>'2010-12-20T14:58:38','version'=>'0.1622' },{'date'=>'2010-12-21T16:10:25','version'=>'0.1623' },{'date'=>'2010-12-22T08:41:09','version'=>'0.1624' },{'date'=>'2011-01-01T16:08:48','version'=>'0.1625' },{'date'=>'2011-01-02T04:21:11','version'=>'0.1626' },{'date'=>'2011-01-04T15:18:21','version'=>'0.1627' },{'date'=>'2011-01-12T07:29:29','version'=>'0.1628' },{'date'=>'2011-01-12T15:35:11','version'=>'0.1629' },{'date'=>'2011-01-13T15:41:25','version'=>'0.1630' },{'date'=>'2011-01-17T15:53:44','version'=>'0.1631' },{'date'=>'2011-01-18T14:43:16','version'=>'0.1632' },{'date'=>'2011-01-18T15:22:37','version'=>'0.1633' },{'date'=>'2011-01-19T14:52:48','version'=>'0.1634' },{'date'=>'2011-01-21T14:04:02','version'=>'0.1635' },{'date'=>'2011-01-22T13:02:55','version'=>'0.1636' },{'date'=>'2011-01-24T12:58:40','version'=>'0.1637' },{'date'=>'2011-01-25T12:32:26','version'=>'0.1638' },{'date'=>'2011-01-26T09:23:22','version'=>'0.1639' },{'date'=>'2011-01-26T13:59:10','version'=>'0.1640' },{'date'=>'2011-01-27T05:19:14','version'=>'0.1641' },{'date'=>'2011-01-28T12:18:42','version'=>'0.1642' },{'date'=>'2011-02-09T08:54:11','version'=>'0.1643' },{'date'=>'2011-02-11T14:07:25','version'=>'0.1644' },{'date'=>'2011-02-14T15:24:30','version'=>'0.1645' },{'date'=>'2011-02-18T17:48:52','version'=>'0.1646' },{'date'=>'2011-02-19T00:30:41','version'=>'0.1647' },{'date'=>'2011-02-21T16:13:29','version'=>'0.1648' },{'date'=>'2011-02-22T14:53:08','version'=>'0.1649' },{'date'=>'2011-02-24T05:45:44','version'=>'0.1650' },{'date'=>'2011-02-24T14:35:20','version'=>'0.1651' },{'date'=>'2011-02-25T14:39:56','version'=>'0.1652' },{'date'=>'2011-02-28T13:18:03','version'=>'0.1653' },{'date'=>'2011-03-06T14:32:11','version'=>'0.1654' },{'date'=>'2011-03-08T14:59:08','version'=>'0.1655' },{'date'=>'2011-03-09T13:44:35','version'=>'0.1656' },{'date'=>'2011-03-10T15:44:50','version'=>'0.1657' },{'date'=>'2011-03-11T16:23:11','version'=>'0.1658' },{'date'=>'2011-03-12T08:20:07','version'=>'0.1659' },{'date'=>'2011-03-14T11:16:27','version'=>'0.1660' },{'date'=>'2011-03-15T16:32:52','version'=>'0.1661' },{'date'=>'2011-03-19T14:40:50','version'=>'0.1662' },{'date'=>'2011-03-21T03:53:25','version'=>'0.1663' },{'date'=>'2011-03-24T14:45:52','version'=>'0.1664' },{'date'=>'2011-03-25T14:25:43','version'=>'0.1665' },{'date'=>'2011-03-29T17:26:27','version'=>'0.1666' },{'date'=>'2011-03-30T08:03:39','version'=>'0.1667' },{'date'=>'2011-03-30T15:04:03','version'=>'0.1668' },{'date'=>'2011-03-30T15:25:45','version'=>'0.1669' },{'date'=>'2011-04-01T15:29:33','version'=>'0.1670' },{'date'=>'2011-04-02T16:31:44','version'=>'0.1671' },{'date'=>'2011-04-04T13:37:34','version'=>'0.1672' },{'date'=>'2011-04-05T11:45:54','version'=>'0.1673' },{'date'=>'2011-04-05T11:59:11','version'=>'0.1674' },{'date'=>'2011-04-11T13:47:34','version'=>'0.1675' },{'date'=>'2011-04-11T14:55:38','version'=>'0.1676' },{'date'=>'2011-04-12T15:17:24','version'=>'0.1677' },{'date'=>'2011-04-18T13:36:31','version'=>'0.1678' },{'date'=>'2011-04-19T11:07:27','version'=>'0.1679' },{'date'=>'2011-04-25T14:05:23','version'=>'0.1680' },{'date'=>'2011-04-26T14:07:02','version'=>'0.1681' },{'date'=>'2011-05-23T14:40:41','version'=>'0.1682' },{'date'=>'2011-06-06T11:52:44','version'=>'0.1683' },{'date'=>'2011-06-07T13:07:20','version'=>'0.1684' },{'date'=>'2011-06-08T10:32:35','version'=>'0.1685' },{'date'=>'2011-06-08T12:24:07','version'=>'0.1686' },{'date'=>'2011-06-09T13:59:44','version'=>'0.1687' },{'date'=>'2011-06-10T13:26:20','version'=>'0.1688' },{'date'=>'2011-06-12T03:22:26','version'=>'0.1689' },{'date'=>'2011-06-12T12:01:43','version'=>'0.1690' },{'date'=>'2011-06-13T13:31:21','version'=>'0.1691' },{'date'=>'2011-06-14T13:27:31','version'=>'0.1692' },{'date'=>'2011-06-15T08:51:43','version'=>'0.1693' },{'date'=>'2011-06-17T14:38:23','version'=>'0.1694' },{'date'=>'2011-06-20T13:08:47','version'=>'0.1695' },{'date'=>'2011-06-21T13:12:38','version'=>'0.1696' },{'date'=>'2011-06-24T13:42:00','version'=>'0.1697' },{'date'=>'2011-06-27T13:23:13','version'=>'0.1698' },{'date'=>'2011-06-28T14:39:21','version'=>'0.1699' },{'date'=>'2011-07-01T11:04:37','version'=>'0.1700' },{'date'=>'2011-07-11T13:19:20','version'=>'0.1701' },{'date'=>'2011-07-26T14:09:43','version'=>'0.1702' },{'date'=>'2011-07-28T04:59:20','version'=>'0.1703' },{'date'=>'2011-07-29T13:45:24','version'=>'0.1704' },{'date'=>'2011-07-29T14:35:38','version'=>'0.1705' },{'date'=>'2011-07-30T04:25:21','version'=>'0.1706' },{'date'=>'2011-07-30T05:16:05','version'=>'0.1707' },{'date'=>'2011-07-30T14:32:34','version'=>'0.1708' },{'date'=>'2011-08-01T12:48:52','version'=>'0.1709' },{'date'=>'2011-08-02T13:30:15','version'=>'0.1710' },{'date'=>'2011-08-09T14:11:24','version'=>'0.1711' },{'date'=>'2011-08-10T16:16:52','version'=>'0.1712' },{'date'=>'2011-08-12T13:45:58','version'=>'0.1713' },{'date'=>'2011-08-13T13:38:02','version'=>'0.1714' },{'date'=>'2011-08-14T03:47:28','version'=>'0.1715' },{'date'=>'2011-08-15T14:00:28','version'=>'0.1716' },{'date'=>'2011-08-16T04:03:16','version'=>'0.1717' },{'date'=>'2011-08-20T09:40:46','version'=>'0.1718' },{'date'=>'2011-08-22T13:43:21','version'=>'0.1720' },{'date'=>'2011-08-26T14:11:53','version'=>'0.1721' },{'date'=>'2011-09-02T15:12:10','version'=>'0.1722' },{'date'=>'2011-09-12T12:24:14','version'=>'0.1723' },{'date'=>'2011-09-16T15:15:54','version'=>'0.1724' },{'date'=>'2011-09-27T11:48:33','version'=>'0.1725' },{'date'=>'2011-09-30T11:21:45','version'=>'0.1726' },{'date'=>'2011-10-03T10:43:32','version'=>'0.1727' },{'date'=>'2011-10-05T04:10:35','version'=>'0.1728' },{'date'=>'2011-10-05T08:12:55','version'=>'0.1729' },{'date'=>'2011-10-10T11:35:23','version'=>'0.1730' },{'date'=>'2011-10-11T14:30:46','version'=>'0.1731' },{'date'=>'2011-10-20T11:56:08','version'=>'0.1732' },{'date'=>'2011-10-21T22:47:50','version'=>'0.1733' },{'date'=>'2011-10-22T22:02:37','version'=>'0.1734' },{'date'=>'2011-10-23T00:11:48','version'=>'0.1735' },{'date'=>'2011-10-23T13:08:15','version'=>'0.1736' },{'date'=>'2011-10-24T14:07:44','version'=>'0.1737' },{'date'=>'2011-10-25T14:31:15','version'=>'0.1738' },{'date'=>'2011-10-26T01:14:58','version'=>'0.1739' },{'date'=>'2011-10-27T12:59:00','version'=>'0.1740' },{'date'=>'2011-10-28T11:49:57','version'=>'0.1741' },{'date'=>'2011-10-31T15:37:07','version'=>'0.1742' },{'date'=>'2011-11-01T12:02:38','version'=>'0.1743' },{'date'=>'2011-11-03T13:38:04','version'=>'0.1744' },{'date'=>'2011-11-04T14:16:11','version'=>'0.1745' },{'date'=>'2011-11-07T12:19:53','version'=>'0.1746' },{'date'=>'2011-11-11T11:59:27','version'=>'0.1747' },{'date'=>'2011-11-16T00:36:45','version'=>'0.20_01' },{'date'=>'2011-11-16T08:50:11','version'=>'0.2100' },{'date'=>'2011-11-21T11:05:36','version'=>'0.2101' },{'date'=>'2011-11-25T14:34:26','version'=>'0.2102' },{'date'=>'2011-11-28T10:38:56','version'=>'0.2103' },{'date'=>'2011-11-29T13:48:49','version'=>'0.2104' },{'date'=>'2012-01-14T13:39:10','version'=>'0.2105' },{'date'=>'2012-01-20T15:16:34','version'=>'0.2106' },{'date'=>'2012-01-25T08:56:44','version'=>'0.2107' },{'date'=>'2012-01-29T14:30:53','version'=>'0.2108' },{'date'=>'2012-02-07T13:31:49','version'=>'0.2109' },{'date'=>'2012-02-10T14:51:17','version'=>'0.2110' },{'date'=>'2012-02-11T14:45:41','version'=>'0.2111' },{'date'=>'2012-02-28T14:33:03','version'=>'0.22' },{'date'=>'2012-03-01T00:07:11','version'=>'0.23' },{'date'=>'2012-03-02T14:57:03','version'=>'0.24' },{'date'=>'2012-03-19T11:58:43','version'=>'0.25' },{'date'=>'2012-07-11T08:20:53','version'=>'0.26' },{'date'=>'2012-09-17T13:15:26','version'=>'0.27' },{'date'=>'2013-03-04T11:25:17','version'=>'0.28' },{'date'=>'2014-02-03T09:21:29','version'=>'0.29' },{'date'=>'2014-02-04T00:17:32','version'=>'0.30' },{'date'=>'2015-01-13T01:36:24','version'=>'0.31' },{'date'=>'2015-01-13T05:24:10','version'=>'0.32' },{'date'=>'2015-01-13T07:52:20','version'=>'0.33' },{'date'=>'2015-01-15T02:04:26','version'=>'0.34' },{'date'=>'2015-05-23T05:44:25','version'=>'0.35' },{'date'=>'2015-05-25T02:52:16','version'=>'0.36' },{'date'=>'2016-05-21T07:00:46','version'=>'0.37' },{'date'=>'2017-03-16T07:48:58','version'=>'0.38' },{'date'=>'2017-03-29T02:29:03','version'=>'0.39' },{'date'=>'2017-03-30T01:41:11','version'=>'0.40' },{'date'=>'2017-11-06T15:17:26','version'=>'0.41' }]},'Dancer'=>{'advisories'=>[{'affected_versions'=>'<1.3114','cves'=>['CVE-2012-5572' ],'description'=>'CRLF injection vulnerability in the cookie method allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via a cookie name.
  ','distribution'=>'Dancer','fixed_versions'=>'>=1.3114','id'=>'CPANSA-Dancer-2014-01','references'=>['https://metacpan.org/changes/distribution/Dancer','https://github.com/PerlDancer/Dancer/commit/46ef9124f3149f697455061499ac7cee40930349' ],'reported'=>'2014-05-30' },{'affected_versions'=>'<1.3051','cves'=>['CVE-2011-1589' ],'description'=>'Directory traversal vulnerability (Mojolicious report, but Dancer was vulnerable as well).
  ','distribution'=>'Dancer','fixed_versions'=>'>=1.3051','id'=>'CPANSA-Dancer-2011-01','references'=>['https://metacpan.org/changes/distribution/Dancer','https://github.com/PerlDancer/Dancer/commit/91d0bf6a36705b0971b18f7d38fa2f3df8c7b994' ],'reported'=>'2011-04-05' }],'main_module'=>'Dancer','versions'=>[{'date'=>'2009-07-27T13:18:07','version'=>'20090727.1315' },{'date'=>'2009-07-27T14:14:13','version'=>'0_0.99' },{'date'=>'2009-08-01T13:48:20','version'=>'0.9901' },{'date'=>'2009-08-04T10:01:54','version'=>'0.9902' },{'date'=>'2009-08-07T12:29:03','version'=>'0.9003' },{'date'=>'2009-09-19T15:30:19','version'=>'0.9904' },{'date'=>'2009-09-23T21:33:51','version'=>'0.9905' },{'date'=>'2009-11-20T11:14:20','version'=>'1.000' },{'date'=>'2010-01-06T13:53:28','version'=>'1.100' },{'date'=>'2010-01-11T09:46:45','version'=>'1.110' },{'date'=>'2010-01-15T16:03:35','version'=>'1.120' },{'date'=>'2010-01-15T17:53:08','version'=>'1.121' },{'date'=>'2010-01-20T07:48:38','version'=>'1.122' },{'date'=>'2010-01-29T17:29:24','version'=>'1.130' },{'date'=>'2010-02-09T07:55:18','version'=>'1.140' },{'date'=>'2010-02-17T15:09:48','version'=>'1.150' },{'date'=>'2010-03-07T17:50:01','version'=>'1.160' },{'date'=>'2010-03-24T11:19:00','version'=>'1.170' },{'date'=>'2010-03-24T13:44:04','version'=>'1.171' },{'date'=>'2010-03-28T15:09:59','version'=>'1.172' },{'date'=>'2010-04-01T14:13:30','version'=>'1.173' },{'date'=>'2010-04-04T11:03:53','version'=>'1.173_01' },{'date'=>'2010-04-08T13:49:39','version'=>'1.174' },{'date'=>'2010-04-11T10:49:39','version'=>'1.175' },{'date'=>'2010-04-19T08:43:22','version'=>'1.175_01' },{'date'=>'2010-04-22T20:29:56','version'=>'1.176' },{'date'=>'2010-05-05T12:21:26','version'=>'1.178_01' },{'date'=>'2010-05-16T10:28:47','version'=>'1.1800' },{'date'=>'2010-05-19T14:17:57','version'=>'1.1801' },{'date'=>'2010-05-19T17:32:52','version'=>'1.1802' },{'date'=>'2010-05-23T20:45:17','version'=>'1.1803' },{'date'=>'2010-06-18T11:59:20','version'=>'1.1804' },{'date'=>'2010-06-22T06:41:58','version'=>'1.1805' },{'date'=>'2010-07-07T06:15:55','version'=>'1.1806_01' },{'date'=>'2010-08-14T16:37:45','version'=>'1.1806_02' },{'date'=>'2010-08-23T17:47:12','version'=>'1.1807' },{'date'=>'2010-08-24T06:23:38','version'=>'1.1808' },{'date'=>'2010-08-25T05:41:15','version'=>'1.1809' },{'date'=>'2010-09-01T06:19:20','version'=>'1.1810' },{'date'=>'2010-09-03T09:23:14','version'=>'1.1811' },{'date'=>'2010-09-21T12:19:35','version'=>'1.1812' },{'date'=>'2010-09-24T14:25:44','version'=>'1.1901' },{'date'=>'2010-10-14T09:25:03','version'=>'1.1999_01' },{'date'=>'2010-10-28T15:41:17','version'=>'1.1999_02' },{'date'=>'2010-11-02T14:14:32','version'=>'1.1902' },{'date'=>'2010-11-02T14:25:04','version'=>'1.1902' },{'date'=>'2010-11-03T17:07:29','version'=>'1.1903' },{'date'=>'2010-11-04T11:16:17','version'=>'1.1904' },{'date'=>'2010-11-11T07:43:21','version'=>'1.1999_03' },{'date'=>'2010-11-14T08:08:56','version'=>'1.1999_04' },{'date'=>'2010-11-18T15:54:33','version'=>'1.200' },{'date'=>'2010-11-18T16:52:47','version'=>'1.2000' },{'date'=>'2010-11-29T22:05:38','version'=>'1.2000_01' },{'date'=>'2010-11-30T10:00:23','version'=>'1.2000_02' },{'date'=>'2010-11-30T19:59:09','version'=>'1.2001' },{'date'=>'2010-12-02T12:18:12','version'=>'1.2001_01' },{'date'=>'2010-12-03T20:28:56','version'=>'1.2002' },{'date'=>'2010-12-07T18:05:50','version'=>'1.2002_01' },{'date'=>'2010-12-08T21:38:17','version'=>'1.2002_02' },{'date'=>'2010-12-10T18:28:16','version'=>'1.2003' },{'date'=>'2010-12-22T17:57:55','version'=>'1.3000_01' },{'date'=>'2011-01-03T15:17:14','version'=>'1.3000_02' },{'date'=>'2011-01-27T10:00:22','version'=>'1.2004' },{'date'=>'2011-01-27T10:09:31','version'=>'1.3001' },{'date'=>'2011-02-02T15:42:28','version'=>'1.3002' },{'date'=>'2011-02-05T17:07:15','version'=>'1.2005' },{'date'=>'2011-02-06T13:12:28','version'=>'1.3003' },{'date'=>'2011-02-10T20:48:48','version'=>'1.3010' },{'date'=>'2011-02-12T12:50:18','version'=>'1.3010_01' },{'date'=>'2011-02-14T15:58:10','version'=>'1.3011' },{'date'=>'2011-03-01T19:00:52','version'=>'1.3012' },{'date'=>'2011-03-03T08:41:00','version'=>'1.3013' },{'date'=>'2011-03-04T12:56:36','version'=>'1.3014' },{'date'=>'2011-03-10T14:16:24','version'=>'1.3014_01' },{'date'=>'2011-03-13T13:17:43','version'=>'1.3019_01' },{'date'=>'2011-03-14T07:44:57','version'=>'1.3019_02' },{'date'=>'2011-03-21T13:44:17','version'=>'1.3020' },{'date'=>'2011-04-01T15:22:58','version'=>'1.3029_01' },{'date'=>'2011-04-08T20:07:26','version'=>'1.3029_02' },{'date'=>'2011-04-10T08:18:44','version'=>'1.3029_03' },{'date'=>'2011-04-13T08:26:50','version'=>'1.3030' },{'date'=>'2011-04-27T14:58:57','version'=>'1.3039_01' },{'date'=>'2011-05-01T14:55:49','version'=>'1.3040' },{'date'=>'2011-05-14T15:03:00','version'=>'1.3049_01' },{'date'=>'2011-05-20T10:57:10','version'=>'1.3050' },{'date'=>'2011-05-27T12:57:27','version'=>'1.3051' },{'date'=>'2011-05-27T13:07:51','version'=>'1.3059_01' },{'date'=>'2011-05-29T14:06:24','version'=>'1.3059_02' },{'date'=>'2011-06-11T14:02:50','version'=>'1.3059_03' },{'date'=>'2011-06-12T17:31:55','version'=>'1.3059_04' },{'date'=>'2011-06-15T10:35:07','version'=>'1.3060' },{'date'=>'2011-07-07T13:19:45','version'=>'1.3069_01' },{'date'=>'2011-07-10T16:14:53','version'=>'1.3069_02' },{'date'=>'2011-07-14T13:47:19','version'=>'1.3070' },{'date'=>'2011-07-26T16:21:51','version'=>'1.3071' },{'date'=>'2011-08-17T15:27:53','version'=>'1.3079_01' },{'date'=>'2011-08-23T09:55:46','version'=>'1.3072' },{'date'=>'2011-08-28T14:13:40','version'=>'1.3079_02' },{'date'=>'2011-09-10T15:10:29','version'=>'1.3079_03' },{'date'=>'2011-10-02T16:07:02','version'=>'1.3079_04' },{'date'=>'2011-10-18T14:43:22','version'=>'1.3079_05' },{'date'=>'2011-10-25T21:16:42','version'=>'1.3080' },{'date'=>'2011-11-27T06:51:43','version'=>'1.3089_01' },{'date'=>'2011-12-13T14:41:24','version'=>'1.3090' },{'date'=>'2011-12-17T11:09:48','version'=>'1.3091' },{'date'=>'2012-01-27T14:38:05','version'=>'1.3092' },{'date'=>'2012-02-29T14:34:55','version'=>'1.3093' },{'date'=>'2012-03-31T09:57:40','version'=>'1.3094' },{'date'=>'2012-04-01T19:22:56','version'=>'1.3095' },{'date'=>'2012-06-22T20:18:54','version'=>'1.3095_01' },{'date'=>'2012-07-03T07:27:28','version'=>'1.3095_02' },{'date'=>'2012-07-05T23:09:20','version'=>'1.3096' },{'date'=>'2012-07-08T18:36:14','version'=>'1.3097' },{'date'=>'2012-07-28T14:40:15','version'=>'1.3098' },{'date'=>'2012-08-11T13:54:49','version'=>'1.3099' },{'date'=>'2012-08-25T19:42:47','version'=>'1.3100' },{'date'=>'2012-10-06T13:24:53','version'=>'1.3110' },{'date'=>'2012-12-24T13:17:58','version'=>'1.9999_01' },{'date'=>'2012-12-24T13:48:35','version'=>'1.9999_02' },{'date'=>'2013-01-22T21:38:11','version'=>'2.0000_01' },{'date'=>'2013-02-22T15:33:14','version'=>'2.000001' },{'date'=>'2013-02-24T22:51:59','version'=>'1.3111' },{'date'=>'2013-03-30T16:33:05','version'=>'1.3111_01' },{'date'=>'2013-04-01T22:31:08','version'=>'1.3111_02' },{'date'=>'2013-04-11T01:04:37','version'=>'1.3112' },{'date'=>'2013-05-09T00:36:16','version'=>'1.3113' },{'date'=>'2013-06-02T16:49:58','version'=>'1.3114' },{'date'=>'2013-06-09T23:54:16','version'=>'1.3115' },{'date'=>'2013-07-04T01:35:27','version'=>'1.3116' },{'date'=>'2013-07-31T22:40:52','version'=>'1.3117' },{'date'=>'2013-09-01T16:45:13','version'=>'1.3118' },{'date'=>'2013-10-26T19:42:59','version'=>'1.3119' },{'date'=>'2013-12-24T16:23:20','version'=>'1.3120' },{'date'=>'2014-02-02T22:26:53','version'=>'1.3121' },{'date'=>'2014-04-10T23:16:40','version'=>'1.3122' },{'date'=>'2014-04-12T15:47:53','version'=>'1.3123' },{'date'=>'2014-05-10T16:15:17','version'=>'1.3124' },{'date'=>'2014-07-12T17:19:08','version'=>'1.3125' },{'date'=>'2014-07-15T02:01:21','version'=>'1.3126' },{'date'=>'2014-09-09T00:49:19','version'=>'1.3127' },{'date'=>'2014-09-09T11:47:21','version'=>'1.3128' },{'date'=>'2014-09-10T00:50:37','version'=>'1.3129' },{'date'=>'2014-09-16T01:21:25','version'=>'1.3130' },{'date'=>'2014-10-11T18:59:22','version'=>'1.3131_0' },{'date'=>'2014-10-13T23:25:36','version'=>'1.3131_1' },{'date'=>'2014-10-20T23:14:23','version'=>'1.3132' },{'date'=>'2014-11-26T22:20:35','version'=>'1.3133' },{'date'=>'2015-02-23T01:33:08','version'=>'1.3134' },{'date'=>'2015-04-23T01:54:25','version'=>'1.3135' },{'date'=>'2015-05-24T15:48:19','version'=>'1.3136' },{'date'=>'2015-06-05T20:05:21','version'=>'1.3137' },{'date'=>'2015-06-12T20:55:50','version'=>'1.3138' },{'date'=>'2015-06-25T20:13:45','version'=>'1.3139' },{'date'=>'2015-07-03T13:56:32','version'=>'1.3140' },{'date'=>'2015-09-07T15:15:26','version'=>'1.3141' },{'date'=>'2015-09-15T00:52:23','version'=>'1.3142' },{'date'=>'2015-10-26T21:15:31','version'=>'1.3143' },{'date'=>'2015-11-04T12:36:07','version'=>'1.3144' },{'date'=>'2015-11-06T22:12:42','version'=>'1.3200' },{'date'=>'2015-11-07T19:27:25','version'=>'1.3201' },{'date'=>'2015-11-07T21:52:17','version'=>'1.3202' },{'date'=>'2016-02-15T21:33:45','version'=>'1.3300' },{'date'=>'2016-02-16T22:42:44','version'=>'1.3301' },{'date'=>'2018-05-20T19:52:07','version'=>'1.3203' },{'date'=>'2018-05-23T13:43:34','version'=>'1.3204' },{'date'=>'2018-06-13T22:02:36','version'=>'1.3205' },{'date'=>'2018-06-15T22:11:45','version'=>'1.3400' },{'date'=>'2018-10-01T11:53:31','version'=>'1.3401' },{'date'=>'2018-10-10T10:44:29','version'=>'1.3402' },{'date'=>'2018-10-11T22:45:37','version'=>'1.3403' },{'date'=>'2018-10-12T20:33:54','version'=>'1.3500' }]},'Dancer2'=>{'advisories'=>[{'affected_versions'=>'<0.206000','description'=>'There is a potential RCE with regards to Storable. We have added session ID validation to the session engine so that session backends based on Storable can reject malformed session IDs that may lead to exploitation of the RCE.
  ','distribution'=>'Dancer2','fixed_versions'=>'>=0.206000','id'=>'CPANSA-Dancer2-2018-01','references'=>['https://metacpan.org/changes/distribution/Dancer2','http://lists.preshweb.co.uk/pipermail/dancer-users/2018-April/005952.html','https://github.com/PerlDancer/Dancer2/commit/3580f5d0874a9abf5483528f73bda9a7fd9ec7f1' ],'reported'=>'2018-01-30','severity'=>'critical' }],'main_module'=>'Dancer2','versions'=>[{'date'=>'2013-02-22T15:39:46','version'=>'0.01' },{'date'=>'2013-02-24T11:04:25','version'=>'0.02' },{'date'=>'2013-03-07T17:30:37','version'=>'0.03' },{'date'=>'2013-04-22T19:58:02','version'=>'0.04' },{'date'=>'2013-07-20T16:53:37','version'=>'0.05' },{'date'=>'2013-07-30T14:29:42','version'=>'0.06' },{'date'=>'2013-08-03T22:17:54','version'=>'0.07' },{'date'=>'2013-08-18T12:24:31','version'=>'0.08' },{'date'=>'2013-09-01T21:19:26','version'=>'0.09' },{'date'=>'2013-09-28T13:29:35','version'=>'0.10' },{'date'=>'2013-12-15T13:21:28','version'=>'0.11' },{'date'=>'2014-04-07T21:05:16','version'=>'0.12' },{'date'=>'2014-04-13T17:20:22','version'=>'0.13' },{'date'=>'2014-04-28T21:16:57','version'=>'0.140000' },{'date'=>'2014-05-01T08:50:43','version'=>'0.140001' },{'date'=>'2014-06-07T20:35:57','version'=>'0.140900_01' },{'date'=>'2014-06-08T20:29:28','version'=>'0.141000' },{'date'=>'2014-06-24T19:18:07','version'=>'0.142000' },{'date'=>'2014-07-05T19:43:17','version'=>'0.143000' },{'date'=>'2014-07-23T19:34:51','version'=>'0.149000_01' },{'date'=>'2014-08-10T11:53:37','version'=>'0.149000_02' },{'date'=>'2014-08-16T23:38:39','version'=>'0.150000' },{'date'=>'2014-10-08T19:51:49','version'=>'0.151000' },{'date'=>'2014-10-14T02:33:06','version'=>'0.152000' },{'date'=>'2014-10-23T21:48:36','version'=>'0.153000' },{'date'=>'2014-10-29T21:41:13','version'=>'0.153001' },{'date'=>'2014-10-30T08:29:15','version'=>'0.153002' },{'date'=>'2014-11-17T14:41:14','version'=>'0.154000' },{'date'=>'2014-11-28T00:21:55','version'=>'0.155000' },{'date'=>'2014-11-28T16:44:27','version'=>'0.155001' },{'date'=>'2014-12-02T22:02:03','version'=>'0.155002' },{'date'=>'2014-12-03T21:35:35','version'=>'0.155003' },{'date'=>'2014-12-04T10:57:08','version'=>'0.155004' },{'date'=>'2014-12-07T17:07:21','version'=>'0.156000' },{'date'=>'2014-12-08T22:08:30','version'=>'0.156001' },{'date'=>'2014-12-14T17:25:53','version'=>'0.157000' },{'date'=>'2014-12-21T19:42:24','version'=>'0.157001' },{'date'=>'2015-01-01T17:11:48','version'=>'0.158000' },{'date'=>'2015-02-24T03:54:24','version'=>'0.159000' },{'date'=>'2015-02-25T14:33:59','version'=>'0.159001' },{'date'=>'2015-03-03T18:25:28','version'=>'0.159002' },{'date'=>'2015-03-23T14:00:19','version'=>'0.159003' },{'date'=>'2015-04-26T22:15:22','version'=>'0.160000' },{'date'=>'2015-05-14T18:46:02','version'=>'0.160001' },{'date'=>'2015-06-04T11:07:02','version'=>'0.160002' },{'date'=>'2015-06-06T09:11:43','version'=>'0.160003' },{'date'=>'2015-07-08T13:04:02','version'=>'0.161000' },{'date'=>'2015-08-28T13:32:02','version'=>'0.161000_01' },{'date'=>'2015-09-06T11:13:10','version'=>'0.162000' },{'date'=>'2015-10-13T15:08:16','version'=>'0.162000_01' },{'date'=>'2015-10-15T11:00:10','version'=>'0.163000' },{'date'=>'2015-12-16T22:44:32','version'=>'0.164000' },{'date'=>'2015-12-17T08:23:24','version'=>'0.165000' },{'date'=>'2016-01-12T18:04:57','version'=>'0.166000' },{'date'=>'2016-01-22T06:57:11','version'=>'0.166001' },{'date'=>'2016-04-19T19:52:27','version'=>'0.166001_01' },{'date'=>'2016-04-29T14:45:41','version'=>'0.166001_02' },{'date'=>'2016-05-27T11:25:55','version'=>'0.166001_03' },{'date'=>'2016-05-27T12:57:04','version'=>'0.166001_04' },{'date'=>'2016-05-31T13:29:37','version'=>'0.200000' },{'date'=>'2016-06-16T14:00:23','version'=>'0.200001' },{'date'=>'2016-06-22T14:41:29','version'=>'0.200002' },{'date'=>'2016-07-05T19:36:46','version'=>'0.200003' },{'date'=>'2016-07-11T15:21:33','version'=>'0.200003' },{'date'=>'2016-07-22T04:41:26','version'=>'0.200004' },{'date'=>'2016-07-22T13:28:45','version'=>'0.201000' },{'date'=>'2016-08-13T18:53:07','version'=>'0.202000' },{'date'=>'2016-08-25T03:12:19','version'=>'0.203000' },{'date'=>'2016-09-04T02:01:29','version'=>'0.203001' },{'date'=>'2016-10-11T01:59:49','version'=>'0.204000' },{'date'=>'2016-10-17T13:32:25','version'=>'0.204001' },{'date'=>'2016-12-21T21:47:24','version'=>'0.204002' },{'date'=>'2017-01-25T21:23:22','version'=>'0.204003' },{'date'=>'2017-01-26T17:31:30','version'=>'0.204004' },{'date'=>'2017-03-10T21:40:43','version'=>'0.205000' },{'date'=>'2017-07-11T13:04:56','version'=>'0.205001' },{'date'=>'2017-10-17T21:10:03','version'=>'0.205002' },{'date'=>'2018-04-09T00:54:25','version'=>'0.206000_01' },{'date'=>'2018-04-10T01:50:18','version'=>'0.206000_02' },{'date'=>'2018-04-20T02:12:22','version'=>'0.206000' },{'date'=>'2018-11-14T22:26:15','version'=>'0.207000' }]},'Data-Dumper'=>{'advisories'=>[{'affected_versions'=>'<2.154','cves'=>['CVE-2014-4330' ],'description'=>'Infinite recursion.
  ','distribution'=>'Data-Dumper','fixed_versions'=>'>=2.154','id'=>'CPANSA-Data-Dumper-2014-01','references'=>['https://metacpan.org/changes/distribution/Data-Dumper' ],'reported'=>'2014-09-30' }],'main_module'=>'Data::Dumper','versions'=>[{'date'=>'1995-11-19T22:29:08','version'=>'1.21' },{'date'=>'1995-11-23T05:45:27','version'=>'1.22' },{'date'=>'1995-12-04T03:12:16','version'=>'1.23' },{'date'=>'1996-04-09T15:54:26','version'=>'2.00' },{'date'=>'1996-04-10T04:25:17','version'=>'2.01' },{'date'=>'1996-04-13T07:14:35','version'=>'2.02' },{'date'=>'1996-08-26T14:36:59','version'=>'2.03' },{'date'=>'1996-08-28T20:11:49','version'=>'2.04' },{'date'=>'1996-12-02T13:42:49','version'=>'2.05' },{'date'=>'1996-12-02T23:07:56','version'=>'2.06' },{'date'=>'1996-12-07T17:28:27','version'=>'2.07' },{'date'=>'1997-12-07T21:27:09','version'=>'2.08' },{'date'=>'1998-01-15T20:36:46','version'=>'2.081' },{'date'=>'1998-03-06T21:08:49','version'=>'2.081' },{'date'=>'1998-07-17T05:23:08','version'=>'2.09' },{'date'=>'1998-07-21T12:08:19','version'=>'2.09' },{'date'=>'1998-10-31T12:10:30','version'=>'2.10' },{'date'=>'1999-05-01T02:01:03','version'=>'2.101' },{'date'=>'1999-06-02T01:30:55','version'=>'2.101' },{'date'=>'2003-07-20T16:59:48','version'=>'2.12_01' },{'date'=>'2003-07-31T19:12:44','version'=>'2.12_02' },{'date'=>'2003-08-25T11:49:41','version'=>'2.121' },{'date'=>'2009-06-06T14:45:36','version'=>'2.121_20' },{'date'=>'2009-06-09T15:49:12','version'=>'2.122' },{'date'=>'2009-06-11T08:07:01','version'=>'2.123' },{'date'=>'2009-06-13T15:22:32','version'=>'2.124' },{'date'=>'2009-08-08T10:33:01','version'=>'2.125' },{'date'=>'2010-04-15T19:55:01','version'=>'2.126' },{'date'=>'2010-09-06T14:28:10','version'=>'2.126_01' },{'date'=>'2010-09-10T07:08:41','version'=>'2.127' },{'date'=>'2010-09-10T07:11:52','version'=>'2.128' },{'date'=>'2011-05-20T15:53:12','version'=>'2.130_03' },{'date'=>'2011-05-27T14:19:03','version'=>'2.131' },{'date'=>'2011-12-19T08:23:05','version'=>'2.135_01' },{'date'=>'2011-12-29T17:09:49','version'=>'2.135_02' },{'date'=>'2012-08-07T06:59:51','version'=>'2.135_07' },{'date'=>'2012-10-04T07:35:07','version'=>'2.136' },{'date'=>'2012-12-12T06:30:48','version'=>'2.139' },{'date'=>'2013-02-26T06:57:29','version'=>'2.143' },{'date'=>'2013-03-15T09:46:49','version'=>'2.145' },{'date'=>'2014-03-07T09:28:44','version'=>'2.151' },{'date'=>'2014-09-18T15:47:37','version'=>'2.154' },{'date'=>'2016-07-03T19:17:57','version'=>'2.160' },{'date'=>'2016-07-11T20:13:06','version'=>'2.161' },{'date'=>'2017-07-31T15:31:28','version'=>'2.167_01' },{'date'=>'2017-08-04T08:05:22','version'=>'2.167_02' },{'date'=>'2018-09-19T14:41:58','version'=>'2.172' },{'date'=>'2018-11-10T10:10:30','version'=>'2.173' }]},'Dezi'=>{'advisories'=>[{'affected_versions'=>'<0.002002','description'=>'Bypassing authentication on the /index URL app with non-idempotent requests to /search URL.
  ','distribution'=>'Dezi','fixed_versions'=>'>=0.002002','id'=>'CPANSA-Dezi-2012-01','references'=>['https://metacpan.org/changes/distribution/Dezi','https://github.com/karpet/Dezi/commit/f1ad292b4dd988d1a38202c804bb7a2a3bcca3c8' ],'reported'=>'2012-09-13' }],'main_module'=>'Dezi','versions'=>[{'date'=>'2011-06-22T04:53:57','version'=>'0.001000' },{'date'=>'2011-08-03T02:42:22','version'=>'0.001001' },{'date'=>'2011-09-30T03:35:08','version'=>'0.001002' },{'date'=>'2011-10-23T02:12:02','version'=>'0.001003' },{'date'=>'2012-03-17T02:40:15','version'=>'0.001004' },{'date'=>'2012-07-11T03:20:40','version'=>'0.001005' },{'date'=>'2012-08-18T02:43:23','version'=>'0.001006' },{'date'=>'2012-08-22T03:58:33','version'=>'0.001007' },{'date'=>'2012-09-04T02:05:34','version'=>'0.001008' },{'date'=>'2012-09-12T03:51:13','version'=>'0.002000' },{'date'=>'2012-09-13T01:50:59','version'=>'0.002001' },{'date'=>'2012-09-13T14:10:02','version'=>'0.002002' },{'date'=>'2012-10-16T00:57:46','version'=>'0.002003' },{'date'=>'2012-10-18T03:15:21','version'=>'0.002004' },{'date'=>'2012-12-19T05:25:13','version'=>'0.002005' },{'date'=>'2013-02-03T02:49:07','version'=>'0.002006' },{'date'=>'2013-02-05T15:02:54','version'=>'0.002007' },{'date'=>'2013-02-09T05:37:41','version'=>'0.002008' },{'date'=>'2013-02-13T02:30:33','version'=>'0.002009' },{'date'=>'2013-02-13T04:31:49','version'=>'0.002010' },{'date'=>'2013-11-13T17:08:03','version'=>'0.002011' },{'date'=>'2014-02-27T18:08:30','version'=>'0.002012' },{'date'=>'2014-06-05T06:59:12','version'=>'0.002998_01' },{'date'=>'2014-06-08T04:59:17','version'=>'0.003000' },{'date'=>'2014-07-30T20:40:24','version'=>'0.004000' },{'date'=>'2014-09-02T02:45:00','version'=>'0.004001' },{'date'=>'2015-04-30T22:01:11','version'=>'0.004002' },{'date'=>'2018-05-16T02:24:24','version'=>'0.004003' }]},'Email-Address'=>{'advisories'=>[{'affected_versions'=>'<1.905','cves'=>['CVE-2014-0477' ],'description'=>'Inefficient regular expression, which allows remote attackers to cause a denial of service (CPU consumption) via an empty quoted string in an RFC 2822 address.
  ','distribution'=>'Email-Address','fixed_versions'=>'>=1.905','id'=>'CPANSA-Email-Address-2014-01','references'=>['https://metacpan.org/changes/distribution/Email-Address' ],'reported'=>'2014-07-03' }],'main_module'=>'Email::Address','versions'=>[{'date'=>'2004-05-27T03:19:56','version'=>'1.1' },{'date'=>'2004-06-02T16:35:30','version'=>'1.2' },{'date'=>'2004-08-16T21:39:58','version'=>'1.3' },{'date'=>'2004-10-05T18:10:42','version'=>'1.5' },{'date'=>'2004-10-05T18:20:42','version'=>'1.6' },{'date'=>'2004-10-13T10:21:17','version'=>'1.7' },{'date'=>'2004-10-22T16:37:27','version'=>'1.80' },{'date'=>'2006-07-11T15:04:28','version'=>'1.85' },{'date'=>'2006-07-22T00:42:17','version'=>'1.86' },{'date'=>'2006-08-10T16:48:44','version'=>'1.870' },{'date'=>'2006-10-12T19:35:04','version'=>'1.861' },{'date'=>'2006-10-12T22:16:28','version'=>'1.871' },{'date'=>'2006-11-11T16:01:38','version'=>'1.880' },{'date'=>'2006-11-19T21:19:02','version'=>'1.881' },{'date'=>'2006-11-22T01:26:44','version'=>'1.882' },{'date'=>'2006-11-25T13:53:46','version'=>'1.883' },{'date'=>'2006-12-05T03:41:39','version'=>'1.884' },{'date'=>'2007-03-01T01:08:16','version'=>'1.885' },{'date'=>'2007-03-01T20:18:53','version'=>'1.886' },{'date'=>'2007-04-01T19:15:49','version'=>'1.887' },{'date'=>'2007-06-23T01:27:24','version'=>'1.888' },{'date'=>'2007-12-19T22:14:37','version'=>'1.889' },{'date'=>'2010-08-22T19:03:33','version'=>'1.890' },{'date'=>'2010-08-31T00:56:53','version'=>'1.891' },{'date'=>'2010-09-03T23:45:13','version'=>'1.892' },{'date'=>'2012-01-03T03:55:12','version'=>'1.893' },{'date'=>'2012-01-14T16:17:56','version'=>'1.894' },{'date'=>'2012-01-15T18:41:33','version'=>'1.895' },{'date'=>'2012-08-01T03:07:33','version'=>'1.896' },{'date'=>'2012-12-17T15:16:33','version'=>'1.897' },{'date'=>'2013-02-07T21:41:48','version'=>'1.898' },{'date'=>'2013-08-02T14:54:13','version'=>'1.899' },{'date'=>'2013-08-08T18:46:07','version'=>'1.900' },{'date'=>'2014-01-29T03:43:28','version'=>'1.901' },{'date'=>'2014-04-17T15:19:31','version'=>'1.902' },{'date'=>'2014-04-18T01:07:10','version'=>'1.903' },{'date'=>'2014-06-14T04:22:22','version'=>'1.904' },{'date'=>'2014-06-18T02:55:59','version'=>'1.905' },{'date'=>'2015-02-03T21:49:39','version'=>'1.906' },{'date'=>'2015-02-03T22:48:46','version'=>'1.907' },{'date'=>'2015-09-20T02:55:12','version'=>'1.908' },{'date'=>'2018-03-05T03:26:56','version'=>'1.909' },{'date'=>'2018-12-18T02:29:23','version'=>'1.910' },{'date'=>'2018-12-22T16:31:37','version'=>'1.911' },{'date'=>'2018-12-31T19:51:36','version'=>'1.912' }]},'Encode'=>{'advisories'=>[{'affected_versions'=>'<2.85','cves'=>['CVE-2016-1238' ],'description'=>'Loading optional modules from . (current directory).
  ','distribution'=>'Encode','fixed_versions'=>'>=2.85','id'=>'CPANSA-Encode-2016-01','references'=>['https://metacpan.org/changes/distribution/Encode','https://github.com/dankogai/p5-encode/pull/58/commits/12be15d64ce089154c4367dc1842cd0dc0993ec6' ],'reported'=>'2016-07-27' }],'main_module'=>'Encode','versions'=>[{'date'=>'2002-03-20T08:30:40','version'=>'0.93' },{'date'=>'2002-03-20T20:15:52','version'=>'0.94' },{'date'=>'2002-03-21T16:07:21','version'=>'0.95' },{'date'=>'2002-03-22T22:33:15','version'=>'0.96' },{'date'=>'2002-03-23T20:36:05','version'=>'0.97' },{'date'=>'2002-03-24T16:07:09','version'=>'0.98' },{'date'=>'2002-03-25T19:45:16','version'=>'0.99' },{'date'=>'2002-03-28T23:39:49','version'=>'1.00' },{'date'=>'2002-03-29T21:43:17','version'=>'1.01' },{'date'=>'2002-03-31T21:40:25','version'=>'1.10' },{'date'=>'2002-03-31T22:27:07','version'=>'1.11' },{'date'=>'2002-04-04T20:02:40','version'=>'1.20' },{'date'=>'2002-04-07T15:36:48','version'=>'1.26' },{'date'=>'2002-04-07T18:49:41','version'=>'1.27' },{'date'=>'2002-04-07T19:05:34','version'=>'1.28' },{'date'=>'2002-04-08T02:49:31','version'=>'1.30' },{'date'=>'2002-04-08T18:51:14','version'=>'1.31' },{'date'=>'2002-04-09T20:26:37','version'=>'1.32' },{'date'=>'2002-04-10T22:44:19','version'=>'1.33' },{'date'=>'2002-04-14T22:49:10','version'=>'1.40' },{'date'=>'2002-04-16T23:47:16','version'=>'1.41' },{'date'=>'2002-04-19T06:18:26','version'=>'1.50' },{'date'=>'2002-04-20T10:08:39','version'=>'1.51' },{'date'=>'2002-04-20T23:55:45','version'=>'1.52' },{'date'=>'2002-04-22T09:56:04','version'=>'1.56' },{'date'=>'2002-04-22T20:37:12','version'=>'1.57' },{'date'=>'2002-04-23T00:22:06','version'=>'1.58' },{'date'=>'2002-04-24T20:23:42','version'=>'1.60' },{'date'=>'2002-04-26T03:19:40','version'=>'1.61' },{'date'=>'2002-04-27T11:43:39','version'=>'1.62' },{'date'=>'2002-04-27T19:52:51','version'=>'1.63' },{'date'=>'2002-04-29T07:20:38','version'=>'1.64' },{'date'=>'2002-04-30T16:40:07','version'=>'1.65' },{'date'=>'2002-05-01T05:51:35','version'=>'1.66' },{'date'=>'2002-05-02T07:43:35','version'=>'1.67' },{'date'=>'2002-05-03T12:29:47','version'=>'1.68' },{'date'=>'2002-05-04T16:50:40','version'=>'1.69' },{'date'=>'2002-05-06T10:36:39','version'=>'1.70' },{'date'=>'2002-05-07T16:30:42','version'=>'1.71' },{'date'=>'2002-05-20T16:04:48','version'=>'1.72' },{'date'=>'2002-05-28T18:41:36','version'=>'1.74' },{'date'=>'2002-06-01T18:17:49','version'=>'1.75' },{'date'=>'2002-08-25T15:18:49','version'=>'1.76' },{'date'=>'2002-10-06T03:59:19','version'=>'1.77' },{'date'=>'2002-10-20T15:55:16','version'=>'1.78' },{'date'=>'2002-10-21T06:11:36','version'=>'1.79' },{'date'=>'2002-10-21T20:42:56','version'=>'1.80' },{'date'=>'2002-11-08T18:42:11','version'=>'1.81' },{'date'=>'2002-11-14T23:17:11','version'=>'1.82' },{'date'=>'2002-11-18T18:06:47','version'=>'1.83' },{'date'=>'2003-01-10T12:09:05','version'=>'1.84' },{'date'=>'2003-01-21T22:23:28','version'=>'1.85' },{'date'=>'2003-01-22T03:36:42','version'=>'1.86' },{'date'=>'2003-02-06T02:01:00','version'=>'1.87' },{'date'=>'2003-02-20T14:46:12','version'=>'1.88' },{'date'=>'2003-02-28T01:45:53','version'=>'1.89' },{'date'=>'2003-03-09T17:54:26','version'=>'1.90' },{'date'=>'2003-03-09T20:12:08','version'=>'1.91' },{'date'=>'2003-03-31T03:51:31','version'=>'1.92' },{'date'=>'2003-04-24T17:50:54','version'=>'1.93' },{'date'=>'2003-05-10T18:31:48','version'=>'1.94' },{'date'=>'2003-05-21T09:22:43','version'=>'1.95' },{'date'=>'2003-06-18T09:41:21','version'=>'1.96' },{'date'=>'2003-07-08T22:01:28','version'=>'1.97' },{'date'=>'2003-08-25T11:47:32','version'=>'1.98' },{'date'=>'2003-12-29T02:52:28','version'=>'1.99' },{'date'=>'2004-05-16T21:05:06','version'=>'2.00' },{'date'=>'2004-05-25T16:31:35','version'=>'2.01' },{'date'=>'2004-08-31T11:01:51','version'=>'2.02' },{'date'=>'2004-10-06T06:50:47','version'=>'2.03' },{'date'=>'2004-10-16T21:26:58','version'=>'2.04' },{'date'=>'2004-10-19T05:03:32','version'=>'2.05' },{'date'=>'2004-10-22T06:29:14','version'=>'2.06' },{'date'=>'2004-10-22T19:43:19','version'=>'2.07' },{'date'=>'2004-10-24T13:04:29','version'=>'2.08' },{'date'=>'2004-12-03T19:21:42','version'=>'2.09' },{'date'=>'2005-05-16T18:54:53','version'=>'2.10' },{'date'=>'2005-08-05T11:26:06','version'=>'2.11' },{'date'=>'2005-09-08T14:23:38','version'=>'2.12' },{'date'=>'2006-01-15T15:12:01','version'=>'2.13' },{'date'=>'2006-01-15T15:57:41','version'=>'2.14' },{'date'=>'2006-04-06T16:01:30','version'=>'2.15' },{'date'=>'2006-05-03T18:38:44','version'=>'2.16' },{'date'=>'2006-05-09T17:14:04','version'=>'2.17' },{'date'=>'2006-06-03T20:34:08','version'=>'2.18' },{'date'=>'2007-04-06T13:05:52','version'=>'2.19' },{'date'=>'2007-04-22T15:17:34','version'=>'2.20' },{'date'=>'2007-05-12T06:50:09','version'=>'2.21' },{'date'=>'2007-05-29T07:43:07','version'=>'2.22' },{'date'=>'2007-05-29T18:21:25','version'=>'2.23' },{'date'=>'2008-03-12T10:12:18','version'=>'2.24' },{'date'=>'2008-05-07T21:06:08','version'=>'2.25' },{'date'=>'2008-07-01T21:03:33','version'=>'2.26' },{'date'=>'2009-01-21T23:01:50','version'=>'2.27' },{'date'=>'2009-02-01T13:16:44','version'=>'2.29' },{'date'=>'2009-02-15T17:48:01','version'=>'2.30' },{'date'=>'2009-02-16T06:25:32','version'=>'2.31' },{'date'=>'2009-03-07T07:45:00','version'=>'2.32' },{'date'=>'2009-03-25T08:01:10','version'=>'2.33' },{'date'=>'2009-07-08T13:53:25','version'=>'2.34' },{'date'=>'2009-07-13T02:32:45','version'=>'2.35' },{'date'=>'2009-09-06T09:20:21','version'=>'2.36' },{'date'=>'2009-09-06T14:37:23','version'=>'2.37' },{'date'=>'2009-11-16T14:34:43','version'=>'2.38' },{'date'=>'2009-11-26T09:31:02','version'=>'2.39' },{'date'=>'2010-09-18T18:47:17','version'=>'2.40' },{'date'=>'2010-12-23T11:12:33','version'=>'2.41' },{'date'=>'2010-12-31T22:52:35','version'=>'2.42' },{'date'=>'2011-05-21T23:21:24','version'=>'2.43' },{'date'=>'2011-08-09T08:01:30','version'=>'2.44' },{'date'=>'2012-08-05T23:15:11','version'=>'2.45' },{'date'=>'2012-08-12T05:52:45','version'=>'2.46' },{'date'=>'2012-08-15T05:40:21','version'=>'2.47' },{'date'=>'2013-02-18T02:43:35','version'=>'2.48' },{'date'=>'2013-03-05T03:19:15','version'=>'2.49' },{'date'=>'2013-04-26T18:36:59','version'=>'2.50' },{'date'=>'2013-04-29T22:21:31','version'=>'2.51' },{'date'=>'2013-08-14T02:33:46','version'=>'2.52' },{'date'=>'2013-08-29T15:27:02','version'=>'2.53' },{'date'=>'2013-08-29T16:50:08','version'=>'2.54' },{'date'=>'2013-09-14T07:58:54','version'=>'2.55' },{'date'=>'2013-12-22T04:12:07','version'=>'2.56' },{'date'=>'2014-01-03T04:55:36','version'=>'2.57' },{'date'=>'2014-03-28T02:41:54','version'=>'2.58' },{'date'=>'2014-04-06T17:41:19','version'=>'2.59' },{'date'=>'2014-04-29T16:34:10','version'=>'2.60' },{'date'=>'2014-05-31T09:55:56','version'=>'2.61' },{'date'=>'2014-05-31T12:20:28','version'=>'2.62' },{'date'=>'2014-10-19T07:13:44','version'=>'2.63' },{'date'=>'2014-10-29T15:42:04','version'=>'2.64' },{'date'=>'2014-11-27T14:12:57','version'=>'2.65' },{'date'=>'2014-12-02T23:37:28','version'=>'2.66' },{'date'=>'2014-12-04T20:28:33','version'=>'2.67' },{'date'=>'2015-01-22T10:29:46','version'=>'2.68' },{'date'=>'2015-02-05T10:43:34','version'=>'2.69' },{'date'=>'2015-02-05T10:56:52','version'=>'2.70' },{'date'=>'2015-03-12T00:14:19','version'=>'2.71' },{'date'=>'2015-03-14T02:51:25','version'=>'2.72' },{'date'=>'2015-04-15T23:27:13','version'=>'2.73' },{'date'=>'2015-06-25T00:59:20','version'=>'2.74' },{'date'=>'2015-06-30T10:10:03','version'=>'2.75' },{'date'=>'2015-07-31T02:26:51','version'=>'2.76' },{'date'=>'2015-09-15T14:03:35','version'=>'2.77' },{'date'=>'2015-09-24T02:29:52','version'=>'2.78' },{'date'=>'2016-01-22T07:08:25','version'=>'2.79' },{'date'=>'2016-01-25T15:04:42','version'=>'2.80' },{'date'=>'2016-02-06T19:34:58','version'=>'2.81' },{'date'=>'2016-02-06T20:21:37','version'=>'2.82' },{'date'=>'2016-03-24T08:00:30','version'=>'2.83' },{'date'=>'2016-04-11T07:24:26','version'=>'2.84' },{'date'=>'2016-08-04T03:37:23','version'=>'2.85' },{'date'=>'2016-08-10T18:25:39','version'=>'2.86' },{'date'=>'2016-10-28T05:15:33','version'=>'2.87' },{'date'=>'2016-11-29T23:38:19','version'=>'2.88' },{'date'=>'2017-04-21T05:24:59','version'=>'2.89' },{'date'=>'2017-06-10T17:46:11','version'=>'2.90' },{'date'=>'2017-06-22T08:18:22','version'=>'2.91' },{'date'=>'2017-07-18T07:23:39','version'=>'2.92' },{'date'=>'2017-10-06T22:33:35','version'=>'2.93' },{'date'=>'2018-01-09T06:04:38','version'=>'2.94' },{'date'=>'2018-02-08T00:41:02','version'=>'2.95' },{'date'=>'2018-02-11T05:41:37','version'=>'2.96' },{'date'=>'2018-02-21T12:30:05','version'=>'2.97' },{'date'=>'2018-04-22T09:14:59','version'=>'2.98' },{'date'=>'2019-01-21T03:28:35','version'=>'2.99' },{'date'=>'2019-01-31T04:42:29','version'=>'2.100' },{'date'=>'2019-01-31T05:05:06','version'=>'3.00' }]},'ExtUtils-MakeMaker'=>{'advisories'=>[{'affected_versions'=>'<7.22','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'ExtUtils-MakeMaker','fixed_versions'=>'>=7.22','id'=>'CPANSA-ExtUtils-MakeMaker-2016-01','references'=>['https://metacpan.org/changes/distribution/ExtUtils-MakeMaker','https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker/commit/3e9df17d11c40f2561c23ec79693c8c390e0ae88' ],'reported'=>'2016-08-07' }],'main_module'=>'ExtUtils::MakeMaker','versions'=>[{'date'=>'2001-07-06T08:23:56','version'=>'5.47_01' },{'date'=>'2002-01-16T20:19:18','version'=>'5.48_01' },{'date'=>'2002-01-18T04:56:33','version'=>'5.48_03' },{'date'=>'2002-01-22T00:33:31','version'=>'5.48_04' },{'date'=>'2002-02-04T08:46:04','version'=>'5.49_01' },{'date'=>'2002-03-05T04:53:40','version'=>'5.50_01' },{'date'=>'2002-03-25T07:53:14','version'=>'5.51_01' },{'date'=>'2002-03-26T05:56:07','version'=>'5.52_01' },{'date'=>'2002-03-31T03:55:52','version'=>'5.54_01' },{'date'=>'2002-04-05T05:01:52','version'=>'5.55_01' },{'date'=>'2002-04-06T08:29:20','version'=>'5.55_02' },{'date'=>'2002-04-07T03:04:18','version'=>'5.55_03' },{'date'=>'2002-04-11T05:32:04','version'=>'5.90_01' },{'date'=>'2002-04-24T04:21:44','version'=>'5.91_01' },{'date'=>'2002-04-30T03:43:53','version'=>'5.92_01' },{'date'=>'2002-05-06T06:02:08','version'=>'5.93_01' },{'date'=>'2002-05-17T19:04:41','version'=>'5.94_01' },{'date'=>'2002-05-17T21:24:13','version'=>'5.94_02' },{'date'=>'2002-05-18T18:43:02','version'=>'5.95_01' },{'date'=>'2002-05-23T21:01:02','version'=>'5.96_01' },{'date'=>'2002-05-26T01:25:25','version'=>'6.00' },{'date'=>'2002-05-30T19:02:20','version'=>'6.01' },{'date'=>'2002-06-16T05:41:28','version'=>'6.02' },{'date'=>'2002-06-19T21:24:32','version'=>'6.03' },{'date'=>'2002-08-27T01:42:36','version'=>'6.04' },{'date'=>'2002-08-27T23:24:30','version'=>'6.05' },{'date'=>'2002-12-19T08:42:01','version'=>'6.06_01' },{'date'=>'2002-12-24T04:54:53','version'=>'6.06_02' },{'date'=>'2003-03-30T03:49:59','version'=>'6.06_03' },{'date'=>'2003-03-31T04:37:55','version'=>'6.06_04' },{'date'=>'2003-03-31T10:50:00','version'=>'6.06_05' },{'date'=>'2003-04-07T02:46:10','version'=>'6.10_01' },{'date'=>'2003-04-07T08:33:23','version'=>'6.10_02' },{'date'=>'2003-04-11T07:27:36','version'=>'6.10_03' },{'date'=>'2003-05-23T09:05:27','version'=>'6.10_04' },{'date'=>'2003-06-07T01:32:29','version'=>'6.10_05' },{'date'=>'2003-06-07T08:00:14','version'=>'6.10_06' },{'date'=>'2003-07-05T23:40:34','version'=>'6.10_07' },{'date'=>'2003-07-22T01:23:46','version'=>'6.10_08' },{'date'=>'2003-07-28T04:00:19','version'=>'6.11' },{'date'=>'2003-07-30T05:28:47','version'=>'6.12' },{'date'=>'2003-07-31T23:51:40','version'=>'6.13' },{'date'=>'2003-08-03T23:27:51','version'=>'6.14' },{'date'=>'2003-08-03T23:46:11','version'=>'6.15' },{'date'=>'2003-08-18T08:43:08','version'=>'6.16' },{'date'=>'2003-09-15T22:23:01','version'=>'6.17' },{'date'=>'2003-11-04T04:12:53','version'=>'6.18' },{'date'=>'2003-11-04T07:03:30','version'=>'6.19' },{'date'=>'2003-11-06T10:37:47','version'=>'6.20' },{'date'=>'2003-11-11T08:26:17','version'=>'6.21' },{'date'=>'2004-04-03T21:33:45','version'=>'6.21_03' },{'date'=>'2004-11-24T04:06:20','version'=>'6.22' },{'date'=>'2004-11-26T21:15:45','version'=>'6.23' },{'date'=>'2004-11-30T20:42:14','version'=>'6.24' },{'date'=>'2004-12-09T06:00:53','version'=>'6.24_01' },{'date'=>'2004-12-15T12:05:50','version'=>'6.25' },{'date'=>'2004-12-18T02:34:56','version'=>'6.25_01' },{'date'=>'2004-12-20T08:36:56','version'=>'6.25_02' },{'date'=>'2004-12-21T04:17:27','version'=>'6.25_03' },{'date'=>'2004-12-21T05:58:10','version'=>'6.25_04' },{'date'=>'2004-12-22T13:05:53','version'=>'6.25_05' },{'date'=>'2004-12-26T22:26:26','version'=>'6.25_06' },{'date'=>'2004-12-31T08:53:31','version'=>'6.25_07' },{'date'=>'2005-02-08T14:21:17','version'=>'6.25_08' },{'date'=>'2005-03-12T18:29:26','version'=>'6.25_09' },{'date'=>'2005-03-14T00:17:26','version'=>'6.25_10' },{'date'=>'2005-03-15T10:05:07','version'=>'6.25_11' },{'date'=>'2005-03-19T00:19:47','version'=>'6.25_12' },{'date'=>'2005-03-22T22:50:34','version'=>'6.26' },{'date'=>'2005-03-29T05:48:40','version'=>'6.26_01' },{'date'=>'2005-04-04T23:55:46','version'=>'6.27' },{'date'=>'2005-04-12T23:23:53','version'=>'6.28' },{'date'=>'2005-05-19T21:22:00','version'=>'6.29' },{'date'=>'2005-05-20T23:14:45','version'=>'6.30' },{'date'=>'2005-08-17T06:59:11','version'=>'6.30_01' },{'date'=>'2006-09-01T19:07:28','version'=>'6.30_02' },{'date'=>'2006-09-01T21:06:57','version'=>'6.30_03' },{'date'=>'2006-09-11T20:20:27','version'=>'6.30_04' },{'date'=>'2006-10-10T01:04:44','version'=>'6.31' },{'date'=>'2007-02-21T16:02:09','version'=>'6.32' },{'date'=>'2007-06-29T22:18:15','version'=>'6.33' },{'date'=>'2007-06-30T16:10:15','version'=>'6.34' },{'date'=>'2007-07-02T03:56:25','version'=>'6.35' },{'date'=>'2007-07-03T08:10:57','version'=>'6.36' },{'date'=>'2007-11-26T01:10:14','version'=>'6.37_01' },{'date'=>'2007-11-26T07:35:50','version'=>'6.37_02' },{'date'=>'2007-11-26T22:18:55','version'=>'6.37_03' },{'date'=>'2007-11-29T00:04:35','version'=>'6.38' },{'date'=>'2007-12-06T11:08:15','version'=>'6.40' },{'date'=>'2007-12-08T01:02:26','version'=>'6.42' },{'date'=>'2008-01-02T00:09:23','version'=>'6.43_01' },{'date'=>'2008-02-29T00:08:42','version'=>'6.44' },{'date'=>'2008-09-06T10:22:44','version'=>'6.45_01' },{'date'=>'2008-09-07T21:18:05','version'=>'6.45_02' },{'date'=>'2008-09-27T21:37:54','version'=>'6.46' },{'date'=>'2008-10-14T16:41:49','version'=>'6.47_01' },{'date'=>'2008-10-16T23:18:52','version'=>'6.47_02' },{'date'=>'2008-10-20T18:20:40','version'=>'6.48' },{'date'=>'2009-02-20T01:11:08','version'=>'6.49_01' },{'date'=>'2009-03-22T19:30:00','version'=>'6.50' },{'date'=>'2009-04-10T21:33:29','version'=>'6.51_01' },{'date'=>'2009-04-14T04:22:58','version'=>'6.51_02' },{'date'=>'2009-05-24T05:41:35','version'=>'6.51_03' },{'date'=>'2009-05-24T21:07:28','version'=>'6.51_04' },{'date'=>'2009-05-30T18:41:35','version'=>'6.52' },{'date'=>'2009-06-08T02:05:24','version'=>'6.53_01' },{'date'=>'2009-06-08T02:28:24','version'=>'6.53_02' },{'date'=>'2009-07-02T21:55:25','version'=>'6.53_03' },{'date'=>'2009-07-07T23:53:09','version'=>'6.54' },{'date'=>'2009-07-14T23:02:39','version'=>'6.55_01' },{'date'=>'2009-08-05T07:40:59','version'=>'6.55_02' },{'date'=>'2009-12-05T07:09:23','version'=>'6.55_03' },{'date'=>'2009-12-17T22:06:47','version'=>'6.56' },{'date'=>'2010-08-24T08:38:36','version'=>'6.57_01' },{'date'=>'2010-09-07T23:43:49','version'=>'6.57_02' },{'date'=>'2010-09-08T22:33:36','version'=>'6.57_03' },{'date'=>'2010-09-09T23:52:37','version'=>'6.57_04' },{'date'=>'2010-09-11T20:25:23','version'=>'6.57_05' },{'date'=>'2010-10-06T10:53:43','version'=>'6.57_06' },{'date'=>'2011-03-25T03:41:39','version'=>'6.57_07' },{'date'=>'2011-03-27T11:00:41','version'=>'6.57_08' },{'date'=>'2011-03-28T00:15:59','version'=>'6.57_09' },{'date'=>'2011-04-04T05:33:46','version'=>'6.57_10' },{'date'=>'2011-05-20T00:34:23','version'=>'6.57_11' },{'date'=>'2011-07-06T21:22:27','version'=>'6.58' },{'date'=>'2011-08-03T20:25:34','version'=>'6.58_01' },{'date'=>'2011-08-05T13:07:58','version'=>'6.59' },{'date'=>'2011-09-25T05:23:43','version'=>'6.61_01' },{'date'=>'2011-10-23T23:48:06','version'=>'6.62' },{'date'=>'2011-10-24T00:40:49','version'=>'6.63_01' },{'date'=>'2011-11-02T00:07:43','version'=>'6.63_02' },{'date'=>'2012-11-02T03:58:40','version'=>'6.63_03' },{'date'=>'2012-11-22T21:25:35','version'=>'6.63_04' },{'date'=>'2012-12-17T02:35:20','version'=>'6.64' },{'date'=>'2013-03-18T23:21:28','version'=>'6.65_01' },{'date'=>'2013-04-14T09:59:15','version'=>'6.65_02' },{'date'=>'2013-04-15T12:50:31','version'=>'6.65_03' },{'date'=>'2013-04-19T17:52:08','version'=>'6.66' },{'date'=>'2013-04-25T20:08:31','version'=>'6.67_01' },{'date'=>'2013-06-02T17:31:16','version'=>'6.67_02' },{'date'=>'2013-06-05T21:09:00','version'=>'6.67_03' },{'date'=>'2013-06-10T19:25:22','version'=>'6.67_04' },{'date'=>'2013-06-13T20:55:25','version'=>'6.67_05' },{'date'=>'2013-06-14T22:35:24','version'=>'6.68' },{'date'=>'2013-06-20T12:00:00','version'=>'6.69_01' },{'date'=>'2013-07-02T12:16:23','version'=>'6.69_02' },{'date'=>'2013-07-09T21:47:07','version'=>'6.69_03' },{'date'=>'2013-07-10T10:50:08','version'=>'6.69_04' },{'date'=>'2013-07-11T21:20:53','version'=>'6.69_05' },{'date'=>'2013-07-12T13:51:50','version'=>'6.69_06' },{'date'=>'2013-07-16T14:34:32','version'=>'6.69_07' },{'date'=>'2013-07-16T23:40:44','version'=>'6.69_08' },{'date'=>'2013-07-21T08:26:44','version'=>'6.69_09' },{'date'=>'2013-07-23T21:42:47','version'=>'6.70' },{'date'=>'2013-07-24T08:33:58','version'=>'6.71_01' },{'date'=>'2013-07-24T17:42:20','version'=>'6.72' },{'date'=>'2013-07-24T22:53:41','version'=>'6.73_01' },{'date'=>'2013-07-26T12:34:19','version'=>'6.73_02' },{'date'=>'2013-07-30T21:12:02','version'=>'6.73_03' },{'date'=>'2013-08-01T21:41:12','version'=>'6.73_04' },{'date'=>'2013-08-05T16:45:38','version'=>'6.73_05' },{'date'=>'2013-08-05T23:52:18','version'=>'6.73_06' },{'date'=>'2013-08-07T15:09:12','version'=>'6.73_07' },{'date'=>'2013-08-09T18:52:24','version'=>'6.73_08' },{'date'=>'2013-08-09T19:00:18','version'=>'6.73_09' },{'date'=>'2013-08-16T15:43:35','version'=>'6.73_10' },{'date'=>'2013-08-17T21:57:55','version'=>'6.73_11' },{'date'=>'2013-08-23T09:52:43','version'=>'6.73_12' },{'date'=>'2013-08-27T11:45:55','version'=>'6.74' },{'date'=>'2013-08-29T14:09:22','version'=>'6.75_01' },{'date'=>'2013-09-01T20:52:29','version'=>'6.75_02' },{'date'=>'2013-09-02T23:26:56','version'=>'6.75_03' },{'date'=>'2013-09-05T11:10:20','version'=>'6.75_04' },{'date'=>'2013-09-06T12:40:59','version'=>'6.76' },{'date'=>'2013-09-10T14:22:45','version'=>'6.77_01' },{'date'=>'2013-09-12T20:23:49','version'=>'6.77_02' },{'date'=>'2013-09-16T11:23:59','version'=>'6.77_03' },{'date'=>'2013-09-18T18:25:33','version'=>'6.77_04' },{'date'=>'2013-09-19T13:12:32','version'=>'6.77_05' },{'date'=>'2013-09-19T14:43:24','version'=>'6.77_06' },{'date'=>'2013-09-21T08:48:44','version'=>'6.77_07' },{'date'=>'2013-09-22T17:46:50','version'=>'6.77_08' },{'date'=>'2013-09-23T12:47:39','version'=>'6.78' },{'date'=>'2013-10-01T14:01:33','version'=>'6.79_01' },{'date'=>'2013-10-11T12:01:23','version'=>'6.79_02' },{'date'=>'2013-10-11T13:00:29','version'=>'6.79_03' },{'date'=>'2013-10-11T17:59:30','version'=>'6.79_04' },{'date'=>'2013-10-15T15:08:06','version'=>'6.80' },{'date'=>'2013-10-16T08:04:29','version'=>'6.81_01' },{'date'=>'2013-10-17T11:24:19','version'=>'6.81_02' },{'date'=>'2013-10-24T19:54:34','version'=>'6.81_03' },{'date'=>'2013-11-01T19:56:13','version'=>'6.81_04' },{'date'=>'2013-11-02T21:44:06','version'=>'6.81_05' },{'date'=>'2013-11-04T19:24:38','version'=>'6.82' },{'date'=>'2013-11-05T11:45:54','version'=>'6.83_01' },{'date'=>'2013-11-12T11:15:21','version'=>'6.83_02' },{'date'=>'2013-11-15T09:49:39','version'=>'6.83_03' },{'date'=>'2013-11-17T11:44:01','version'=>'6.83_04' },{'date'=>'2013-11-25T22:52:46','version'=>'6.83_05' },{'date'=>'2013-11-29T21:55:40','version'=>'6.83_06' },{'date'=>'2013-11-30T15:27:01','version'=>'6.84' },{'date'=>'2013-12-16T13:18:35','version'=>'6.85_01' },{'date'=>'2013-12-17T10:17:50','version'=>'6.85_02' },{'date'=>'2013-12-23T14:59:36','version'=>'6.85_03' },{'date'=>'2013-12-23T15:02:38','version'=>'6.85_04' },{'date'=>'2013-12-29T11:28:14','version'=>'6.85_05' },{'date'=>'2013-12-30T23:18:09','version'=>'6.85_06' },{'date'=>'2014-01-01T19:00:36','version'=>'6.85_07' },{'date'=>'2014-01-04T12:21:05','version'=>'6.86' },{'date'=>'2014-01-12T10:34:38','version'=>'6.87_01' },{'date'=>'2014-01-18T13:30:15','version'=>'6.87_02' },{'date'=>'2014-01-19T17:53:19','version'=>'6.87_03' },{'date'=>'2014-01-26T19:33:34','version'=>'6.87_04' },{'date'=>'2014-01-28T14:00:44','version'=>'6.87_05' },{'date'=>'2014-01-31T20:59:13','version'=>'6.88' },{'date'=>'2014-02-17T16:23:55','version'=>'6.89_01' },{'date'=>'2014-02-20T20:49:24','version'=>'6.90' },{'date'=>'2014-03-06T13:52:24','version'=>'6.91_01' },{'date'=>'2014-03-13T16:34:37','version'=>'6.92' },{'date'=>'2014-03-24T16:57:01','version'=>'6.93_01' },{'date'=>'2014-03-25T20:38:21','version'=>'6.94' },{'date'=>'2014-04-02T20:52:53','version'=>'6.95_01' },{'date'=>'2014-04-07T14:29:26','version'=>'6.95_02' },{'date'=>'2014-04-11T21:09:21','version'=>'6.96' },{'date'=>'2014-04-24T13:29:12','version'=>'6.97_01' },{'date'=>'2014-04-28T10:55:44','version'=>'6.97_02' },{'date'=>'2014-04-29T20:41:00','version'=>'6.98' },{'date'=>'2014-06-03T21:19:42','version'=>'6.99_01' },{'date'=>'2014-06-05T11:18:25','version'=>'6.99_02' },{'date'=>'2014-07-04T10:15:23','version'=>'6.99_03' },{'date'=>'2014-07-12T11:54:35','version'=>'6.99_04' },{'date'=>'2014-07-22T11:42:12','version'=>'6.99_05' },{'date'=>'2014-07-28T14:07:14','version'=>'6.99_06' },{'date'=>'2014-07-30T16:44:02','version'=>'6.99_07' },{'date'=>'2014-08-18T13:19:18','version'=>'6.99_08' },{'date'=>'2014-08-28T10:13:30','version'=>'6.99_09' },{'date'=>'2014-09-04T14:04:55','version'=>'6.99_10' },{'date'=>'2014-09-08T13:39:46','version'=>'6.99_11' },{'date'=>'2014-09-11T14:32:19','version'=>'6.99_12' },{'date'=>'2014-09-15T19:11:34','version'=>'6.99_13' },{'date'=>'2014-09-19T14:06:14','version'=>'6.99_14' },{'date'=>'2014-09-21T12:23:58','version'=>'6.99_15' },{'date'=>'2014-10-02T18:50:08','version'=>'6.99_16' },{'date'=>'2014-10-12T18:41:24','version'=>'6.99_17' },{'date'=>'2014-10-20T09:14:39','version'=>'6.99_18' },{'date'=>'2014-10-22T19:48:56','version'=>'7.00' },{'date'=>'2014-10-25T12:49:55','version'=>'7.01_01' },{'date'=>'2014-10-25T16:49:40','version'=>'7.01_02' },{'date'=>'2014-10-30T19:48:04','version'=>'7.01_03' },{'date'=>'2014-10-31T10:13:56','version'=>'7.01_04' },{'date'=>'2014-11-03T12:53:43','version'=>'7.01_05' },{'date'=>'2014-11-03T20:55:23','version'=>'7.01_06' },{'date'=>'2014-11-04T19:40:07','version'=>'7.01_07' },{'date'=>'2014-11-04T20:29:00','version'=>'7.01_08' },{'date'=>'2014-11-06T21:59:55','version'=>'7.01_09' },{'date'=>'2014-11-08T10:39:16','version'=>'7.02' },{'date'=>'2014-11-18T21:47:11','version'=>'7.03_01' },{'date'=>'2014-11-24T13:26:46','version'=>'7.03_02' },{'date'=>'2014-11-25T16:43:06','version'=>'7.03_03' },{'date'=>'2014-11-27T14:42:51','version'=>'7.03_04' },{'date'=>'2014-11-28T18:32:48','version'=>'7.03_05' },{'date'=>'2014-12-01T15:37:46','version'=>'7.03_06' },{'date'=>'2014-12-02T12:56:02','version'=>'7.04' },{'date'=>'2014-12-06T16:58:07','version'=>'7.05_01' },{'date'=>'2014-12-15T20:13:08','version'=>'7.05_02' },{'date'=>'2014-12-24T12:12:00','version'=>'7.05_03' },{'date'=>'2014-12-24T14:49:46','version'=>'7.05_04' },{'date'=>'2014-12-31T23:21:05','version'=>'7.05_05' },{'date'=>'2015-01-08T19:09:29','version'=>'7.05_06' },{'date'=>'2015-01-09T16:23:43','version'=>'7.05_07' },{'date'=>'2015-01-20T10:13:21','version'=>'7.05_08' },{'date'=>'2015-01-23T10:51:30','version'=>'7.05_09' },{'date'=>'2015-01-26T15:19:01','version'=>'7.05_10' },{'date'=>'2015-01-31T16:40:19','version'=>'7.05_11' },{'date'=>'2015-02-07T15:19:11','version'=>'7.05_12' },{'date'=>'2015-02-18T22:49:29','version'=>'7.05_13' },{'date'=>'2015-02-20T17:32:55','version'=>'7.05_14' },{'date'=>'2015-03-05T19:44:02','version'=>'7.05_15' },{'date'=>'2015-03-09T11:35:12','version'=>'7.05_16' },{'date'=>'2015-03-24T12:27:52','version'=>'7.05_17' },{'date'=>'2015-03-27T12:20:03','version'=>'7.05_18' },{'date'=>'2015-03-27T16:59:34','version'=>'7.05_19' },{'date'=>'2015-04-04T15:53:36','version'=>'7.05_20' },{'date'=>'2015-06-13T14:19:26','version'=>'7.05_21' },{'date'=>'2015-06-14T13:44:56','version'=>'7.05_22' },{'date'=>'2015-06-24T19:51:24','version'=>'7.05_23' },{'date'=>'2015-07-01T18:30:38','version'=>'7.05_24' },{'date'=>'2015-07-07T17:18:36','version'=>'7.05_25' },{'date'=>'2015-08-04T19:41:25','version'=>'7.05_26' },{'date'=>'2015-08-05T09:35:40','version'=>'7.05_27' },{'date'=>'2015-08-19T18:10:20','version'=>'7.05_28' },{'date'=>'2015-08-24T15:26:22','version'=>'7.05_29' },{'date'=>'2015-08-31T18:06:48','version'=>'7.06' },{'date'=>'2015-09-02T11:55:33','version'=>'7.07_01' },{'date'=>'2015-09-08T19:59:05','version'=>'7.08' },{'date'=>'2015-09-10T18:55:41','version'=>'7.10' },{'date'=>'2015-11-12T12:35:03','version'=>'7.11_01' },{'date'=>'2015-11-21T20:23:22','version'=>'7.11_02' },{'date'=>'2015-11-25T15:40:06','version'=>'7.11_03' },{'date'=>'2016-02-15T11:40:55','version'=>'7.11_04' },{'date'=>'2016-03-19T10:07:11','version'=>'7.11_05' },{'date'=>'2016-03-29T18:44:47','version'=>'7.11_06' },{'date'=>'2016-04-19T11:41:10','version'=>'7.12' },{'date'=>'2016-04-23T16:35:56','version'=>'7.13_01' },{'date'=>'2016-04-24T13:20:40','version'=>'7.14' },{'date'=>'2016-04-27T18:27:25','version'=>'7.15_01' },{'date'=>'2016-04-28T12:15:28','version'=>'7.15_02' },{'date'=>'2016-05-01T13:29:10','version'=>'7.15_03' },{'date'=>'2016-05-07T10:28:49','version'=>'7.16' },{'date'=>'2016-05-09T19:14:54','version'=>'7.17_01' },{'date'=>'2016-05-09T23:07:33','version'=>'7.17_02' },{'date'=>'2016-05-11T18:22:21','version'=>'7.17_03' },{'date'=>'2016-05-23T15:39:08','version'=>'7.18' },{'date'=>'2016-06-02T14:01:28','version'=>'7.19_01' },{'date'=>'2016-06-13T09:11:52','version'=>'7.19_02' },{'date'=>'2016-06-13T13:44:33','version'=>'7.19_03' },{'date'=>'2016-06-14T11:35:43','version'=>'7.19_04' },{'date'=>'2016-06-20T14:40:57','version'=>'7.19_05' },{'date'=>'2016-06-27T12:04:29','version'=>'7.19_06' },{'date'=>'2016-07-03T14:30:23','version'=>'7.19_07' },{'date'=>'2016-07-28T12:26:56','version'=>'7.19_08' },{'date'=>'2016-08-05T08:57:09','version'=>'7.20' },{'date'=>'2016-08-07T09:54:04','version'=>'7.21_01' },{'date'=>'2016-08-08T08:42:10','version'=>'7.22' },{'date'=>'2016-08-19T09:24:06','version'=>'7.23_01' },{'date'=>'2016-08-20T12:35:27','version'=>'7.24' },{'date'=>'2017-02-03T15:21:22','version'=>'7.25_01' },{'date'=>'2017-05-11T11:19:49','version'=>'7.25_02' },{'date'=>'2017-05-11T17:09:16','version'=>'7.25_03' },{'date'=>'2017-05-12T12:25:54','version'=>'7.25_04' },{'date'=>'2017-05-15T09:41:49','version'=>'7.25_05' },{'date'=>'2017-05-23T19:31:28','version'=>'7.25_06' },{'date'=>'2017-05-27T20:21:06','version'=>'7.26' },{'date'=>'2017-05-28T10:50:55','version'=>'7.27_01' },{'date'=>'2017-05-30T08:56:32','version'=>'7.27_02' },{'date'=>'2017-05-30T21:26:23','version'=>'7.28' },{'date'=>'2017-05-31T08:32:44','version'=>'7.29_01' },{'date'=>'2017-06-11T11:17:55','version'=>'7.29_02' },{'date'=>'2017-06-12T12:31:08','version'=>'7.30' },{'date'=>'2017-06-14T15:10:23','version'=>'7.31_01' },{'date'=>'2017-06-26T13:14:10','version'=>'7.31_02' },{'date'=>'2017-07-10T09:02:35','version'=>'7.31_03' },{'date'=>'2017-10-05T12:19:00','version'=>'7.31_04' },{'date'=>'2017-11-25T09:37:04','version'=>'7.31_05' },{'date'=>'2018-01-16T13:28:46','version'=>'7.31_06' },{'date'=>'2018-01-16T16:24:23','version'=>'7.31_07' },{'date'=>'2018-02-12T12:32:45','version'=>'7.31_08' },{'date'=>'2018-02-16T20:25:44','version'=>'7.32' },{'date'=>'2018-02-20T10:44:19','version'=>'7.33_01' },{'date'=>'2018-02-24T14:05:00','version'=>'7.33_02' },{'date'=>'2018-02-24T20:21:42','version'=>'7.33_03' },{'date'=>'2018-03-19T10:51:54','version'=>'7.34' },{'date'=>'2018-04-19T12:46:01','version'=>'7.35_01' },{'date'=>'2018-04-24T11:01:35','version'=>'7.35_02' },{'date'=>'2018-04-27T13:59:23','version'=>'7.35_03' },{'date'=>'2018-07-09T09:50:43','version'=>'7.35_04' },{'date'=>'2018-07-10T09:18:31','version'=>'7.35_05' },{'date'=>'2018-07-19T19:49:08','version'=>'7.35_06' },{'date'=>'2018-11-23T11:59:44','version'=>'7.35_07' },{'date'=>'2018-12-06T10:56:33','version'=>'7.35_08' },{'date'=>'2019-02-18T10:27:00','version'=>'7.35_09' },{'date'=>'2019-02-20T10:06:48','version'=>'7.35_10' }]},'FCGI'=>{'advisories'=>[{'affected_versions'=>'<0.74','cves'=>['CVE-2011-2766' ],'description'=>'Leaking information across requests when using the deprecated and undocumented old FCGI interface.
  ','distribution'=>'FCGI','fixed_versions'=>'>=0.74','id'=>'CPANSA-FCGI-2011-01','references'=>['https://metacpan.org/changes/distribution/FCGI','https://github.com/perl-catalyst/FCGI/commit/297693dc8362d25bb25e473899c72508a0f71d2e' ],'reported'=>'2011-09-24' }],'main_module'=>'FCGI','versions'=>[{'date'=>'1996-09-25T17:48:57','version'=>'0.25' },{'date'=>'1996-10-15T21:51:06','version'=>'0.26' },{'date'=>'1997-02-20T08:55:44','version'=>'0.27' },{'date'=>'1997-02-25T07:14:13','version'=>'0.28' },{'date'=>'1997-06-10T18:16:17','version'=>'0.29' },{'date'=>'1997-06-24T17:17:05','version'=>'0.30' },{'date'=>'1997-07-24T11:05:43','version'=>'0.31' },{'date'=>'1998-06-17T10:24:17','version'=>'0.34' },{'date'=>'1998-06-22T15:38:51','version'=>'0.35' },{'date'=>'1998-06-24T19:42:57','version'=>'0.36' },{'date'=>'1998-06-27T16:08:39','version'=>'0.37' },{'date'=>'1998-07-15T15:24:00','version'=>'0.40' },{'date'=>'1998-07-29T16:05:51','version'=>'0.41' },{'date'=>'1998-08-28T15:30:49','version'=>'0.42' },{'date'=>'1998-12-22T22:34:14','version'=>'0.43' },{'date'=>'1998-12-23T11:28:39','version'=>'0.44' },{'date'=>'1999-03-08T17:04:02','version'=>'0.45' },{'date'=>'1999-07-30T08:26:31','version'=>'0.46' },{'date'=>'1999-07-31T21:58:01','version'=>'0.47' },{'date'=>'1999-08-27T13:41:54','version'=>'0.48' },{'date'=>'2000-04-09T18:58:32','version'=>'0.49' },{'date'=>'2000-04-10T07:04:43','version'=>'0.50' },{'date'=>'2000-04-12T12:27:09','version'=>'0.51' },{'date'=>'2000-04-12T14:10:02','version'=>'0.52' },{'date'=>'2000-07-10T10:01:51','version'=>'0.53' },{'date'=>'2000-10-08T19:52:29','version'=>'0.54' },{'date'=>'2000-10-18T21:22:46','version'=>'0.55' },{'date'=>'2000-11-03T15:44:28','version'=>'0.56' },{'date'=>'2000-11-12T15:15:01','version'=>'0.57' },{'date'=>'2000-11-14T23:20:24','version'=>'0.58' },{'date'=>'2000-12-31T22:05:44','version'=>'0.59' },{'date'=>'2001-06-08T15:19:08','version'=>'0.60' },{'date'=>'2001-09-20T12:34:13','version'=>'0.61' },{'date'=>'2001-09-21T16:19:42','version'=>'0.62' },{'date'=>'2001-09-24T20:43:48','version'=>'0.63' },{'date'=>'2001-09-25T08:26:24','version'=>'0.64' },{'date'=>'2002-02-19T14:16:27','version'=>'0.65' },{'date'=>'2002-09-05T16:23:07','version'=>'0.66' },{'date'=>'2002-12-23T10:21:36','version'=>'0.67' },{'date'=>'2009-12-20T21:05:48','version'=>'0.67_01' },{'date'=>'2010-01-06T10:07:05','version'=>'0.68' },{'date'=>'2010-01-10T01:35:11','version'=>'0.68_01' },{'date'=>'2010-01-13T19:25:40','version'=>'0.68_02' },{'date'=>'2010-02-15T23:08:12','version'=>'0.69' },{'date'=>'2010-03-22T14:35:03','version'=>'0.70' },{'date'=>'2010-04-01T00:55:33','version'=>'0.71' },{'date'=>'2010-08-24T21:32:56','version'=>'0.71_01' },{'date'=>'2011-04-28T08:50:09','version'=>'0.71_02' },{'date'=>'2011-04-28T09:05:42','version'=>'0.71_03' },{'date'=>'2011-05-19T09:06:02','version'=>'0.72' },{'date'=>'2011-05-28T01:35:17','version'=>'0.73' },{'date'=>'2011-09-24T08:31:47','version'=>'0.74' },{'date'=>'2014-07-17T00:19:02','version'=>'0.75' },{'date'=>'2014-08-05T01:29:06','version'=>'0.76' },{'date'=>'2014-08-05T15:53:28','version'=>'0.77' },{'date'=>'2016-03-07T00:08:23','version'=>'0.78' }]},'Fake-Encode'=>{'advisories'=>[{'affected_versions'=>'<0.08','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'Fake-Encode','fixed_versions'=>'>=0.08','id'=>'CPANSA-Fake-Encode-2017-01','references'=>['https://metacpan.org/changes/distribution/Fake-Encode' ],'reported'=>'2017-01-23' }],'main_module'=>'Fake::Encode','versions'=>[{'date'=>'2016-05-31T14:11:49','version'=>'0.01' },{'date'=>'2017-01-23T12:34:23','version'=>'0.02' },{'date'=>'2017-01-25T15:52:13','version'=>'0.03' },{'date'=>'2017-01-26T15:17:01','version'=>'0.04' },{'date'=>'2017-03-06T16:01:40','version'=>'0.05' },{'date'=>'2017-09-08T17:54:14','version'=>'0.06' },{'date'=>'2017-09-09T15:27:50','version'=>'0.07' },{'date'=>'2018-02-03T14:50:49','version'=>'0.08' },{'date'=>'2018-02-19T12:21:04','version'=>'0.09' }]},'Fake-Our'=>{'advisories'=>[{'affected_versions'=>'<0.06','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'Fake-Our','fixed_versions'=>'>=0.06','id'=>'CPANSA-Fake-Our-2017-01','references'=>['https://metacpan.org/changes/distribution/Fake-Our' ],'reported'=>'2017-01-23' }],'main_module'=>'Fake::Our','versions'=>[{'date'=>'2014-02-09T05:36:09','version'=>'0.01' },{'date'=>'2014-08-06T17:33:15','version'=>'0.02' },{'date'=>'2014-08-09T02:35:25','version'=>'0.03' },{'date'=>'2014-08-10T15:33:58','version'=>'0.04' },{'date'=>'2015-06-21T04:09:47','version'=>'0.05' },{'date'=>'2017-01-23T12:34:34','version'=>'0.06' },{'date'=>'2017-01-26T15:21:45','version'=>'0.07' },{'date'=>'2017-01-27T15:18:56','version'=>'0.08' },{'date'=>'2017-01-28T15:07:50','version'=>'0.09' },{'date'=>'2017-03-06T16:01:51','version'=>'0.10' },{'date'=>'2018-02-03T11:05:49','version'=>'0.11' },{'date'=>'2018-02-16T17:54:00','version'=>'0.12' },{'date'=>'2018-02-17T01:35:58','version'=>'0.13' },{'date'=>'2018-02-18T15:32:17','version'=>'0.14' }]},'File-DataClass'=>{'advisories'=>[{'affected_versions'=>'<0.72.1','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'File-DataClass','fixed_versions'=>'>=0.72.1','id'=>'CPANSA-File-DataClass-2017-01','references'=>['https://metacpan.org/changes/distribution/File-DataClass' ],'reported'=>'2017-04-01' }],'main_module'=>'File::DataClass','versions'=>[{'date'=>'2010-09-29T16:37:04','version'=>'0.1.228' },{'date'=>'2010-10-06T14:20:31','version'=>'0.2.234' },{'date'=>'2011-01-26T18:14:50','version'=>'0.3.238' },{'date'=>'2011-02-27T23:09:38','version'=>'0.3.239' },{'date'=>'2011-04-12T19:44:59','version'=>'0.3.259' },{'date'=>'2011-05-15T17:45:09','version'=>'0.4.268' },{'date'=>'2011-05-30T01:47:40','version'=>'0.5.271' },{'date'=>'2011-07-11T13:39:10','version'=>'0.6.286' },{'date'=>'2011-11-30T00:05:18','version'=>'0.7.321' },{'date'=>'2011-12-02T04:40:20','version'=>'0.7.325' },{'date'=>'2011-12-02T22:39:25','version'=>'0.7.326' },{'date'=>'2011-12-03T18:43:58','version'=>'0.7.328' },{'date'=>'2012-02-22T18:28:29','version'=>'0.7.330' },{'date'=>'2012-02-23T11:00:24','version'=>'0.7.331' },{'date'=>'2012-02-24T10:52:18','version'=>'0.7.332' },{'date'=>'2012-03-12T17:34:58','version'=>'0.7.335' },{'date'=>'2012-03-20T18:24:26','version'=>'0.7.336' },{'date'=>'2012-03-21T22:43:50','version'=>'0.7.338' },{'date'=>'2012-03-22T13:48:59','version'=>'0.7.339' },{'date'=>'2012-03-24T00:37:31','version'=>'0.7.343' },{'date'=>'2012-03-28T23:58:41','version'=>'0.8.351' },{'date'=>'2012-03-29T22:05:21','version'=>'0.8.355' },{'date'=>'2012-04-03T00:26:12','version'=>'0.8.357' },{'date'=>'2012-04-04T15:19:03','version'=>'0.8.360' },{'date'=>'2012-04-17T18:57:01','version'=>'0.9.368' },{'date'=>'2012-05-19T21:05:56','version'=>'0.10.380' },{'date'=>'2012-07-10T00:34:23','version'=>'0.11.401' },{'date'=>'2012-09-02T13:43:37','version'=>'0.12.406' },{'date'=>'2012-09-06T14:02:06','version'=>'0.12.409' },{'date'=>'2012-11-07T07:49:39','version'=>'0.13.416' },{'date'=>'2012-11-13T20:16:27','version'=>'0.13.418' },{'date'=>'2012-12-12T23:25:16','version'=>'0.13.420' },{'date'=>'2012-12-14T17:58:08','version'=>'0.13.421' },{'date'=>'2012-12-19T22:23:08','version'=>'0.13.422' },{'date'=>'2012-12-21T20:48:41','version'=>'0.13.424' },{'date'=>'2012-12-30T03:05:28','version'=>'0.13.427' },{'date'=>'2013-01-07T00:52:48','version'=>'0.14.429' },{'date'=>'2013-04-01T01:14:44','version'=>'0.15.431' },{'date'=>'2013-04-02T14:21:13','version'=>'0.15.434' },{'date'=>'2013-04-14T16:15:55','version'=>'v0.16.438' },{'date'=>'2013-04-15T20:42:56','version'=>'v0.16.442' },{'date'=>'2013-04-24T03:47:54','version'=>'v0.16.445' },{'date'=>'2013-04-29T17:12:37','version'=>'v0.17.450' },{'date'=>'2013-04-30T22:15:36','version'=>'v0.18.6' },{'date'=>'2013-05-02T14:14:57','version'=>'v0.19.1' },{'date'=>'2013-05-07T23:33:06','version'=>'v0.20.6' },{'date'=>'2013-05-10T14:58:03','version'=>'v0.20.7' },{'date'=>'2013-05-14T13:32:28','version'=>'v0.20.8' },{'date'=>'2013-05-15T20:03:34','version'=>'v0.20.9' },{'date'=>'2013-05-16T00:11:50','version'=>'v0.20.10' },{'date'=>'2013-05-17T16:07:41','version'=>'v0.20.12' },{'date'=>'2013-06-08T13:26:40','version'=>'v0.20.13' },{'date'=>'2013-07-28T17:41:14','version'=>'v0.22.1' },{'date'=>'2013-07-29T11:39:49','version'=>'v0.22.2' },{'date'=>'2013-07-29T11:46:28','version'=>'v0.22.3' },{'date'=>'2013-07-29T18:37:14','version'=>'v0.22.4' },{'date'=>'2013-07-30T10:19:23','version'=>'v0.22.5' },{'date'=>'2013-07-30T16:25:59','version'=>'v0.22.7' },{'date'=>'2013-07-31T09:54:30','version'=>'v0.22.8' },{'date'=>'2013-08-02T19:06:49','version'=>'v0.22.9' },{'date'=>'2013-08-06T17:19:31','version'=>'v0.23.1' },{'date'=>'2013-08-07T13:14:13','version'=>'v0.23.2' },{'date'=>'2013-08-13T18:01:24','version'=>'0.24.1' },{'date'=>'2013-08-16T22:49:23','version'=>'0.24.3' },{'date'=>'2013-09-03T13:11:17','version'=>'0.25.1' },{'date'=>'2013-09-26T16:04:18','version'=>'0.26.1' },{'date'=>'2013-11-22T09:42:00','version'=>'0.27.1' },{'date'=>'2014-01-01T15:02:23','version'=>'0.28.1' },{'date'=>'2014-01-01T17:03:18','version'=>'0.29.1' },{'date'=>'2014-01-02T02:33:28','version'=>'0.30.1' },{'date'=>'2014-01-13T18:41:29','version'=>'0.31.1' },{'date'=>'2014-01-24T20:56:21','version'=>'0.33.1' },{'date'=>'2014-04-04T10:52:59','version'=>'0.34.1' },{'date'=>'2014-05-01T14:40:32','version'=>'0.35.1' },{'date'=>'2014-05-13T10:03:54','version'=>'0.36.1' },{'date'=>'2014-05-13T21:08:07','version'=>'0.37.1' },{'date'=>'2014-05-15T00:11:43','version'=>'0.38.1' },{'date'=>'2014-05-16T08:19:01','version'=>'0.39.1' },{'date'=>'2014-05-22T09:37:34','version'=>'0.40.1' },{'date'=>'2014-05-22T14:10:49','version'=>'0.40.2' },{'date'=>'2014-05-28T10:28:42','version'=>'0.41.1' },{'date'=>'2014-07-03T23:27:53','version'=>'0.42.1' },{'date'=>'2014-07-04T09:25:10','version'=>'0.42.2' },{'date'=>'2014-07-04T12:19:02','version'=>'0.43.1' },{'date'=>'2014-07-16T12:39:03','version'=>'0.44.1' },{'date'=>'2014-08-18T23:00:05','version'=>'0.45.1' },{'date'=>'2014-08-26T12:43:14','version'=>'0.45.5' },{'date'=>'2014-08-26T16:41:35','version'=>'0.46.1' },{'date'=>'2014-08-27T16:17:50','version'=>'0.47.1' },{'date'=>'2014-09-03T22:25:51','version'=>'0.48.1' },{'date'=>'2014-10-02T17:39:13','version'=>'0.48.3' },{'date'=>'2014-10-02T19:59:28','version'=>'0.49.1' },{'date'=>'2014-11-07T18:51:52','version'=>'0.50.1' },{'date'=>'2014-11-08T21:45:45','version'=>'0.50.2' },{'date'=>'2014-11-09T13:19:50','version'=>'0.50.3' },{'date'=>'2014-11-09T15:52:41','version'=>'0.51.1' },{'date'=>'2014-11-10T12:44:49','version'=>'0.52.1' },{'date'=>'2014-12-19T11:49:49','version'=>'0.53.1' },{'date'=>'2014-12-19T22:54:41','version'=>'0.54.1' },{'date'=>'2015-02-05T00:04:33','version'=>'0.55.1' },{'date'=>'2015-03-19T14:59:03','version'=>'0.56.1' },{'date'=>'2015-04-04T20:00:58','version'=>'0.57.1' },{'date'=>'2015-04-04T20:16:31','version'=>'0.58.1' },{'date'=>'2015-04-05T17:58:31','version'=>'0.59.1' },{'date'=>'2015-04-08T23:10:28','version'=>'0.60.1' },{'date'=>'2015-05-11T12:15:05','version'=>'0.61.1' },{'date'=>'2015-05-24T11:52:28','version'=>'0.62.1' },{'date'=>'2015-06-21T21:42:17','version'=>'0.63.1' },{'date'=>'2015-08-29T08:58:54','version'=>'0.66.1' },{'date'=>'2016-02-01T00:18:43','version'=>'0.67.1' },{'date'=>'2016-02-01T14:33:11','version'=>'0.68.1' },{'date'=>'2016-07-05T00:36:52','version'=>'0.69.1' },{'date'=>'2016-07-29T15:24:24','version'=>'0.70.1' },{'date'=>'2016-07-29T18:59:13','version'=>'0.71.1' },{'date'=>'2017-04-02T08:23:47','version'=>'0.72.1' },{'date'=>'2017-06-02T00:03:17','version'=>'0.73.1' }]},'File-Path'=>{'advisories'=>[{'affected_versions'=>'<2.13','cves'=>['CVE-2017-6512' ],'description'=>'Race condition in the rmtree and remove_tree functions allows attackers to set the mode on arbitrary files via vectors involving directory-permission loosening logic.
  ','distribution'=>'Fake-Encode','fixed_versions'=>'>=2.13','id'=>'CPANSA-File-Path-2017-01','references'=>['https://metacpan.org/changes/distribution/File-Path','https://github.com/jkeenan/File-Path/commit/e5ef95276ee8ad471c66ee574a5d42552b3a6af2' ],'reported'=>'2017-05-02' }],'main_module'=>'File::Path','versions'=>[{'date'=>'2007-05-17T13:46:15','version'=>'1.99_01' },{'date'=>'2007-05-27T09:29:48','version'=>'1.99_02' },{'date'=>'2007-06-27T19:23:09','version'=>'2.00_05' },{'date'=>'2007-07-04T21:37:13','version'=>'2.00_06' },{'date'=>'2007-07-09T19:37:02','version'=>'2.00_07' },{'date'=>'2007-08-01T00:10:43','version'=>'2.00_08' },{'date'=>'2007-08-20T18:15:55','version'=>'2.00_09' },{'date'=>'2007-09-04T17:20:45','version'=>'2.00_10' },{'date'=>'2007-09-08T12:53:07','version'=>'2.00_11' },{'date'=>'2007-09-29T10:29:32','version'=>'2.01' },{'date'=>'2007-10-24T10:36:09','version'=>'2.02' },{'date'=>'2007-11-04T18:36:19','version'=>'2.03' },{'date'=>'2007-11-24T09:53:23','version'=>'2.04' },{'date'=>'2008-05-07T08:25:05','version'=>'2.05' },{'date'=>'2008-05-08T09:36:50','version'=>'2.06' },{'date'=>'2008-05-10T21:02:47','version'=>'2.06_01' },{'date'=>'2008-05-12T10:07:46','version'=>'2.06_02' },{'date'=>'2008-05-12T21:43:43','version'=>'2.06_03' },{'date'=>'2008-05-13T14:40:30','version'=>'2.06_04' },{'date'=>'2008-10-01T20:41:37','version'=>'2.06_05' },{'date'=>'2008-10-05T21:59:58','version'=>'2.06_06' },{'date'=>'2008-10-29T17:55:36','version'=>'2.06_07' },{'date'=>'2008-11-05T00:12:29','version'=>'2.06_08' },{'date'=>'2008-11-09T13:11:17','version'=>'2.07' },{'date'=>'2009-06-21T13:23:32','version'=>'2.07_03' },{'date'=>'2009-10-04T10:31:05','version'=>'2.08' },{'date'=>'2013-01-16T21:36:05','version'=>'2.09' },{'date'=>'2015-06-24T17:03:22','version'=>'2.10_001' },{'date'=>'2015-06-26T17:28:20','version'=>'2.10_002' },{'date'=>'2015-07-08T16:59:11','version'=>'2.10_003' },{'date'=>'2015-07-10T11:34:44','version'=>'2.10_004' },{'date'=>'2015-07-17T15:03:07','version'=>'2.10_005' },{'date'=>'2015-07-18T02:28:14','version'=>'2.11' },{'date'=>'2015-07-24T23:01:36','version'=>'2.11_001' },{'date'=>'2015-07-25T09:56:18','version'=>'2.11_002' },{'date'=>'2015-08-03T18:07:05','version'=>'2.11_003' },{'date'=>'2015-10-01T19:34:07','version'=>'2.11_004' },{'date'=>'2015-10-09T12:11:52','version'=>'2.12' },{'date'=>'2016-09-18T13:35:39','version'=>'2.12_001' },{'date'=>'2017-03-12T22:09:35','version'=>'2.12_002' },{'date'=>'2017-04-07T13:59:30','version'=>'2.12_003' },{'date'=>'2017-04-18T18:37:56','version'=>'2.12_004' },{'date'=>'2017-04-21T12:03:20','version'=>'2.12_005' },{'date'=>'2017-04-21T21:58:56','version'=>'2.12_006' },{'date'=>'2017-04-22T20:09:24','version'=>'2.12_007' },{'date'=>'2017-05-07T17:48:35','version'=>'2.12_008' },{'date'=>'2017-05-31T23:44:51','version'=>'2.13' },{'date'=>'2017-06-07T21:34:52','version'=>'2.14' },{'date'=>'2017-07-30T02:40:36','version'=>'2.15' },{'date'=>'2018-08-31T13:04:13','version'=>'2.16' }]},'GBrowse'=>{'advisories'=>[{'affected_versions'=>'<2.56','description'=>'An attacker is able to delete other users\' accounts.  No httponly cookie flag.  Cross-site scripting vulnerability in generation of citation text.
  ','distribution'=>'GBrowse','fixed_versions'=>'>=2.56','id'=>'CPANSA-GBrowser-2017-01','references'=>['https://metacpan.org/changes/distribution/GBrowse' ],'reported'=>'2017-01-15' },{'affected_versions'=>'<1.62','description'=>'Cross-site scripting.
  ','distribution'=>'GBrowse','fixed_versions'=>'>=1.62','id'=>'CPANSA-GBrowser-2004-01','references'=>['https://metacpan.org/changes/distribution/GBrowse' ],'reported'=>'2004-04-05' },{'affected_versions'=>'<1.54','description'=>'Path traversal.
  ','distribution'=>'GBrowse','fixed_versions'=>'>=1.54','id'=>'CPANSA-GBrowser-2003-01','references'=>['https://metacpan.org/changes/distribution/GBrowse' ],'reported'=>'2003-08-23' }],'main_module'=>'CGI::Toggle','versions'=>[{'date'=>'2008-12-29T15:38:27','version'=>'1.981' },{'date'=>'2008-12-29T17:21:12','version'=>'1.982' },{'date'=>'2009-01-06T07:42:56','version'=>'1.983' },{'date'=>'2009-01-06T09:17:54','version'=>'1.984' },{'date'=>'2009-01-10T12:37:42','version'=>'1.985' },{'date'=>'2009-01-12T16:58:20','version'=>'1.986' },{'date'=>'2009-01-22T19:49:50','version'=>'1.987' },{'date'=>'2009-01-30T00:12:57','version'=>'1.988' },{'date'=>'2009-03-10T19:24:17','version'=>'1.989' },{'date'=>'2009-04-03T19:29:22','version'=>'1.99' },{'date'=>'2009-05-04T05:30:31','version'=>'1.991' },{'date'=>'2009-05-05T23:40:00','version'=>'1.992' },{'date'=>'2009-05-07T14:11:11','version'=>'1.993' },{'date'=>'2009-05-30T22:07:17','version'=>'1.994' },{'date'=>'2009-06-08T21:27:08','version'=>'1.995' },{'date'=>'2009-07-06T14:12:57','version'=>'1.996' },{'date'=>'2009-07-30T16:40:54','version'=>'1.997' },{'date'=>'2009-08-19T19:19:44','version'=>'1.9971' },{'date'=>'2009-12-09T21:39:37','version'=>'1.998' },{'date'=>'2009-12-15T15:59:37','version'=>'1.9982' },{'date'=>'2009-12-18T19:25:25','version'=>'1.9983' },{'date'=>'2009-12-22T21:20:40','version'=>'1.9984' },{'date'=>'2009-12-23T21:56:31','version'=>'1.999' },{'date'=>'2010-01-28T02:58:41','version'=>'2.00' },{'date'=>'2010-02-09T18:13:33','version'=>'2.01' },{'date'=>'2010-03-10T05:56:50','version'=>'2.02' },{'date'=>'2010-03-25T16:06:21','version'=>'2.03' },{'date'=>'2010-04-18T21:44:27','version'=>'2.04' },{'date'=>'2010-05-13T03:30:32','version'=>'2.05' },{'date'=>'2010-05-13T21:17:05','version'=>'2.06' },{'date'=>'2010-05-17T14:49:41','version'=>'2.07' },{'date'=>'2010-05-21T02:52:47','version'=>'2.08' },{'date'=>'2010-06-10T20:17:32','version'=>'2.09' },{'date'=>'2010-06-15T14:20:30','version'=>'2.10' },{'date'=>'2010-06-30T19:15:37','version'=>'2.11' },{'date'=>'2010-06-30T19:30:03','version'=>'2.12' },{'date'=>'2010-07-05T20:17:39','version'=>'2.13' },{'date'=>'2010-08-27T15:06:04','version'=>'2.14' },{'date'=>'2010-09-13T22:17:44','version'=>'2.15' },{'date'=>'2010-11-01T16:24:01','version'=>'2.16' },{'date'=>'2010-11-18T17:08:57','version'=>'2.17' },{'date'=>'2011-01-18T22:35:59','version'=>'2.20' },{'date'=>'2011-01-22T17:17:34','version'=>'2.21' },{'date'=>'2011-01-26T14:31:35','version'=>'2.22' },{'date'=>'2011-01-30T20:03:25','version'=>'2.23' },{'date'=>'2011-01-31T17:19:08','version'=>'2.24' },{'date'=>'2011-02-02T18:53:40','version'=>'2.25' },{'date'=>'2011-02-04T18:51:54','version'=>'2.26' },{'date'=>'2011-04-10T21:07:42','version'=>'2.27' },{'date'=>'2011-04-10T21:32:05','version'=>'2.28' },{'date'=>'2011-05-02T16:12:11','version'=>'2.29' },{'date'=>'2011-05-03T12:17:18','version'=>'2.30' },{'date'=>'2011-05-03T15:50:21','version'=>'2.31' },{'date'=>'2011-05-04T18:47:51','version'=>'2.32' },{'date'=>'2011-05-07T03:27:32','version'=>'2.33' },{'date'=>'2011-06-01T15:19:47','version'=>'2.34' },{'date'=>'2011-06-03T13:41:28','version'=>'2.35' },{'date'=>'2011-06-04T14:58:14','version'=>'2.36' },{'date'=>'2011-06-06T21:24:59','version'=>'2.37' },{'date'=>'2011-06-09T16:00:48','version'=>'2.38' },{'date'=>'2011-06-29T17:45:00','version'=>'2.39' },{'date'=>'2011-09-30T16:56:29','version'=>'2.40' },{'date'=>'2011-10-07T13:31:48','version'=>'2.41' },{'date'=>'2011-10-12T19:33:22','version'=>'2.42' },{'date'=>'2011-10-24T16:43:23','version'=>'2.43' },{'date'=>'2011-12-08T23:09:26','version'=>'2.44' },{'date'=>'2012-01-03T21:35:41','version'=>'2.45' },{'date'=>'2012-02-10T17:28:20','version'=>'2.46' },{'date'=>'2012-02-16T12:40:04','version'=>'2.47' },{'date'=>'2012-02-24T21:06:10','version'=>'2.48' },{'date'=>'2012-04-17T23:48:26','version'=>'2.49' },{'date'=>'2012-09-04T16:22:21','version'=>'2.50' },{'date'=>'2012-09-18T03:01:31','version'=>'2.51' },{'date'=>'2012-09-26T02:54:36','version'=>'2.52' },{'date'=>'2012-12-10T11:23:34','version'=>'2.53' },{'date'=>'2012-12-11T15:49:03','version'=>'2.54' },{'date'=>'2013-07-10T14:51:25','version'=>'2.55' },{'date'=>'2017-01-15T21:29:11','version'=>'2.56' }]},'HTML-Perlinfo'=>{'advisories'=>[{'affected_versions'=>'<1.52','description'=>'Possibility of denial-of-service attack.
  ','distribution'=>'HTML-Perlinfo','fixed_versions'=>'>=1.52','id'=>'CPANSA-HTML-Perlinfo-2008-01','references'=>['https://metacpan.org/changes/release/ACCARDO/HTML-Perlinfo-1.52' ],'reported'=>'2008-07-04' }],'main_module'=>'HTML::Perlinfo','versions'=>[{'date'=>'2005-08-18T21:39:08','version'=>'1.00' },{'date'=>'2005-09-19T20:41:07','version'=>'1.05' },{'date'=>'2006-01-14T05:25:20','version'=>'1.25' },{'date'=>'2006-08-13T03:42:36','version'=>'1.40' },{'date'=>'2006-08-13T09:29:45','version'=>'1.41' },{'date'=>'2006-08-15T01:04:34','version'=>'1.42' },{'date'=>'2006-08-25T07:51:28','version'=>'1.43' },{'date'=>'2006-09-10T23:20:13','version'=>'1.44' },{'date'=>'2006-09-24T02:22:48','version'=>'1.45' },{'date'=>'2006-09-27T20:08:12','version'=>'1.46' },{'date'=>'2006-10-02T19:30:30','version'=>'1.47' },{'date'=>'2008-03-16T03:15:04','version'=>'1.48' },{'date'=>'2008-04-26T04:17:07','version'=>'1.49' },{'date'=>'2008-04-30T20:44:40','version'=>'1.50' },{'date'=>'2008-06-08T21:07:29','version'=>'1.51' },{'date'=>'2008-07-03T23:57:26','version'=>'1.52' },{'date'=>'2008-07-21T22:24:22','version'=>'1.53' },{'date'=>'2008-07-27T23:52:36','version'=>'1.54' },{'date'=>'2009-04-08T01:09:54','version'=>'1.55' },{'date'=>'2009-04-08T19:06:59','version'=>'1.56' },{'date'=>'2009-04-16T15:57:34','version'=>'1.57' },{'date'=>'2009-04-17T02:41:48','version'=>'1.58' },{'date'=>'2009-04-22T03:29:45','version'=>'1.59' },{'date'=>'2009-05-02T20:48:38','version'=>'1.60' },{'date'=>'2009-05-02T22:21:42','version'=>'1.60' },{'date'=>'2009-05-03T23:02:35','version'=>'1.61' },{'date'=>'2011-06-13T19:28:39','version'=>'1.62' },{'date'=>'2014-08-19T21:37:30','version'=>'1.63' },{'date'=>'2014-08-19T22:29:15','version'=>'1.64' },{'date'=>'2015-06-06T23:25:41','version'=>'1.65' },{'date'=>'2015-06-08T18:20:03','version'=>'1.66' },{'date'=>'2015-06-08T20:22:33','version'=>'1.67' },{'date'=>'2015-06-12T02:03:18','version'=>'1.68' },{'date'=>'2016-11-29T19:21:00','version'=>'1.69' }]},'HTML-Scrubber'=>{'advisories'=>[{'affected_versions'=>'<0.15','description'=>'Cross-site scripting vulnerability.
  ','distribution'=>'HTML-Scrubber','fixed_versions'=>'>=0.15','id'=>'CPANSA-HTML-Scrubber-2015-01','references'=>['https://jvn.jp/en/jp/JVN53973084/index.html' ],'reported'=>'2015-10-10' }],'main_module'=>'HTML::Scrubber','versions'=>[{'date'=>'2003-04-18T14:10:19','version'=>'0.02' },{'date'=>'2003-07-21T14:57:02','version'=>'0.03' },{'date'=>'2003-10-30T02:31:36','version'=>'0.04' },{'date'=>'2003-10-31T07:27:00','version'=>'0.05' },{'date'=>'2003-11-02T11:10:49','version'=>'0.06' },{'date'=>'2004-03-18T14:35:12','version'=>'0.07' },{'date'=>'2004-04-01T22:12:20','version'=>'0.08' },{'date'=>'2011-04-01T15:36:18','version'=>'0.09' },{'date'=>'2013-09-27T14:06:41','version'=>'0.10' },{'date'=>'2013-10-11T14:13:11','version'=>'0.11' },{'date'=>'2015-03-14T18:25:35','version'=>'0.12' },{'date'=>'2015-03-19T16:31:12','version'=>'0.13' },{'date'=>'2015-04-02T16:20:48','version'=>'0.14' },{'date'=>'2015-10-10T14:02:08','version'=>'0.15' },{'date'=>'2017-06-25T19:31:24','version'=>'0.16' },{'date'=>'2017-06-27T13:04:46','version'=>'0.17' }]},'HTTP-Body'=>{'advisories'=>[{'affected_versions'=>'>=1.08, <1.19','description'=>'HTTP::Body::Multipart in the HTTP-Body 1.08, 1.17, and earlier module for Perl uses the part of the uploaded file\'s name after the first "." character as the suffix of a temporary file, which makes it easier for remote attackers to conduct attacks by leveraging subsequent behavior that may assume the suffix is well-formed.
  ','distribution'=>'HTTP-Body','id'=>'CPANSA-HTTP-Body-2013-01','references'=>['https://security-tracker.debian.org/tracker/CVE-2013-4407','https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=721634' ],'reported'=>'2013-09-02','severity'=>'moderate' }],'main_module'=>'HTTP::Body','versions'=>[{'date'=>'2005-10-06T23:31:10','version'=>'0.01' },{'date'=>'2005-10-07T19:39:00','version'=>'0.2' },{'date'=>'2005-10-28T00:04:21','version'=>'0.03' },{'date'=>'2005-11-09T06:02:28','version'=>'0.4' },{'date'=>'2005-11-17T04:03:44','version'=>'0.5' },{'date'=>'2006-01-06T11:55:08','version'=>'0.6' },{'date'=>'2007-03-23T17:02:39','version'=>'0.7' },{'date'=>'2007-03-24T01:48:23','version'=>'0.8' },{'date'=>'2007-03-27T17:55:21','version'=>'0.9' },{'date'=>'2008-02-23T16:03:17','version'=>'1.00' },{'date'=>'2008-02-23T16:16:09','version'=>'1.01' },{'date'=>'2008-02-27T22:08:06','version'=>'1.02' },{'date'=>'2008-04-07T14:20:46','version'=>'1.03' },{'date'=>'2008-06-23T19:41:56','version'=>'1.04' },{'date'=>'2008-12-01T22:14:51','version'=>'1.05' },{'date'=>'2010-01-09T18:23:07','version'=>'1.06' },{'date'=>'2010-01-24T19:42:49','version'=>'1.07' },{'date'=>'2010-08-19T19:02:08','version'=>'1.08' },{'date'=>'2010-08-19T23:11:46','version'=>'1.09' },{'date'=>'2010-10-08T14:52:40','version'=>'1.10' },{'date'=>'2010-10-26T14:38:59','version'=>'1.11' },{'date'=>'2011-03-20T00:58:03','version'=>'1.12' },{'date'=>'2011-11-04T18:44:06','version'=>'1.14' },{'date'=>'2011-12-05T03:02:21','version'=>'1.15' },{'date'=>'2012-10-03T15:19:24','version'=>'1.16' },{'date'=>'2012-10-03T22:04:49','version'=>'1.17' },{'date'=>'2013-12-06T15:06:26','version'=>'1.18' },{'date'=>'2013-12-06T15:07:56','version'=>'1.19' },{'date'=>'2015-01-28T15:21:00','version'=>'1.20' },{'date'=>'2015-01-29T03:50:10','version'=>'1.21' },{'date'=>'2015-01-29T03:53:01','version'=>'1.22' }]},'HTTP-Session2'=>{'advisories'=>[{'affected_versions'=>'<1.10','description'=>'HTTP::Session2 1.10 does not validate session id, this causes RCE depending on the session store you use.
  ','distribution'=>'HTTP-Session2','fixed_versions'=>'>=1.10','id'=>'CPANSA-HTTP-Session2-2018-01','references'=>['https://metacpan.org/changes/distribution/HTTP-Session2','https://github.com/tokuhirom/HTTP-Session2/commit/813838f6d08034b6a265a70e53b59b941b5d3e6d' ],'reported'=>'2018-01-26','severity'=>'critical' }],'main_module'=>'HTTP::Session2','versions'=>[{'date'=>'2013-10-28T03:20:09','version'=>'0.01' },{'date'=>'2013-10-30T00:17:21','version'=>'0.02' },{'date'=>'2013-10-31T01:21:27','version'=>'0.03' },{'date'=>'2013-11-01T01:10:52','version'=>'0.04' },{'date'=>'2014-03-18T18:53:09','version'=>'0.05' },{'date'=>'2014-07-28T04:10:11','version'=>'1.00' },{'date'=>'2014-07-28T11:44:05','version'=>'1.01' },{'date'=>'2014-07-31T21:17:23','version'=>'1.02' },{'date'=>'2014-08-01T11:04:00','version'=>'1.03' },{'date'=>'2014-08-01T11:10:56','version'=>'1.04' },{'date'=>'2014-08-01T11:20:46','version'=>'1.05' },{'date'=>'2014-08-01T14:04:04','version'=>'1.06' },{'date'=>'2014-08-01T14:08:11','version'=>'1.07' },{'date'=>'2014-08-03T07:23:00','version'=>'1.08' },{'date'=>'2014-09-01T02:26:38','version'=>'1.09' },{'date'=>'2018-01-26T05:02:08','version'=>'1.10' }]},'HTTP-Tiny'=>{'advisories'=>[{'affected_versions'=>'<0.059','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'HTTP-Tiny','fixed_versions'=>'>=0.059','id'=>'CPANSA-HTTP-Tiny-2016-01','references'=>['https://metacpan.org/changes/distribution/HTTP-Tiny','https://github.com/chansen/p5-http-tiny/commit/b239c95ea7a256cfee9b8848f1bd4d1df6e66444' ],'reported'=>'2016-07-29' }],'main_module'=>'HTTP::Tiny','versions'=>[{'date'=>'2010-12-11T12:59:31','version'=>'0.001' },{'date'=>'2010-12-14T02:59:37','version'=>'0.002' },{'date'=>'2010-12-15T17:30:49','version'=>'0.003' },{'date'=>'2010-12-16T03:53:33','version'=>'0.004' },{'date'=>'2011-01-08T11:32:21','version'=>'0.005' },{'date'=>'2011-01-10T12:27:39','version'=>'0.006' },{'date'=>'2011-01-12T09:56:28','version'=>'0.007' },{'date'=>'2011-01-14T11:34:51','version'=>'0.008' },{'date'=>'2011-01-17T21:29:27','version'=>'0.009' },{'date'=>'2011-02-04T07:45:53','version'=>'0.010' },{'date'=>'2011-03-20T00:49:53','version'=>'0.011' },{'date'=>'2011-03-31T19:49:33','version'=>'0.012' },{'date'=>'2011-07-18T03:15:12','version'=>'0.013' },{'date'=>'2011-10-20T17:55:01','version'=>'0.014' },{'date'=>'2011-10-26T20:42:15','version'=>'0.015' },{'date'=>'2011-10-27T03:06:06','version'=>'0.016' },{'date'=>'2012-02-23T02:58:42','version'=>'0.017' },{'date'=>'2012-04-18T13:41:15','version'=>'0.018' },{'date'=>'2012-05-14T11:15:52','version'=>'0.019' },{'date'=>'2012-05-14T19:25:57','version'=>'0.020' },{'date'=>'2012-05-16T02:39:55','version'=>'0.021' },{'date'=>'2012-06-02T03:32:21','version'=>'0.022' },{'date'=>'2012-09-19T16:06:37','version'=>'0.023' },{'date'=>'2012-10-10T00:45:59','version'=>'0.024' },{'date'=>'2012-12-26T17:11:23','version'=>'0.025' },{'date'=>'2013-03-05T03:54:12','version'=>'0.026' },{'date'=>'2013-03-05T17:04:07','version'=>'0.027' },{'date'=>'2013-03-05T19:13:42','version'=>'0.028' },{'date'=>'2013-04-17T17:51:23','version'=>'0.029' },{'date'=>'2013-06-13T15:47:33','version'=>'0.030' },{'date'=>'2013-06-17T03:18:45','version'=>'0.031' },{'date'=>'2013-06-20T15:42:26','version'=>'0.032' },{'date'=>'2013-06-21T10:27:45','version'=>'0.033' },{'date'=>'2013-06-26T23:03:50','version'=>'0.034' },{'date'=>'2013-09-10T16:30:04','version'=>'0.035' },{'date'=>'2013-09-25T16:11:04','version'=>'0.036' },{'date'=>'2013-10-28T17:50:02','version'=>'0.037' },{'date'=>'2013-11-18T17:57:17','version'=>'0.038' },{'date'=>'2013-11-28T00:49:36','version'=>'0.039' },{'date'=>'2014-02-17T18:05:10','version'=>'0.040' },{'date'=>'2014-02-17T18:09:12','version'=>'0.041' },{'date'=>'2014-02-18T16:24:50','version'=>'0.042' },{'date'=>'2014-02-21T01:42:05','version'=>'0.043' },{'date'=>'2014-07-17T03:47:41','version'=>'0.044' },{'date'=>'2014-07-20T23:24:33','version'=>'0.045' },{'date'=>'2014-07-21T14:33:53','version'=>'0.046' },{'date'=>'2014-07-29T18:13:01','version'=>'0.047' },{'date'=>'2014-08-21T17:20:45','version'=>'0.048' },{'date'=>'2014-09-02T15:21:17','version'=>'0.049' },{'date'=>'2014-09-23T19:32:00','version'=>'0.050' },{'date'=>'2014-11-18T03:59:56','version'=>'0.051' },{'date'=>'2014-12-11T20:25:19','version'=>'0.052' },{'date'=>'2014-12-12T04:43:37','version'=>'0.053' },{'date'=>'2015-01-27T12:18:58','version'=>'0.054' },{'date'=>'2015-05-07T22:15:24','version'=>'0.055' },{'date'=>'2015-05-19T10:01:27','version'=>'0.056' },{'date'=>'2016-04-18T14:19:09','version'=>'0.057' },{'date'=>'2016-05-03T17:49:33','version'=>'0.058' },{'date'=>'2016-07-29T20:12:12','version'=>'0.059' },{'date'=>'2016-08-05T16:12:02','version'=>'0.061' },{'date'=>'2016-08-08T16:20:33','version'=>'0.063' },{'date'=>'2016-08-17T01:43:01','version'=>'0.064' },{'date'=>'2016-09-10T02:43:48','version'=>'0.065' },{'date'=>'2016-09-14T15:45:04','version'=>'0.067' },{'date'=>'2016-09-23T20:15:05','version'=>'0.068' },{'date'=>'2016-10-05T15:37:11','version'=>'0.069' },{'date'=>'2016-10-10T03:25:33','version'=>'0.070' },{'date'=>'2018-07-24T15:35:02','version'=>'0.073' },{'date'=>'2018-07-30T19:37:29','version'=>'0.074' },{'date'=>'2018-08-01T11:10:11','version'=>'0.075' },{'date'=>'2018-08-06T01:09:54','version'=>'0.076' }]},'Imager'=>{'advisories'=>[{'affected_versions'=>'<1.006','cves'=>['CVE-2016-1238' ],'description'=>'Loading modules from . (current directory).
  ','distribution'=>'Imager','fixed_versions'=>'>=1.006','id'=>'CPANSA-Imager-2016-01','references'=>['https://metacpan.org/changes/distribution/Imager' ],'reported'=>'2017-08-26' },{'affected_versions'=>'<0.64','cves'=>['CVE-2008-1928' ],'description'=>'Buffer overflow in the floating point sample path for image based fills.
  ','distribution'=>'Imager','fixed_versions'=>'>=0.64','id'=>'CPANSA-Imager-2008-01','references'=>['https://rt.cpan.org/Ticket/Display.html?id=68910','https://metacpan.org/changes/distribution/Imager' ],'reported'=>'2008-04-23' },{'affected_versions'=>'<0.57','cves'=>['CVE-2007-2459','CVE-2007-2413' ],'description'=>'A specially crafted compressed BMP file can cause a buffer overflow in malloced memory.
  ','distribution'=>'Imager','fixed_versions'=>'>=0.57','id'=>'CPANSA-Imager-2007-01','references'=>['https://rt.cpan.org/Public/Bug/Display.html?id=26811','https://metacpan.org/changes/distribution/Imager' ],'reported'=>'2008-04-30' }],'main_module'=>'Imager','versions'=>[{'date'=>'1999-07-19T14:26:37','version'=>'0.21' },{'date'=>'2000-01-03T20:14:03','version'=>'0.27' },{'date'=>'2000-01-04T11:16:56','version'=>'0.28' },{'date'=>'2000-01-05T10:48:05','version'=>'0.29' },{'date'=>'2000-01-16T12:52:22','version'=>'0.31' },{'date'=>'2000-03-04T13:28:32','version'=>'0.32' },{'date'=>'2001-01-29T00:50:14','version'=>'0.35' },{'date'=>'2001-01-29T15:06:27','version'=>'0.36' },{'date'=>'2001-01-31T05:02:15','version'=>'0.37' },{'date'=>'2001-05-21T16:21:08','version'=>'0.38' },{'date'=>'2001-11-02T21:39:20','version'=>'0.39' },{'date'=>'2002-04-11T15:09:57','version'=>'0.40' },{'date'=>'2002-04-12T12:07:29','version'=>'0.41' },{'date'=>'2004-01-04T12:47:37','version'=>'0.42' },{'date'=>'2004-02-17T07:53:52','version'=>'0.43' },{'date'=>'2004-12-07T23:58:16','version'=>'0.43_03' },{'date'=>'2004-12-15T13:02:40','version'=>'0.44' },{'date'=>'2005-05-24T07:08:15','version'=>'0.44_01' },{'date'=>'2005-05-30T04:41:43','version'=>'0.45' },{'date'=>'2005-12-12T04:07:30','version'=>'0.45_02' },{'date'=>'2005-12-20T00:13:31','version'=>'0.46' },{'date'=>'2005-12-30T06:05:50','version'=>'0.47' },{'date'=>'2006-02-21T06:09:30','version'=>'0.47_01' },{'date'=>'2006-03-03T05:06:46','version'=>'0.48' },{'date'=>'2006-03-07T01:04:03','version'=>'0.49' },{'date'=>'2006-03-28T04:31:56','version'=>'0.49_01' },{'date'=>'2006-03-29T00:31:03','version'=>'0.50' },{'date'=>'2006-04-23T14:29:42','version'=>'0.51' },{'date'=>'2006-06-28T13:38:48','version'=>'0.51_01' },{'date'=>'2006-07-04T14:03:23','version'=>'0.51_02' },{'date'=>'2006-07-19T00:58:22','version'=>'0.51_03' },{'date'=>'2006-07-25T05:09:08','version'=>'0.52' },{'date'=>'2006-07-27T01:01:57','version'=>'0.53' },{'date'=>'2006-09-14T07:58:27','version'=>'0.54' },{'date'=>'2006-12-16T22:31:19','version'=>'0.55' },{'date'=>'2007-04-01T12:30:34','version'=>'0.56' },{'date'=>'2007-04-30T08:49:39','version'=>'0.57' },{'date'=>'2007-05-11T11:00:18','version'=>'0.57_01' },{'date'=>'2007-05-16T12:49:23','version'=>'0.58' },{'date'=>'2007-06-14T07:33:05','version'=>'0.59' },{'date'=>'2007-08-30T07:51:36','version'=>'0.60' },{'date'=>'2007-11-05T07:53:45','version'=>'0.61' },{'date'=>'2007-11-28T10:06:27','version'=>'0.61_02' },{'date'=>'2007-12-10T08:31:12','version'=>'0.62' },{'date'=>'2008-04-07T08:49:14','version'=>'0.63' },{'date'=>'2008-04-23T04:10:18','version'=>'0.64' },{'date'=>'2008-05-20T06:34:48','version'=>'0.65' },{'date'=>'2008-12-12T11:57:40','version'=>'0.67' },{'date'=>'2009-09-02T07:05:11','version'=>'0.67_01' },{'date'=>'2009-09-07T05:14:24','version'=>'0.68' },{'date'=>'2009-09-08T09:23:38','version'=>'0.69' },{'date'=>'2009-09-21T03:36:15','version'=>'0.70' },{'date'=>'2009-11-16T04:15:54','version'=>'0.71' },{'date'=>'2009-11-30T07:17:33','version'=>'0.71_01' },{'date'=>'2009-12-01T09:06:53','version'=>'0.71_02' },{'date'=>'2009-12-04T14:21:49','version'=>'0.71_03' },{'date'=>'2009-12-10T00:44:51','version'=>'0.72' },{'date'=>'2010-03-15T07:24:59','version'=>'0.73' },{'date'=>'2010-05-06T14:29:21','version'=>'0.74' },{'date'=>'2010-06-20T10:47:23','version'=>'0.75' },{'date'=>'2010-08-06T10:49:44','version'=>'0.75_01' },{'date'=>'2010-08-07T01:48:37','version'=>'0.75_02' },{'date'=>'2010-08-09T12:49:36','version'=>'0.75_03' },{'date'=>'2010-08-11T09:33:24','version'=>'0.77' },{'date'=>'2010-09-13T10:48:57','version'=>'0.77_01' },{'date'=>'2010-09-27T04:59:03','version'=>'0.77_02' },{'date'=>'2010-10-04T09:00:26','version'=>'0.78' },{'date'=>'2010-12-11T01:09:12','version'=>'0.79' },{'date'=>'2011-01-17T07:43:35','version'=>'0.80' },{'date'=>'2011-02-14T08:22:57','version'=>'0.81' },{'date'=>'2011-03-14T12:18:07','version'=>'0.82' },{'date'=>'2011-05-17T11:15:02','version'=>'0.82_01' },{'date'=>'2011-05-20T14:07:44','version'=>'0.83' },{'date'=>'2011-06-20T12:54:05','version'=>'0.84' },{'date'=>'2011-08-08T12:39:58','version'=>'0.84_01' },{'date'=>'2011-08-22T09:28:25','version'=>'0.84_02' },{'date'=>'2011-08-29T09:19:04','version'=>'0.85' },{'date'=>'2011-10-10T07:22:51','version'=>'0.85_01' },{'date'=>'2011-10-24T10:14:57','version'=>'0.85_02' },{'date'=>'2011-10-31T10:37:15','version'=>'0.86' },{'date'=>'2012-01-03T05:27:14','version'=>'0.87' },{'date'=>'2012-02-22T05:13:09','version'=>'0.88' },{'date'=>'2012-03-18T01:45:35','version'=>'0.89' },{'date'=>'2012-04-30T09:09:02','version'=>'0.90' },{'date'=>'2012-06-04T12:27:17','version'=>'0.91' },{'date'=>'2012-08-14T09:53:38','version'=>'0.92' },{'date'=>'2012-08-18T01:41:22','version'=>'0.92_01' },{'date'=>'2012-10-15T10:15:07','version'=>'0.93' },{'date'=>'2012-11-12T10:44:54','version'=>'0.93_01' },{'date'=>'2012-11-25T00:13:16','version'=>'0.93_02' },{'date'=>'2012-12-14T22:59:55','version'=>'0.94' },{'date'=>'2013-03-02T08:34:07','version'=>'0.94_01' },{'date'=>'2013-04-05T06:19:32','version'=>'0.94_02' },{'date'=>'2013-04-19T12:13:27','version'=>'0.95' },{'date'=>'2013-05-19T04:27:19','version'=>'0.96' },{'date'=>'2013-07-01T13:21:32','version'=>'0.96_01' },{'date'=>'2013-07-09T13:46:48','version'=>'0.96_02' },{'date'=>'2013-07-15T09:52:06','version'=>'0.97' },{'date'=>'2014-01-02T22:22:03','version'=>'0.98' },{'date'=>'2014-06-25T11:36:29','version'=>'0.99' },{'date'=>'2014-06-29T05:06:45','version'=>'0.99_01' },{'date'=>'2014-07-21T09:16:17','version'=>'0.99_02' },{'date'=>'2014-07-29T09:13:55','version'=>'1.000' },{'date'=>'2015-01-02T03:34:59','version'=>'1.001' },{'date'=>'2015-04-03T01:31:26','version'=>'1.002' },{'date'=>'2015-05-12T08:11:18','version'=>'1.003' },{'date'=>'2015-11-08T09:45:59','version'=>'1.004' },{'date'=>'2016-03-16T08:35:26','version'=>'1.004_001' },{'date'=>'2016-03-20T01:27:53','version'=>'1.004_002' },{'date'=>'2016-03-23T09:34:13','version'=>'1.004_003' },{'date'=>'2016-04-15T05:58:07','version'=>'1.004_004' },{'date'=>'2016-04-16T00:01:33','version'=>'1.005' },{'date'=>'2017-08-26T04:27:06','version'=>'1.006' },{'date'=>'2018-11-24T01:47:34','version'=>'1.007' },{'date'=>'2018-12-31T10:04:02','version'=>'1.008' },{'date'=>'2019-01-11T09:10:13','version'=>'1.009' },{'date'=>'2019-02-13T08:14:07','version'=>'1.010' },{'date'=>'2019-03-07T03:20:03','version'=>'1.011' }]},'LWP-Protocol-Net-Curl'=>{'advisories'=>[{'affected_versions'=>'<0.009','description'=>'Misconfiguration with libcurl v7.28.1 causes a HTTPS validation issues.
  ','distribution'=>'LWP-Protocol-Net-Curl','fixed_versions'=>'>=0.009','id'=>'CPANSA-LWP-Protocol-Net-Curl-2012-01','references'=>['https://metacpan.org/changes/distribution/LWP-Protocol-Net-Curl','https://github.com/creaktive/LWP-Protocol-Net-Curl/commit/dc8b183c6520a2b6bcde685de635675ee4a7e019' ],'reported'=>'2012-11-28' }],'main_module'=>'LWP::Protocol::Net::Curl','versions'=>[{'date'=>'2012-10-24T18:49:20','version'=>'0.001' },{'date'=>'2012-10-26T20:05:13','version'=>'0.002' },{'date'=>'2012-10-29T18:55:46','version'=>'0.003' },{'date'=>'2012-10-31T13:01:46','version'=>'0.004' },{'date'=>'2012-11-01T15:17:14','version'=>'0.005' },{'date'=>'2012-11-12T12:23:09','version'=>'0.006' },{'date'=>'2012-11-13T14:33:10','version'=>'0.007' },{'date'=>'2012-11-25T22:38:58','version'=>'0.008' },{'date'=>'2012-11-28T19:03:10','version'=>'0.009' },{'date'=>'2012-12-07T00:13:55','version'=>'0.010' },{'date'=>'2012-12-18T12:05:00','version'=>'0.011' },{'date'=>'2013-02-08T11:00:04','version'=>'0.012' },{'date'=>'2013-02-11T01:56:30','version'=>'0.013' },{'date'=>'2013-02-16T12:51:03','version'=>'0.014' },{'date'=>'2013-05-13T21:41:47','version'=>'0.015' },{'date'=>'2013-05-18T22:12:03','version'=>'0.016' },{'date'=>'2013-07-13T12:22:34','version'=>'0.017' },{'date'=>'2013-08-17T11:34:49','version'=>'0.018' },{'date'=>'2013-10-11T12:33:53','version'=>'0.019' },{'date'=>'2013-10-13T09:02:17','version'=>'0.020' },{'date'=>'2014-01-21T17:46:37','version'=>'0.021' },{'date'=>'2014-07-09T15:04:06','version'=>'0.022' },{'date'=>'2014-12-23T17:06:56','version'=>'0.023' }]},'Lemonldap-NG-Portal'=>{'advisories'=>[{'affected_versions'=>'<0.87','description'=>'When running on Apache with thread support setMacros and setGroups were not launched with the good datas.
  ','distribution'=>'Lemonldap-NG-Portal','fixed_versions'=>'>=0.87','id'=>'CPANSA-Lemonldap-NG-Portal-2009-01','references'=>['https://metacpan.org/changes/distribution/Lemonldap-NG-Portal' ],'reported'=>'2009-02-08' }],'main_module'=>'Lemonldap::NG::Portal','versions'=>[{'date'=>'2005-06-29T18:44:50','version'=>'0.01' },{'date'=>'2005-07-02T08:49:37','version'=>'0.02' },{'date'=>'2006-10-07T13:24:36','version'=>'0.1' },{'date'=>'2006-10-14T13:26:07','version'=>'0.11' },{'date'=>'2006-10-14T14:11:06','version'=>'0.111' },{'date'=>'2006-10-17T13:58:53','version'=>'0.2' },{'date'=>'2006-11-02T15:23:31','version'=>'0.4' },{'date'=>'2006-11-03T07:25:06','version'=>'0.41' },{'date'=>'2006-12-07T21:02:36','version'=>'0.42' },{'date'=>'2006-12-19T18:26:07','version'=>'0.5' },{'date'=>'2006-12-31T13:03:32','version'=>'0.51' },{'date'=>'2007-01-13T19:47:36','version'=>'0.6' },{'date'=>'2007-02-28T22:29:18','version'=>'0.62' },{'date'=>'2007-03-04T18:23:52','version'=>'0.63' },{'date'=>'2007-03-09T20:18:23','version'=>'0.64' },{'date'=>'2007-03-29T19:52:31','version'=>'0.7' },{'date'=>'2007-04-01T20:26:10','version'=>'0.71' },{'date'=>'2007-04-14T20:46:13','version'=>'0.72' },{'date'=>'2007-04-20T06:51:13','version'=>'0.73' },{'date'=>'2007-06-13T13:54:26','version'=>'0.74' },{'date'=>'2007-07-22T20:35:13','version'=>'0.76' },{'date'=>'2007-07-31T05:11:34','version'=>'0.77' },{'date'=>'2007-10-15T06:03:56','version'=>'0.8' },{'date'=>'2008-02-28T07:13:04','version'=>'0.81' },{'date'=>'2008-04-11T14:53:38','version'=>'0.82' },{'date'=>'2008-06-06T05:50:06','version'=>'0.83' },{'date'=>'2008-06-06T12:46:10','version'=>'0.84' },{'date'=>'2008-08-25T19:53:48','version'=>'0.85' },{'date'=>'2008-12-25T08:26:49','version'=>'0.86' },{'date'=>'2009-02-08T07:13:05','version'=>'0.87' },{'date'=>'2009-06-29T10:14:46','version'=>'0.88' },{'date'=>'2009-07-05T11:40:59','version'=>'0.89' },{'date'=>'2009-10-11T08:26:21','version'=>'0.90' },{'date'=>'2010-10-13T21:02:21','version'=>'0.99' },{'date'=>'2010-10-22T05:36:29','version'=>'0.99.1' },{'date'=>'2010-10-22T05:45:04','version'=>'0.991' },{'date'=>'2010-10-24T06:33:29','version'=>'0.992' },{'date'=>'2010-11-26T13:38:59','version'=>'1.0.0' },{'date'=>'2011-02-28T13:42:23','version'=>'1.0.2' },{'date'=>'2011-03-07T11:17:03','version'=>'v1.0.3' },{'date'=>'2011-03-23T14:54:26','version'=>'1.0.4' },{'date'=>'2011-04-15T14:51:44','version'=>'1.0.5' },{'date'=>'2011-05-30T08:40:46','version'=>'1.0.6' },{'date'=>'2011-07-08T09:33:35','version'=>'1.1.0' },{'date'=>'2011-07-29T13:43:35','version'=>'1.1.1' },{'date'=>'2011-10-07T12:58:06','version'=>'1.1.2' },{'date'=>'2012-06-18T10:13:31','version'=>'1.2.0' },{'date'=>'2012-07-06T09:18:54','version'=>'1.2.1' },{'date'=>'2012-09-17T14:04:26','version'=>'1.2.2' },{'date'=>'2013-01-25T21:51:54','version'=>'1.2.2_01' },{'date'=>'2013-02-08T17:11:38','version'=>'1.2.3' },{'date'=>'2013-04-23T13:19:57','version'=>'1.2.4' },{'date'=>'2013-08-26T10:39:11','version'=>'1.2.5' },{'date'=>'2013-11-02T16:31:10','version'=>'v1.3.0' },{'date'=>'2013-11-10T18:00:31','version'=>'v1.3.0_01' },{'date'=>'2013-11-11T14:01:21','version'=>'v1.3.1' },{'date'=>'2014-02-05T09:31:50','version'=>'1.3.2' },{'date'=>'2014-03-07T13:55:23','version'=>'1.3.3' },{'date'=>'2014-06-30T12:54:16','version'=>'v1.4.0' },{'date'=>'2014-07-25T09:55:37','version'=>'v1.4.1' },{'date'=>'2014-11-05T15:15:30','version'=>'v1.4.2' },{'date'=>'2014-12-19T10:31:47','version'=>'v1.4.3' },{'date'=>'2015-04-15T10:05:31','version'=>'v1.4.4' },{'date'=>'2015-05-22T16:54:10','version'=>'v1.4.5' },{'date'=>'2015-10-09T09:21:04','version'=>'v1.4.6' },{'date'=>'2016-03-02T09:50:24','version'=>'v1.9.0' },{'date'=>'2016-03-22T14:25:24','version'=>'v1.4.7' },{'date'=>'2016-04-05T16:02:49','version'=>'v1.9.1' },{'date'=>'2016-04-27T15:23:10','version'=>'v1.4.8' },{'date'=>'2016-05-01T19:25:36','version'=>'v1.9.2' },{'date'=>'2016-06-03T14:14:52','version'=>'v1.4.9' },{'date'=>'2016-06-07T15:48:38','version'=>'v1.9.3' },{'date'=>'2016-06-14T18:36:34','version'=>'v1.9.4' },{'date'=>'2016-07-13T09:08:18','version'=>'v1.4.10' },{'date'=>'2016-07-13T12:58:54','version'=>'v1.9.5' },{'date'=>'2016-10-10T13:34:33','version'=>'v1.4.11' },{'date'=>'2016-10-16T12:23:25','version'=>'v1.9.6' },{'date'=>'2016-12-14T19:57:55','version'=>'v1.9.7' },{'date'=>'2017-02-28T21:11:18','version'=>'v1.9.99_2.0alpha1' },{'date'=>'2017-03-02T14:55:34','version'=>'v1.9.8' },{'date'=>'2017-03-07T05:48:09','version'=>'v1.9.99_02' },{'date'=>'2017-03-07T06:00:28','version'=>'v1.9.99_03' },{'date'=>'2017-03-15T05:34:48','version'=>'v1.9.991_01' },{'date'=>'2017-03-17T07:21:31','version'=>'v1.9.9' },{'date'=>'2017-05-19T18:48:42','version'=>'v1.9.10' },{'date'=>'2017-09-01T10:32:34','version'=>'v1.9.11' },{'date'=>'2017-09-12T08:40:27','version'=>'v1.9.12' },{'date'=>'2017-09-29T14:00:36','version'=>'v1.9.13' },{'date'=>'2017-11-24T19:59:18','version'=>'v1.9.14' },{'date'=>'2018-01-23T12:50:53','version'=>'v1.9.15' },{'date'=>'2018-03-16T10:34:13','version'=>'v1.9.16' },{'date'=>'2018-06-16T09:27:27','version'=>'v1.9.17' },{'date'=>'2018-10-05T09:40:26','version'=>'v1.9.18' },{'date'=>'2018-11-30T10:49:52','version'=>'v2.0.0' },{'date'=>'2019-02-12T17:13:39','version'=>'v2.0.2' }]},'MHonArc'=>{'advisories'=>[{'affected_versions'=>'<2.6.17','cves'=>['CVE-2010-4524' ],'description'=>'Improper escaping of certain HTML sequences (XSS).
  ','distribution'=>'MHonArc','fixed_versions'=>'>=2.6.17','id'=>'CPANSA-MHonArc-2011-01','references'=>['https://metacpan.org/changes/distribution/MHonArc' ],'reported'=>'2011-01-09' },{'affected_versions'=>'<2.6.17','cves'=>['CVE-2010-1677' ],'description'=>'DoS when processing html messages with deep tag nesting.
  ','distribution'=>'MHonArc','fixed_versions'=>'>=2.6.17','id'=>'CPANSA-MHonArc-2011-02','references'=>['https://metacpan.org/changes/distribution/MHonArc' ],'reported'=>'2011-01-09' }],'main_module'=>'MHonArc::Char','versions'=>[{'date'=>'1997-12-11T20:44:41','version'=>'2.1' },{'date'=>'1998-03-04T01:06:00','version'=>'v2.2.0' },{'date'=>'1998-10-11T02:56:10','version'=>'v2.3.0' },{'date'=>'1998-10-25T19:27:37','version'=>'v2.3.1' },{'date'=>'1998-11-01T20:02:48','version'=>'v2.3.2' },{'date'=>'1998-11-08T21:59:21','version'=>'v2.3.3' },{'date'=>'1999-06-26T07:57:53','version'=>'v2.4.0' },{'date'=>'1999-07-26T19:30:51','version'=>'v2.4.1' },{'date'=>'1999-08-12T07:16:14','version'=>'v2.4.2' },{'date'=>'1999-08-16T06:25:39','version'=>'v2.4.3' },{'date'=>'1999-10-01T19:43:07','version'=>'v2.4.4' },{'date'=>'2000-02-15T03:44:03','version'=>'v2.4.5' },{'date'=>'2000-04-24T08:35:56','version'=>'v2.4.6' },{'date'=>'2000-10-29T04:18:32','version'=>'v2.4.7' },{'date'=>'2000-10-30T06:29:47','version'=>'v2.4.7' },{'date'=>'2001-04-14T21:48:01','version'=>'v2.4.8' },{'date'=>'2001-06-11T03:09:13','version'=>'v2.4.9' },{'date'=>'2001-08-26T19:46:53','version'=>'v2.5.0' },{'date'=>'2001-09-07T15:24:19','version'=>'v2.5.0' },{'date'=>'2001-10-17T16:03:13','version'=>'v2.5.0' },{'date'=>'2001-11-14T05:09:59','version'=>'v2.5.1' },{'date'=>'2001-11-25T06:46:19','version'=>'v2.5.2' },{'date'=>'2002-04-18T07:23:29','version'=>'v2.5.3' },{'date'=>'2002-05-03T05:06:16','version'=>'v2.5.4' },{'date'=>'2002-05-28T05:43:00','version'=>'v2.5.5' },{'date'=>'2002-06-18T18:07:38','version'=>'v2.5.6' },{'date'=>'2002-06-21T22:59:36','version'=>'v2.5.7' },{'date'=>'2002-06-29T03:22:26','version'=>'v2.5.8' },{'date'=>'2002-07-20T02:39:53','version'=>'v2.5.9' },{'date'=>'2002-07-29T00:10:32','version'=>'v2.5.10' },{'date'=>'2002-08-04T04:25:22','version'=>'v2.5.11' },{'date'=>'2002-09-04T04:32:14','version'=>'v2.5.12' },{'date'=>'2002-10-21T17:13:35','version'=>'v2.5.13' },{'date'=>'2002-12-22T01:07:40','version'=>'v2.5.14' },{'date'=>'2003-02-10T05:23:02','version'=>'v2.6.0' },{'date'=>'2003-02-23T00:39:05','version'=>'v2.6.1' },{'date'=>'2003-03-12T01:55:48','version'=>'v2.6.2' },{'date'=>'2003-04-06T02:11:59','version'=>'v2.6.3' },{'date'=>'2003-06-22T21:54:52','version'=>'v2.6.4' },{'date'=>'2003-07-20T04:51:56','version'=>'v2.6.5' },{'date'=>'2003-07-21T17:20:07','version'=>'v2.6.6' },{'date'=>'2003-08-07T23:49:43','version'=>'v2.6.7' },{'date'=>'2003-08-13T04:47:02','version'=>'v2.6.8' },{'date'=>'2004-05-17T06:24:46','version'=>'v2.6.9' },{'date'=>'2004-05-17T06:25:16','version'=>'v2.6.10' },{'date'=>'2005-05-20T17:15:40','version'=>'v2.6.11' },{'date'=>'2005-06-09T02:30:11','version'=>'v2.6.12' },{'date'=>'2005-07-06T05:15:55','version'=>'v2.6.13' },{'date'=>'2005-07-23T07:15:49','version'=>'2.6.14' },{'date'=>'2005-07-27T03:46:13','version'=>'2.6.15' },{'date'=>'2006-06-10T03:21:01','version'=>'2.6.16' },{'date'=>'2011-01-09T10:04:06','version'=>'2.6.17' },{'date'=>'2011-01-09T16:35:39','version'=>'2.6.18' },{'date'=>'2014-04-22T03:33:53','version'=>'2.6.19' }]},'Module-Signature'=>{'advisories'=>[{'affected_versions'=>'<0.72','cves'=>['CVE-2013-2145' ],'description'=>'The cpansign verify functionality in the Module::Signature module before 0.72 for Perl allows attackers to bypass the signature check and execute arbitrary code via a SIGNATURE file with a "special unknown cipher" that references an untrusted module in Digest/.
  ','distribution'=>'Module-Signature','fixed_versions'=>'>=0.72','id'=>'CPANSA-Module-Signature-2013-01','references'=>['https://metacpan.org/changes/distribution/Module-Signature' ],'reported'=>'2013-08-19' }],'main_module'=>'Module::Signature','versions'=>[{'date'=>'2002-08-13T14:04:00','version'=>'0.02' },{'date'=>'2002-08-13T15:48:18','version'=>'0.03' },{'date'=>'2002-08-14T08:03:45','version'=>'0.04' },{'date'=>'2002-08-14T09:28:41','version'=>'0.05' },{'date'=>'2002-10-10T15:22:33','version'=>'0.06' },{'date'=>'2002-10-11T04:16:01','version'=>'0.07' },{'date'=>'2002-10-11T19:32:19','version'=>'0.08' },{'date'=>'2002-10-12T10:33:29','version'=>'0.09' },{'date'=>'2002-10-12T11:10:21','version'=>'0.10' },{'date'=>'2002-10-12T19:23:48','version'=>'0.11' },{'date'=>'2002-10-12T22:55:54','version'=>'0.12' },{'date'=>'2002-10-13T05:22:45','version'=>'0.13' },{'date'=>'2002-10-17T06:14:07','version'=>'0.14' },{'date'=>'2002-10-17T22:01:57','version'=>'0.15' },{'date'=>'2002-10-28T23:37:00','version'=>'0.16' },{'date'=>'2002-10-30T07:05:06','version'=>'0.17' },{'date'=>'2002-11-04T15:08:41','version'=>'0.18' },{'date'=>'2002-11-04T15:13:45','version'=>'0.19' },{'date'=>'2002-11-04T15:24:41','version'=>'0.20' },{'date'=>'2002-11-22T10:28:48','version'=>'0.21' },{'date'=>'2003-05-15T18:44:28','version'=>'0.23' },{'date'=>'2003-07-08T02:49:57','version'=>'0.24' },{'date'=>'2003-07-16T06:31:58','version'=>'0.25' },{'date'=>'2003-07-17T14:03:19','version'=>'0.26' },{'date'=>'2003-07-28T14:31:54','version'=>'0.27' },{'date'=>'2003-07-29T15:30:55','version'=>'0.28' },{'date'=>'2003-08-08T02:54:01','version'=>'0.29' },{'date'=>'2003-08-10T13:35:38','version'=>'0.30' },{'date'=>'2003-08-10T17:17:19','version'=>'0.31' },{'date'=>'2003-08-11T09:15:13','version'=>'0.32' },{'date'=>'2003-08-12T04:11:59','version'=>'0.33' },{'date'=>'2003-08-18T15:32:45','version'=>'0.34' },{'date'=>'2003-08-27T07:08:31','version'=>'0.35' },{'date'=>'2003-10-28T04:22:56','version'=>'0.36' },{'date'=>'2003-11-06T10:55:07','version'=>'0.37' },{'date'=>'2004-01-01T10:14:15','version'=>'0.38' },{'date'=>'2004-06-17T15:17:14','version'=>'0.39' },{'date'=>'2004-07-01T12:18:17','version'=>'0.40' },{'date'=>'2004-07-04T08:19:11','version'=>'0.41' },{'date'=>'2004-11-20T06:19:22','version'=>'0.42' },{'date'=>'2004-12-16T06:45:55','version'=>'0.43' },{'date'=>'2004-12-16T07:17:30','version'=>'0.44' },{'date'=>'2005-08-09T04:23:46','version'=>'0.45' },{'date'=>'2005-08-21T08:16:22','version'=>'0.50' },{'date'=>'2006-01-01T18:41:57','version'=>'0.51' },{'date'=>'2006-01-18T16:32:37','version'=>'0.52' },{'date'=>'2006-01-31T05:02:24','version'=>'0.53' },{'date'=>'2006-05-11T17:12:46','version'=>'0.54' },{'date'=>'2006-07-30T01:15:07','version'=>'0.55' },{'date'=>'2009-11-16T14:59:35','version'=>'0.60' },{'date'=>'2009-11-18T16:58:07','version'=>'0.61' },{'date'=>'2010-03-23T21:21:37','version'=>'0.62' },{'date'=>'2010-03-28T02:49:21','version'=>'0.62' },{'date'=>'2010-05-08T22:55:43','version'=>'0.62' },{'date'=>'2010-09-03T19:55:36','version'=>'0.65' },{'date'=>'2010-09-06T20:58:24','version'=>'0.66' },{'date'=>'2011-04-17T15:09:22','version'=>'0.67' },{'date'=>'2011-05-13T09:55:20','version'=>'0.68' },{'date'=>'2012-11-02T15:20:28','version'=>'0.69' },{'date'=>'2012-11-28T17:49:21','version'=>'0.70' },{'date'=>'2013-06-04T10:29:18','version'=>'0.71' },{'date'=>'2013-06-05T15:21:34','version'=>'0.72' },{'date'=>'2013-06-05T20:57:10','version'=>'0.73' },{'date'=>'2015-04-06T18:39:32','version'=>'0.74' },{'date'=>'2015-04-06T20:58:34','version'=>'0.75' },{'date'=>'2015-04-08T10:13:11','version'=>'0.76' },{'date'=>'2015-04-08T11:47:26','version'=>'0.77' },{'date'=>'2015-04-09T09:00:30','version'=>'0.78' },{'date'=>'2015-05-18T15:18:02','version'=>'0.79' },{'date'=>'2016-06-07T06:36:30','version'=>'0.80' },{'date'=>'2016-09-05T06:41:06','version'=>'0.81' },{'date'=>'2018-08-26T15:19:13','version'=>'0.81' },{'date'=>'2018-08-29T08:35:25','version'=>'0.83' }]},'MojoMojo'=>{'advisories'=>[{'affected_versions'=>'<0.999033','description'=>'Anonymous users can delete attachments.
  ','distribution'=>'MojoMojo','fixed_versions'=>'>=0.999033','id'=>'CPANSA-MojoMojo-2009-01','references'=>['https://metacpan.org/changes/distribution/MojoMojo','https://github.com/mojomojo/mojomojo/commit/a9b9fd4f4f037627d30f3cbaa10abe42a3439637' ],'reported'=>'2009-08-14' }],'main_module'=>'MojoMojo','versions'=>[{'date'=>'2007-08-29T14:32:52','version'=>'0.05' },{'date'=>'2007-09-12T21:46:24','version'=>'0.05' },{'date'=>'2007-09-13T11:28:37','version'=>'0.05' },{'date'=>'2007-09-18T07:33:43','version'=>'0.999004' },{'date'=>'2007-09-18T08:02:02','version'=>'0.999005' },{'date'=>'2007-09-19T20:59:39','version'=>'0.999006' },{'date'=>'2007-09-23T23:30:59','version'=>'0.999007' },{'date'=>'2007-11-12T22:25:35','version'=>'0.999008' },{'date'=>'2008-01-20T23:15:07','version'=>'0.999010' },{'date'=>'2008-01-23T23:00:05','version'=>'0.999011' },{'date'=>'2008-02-05T23:20:47','version'=>'0.999012' },{'date'=>'2008-03-05T00:34:49','version'=>'0.999013' },{'date'=>'2008-05-02T18:11:49','version'=>'0.999014' },{'date'=>'2008-05-03T16:10:08','version'=>'0.999015' },{'date'=>'2008-06-29T13:03:39','version'=>'0.999016' },{'date'=>'2008-07-09T14:26:56','version'=>'0.999017' },{'date'=>'2008-07-16T19:26:46','version'=>'0.999018' },{'date'=>'2008-07-19T21:33:36','version'=>'0.999018' },{'date'=>'2008-07-29T16:25:08','version'=>'0.999018' },{'date'=>'2008-11-01T01:04:37','version'=>'0.999021' },{'date'=>'2008-11-15T09:09:37','version'=>'0.999022' },{'date'=>'2008-11-23T16:45:05','version'=>'0.999023' },{'date'=>'2008-12-31T17:53:50','version'=>'0.999024' },{'date'=>'2009-01-04T22:51:40','version'=>'0.999025' },{'date'=>'2009-01-07T23:28:15','version'=>'0.999026' },{'date'=>'2009-01-30T23:29:25','version'=>'0.999027' },{'date'=>'2009-04-23T10:06:20','version'=>'0.999028' },{'date'=>'2009-05-09T23:21:10','version'=>'0.999029' },{'date'=>'2009-07-18T19:39:14','version'=>'0.999030' },{'date'=>'2009-07-26T19:39:37','version'=>'0.999031' },{'date'=>'2009-08-02T21:28:51','version'=>'0.999032' },{'date'=>'2009-08-14T12:50:18','version'=>'0.999033' },{'date'=>'2009-09-04T18:27:34','version'=>'0.999040' },{'date'=>'2009-10-26T16:07:25','version'=>'0.999041' },{'date'=>'2009-12-02T08:22:24','version'=>'0.999042' },{'date'=>'2010-05-11T22:58:19','version'=>'1.00' },{'date'=>'2010-05-27T07:44:39','version'=>'1.01' },{'date'=>'2010-08-30T21:24:41','version'=>'1.02' },{'date'=>'2011-01-13T12:48:10','version'=>'1.03' },{'date'=>'2011-03-12T23:37:45','version'=>'1.04' },{'date'=>'2011-09-14T10:09:05','version'=>'1.05' },{'date'=>'2012-08-07T10:39:42','version'=>'1.06' },{'date'=>'2012-11-12T23:30:00','version'=>'1.07' },{'date'=>'2013-01-06T07:46:41','version'=>'1.08' },{'date'=>'2013-01-25T16:06:42','version'=>'1.09' },{'date'=>'2013-05-12T22:59:03','version'=>'1.10' },{'date'=>'2014-12-25T17:13:24','version'=>'1.11' },{'date'=>'2017-05-13T13:47:52','version'=>'1.12' }]},'Mojolicious'=>{'advisories'=>[{'affected_versions'=>'>7.83, <7.92','description'=>'This release reverts the addition of stream classes (added in 7.83), which have unfortunately resulted in many Mojolicious applications becoming unstable. While there are no known exploits yet, we\'ve chosen to err on the side of cautiousness and will classify this as a security issue.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2018-04','references'=>['https://github.com/mojolicious/mojo/commit/61f6cbf22c7bf8eb4787bd1014d91ee2416c73e7' ],'reported'=>'2018-08-09','severity'=>'critical' },{'affected_versions'=>'<7.80','description'=>'Mojo::UserAgent was not checking peer SSL certificates by default.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2018-03','references'=>['https://github.com/mojolicious/mojo/pull/1226','https://github.com/mojolicious/mojo/commit/d3cbbad890673612fdbdea63fdd522b516f6104c' ],'reported'=>'2018-05-19','severity'=>'high' },{'affected_versions'=>'<7.78','description'=>'GET requests with embedded backslashes can be used to access local files on Windows hosts
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2018-02','references'=>['https://github.com/mojolicious/mojo/pull/1217','https://github.com/mojolicious/mojo/commit/23ebe051d9378f0f122e3c908845fc0c2cae0106' ],'reported'=>'2018-05-11','severity'=>'critical' },{'affected_versions'=>'<7.66','description'=>'Mojo::UserAgent::CookieJar leaks old cookies because of the missing host_only flag on empty domain.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2018-01','references'=>['https://github.com/mojolicious/mojo/pull/1192','https://github.com/mojolicious/mojo/issues/1185','https://github.com/mojolicious/mojo/commit/c16a56a9d6575ddc53d15e76d58f0ebcb0eeb149' ],'reported'=>'2018-02-13','severity'=>'minor' },{'affected_versions'=>'<5.76','description'=>'Directory traversal on Windows
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2015-01','references'=>['https://github.com/mojolicious/mojo/issues/738','https://github.com/mojolicious/mojo/commit/9ffa38fca73a9ddee91cbc70e0696268d500edde' ],'reported'=>'2015-02-02','severity'=>'critical' },{'affected_versions'=>'<5.48','description'=>'Context sensitivity of method param could lead to parameter injection attacks.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2014-01','references'=>['https://github.com/mojolicious/mojo/commit/a815d4797145f872ef6e9f1270841eda1d410afb' ],'reported'=>'2014-10-07','severity'=>'high' },{'affected_versions'=>'<1.16','description'=>'Directory traversal vulnerability in Path.pm in Mojolicious before 1.16 allows remote attackers to read arbitrary files via a %2f..%2f (encoded slash dot dot slash) in a URI.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2011-02','references'=>['https://github.com/mojolicious/mojo/commit/b09854988c5b5b6a2ba53cc8661c4b2677da3818','https://www.cvedetails.com/cve/CVE-2011-1589/' ],'reported'=>'2011-04-05','severity'=>'critical' },{'affected_versions'=>'<1.12','description'=>'Mojolicious is vulnerable to cross-site scripting, caused by improper validation of user-supplied input by link_to helper. A remote attacker could exploit this vulnerability using a specially-crafted URL to execute script in a victim\'s Web browser within the security context of the hosting Web site, once the URL is clicked. An attacker could use this vulnerability to steal the victim\'s cookie-based authentication credentials.
  ','distribution'=>'Mojolicious','id'=>'CPANSA-Mojolicious-2011-01','references'=>['https://exchange.xforce.ibmcloud.com/vulnerabilities/67257','https://www.debian.org/security/2011/dsa-2239','https://github.com/mojolicious/mojo/commit/f6801ef7be8c78092e38f870b19fae3da0899d60' ],'reported'=>'2011-03-10','severity'=>'high' }],'main_module'=>'Mojolicious','versions'=>[{'date'=>'2010-02-11T02:04:14','version'=>'0.999920' },{'date'=>'2010-02-11T02:55:03','version'=>'0.999921' },{'date'=>'2010-02-26T18:50:34','version'=>'0.999922' },{'date'=>'2010-03-08T20:03:52','version'=>'0.999923' },{'date'=>'2010-03-20T22:56:55','version'=>'0.999924' },{'date'=>'2010-06-07T22:33:12','version'=>'0.999925' },{'date'=>'2010-06-11T10:33:01','version'=>'0.999926' },{'date'=>'2010-08-15T13:48:19','version'=>'0.999927' },{'date'=>'2010-08-17T17:41:47','version'=>'0.999928' },{'date'=>'2010-08-17T17:54:45','version'=>'0.999929' },{'date'=>'2010-10-19T13:57:49','version'=>'0.999930' },{'date'=>'2010-10-26T04:44:54','version'=>'0.999931' },{'date'=>'2010-10-30T00:54:42','version'=>'0.999932' },{'date'=>'2010-10-30T19:46:09','version'=>'0.999933' },{'date'=>'2010-11-01T00:33:14','version'=>'0.999934' },{'date'=>'2010-11-03T20:34:11','version'=>'0.999935' },{'date'=>'2010-11-04T23:48:46','version'=>'0.999936' },{'date'=>'2010-11-09T20:13:52','version'=>'0.999937' },{'date'=>'2010-11-09T21:24:17','version'=>'0.999938' },{'date'=>'2010-11-15T17:56:49','version'=>'0.999939' },{'date'=>'2010-11-15T23:18:40','version'=>'0.999940' },{'date'=>'2010-11-19T14:22:51','version'=>'0.999941' },{'date'=>'2010-12-01T18:57:50','version'=>'0.999950' },{'date'=>'2010-12-26T14:55:33','version'=>'1.0' },{'date'=>'2011-01-06T12:00:46','version'=>'1.01' },{'date'=>'2011-02-14T03:22:27','version'=>'1.1' },{'date'=>'2011-02-18T17:07:03','version'=>'1.11' },{'date'=>'2011-03-10T10:05:32','version'=>'1.12' },{'date'=>'2011-03-14T11:58:23','version'=>'1.13' },{'date'=>'2011-03-17T13:24:28','version'=>'1.14' },{'date'=>'2011-03-18T18:31:34','version'=>'1.15' },{'date'=>'2011-04-15T09:07:17','version'=>'1.16' },{'date'=>'2011-04-18T21:49:07','version'=>'1.17' },{'date'=>'2011-04-19T21:03:20','version'=>'1.18' },{'date'=>'2011-04-19T22:17:44','version'=>'1.19' },{'date'=>'2011-04-20T10:39:46','version'=>'1.20' },{'date'=>'2011-04-20T15:29:17','version'=>'1.21' },{'date'=>'2011-05-02T07:00:00','version'=>'1.22' },{'date'=>'2011-05-08T17:00:10','version'=>'1.31' },{'date'=>'2011-05-11T13:29:59','version'=>'1.32' },{'date'=>'2011-05-20T12:32:57','version'=>'1.33' },{'date'=>'2011-05-22T13:20:40','version'=>'1.34' },{'date'=>'2011-06-02T09:03:36','version'=>'1.4' },{'date'=>'2011-06-03T10:12:43','version'=>'1.41' },{'date'=>'2011-06-09T14:12:56','version'=>'1.42' },{'date'=>'2011-06-13T14:05:24','version'=>'1.43' },{'date'=>'2011-06-18T18:14:22','version'=>'1.44' },{'date'=>'2011-06-20T00:25:16','version'=>'1.45' },{'date'=>'2011-06-21T04:56:47','version'=>'1.46' },{'date'=>'2011-06-22T13:03:42','version'=>'1.47' },{'date'=>'2011-06-24T12:01:47','version'=>'1.48' },{'date'=>'2011-06-30T15:18:18','version'=>'1.49' },{'date'=>'2011-07-01T10:26:00','version'=>'1.50' },{'date'=>'2011-07-01T13:59:47','version'=>'1.51' },{'date'=>'2011-07-01T17:48:50','version'=>'1.52' },{'date'=>'2011-07-02T11:48:49','version'=>'1.53' },{'date'=>'2011-07-03T18:04:37','version'=>'1.54' },{'date'=>'2011-07-04T21:23:51','version'=>'1.55' },{'date'=>'2011-07-05T20:49:36','version'=>'1.56' },{'date'=>'2011-07-07T02:00:07','version'=>'1.57' },{'date'=>'2011-07-07T19:52:59','version'=>'1.58' },{'date'=>'2011-07-08T04:58:56','version'=>'1.59' },{'date'=>'2011-07-08T20:44:55','version'=>'1.60' },{'date'=>'2011-07-09T19:36:58','version'=>'1.61' },{'date'=>'2011-07-10T00:40:32','version'=>'1.62' },{'date'=>'2011-07-10T03:19:49','version'=>'1.63' },{'date'=>'2011-07-10T05:51:47','version'=>'1.64' },{'date'=>'2011-07-25T18:13:25','version'=>'1.65' },{'date'=>'2011-07-26T23:14:38','version'=>'1.66' },{'date'=>'2011-07-27T13:57:06','version'=>'1.67' },{'date'=>'2011-07-29T18:39:20','version'=>'1.68' },{'date'=>'2011-08-03T14:32:24','version'=>'1.69' },{'date'=>'2011-08-04T15:34:41','version'=>'1.70' },{'date'=>'2011-08-05T04:01:50','version'=>'1.71' },{'date'=>'2011-08-05T20:07:50','version'=>'1.72' },{'date'=>'2011-08-09T10:07:19','version'=>'1.73' },{'date'=>'2011-08-09T12:09:49','version'=>'1.74' },{'date'=>'2011-08-12T13:14:07','version'=>'1.75' },{'date'=>'2011-08-12T14:54:00','version'=>'1.76' },{'date'=>'2011-08-14T20:48:58','version'=>'1.77' },{'date'=>'2011-08-16T13:22:48','version'=>'1.78' },{'date'=>'2011-08-17T17:43:58','version'=>'1.79' },{'date'=>'2011-08-17T19:08:11','version'=>'1.80' },{'date'=>'2011-08-19T02:48:39','version'=>'1.81' },{'date'=>'2011-08-19T04:55:49','version'=>'1.82' },{'date'=>'2011-08-19T05:21:15','version'=>'1.83' },{'date'=>'2011-08-19T18:08:30','version'=>'1.84' },{'date'=>'2011-08-20T00:19:42','version'=>'1.85' },{'date'=>'2011-08-21T18:59:13','version'=>'1.86' },{'date'=>'2011-08-23T00:49:19','version'=>'1.87' },{'date'=>'2011-08-23T19:20:37','version'=>'1.88' },{'date'=>'2011-08-23T21:15:42','version'=>'1.89' },{'date'=>'2011-08-24T19:01:47','version'=>'1.90' },{'date'=>'2011-08-25T05:54:05','version'=>'1.91' },{'date'=>'2011-08-26T00:47:54','version'=>'1.92' },{'date'=>'2011-08-27T09:11:59','version'=>'1.93' },{'date'=>'2011-08-27T10:52:14','version'=>'1.94' },{'date'=>'2011-09-01T20:50:35','version'=>'1.95' },{'date'=>'2011-09-01T22:42:14','version'=>'1.96' },{'date'=>'2011-09-03T10:32:15','version'=>'1.97' },{'date'=>'2011-09-14T18:21:20','version'=>'1.98' },{'date'=>'2011-09-29T08:27:22','version'=>'1.99' },{'date'=>'2011-10-17T16:25:55','version'=>'2.0' },{'date'=>'2011-10-19T12:49:44','version'=>'2.01' },{'date'=>'2011-10-19T23:41:41','version'=>'2.02' },{'date'=>'2011-10-20T12:24:36','version'=>'2.03' },{'date'=>'2011-10-21T15:37:59','version'=>'2.04' },{'date'=>'2011-10-22T16:36:22','version'=>'2.05' },{'date'=>'2011-10-22T21:44:31','version'=>'2.06' },{'date'=>'2011-10-23T00:39:23','version'=>'2.07' },{'date'=>'2011-10-23T01:30:44','version'=>'2.08' },{'date'=>'2011-10-23T02:13:30','version'=>'2.09' },{'date'=>'2011-10-25T02:22:41','version'=>'2.10' },{'date'=>'2011-10-25T18:47:46','version'=>'2.11' },{'date'=>'2011-10-27T01:54:39','version'=>'2.12' },{'date'=>'2011-10-27T19:15:21','version'=>'2.13' },{'date'=>'2011-10-28T20:28:23','version'=>'2.14' },{'date'=>'2011-10-29T04:29:30','version'=>'2.15' },{'date'=>'2011-10-29T20:52:07','version'=>'2.16' },{'date'=>'2011-10-30T00:55:35','version'=>'2.17' },{'date'=>'2011-10-30T18:03:30','version'=>'2.18' },{'date'=>'2011-10-31T09:07:02','version'=>'2.19' },{'date'=>'2011-11-01T00:40:20','version'=>'2.20' },{'date'=>'2011-11-02T01:29:01','version'=>'2.21' },{'date'=>'2011-11-03T15:21:43','version'=>'2.22' },{'date'=>'2011-11-04T18:45:33','version'=>'2.23' },{'date'=>'2011-11-05T16:16:00','version'=>'2.24' },{'date'=>'2011-11-08T21:13:48','version'=>'2.25' },{'date'=>'2011-11-10T16:53:32','version'=>'2.26' },{'date'=>'2011-11-16T20:59:52','version'=>'2.27' },{'date'=>'2011-11-17T23:44:36','version'=>'2.28' },{'date'=>'2011-11-19T20:10:28','version'=>'2.29' },{'date'=>'2011-11-20T00:19:04','version'=>'2.30' },{'date'=>'2011-11-20T22:25:03','version'=>'2.31' },{'date'=>'2011-11-24T10:31:31','version'=>'2.32' },{'date'=>'2011-11-28T12:32:13','version'=>'2.33' },{'date'=>'2011-11-28T14:02:31','version'=>'2.34' },{'date'=>'2011-12-01T14:19:35','version'=>'2.35' },{'date'=>'2011-12-05T10:52:35','version'=>'2.36' },{'date'=>'2011-12-10T18:18:16','version'=>'2.37' },{'date'=>'2011-12-17T12:03:38','version'=>'2.38' },{'date'=>'2011-12-22T12:31:43','version'=>'2.39' },{'date'=>'2011-12-24T13:04:21','version'=>'2.40' },{'date'=>'2011-12-28T16:09:18','version'=>'2.41' },{'date'=>'2012-01-02T17:15:52','version'=>'2.42' },{'date'=>'2012-01-08T03:43:27','version'=>'2.43' },{'date'=>'2012-01-17T23:21:12','version'=>'2.44' },{'date'=>'2012-01-18T15:23:03','version'=>'2.45' },{'date'=>'2012-01-25T18:20:48','version'=>'2.46' },{'date'=>'2012-02-06T16:28:27','version'=>'2.47' },{'date'=>'2012-02-09T07:04:28','version'=>'2.48' },{'date'=>'2012-02-13T19:45:00','version'=>'2.49' },{'date'=>'2012-02-18T01:18:38','version'=>'2.50' },{'date'=>'2012-02-19T12:32:58','version'=>'2.51' },{'date'=>'2012-02-24T15:01:33','version'=>'2.52' },{'date'=>'2012-02-25T05:53:29','version'=>'2.53' },{'date'=>'2012-02-27T15:31:19','version'=>'2.54' },{'date'=>'2012-02-27T19:26:41','version'=>'2.55' },{'date'=>'2012-03-01T21:07:06','version'=>'2.56' },{'date'=>'2012-03-03T22:01:50','version'=>'2.57' },{'date'=>'2012-03-09T18:38:46','version'=>'2.58' },{'date'=>'2012-03-09T19:02:23','version'=>'2.59' },{'date'=>'2012-03-13T16:50:25','version'=>'2.60' },{'date'=>'2012-03-14T00:41:48','version'=>'2.61' },{'date'=>'2012-03-17T09:05:12','version'=>'2.62' },{'date'=>'2012-03-20T18:39:51','version'=>'2.63' },{'date'=>'2012-03-21T01:23:59','version'=>'2.64' },{'date'=>'2012-03-22T22:06:10','version'=>'2.65' },{'date'=>'2012-03-23T16:16:55','version'=>'2.66' },{'date'=>'2012-03-24T14:29:35','version'=>'2.67' },{'date'=>'2012-03-24T14:59:52','version'=>'2.68' },{'date'=>'2012-03-27T12:53:44','version'=>'2.69' },{'date'=>'2012-03-30T21:24:44','version'=>'2.70' },{'date'=>'2012-04-03T01:46:31','version'=>'2.71' },{'date'=>'2012-04-03T13:16:07','version'=>'2.72' },{'date'=>'2012-04-03T17:10:05','version'=>'2.73' },{'date'=>'2012-04-03T22:33:05','version'=>'2.74' },{'date'=>'2012-04-05T01:57:10','version'=>'2.75' },{'date'=>'2012-04-05T03:52:05','version'=>'2.76' },{'date'=>'2012-04-09T12:36:15','version'=>'2.77' },{'date'=>'2012-04-09T18:54:51','version'=>'2.78' },{'date'=>'2012-04-10T10:58:23','version'=>'2.79' },{'date'=>'2012-04-10T14:25:57','version'=>'2.80' },{'date'=>'2012-04-15T18:49:31','version'=>'2.81' },{'date'=>'2012-04-16T21:09:32','version'=>'2.82' },{'date'=>'2012-04-18T18:51:37','version'=>'2.83' },{'date'=>'2012-04-18T21:29:14','version'=>'2.84' },{'date'=>'2012-04-19T15:37:54','version'=>'2.85' },{'date'=>'2012-04-23T12:21:14','version'=>'2.86' },{'date'=>'2012-04-23T14:19:09','version'=>'2.87' },{'date'=>'2012-04-24T02:15:58','version'=>'2.88' },{'date'=>'2012-04-24T20:08:49','version'=>'2.89' },{'date'=>'2012-04-25T11:35:38','version'=>'2.90' },{'date'=>'2012-04-26T19:20:37','version'=>'2.91' },{'date'=>'2012-04-30T16:50:01','version'=>'2.92' },{'date'=>'2012-05-05T22:00:26','version'=>'2.93' },{'date'=>'2012-05-10T03:49:57','version'=>'2.94' },{'date'=>'2012-05-10T20:08:54','version'=>'2.95' },{'date'=>'2012-05-21T08:26:37','version'=>'2.96' },{'date'=>'2012-05-28T12:11:13','version'=>'2.97' },{'date'=>'2012-05-30T18:21:26','version'=>'2.98' },{'date'=>'2012-06-26T06:45:51','version'=>'3.0' },{'date'=>'2012-07-01T10:00:07','version'=>'3.01' },{'date'=>'2012-07-03T19:21:54','version'=>'3.02' },{'date'=>'2012-07-06T21:17:36','version'=>'3.03' },{'date'=>'2012-07-07T11:29:24','version'=>'3.04' },{'date'=>'2012-07-07T21:49:48','version'=>'3.05' },{'date'=>'2012-07-11T17:27:01','version'=>'3.06' },{'date'=>'2012-07-13T00:25:44','version'=>'3.07' },{'date'=>'2012-07-13T21:53:56','version'=>'3.08' },{'date'=>'2012-07-16T19:46:15','version'=>'3.09' },{'date'=>'2012-07-16T20:00:50','version'=>'3.10' },{'date'=>'2012-07-19T01:44:35','version'=>'3.11' },{'date'=>'2012-07-20T12:30:03','version'=>'3.12' },{'date'=>'2012-07-24T17:03:04','version'=>'3.13' },{'date'=>'2012-07-27T11:05:47','version'=>'3.14' },{'date'=>'2012-07-28T11:32:31','version'=>'3.15' },{'date'=>'2012-07-31T18:55:11','version'=>'3.16' },{'date'=>'2012-08-01T00:38:50','version'=>'3.17' },{'date'=>'2012-08-01T19:15:21','version'=>'3.18' },{'date'=>'2012-08-02T15:40:34','version'=>'3.19' },{'date'=>'2012-08-03T23:32:38','version'=>'3.20' },{'date'=>'2012-08-05T22:32:21','version'=>'3.21' },{'date'=>'2012-08-06T19:53:03','version'=>'3.22' },{'date'=>'2012-08-07T03:37:26','version'=>'3.23' },{'date'=>'2012-08-07T20:56:45','version'=>'3.24' },{'date'=>'2012-08-08T00:31:31','version'=>'3.25' },{'date'=>'2012-08-08T04:04:18','version'=>'3.26' },{'date'=>'2012-08-08T21:18:27','version'=>'3.27' },{'date'=>'2012-08-10T12:18:38','version'=>'3.28' },{'date'=>'2012-08-13T13:42:56','version'=>'3.29' },{'date'=>'2012-08-13T16:14:35','version'=>'3.30' },{'date'=>'2012-08-15T09:37:25','version'=>'3.31' },{'date'=>'2012-08-20T12:37:26','version'=>'3.32' },{'date'=>'2012-08-23T18:34:00','version'=>'3.33' },{'date'=>'2012-08-24T01:17:41','version'=>'3.34' },{'date'=>'2012-08-27T22:52:31','version'=>'3.35' },{'date'=>'2012-08-30T00:59:43','version'=>'3.36' },{'date'=>'2012-09-04T20:50:40','version'=>'3.37' },{'date'=>'2012-09-07T00:05:53','version'=>'3.38' },{'date'=>'2012-09-10T11:58:00','version'=>'3.39' },{'date'=>'2012-09-11T18:03:47','version'=>'3.40' },{'date'=>'2012-09-13T18:22:49','version'=>'3.41' },{'date'=>'2012-09-16T17:29:48','version'=>'3.42' },{'date'=>'2012-09-22T19:40:59','version'=>'3.43' },{'date'=>'2012-09-29T11:20:17','version'=>'3.44' },{'date'=>'2012-10-09T20:39:26','version'=>'3.45' },{'date'=>'2012-10-10T20:55:33','version'=>'3.46' },{'date'=>'2012-10-12T23:10:49','version'=>'3.47' },{'date'=>'2012-10-16T22:51:05','version'=>'3.48' },{'date'=>'2012-10-19T16:34:25','version'=>'3.49' },{'date'=>'2012-10-20T01:34:34','version'=>'3.50' },{'date'=>'2012-10-23T20:23:54','version'=>'3.51' },{'date'=>'2012-10-26T14:41:25','version'=>'3.52' },{'date'=>'2012-10-31T02:41:01','version'=>'3.53' },{'date'=>'2012-11-01T04:36:00','version'=>'3.54' },{'date'=>'2012-11-08T11:20:15','version'=>'3.55' },{'date'=>'2012-11-09T20:09:37','version'=>'3.56' },{'date'=>'2012-11-12T19:47:57','version'=>'3.57' },{'date'=>'2012-11-19T16:05:13','version'=>'3.58' },{'date'=>'2012-11-20T19:53:03','version'=>'3.59' },{'date'=>'2012-11-22T05:12:27','version'=>'3.60' },{'date'=>'2012-11-25T04:19:47','version'=>'3.61' },{'date'=>'2012-11-26T00:57:00','version'=>'3.62' },{'date'=>'2012-11-28T10:17:51','version'=>'3.63' },{'date'=>'2012-12-01T16:39:26','version'=>'3.64' },{'date'=>'2012-12-08T22:47:54','version'=>'3.65' },{'date'=>'2012-12-14T01:03:29','version'=>'3.66' },{'date'=>'2012-12-14T23:48:00','version'=>'3.67' },{'date'=>'2012-12-16T00:55:55','version'=>'3.68' },{'date'=>'2012-12-20T22:47:53','version'=>'3.69' },{'date'=>'2012-12-23T22:18:59','version'=>'3.70' },{'date'=>'2013-01-02T11:57:12','version'=>'3.71' },{'date'=>'2013-01-04T22:16:16','version'=>'3.72' },{'date'=>'2013-01-06T22:46:48','version'=>'3.73' },{'date'=>'2013-01-07T18:47:06','version'=>'3.74' },{'date'=>'2013-01-08T16:15:03','version'=>'3.75' },{'date'=>'2013-01-10T00:00:19','version'=>'3.76' },{'date'=>'2013-01-12T00:36:11','version'=>'3.77' },{'date'=>'2013-01-12T23:47:49','version'=>'3.78' },{'date'=>'2013-01-13T00:50:13','version'=>'3.79' },{'date'=>'2013-01-15T05:02:52','version'=>'3.80' },{'date'=>'2013-01-17T21:32:48','version'=>'3.81' },{'date'=>'2013-01-18T15:50:23','version'=>'3.82' },{'date'=>'2013-01-27T15:28:40','version'=>'3.83' },{'date'=>'2013-01-30T00:32:12','version'=>'3.84' },{'date'=>'2013-02-13T00:56:23','version'=>'3.85' },{'date'=>'2013-02-22T02:01:13','version'=>'3.86' },{'date'=>'2013-02-23T19:36:00','version'=>'3.87' },{'date'=>'2013-03-03T21:53:52','version'=>'3.88' },{'date'=>'2013-03-04T16:12:24','version'=>'3.89' },{'date'=>'2013-03-14T20:08:14','version'=>'3.90' },{'date'=>'2013-03-17T22:59:42','version'=>'3.91' },{'date'=>'2013-04-03T19:48:34','version'=>'3.92' },{'date'=>'2013-04-05T21:46:38','version'=>'3.93' },{'date'=>'2013-04-08T21:48:55','version'=>'3.94' },{'date'=>'2013-04-12T03:49:59','version'=>'3.95' },{'date'=>'2013-04-22T21:34:16','version'=>'3.96' },{'date'=>'2013-04-25T21:49:41','version'=>'3.97' },{'date'=>'2013-05-15T20:02:05','version'=>'4.0' },{'date'=>'2013-05-19T17:24:38','version'=>'4.01' },{'date'=>'2013-05-20T16:55:00','version'=>'4.02' },{'date'=>'2013-05-21T05:24:56','version'=>'4.03' },{'date'=>'2013-05-23T21:25:32','version'=>'4.04' },{'date'=>'2013-05-24T02:59:59','version'=>'4.05' },{'date'=>'2013-05-24T14:23:41','version'=>'4.06' },{'date'=>'2013-05-25T18:07:30','version'=>'4.07' },{'date'=>'2013-05-30T21:45:51','version'=>'4.08' },{'date'=>'2013-05-31T02:24:29','version'=>'4.09' },{'date'=>'2013-06-01T02:09:07','version'=>'4.10' },{'date'=>'2013-06-03T04:34:37','version'=>'4.11' },{'date'=>'2013-06-07T01:51:09','version'=>'4.12' },{'date'=>'2013-06-09T00:25:21','version'=>'4.13' },{'date'=>'2013-06-10T00:23:12','version'=>'4.14' },{'date'=>'2013-06-18T08:02:11','version'=>'4.15' },{'date'=>'2013-06-19T01:27:29','version'=>'4.16' },{'date'=>'2013-07-04T16:14:27','version'=>'4.17' },{'date'=>'2013-07-08T09:17:43','version'=>'4.18' },{'date'=>'2013-07-21T21:47:46','version'=>'4.19' },{'date'=>'2013-07-28T12:53:38','version'=>'4.20' },{'date'=>'2013-07-28T20:17:31','version'=>'4.21' },{'date'=>'2013-07-29T19:13:38','version'=>'4.22' },{'date'=>'2013-07-31T20:35:17','version'=>'4.23' },{'date'=>'2013-08-08T21:10:52','version'=>'4.24' },{'date'=>'2013-08-17T20:16:56','version'=>'4.25' },{'date'=>'2013-08-18T15:06:51','version'=>'4.26' },{'date'=>'2013-08-26T15:29:36','version'=>'4.27' },{'date'=>'2013-08-29T16:11:59','version'=>'4.28' },{'date'=>'2013-08-31T02:01:44','version'=>'4.29' },{'date'=>'2013-09-01T21:48:28','version'=>'4.30' },{'date'=>'2013-09-04T20:09:26','version'=>'4.31' },{'date'=>'2013-09-06T21:19:59','version'=>'4.32' },{'date'=>'2013-09-07T20:38:03','version'=>'4.33' },{'date'=>'2013-09-08T20:58:54','version'=>'4.34' },{'date'=>'2013-09-10T21:40:13','version'=>'4.35' },{'date'=>'2013-09-12T21:31:22','version'=>'4.36' },{'date'=>'2013-09-13T01:32:54','version'=>'4.37' },{'date'=>'2013-09-16T22:01:40','version'=>'4.38' },{'date'=>'2013-09-17T04:53:49','version'=>'4.39' },{'date'=>'2013-09-21T01:15:17','version'=>'4.40' },{'date'=>'2013-09-21T17:25:38','version'=>'4.41' },{'date'=>'2013-09-30T07:46:05','version'=>'4.42' },{'date'=>'2013-10-02T19:16:26','version'=>'4.43' },{'date'=>'2013-10-04T21:18:14','version'=>'4.44' },{'date'=>'2013-10-06T15:46:08','version'=>'4.45' },{'date'=>'2013-10-12T17:11:54','version'=>'4.46' },{'date'=>'2013-10-14T23:51:30','version'=>'4.47' },{'date'=>'2013-10-16T05:28:45','version'=>'4.48' },{'date'=>'2013-10-17T16:53:59','version'=>'4.49' },{'date'=>'2013-10-23T01:18:55','version'=>'4.50' },{'date'=>'2013-10-28T17:20:46','version'=>'4.51' },{'date'=>'2013-10-29T06:27:25','version'=>'4.52' },{'date'=>'2013-10-30T00:21:27','version'=>'4.53' },{'date'=>'2013-11-07T00:45:35','version'=>'4.54' },{'date'=>'2013-11-07T02:38:24','version'=>'4.55' },{'date'=>'2013-11-10T02:56:56','version'=>'4.56' },{'date'=>'2013-11-11T20:30:04','version'=>'4.57' },{'date'=>'2013-11-19T20:46:01','version'=>'4.58' },{'date'=>'2013-12-04T21:35:49','version'=>'4.59' },{'date'=>'2013-12-11T16:33:35','version'=>'4.60' },{'date'=>'2013-12-16T16:59:25','version'=>'4.61' },{'date'=>'2013-12-17T20:35:36','version'=>'4.62' },{'date'=>'2013-12-19T22:59:01','version'=>'4.63' },{'date'=>'2014-01-01T16:20:28','version'=>'4.64' },{'date'=>'2014-01-02T22:36:45','version'=>'4.65' },{'date'=>'2014-01-04T21:48:06','version'=>'4.66' },{'date'=>'2014-01-11T17:20:18','version'=>'4.67' },{'date'=>'2014-01-21T22:24:03','version'=>'4.68' },{'date'=>'2014-01-24T04:06:26','version'=>'4.69' },{'date'=>'2014-01-26T22:08:54','version'=>'4.70' },{'date'=>'2014-01-28T03:10:15','version'=>'4.71' },{'date'=>'2014-01-29T21:29:25','version'=>'4.72' },{'date'=>'2014-02-01T05:20:38','version'=>'4.73' },{'date'=>'2014-02-02T04:30:05','version'=>'4.74' },{'date'=>'2014-02-02T06:54:56','version'=>'4.75' },{'date'=>'2014-02-04T22:41:32','version'=>'4.76' },{'date'=>'2014-02-06T23:19:13','version'=>'4.77' },{'date'=>'2014-02-08T23:02:08','version'=>'4.78' },{'date'=>'2014-02-11T02:49:44','version'=>'4.79' },{'date'=>'2014-02-13T04:30:43','version'=>'4.80' },{'date'=>'2014-02-15T03:27:30','version'=>'4.81' },{'date'=>'2014-02-19T04:11:47','version'=>'4.82' },{'date'=>'2014-02-19T06:20:46','version'=>'4.83' },{'date'=>'2014-02-22T22:59:02','version'=>'4.84' },{'date'=>'2014-02-26T22:48:41','version'=>'4.85' },{'date'=>'2014-03-03T05:45:32','version'=>'4.86' },{'date'=>'2014-03-04T07:14:15','version'=>'4.87' },{'date'=>'2014-03-09T22:42:42','version'=>'4.88' },{'date'=>'2014-03-13T21:30:57','version'=>'4.89' },{'date'=>'2014-03-16T21:22:35','version'=>'4.90' },{'date'=>'2014-03-29T00:05:17','version'=>'4.91' },{'date'=>'2014-04-08T20:41:54','version'=>'4.92' },{'date'=>'2014-04-13T02:17:03','version'=>'4.93' },{'date'=>'2014-04-19T23:39:22','version'=>'4.94' },{'date'=>'2014-04-27T03:27:43','version'=>'4.95' },{'date'=>'2014-04-27T20:04:36','version'=>'4.96' },{'date'=>'2014-04-29T22:12:52','version'=>'4.97' },{'date'=>'2014-05-09T01:57:34','version'=>'4.98' },{'date'=>'2014-05-12T00:46:43','version'=>'4.99' },{'date'=>'2014-05-29T20:15:51','version'=>'5.0' },{'date'=>'2014-05-30T14:51:14','version'=>'5.01' },{'date'=>'2014-05-31T21:51:34','version'=>'5.02' },{'date'=>'2014-06-02T22:07:46','version'=>'5.03' },{'date'=>'2014-06-03T21:11:50','version'=>'5.04' },{'date'=>'2014-06-08T21:50:53','version'=>'5.05' },{'date'=>'2014-06-12T02:08:01','version'=>'5.06' },{'date'=>'2014-06-13T19:28:04','version'=>'5.07' },{'date'=>'2014-06-16T23:44:48','version'=>'5.08' },{'date'=>'2014-06-24T15:02:21','version'=>'5.09' },{'date'=>'2014-06-28T23:25:12','version'=>'5.10' },{'date'=>'2014-07-03T04:01:24','version'=>'5.11' },{'date'=>'2014-07-03T23:06:55','version'=>'5.12' },{'date'=>'2014-07-13T00:44:29','version'=>'5.13' },{'date'=>'2014-07-14T22:01:49','version'=>'5.14' },{'date'=>'2014-07-17T17:58:05','version'=>'5.15' },{'date'=>'2014-07-21T16:01:56','version'=>'5.16' },{'date'=>'2014-07-24T12:40:41','version'=>'5.17' },{'date'=>'2014-07-25T20:25:29','version'=>'5.18' },{'date'=>'2014-07-26T21:03:13','version'=>'5.19' },{'date'=>'2014-07-26T23:36:18','version'=>'5.20' },{'date'=>'2014-07-27T18:48:25','version'=>'5.21' },{'date'=>'2014-07-30T16:42:35','version'=>'5.22' },{'date'=>'2014-07-31T21:32:03','version'=>'5.23' },{'date'=>'2014-08-02T21:56:32','version'=>'5.24' },{'date'=>'2014-08-07T01:29:20','version'=>'5.25' },{'date'=>'2014-08-09T21:26:37','version'=>'5.26' },{'date'=>'2014-08-11T14:26:47','version'=>'5.27' },{'date'=>'2014-08-13T00:32:33','version'=>'5.28' },{'date'=>'2014-08-16T12:40:15','version'=>'5.29' },{'date'=>'2014-08-17T21:49:15','version'=>'5.30' },{'date'=>'2014-08-19T17:40:27','version'=>'5.31' },{'date'=>'2014-08-21T18:19:53','version'=>'5.32' },{'date'=>'2014-08-23T22:25:32','version'=>'5.33' },{'date'=>'2014-08-29T21:53:02','version'=>'5.34' },{'date'=>'2014-08-30T21:57:50','version'=>'5.35' },{'date'=>'2014-09-02T00:20:21','version'=>'5.36' },{'date'=>'2014-09-03T20:55:45','version'=>'5.37' },{'date'=>'2014-09-05T21:57:34','version'=>'5.38' },{'date'=>'2014-09-07T03:18:45','version'=>'5.39' },{'date'=>'2014-09-12T01:06:33','version'=>'5.40' },{'date'=>'2014-09-13T21:24:03','version'=>'5.41' },{'date'=>'2014-09-17T21:54:39','version'=>'5.42' },{'date'=>'2014-09-22T00:14:24','version'=>'5.43' },{'date'=>'2014-09-23T00:49:52','version'=>'5.44' },{'date'=>'2014-09-27T03:21:55','version'=>'5.46' },{'date'=>'2014-09-27T03:24:38','version'=>'5.45' },{'date'=>'2014-09-28T03:31:15','version'=>'5.47' },{'date'=>'2014-10-07T23:08:14','version'=>'5.48' },{'date'=>'2014-10-10T21:12:14','version'=>'5.49' },{'date'=>'2014-10-15T22:00:04','version'=>'5.50' },{'date'=>'2014-10-17T21:48:17','version'=>'5.51' },{'date'=>'2014-10-18T20:49:34','version'=>'5.52' },{'date'=>'2014-10-20T23:34:37','version'=>'5.53' },{'date'=>'2014-10-23T22:51:06','version'=>'5.54' },{'date'=>'2014-10-29T00:58:34','version'=>'5.55' },{'date'=>'2014-10-30T00:23:25','version'=>'5.56' },{'date'=>'2014-11-02T22:52:07','version'=>'5.57' },{'date'=>'2014-11-07T00:04:47','version'=>'5.58' },{'date'=>'2014-11-08T00:26:41','version'=>'5.59' },{'date'=>'2014-11-12T01:31:36','version'=>'5.60' },{'date'=>'2014-11-15T00:46:43','version'=>'5.61' },{'date'=>'2014-11-18T18:24:54','version'=>'5.62' },{'date'=>'2014-11-22T03:52:56','version'=>'5.63' },{'date'=>'2014-11-23T02:12:00','version'=>'5.64' },{'date'=>'2014-11-25T03:23:01','version'=>'5.65' },{'date'=>'2014-11-27T03:13:19','version'=>'5.66' },{'date'=>'2014-11-27T06:19:49','version'=>'5.67' },{'date'=>'2014-12-03T04:36:04','version'=>'5.68' },{'date'=>'2014-12-13T02:19:36','version'=>'5.69' },{'date'=>'2014-12-18T00:12:31','version'=>'5.70' },{'date'=>'2015-01-01T22:44:58','version'=>'5.71' },{'date'=>'2015-01-11T20:02:04','version'=>'5.72' },{'date'=>'2015-01-23T16:29:22','version'=>'5.73' },{'date'=>'2015-01-24T13:32:51','version'=>'5.74' },{'date'=>'2015-01-27T04:08:19','version'=>'5.75' },{'date'=>'2015-02-02T19:36:16','version'=>'5.76' },{'date'=>'2015-02-03T02:37:04','version'=>'5.77' },{'date'=>'2015-02-13T00:21:48','version'=>'5.78' },{'date'=>'2015-02-13T05:32:50','version'=>'5.79' },{'date'=>'2015-02-18T05:24:00','version'=>'5.80' },{'date'=>'2015-02-21T03:30:18','version'=>'5.81' },{'date'=>'2015-02-23T03:05:04','version'=>'5.82' },{'date'=>'2015-02-26T22:17:01','version'=>'6.0' },{'date'=>'2015-03-03T16:12:16','version'=>'6.01' },{'date'=>'2015-03-10T02:53:22','version'=>'6.02' },{'date'=>'2015-03-16T04:43:10','version'=>'6.03' },{'date'=>'2015-03-23T04:42:27','version'=>'6.04' },{'date'=>'2015-03-25T05:08:15','version'=>'6.05' },{'date'=>'2015-04-07T00:55:21','version'=>'6.06' },{'date'=>'2015-04-07T17:38:01','version'=>'6.07' },{'date'=>'2015-04-09T22:03:46','version'=>'6.08' },{'date'=>'2015-04-26T05:10:45','version'=>'6.09' },{'date'=>'2015-04-27T02:01:03','version'=>'6.10' },{'date'=>'2015-05-16T22:14:01','version'=>'6.11' },{'date'=>'2015-06-18T21:48:20','version'=>'6.12' },{'date'=>'2015-08-20T06:09:39','version'=>'6.16' },{'date'=>'2015-08-22T19:38:51','version'=>'6.17' },{'date'=>'2015-09-02T17:26:36','version'=>'6.18' },{'date'=>'2015-09-12T23:37:29','version'=>'6.19' },{'date'=>'2015-09-16T22:50:30','version'=>'6.20' },{'date'=>'2015-09-23T01:05:04','version'=>'6.21' },{'date'=>'2015-09-27T01:03:32','version'=>'6.22' },{'date'=>'2015-10-07T18:17:26','version'=>'6.23' },{'date'=>'2015-10-13T22:54:46','version'=>'6.24' },{'date'=>'2015-10-22T02:49:47','version'=>'6.25' },{'date'=>'2015-10-29T00:29:07','version'=>'6.26' },{'date'=>'2015-10-30T00:07:08','version'=>'6.27' },{'date'=>'2015-11-02T15:17:16','version'=>'6.28' },{'date'=>'2015-11-12T02:59:43','version'=>'6.30' },{'date'=>'2015-11-14T19:38:51','version'=>'6.31' },{'date'=>'2015-11-18T18:16:15','version'=>'6.32' },{'date'=>'2015-11-22T16:47:00','version'=>'6.33' },{'date'=>'2016-01-13T20:08:22','version'=>'6.40' },{'date'=>'2016-01-24T22:01:52','version'=>'6.42' },{'date'=>'2016-02-01T16:15:40','version'=>'6.43' },{'date'=>'2016-02-05T22:42:51','version'=>'6.44' },{'date'=>'2016-02-09T23:29:35','version'=>'6.45' },{'date'=>'2016-02-14T00:51:10','version'=>'6.46' },{'date'=>'2016-02-19T23:09:15','version'=>'6.47' },{'date'=>'2016-02-24T17:07:45','version'=>'6.48' },{'date'=>'2016-02-26T22:47:33','version'=>'6.49' },{'date'=>'2016-02-27T00:12:03','version'=>'6.50' },{'date'=>'2016-02-29T23:03:44','version'=>'6.51' },{'date'=>'2016-03-02T22:24:28','version'=>'6.52' },{'date'=>'2016-03-04T00:58:55','version'=>'6.53' },{'date'=>'2016-03-07T15:09:42','version'=>'6.54' },{'date'=>'2016-03-08T20:42:43','version'=>'6.55' },{'date'=>'2016-03-16T02:42:45','version'=>'6.56' },{'date'=>'2016-03-23T04:23:41','version'=>'6.57' },{'date'=>'2016-04-10T17:11:22','version'=>'6.58' },{'date'=>'2016-04-22T18:45:19','version'=>'6.59' },{'date'=>'2016-04-26T13:16:04','version'=>'6.60' },{'date'=>'2016-05-02T17:31:34','version'=>'6.61' },{'date'=>'2016-05-14T21:05:47','version'=>'6.62' },{'date'=>'2016-06-03T21:10:48','version'=>'6.63' },{'date'=>'2016-06-09T16:41:51','version'=>'6.64' },{'date'=>'2016-06-14T16:15:21','version'=>'6.65' },{'date'=>'2016-06-16T22:35:28','version'=>'6.66' },{'date'=>'2016-07-19T06:21:07','version'=>'7.0' },{'date'=>'2016-08-01T18:46:35','version'=>'7.01' },{'date'=>'2016-08-17T16:34:19','version'=>'7.02' },{'date'=>'2016-08-17T16:40:11','version'=>'7.03' },{'date'=>'2016-08-29T13:59:45','version'=>'7.04' },{'date'=>'2016-08-29T16:44:18','version'=>'7.05' },{'date'=>'2016-09-17T21:05:37','version'=>'7.06' },{'date'=>'2016-09-20T12:30:54','version'=>'7.07' },{'date'=>'2016-09-23T17:19:00','version'=>'7.08' },{'date'=>'2016-10-23T09:46:35','version'=>'7.09' },{'date'=>'2016-11-01T19:02:03','version'=>'7.10' },{'date'=>'2016-11-30T09:23:48','version'=>'7.11' },{'date'=>'2016-12-20T08:41:05','version'=>'7.12' },{'date'=>'2016-12-29T19:40:25','version'=>'7.13' },{'date'=>'2017-01-04T22:58:20','version'=>'7.14' },{'date'=>'2017-01-10T11:42:59','version'=>'7.15' },{'date'=>'2017-01-10T23:52:50','version'=>'7.16' },{'date'=>'2017-01-11T08:35:01','version'=>'7.17' },{'date'=>'2017-01-11T22:05:10','version'=>'7.18' },{'date'=>'2017-01-15T16:05:23','version'=>'7.19' },{'date'=>'2017-01-18T09:38:55','version'=>'7.20' },{'date'=>'2017-01-22T14:29:35','version'=>'7.21' },{'date'=>'2017-01-25T23:09:32','version'=>'7.22' },{'date'=>'2017-01-29T21:43:19','version'=>'7.23' },{'date'=>'2017-02-05T21:09:47','version'=>'7.24' },{'date'=>'2017-02-09T22:51:35','version'=>'7.25' },{'date'=>'2017-02-15T23:08:52','version'=>'7.26' },{'date'=>'2017-02-27T17:02:21','version'=>'7.27' },{'date'=>'2017-03-07T21:36:36','version'=>'7.28' },{'date'=>'2017-03-14T23:27:54','version'=>'7.29' },{'date'=>'2017-04-06T12:04:02','version'=>'7.30' },{'date'=>'2017-04-24T07:50:54','version'=>'7.31' },{'date'=>'2017-05-30T17:08:40','version'=>'7.32' },{'date'=>'2017-06-05T22:14:35','version'=>'7.33' },{'date'=>'2017-07-02T22:04:01','version'=>'7.34' },{'date'=>'2017-07-05T07:50:23','version'=>'7.35' },{'date'=>'2017-07-10T07:48:45','version'=>'7.36' },{'date'=>'2017-07-24T07:55:46','version'=>'7.37' },{'date'=>'2017-08-01T21:56:47','version'=>'7.38' },{'date'=>'2017-08-03T08:50:10','version'=>'7.39' },{'date'=>'2017-08-14T08:32:54','version'=>'7.40' },{'date'=>'2017-08-16T08:19:30','version'=>'7.41' },{'date'=>'2017-08-17T11:15:42','version'=>'7.42' },{'date'=>'2017-08-18T08:26:45','version'=>'7.43' },{'date'=>'2017-09-03T16:04:13','version'=>'7.44' },{'date'=>'2017-09-07T08:41:40','version'=>'7.45' },{'date'=>'2017-09-12T12:27:00','version'=>'7.46' },{'date'=>'2017-10-12T08:26:53','version'=>'7.47' },{'date'=>'2017-10-21T13:33:01','version'=>'7.48' },{'date'=>'2017-10-30T13:18:49','version'=>'7.49' },{'date'=>'2017-10-30T18:18:13','version'=>'7.50' },{'date'=>'2017-10-31T19:14:43','version'=>'7.51' },{'date'=>'2017-11-02T22:29:23','version'=>'7.52' },{'date'=>'2017-11-04T15:24:07','version'=>'7.53' },{'date'=>'2017-11-04T22:50:30','version'=>'7.54' },{'date'=>'2017-11-07T10:58:56','version'=>'7.55' },{'date'=>'2017-11-16T13:33:27','version'=>'7.56' },{'date'=>'2017-11-18T16:10:38','version'=>'7.57' },{'date'=>'2017-12-03T22:14:41','version'=>'7.58' },{'date'=>'2017-12-17T17:58:55','version'=>'7.59' },{'date'=>'2018-01-03T14:00:44','version'=>'7.60' },{'date'=>'2018-01-15T15:35:28','version'=>'7.61' },{'date'=>'2018-02-03T19:53:39','version'=>'7.62' },{'date'=>'2018-02-06T20:52:51','version'=>'7.63' },{'date'=>'2018-02-07T10:17:57','version'=>'7.64' },{'date'=>'2018-02-11T21:55:33','version'=>'7.65' },{'date'=>'2018-02-14T08:55:35','version'=>'7.66' },{'date'=>'2018-02-19T23:11:52','version'=>'7.67' },{'date'=>'2018-02-23T18:44:15','version'=>'7.68' },{'date'=>'2018-02-24T21:58:41','version'=>'7.69' },{'date'=>'2018-02-28T23:47:08','version'=>'7.70' },{'date'=>'2018-03-16T16:41:58','version'=>'7.71' },{'date'=>'2018-04-02T21:01:43','version'=>'7.72' },{'date'=>'2018-04-06T14:10:03','version'=>'7.73' },{'date'=>'2018-04-07T22:15:16','version'=>'7.74' },{'date'=>'2018-04-10T16:04:41','version'=>'7.75' },{'date'=>'2018-04-24T16:55:32','version'=>'7.76' },{'date'=>'2018-05-01T17:18:20','version'=>'7.77' },{'date'=>'2018-05-11T16:36:16','version'=>'7.78' },{'date'=>'2018-05-14T22:13:04','version'=>'7.79' },{'date'=>'2018-05-20T22:46:20','version'=>'7.80' },{'date'=>'2018-05-21T22:39:30','version'=>'7.81' },{'date'=>'2018-05-27T21:59:59','version'=>'7.82' },{'date'=>'2018-06-03T21:10:42','version'=>'7.83' },{'date'=>'2018-06-06T14:04:49','version'=>'7.84' },{'date'=>'2018-06-19T15:57:43','version'=>'7.85' },{'date'=>'2018-07-03T11:30:46','version'=>'7.86' },{'date'=>'2018-07-04T10:20:11','version'=>'7.87' },{'date'=>'2018-07-13T11:00:52','version'=>'7.88' },{'date'=>'2018-08-07T09:38:35','version'=>'7.89' },{'date'=>'2018-08-08T22:19:36','version'=>'7.90' },{'date'=>'2018-08-09T08:39:58','version'=>'7.91' },{'date'=>'2018-08-09T16:52:45','version'=>'7.92' },{'date'=>'2018-08-12T14:23:08','version'=>'7.93' },{'date'=>'2018-08-31T12:53:17','version'=>'7.94' },{'date'=>'2018-09-14T22:17:06','version'=>'8.0' },{'date'=>'2018-09-25T16:14:07','version'=>'8.01' },{'date'=>'2018-10-01T21:34:50','version'=>'8.02' },{'date'=>'2018-10-16T22:41:46','version'=>'8.03' },{'date'=>'2018-10-21T20:23:27','version'=>'8.04' },{'date'=>'2018-11-01T17:15:20','version'=>'8.05' },{'date'=>'2018-11-08T23:31:57','version'=>'8.06' },{'date'=>'2018-11-18T22:09:07','version'=>'8.07' },{'date'=>'2018-12-01T18:26:15','version'=>'8.08' },{'date'=>'2018-12-04T20:59:01','version'=>'8.09' },{'date'=>'2018-12-20T10:28:28','version'=>'8.10' },{'date'=>'2019-01-02T18:04:35','version'=>'8.11' },{'date'=>'2019-02-01T16:34:38','version'=>'8.12' }]},'Mojolicious-Plugin-OAuth2'=>{'advisories'=>[{'affected_versions'=>'<1.3','description'=>'Param injection in case of several parameters of the same name are present.
  ','distribution'=>'Mojolicious-Plugin-OAuth2','fixed_versions'=>'>=1.3','id'=>'CPANSA-Mojolicious-Plugin-OAuth2-2014-01','references'=>['https://metacpan.org/changes/distribution/Mojolicious-Plugin-OAuth2','https://github.com/marcusramberg/Mojolicious-Plugin-OAuth2/commit/68315d329059b427e13d486c0e10733f728709aa' ],'reported'=>'2014-10-07' }],'main_module'=>'Mojolicious::Plugin::OAuth2','versions'=>[{'date'=>'2011-01-08T11:03:42','version'=>'0.01' },{'date'=>'2011-01-09T18:00:14','version'=>'0.02' },{'date'=>'2011-04-03T16:00:38','version'=>'0.1' },{'date'=>'2011-08-01T16:56:18','version'=>'0.2' },{'date'=>'2011-09-04T19:42:29','version'=>'0.3' },{'date'=>'2011-09-07T16:59:50','version'=>'0.4' },{'date'=>'2011-10-19T11:55:32','version'=>'0.5' },{'date'=>'2012-03-09T21:15:39','version'=>'0.6' },{'date'=>'2012-05-30T11:49:29','version'=>'0.7' },{'date'=>'2012-08-23T20:18:41','version'=>'0.8' },{'date'=>'2013-05-20T05:55:18','version'=>'0.9' },{'date'=>'2013-11-06T13:24:52','version'=>'1.0' },{'date'=>'2014-03-13T08:18:10','version'=>'1.1' },{'date'=>'2014-09-06T13:49:59','version'=>'1.2' },{'date'=>'2014-10-07T05:49:16','version'=>'1.3' },{'date'=>'2015-03-01T20:09:19','version'=>'1.4' },{'date'=>'2015-03-02T07:32:59','version'=>'1.5' },{'date'=>'2015-03-18T16:40:18','version'=>'1.51' },{'date'=>'2015-04-06T20:46:39','version'=>'1.52' },{'date'=>'2015-09-08T07:27:41','version'=>'1.53' },{'date'=>'2018-08-30T10:48:55','version'=>'1.54' },{'date'=>'2018-09-08T18:30:54','version'=>'1.55' },{'date'=>'2018-09-23T22:04:16','version'=>'1.56' },{'date'=>'2018-09-24T08:55:14','version'=>'1.57' }]},'Net-DNS'=>{'advisories'=>[{'affected_versions'=>'<0.63','cves'=>['CVE-2007-6341' ],'description'=>'Allows remote attackers to cause a denial of service (program "croak") via a crafted DNS response.
  ','distribution'=>'Net-DNS','fixed_versions'=>'>=0.63','id'=>'CPANSA-Net-DNS-2008-01','references'=>['https://metacpan.org/changes/distribution/Net-DNS' ],'reported'=>'2008-02-08' }],'main_module'=>'Net::DNS','versions'=>[{'date'=>'1997-02-04T10:03:21','version'=>'0.02' },{'date'=>'1997-02-05T05:54:07','version'=>'0.02' },{'date'=>'1997-02-10T16:24:12','version'=>'0.03' },{'date'=>'1997-02-13T23:50:40','version'=>'0.04' },{'date'=>'1997-03-28T06:22:18','version'=>'0.05' },{'date'=>'1997-04-03T06:54:12','version'=>'0.06' },{'date'=>'1997-04-19T18:07:46','version'=>'0.07' },{'date'=>'1997-05-13T15:27:34','version'=>'0.08' },{'date'=>'1997-05-29T22:16:14','version'=>'0.09' },{'date'=>'1997-06-13T04:35:29','version'=>'0.10' },{'date'=>'1997-07-06T18:10:05','version'=>'0.11' },{'date'=>'1997-10-02T05:53:19','version'=>'0.12' },{'date'=>'2002-02-01T21:32:42','version'=>'0.14' },{'date'=>'2002-04-11T23:04:19','version'=>'0.19' },{'date'=>'2002-05-15T00:39:48','version'=>'0.20' },{'date'=>'2002-06-03T21:44:48','version'=>'0.21' },{'date'=>'2002-06-06T21:48:08','version'=>'0.22' },{'date'=>'2002-06-11T22:49:07','version'=>'0.23' },{'date'=>'2002-07-06T20:17:50','version'=>'0.24' },{'date'=>'2002-08-01T10:37:46','version'=>'0.25' },{'date'=>'2002-08-05T20:11:20','version'=>'0.26' },{'date'=>'2002-08-15T15:55:56','version'=>'0.27' },{'date'=>'2002-08-21T00:18:55','version'=>'0.28' },{'date'=>'2002-10-02T06:09:09','version'=>'0.29' },{'date'=>'2002-11-07T13:19:03','version'=>'0.30' },{'date'=>'2002-11-18T04:32:09','version'=>'0.31' },{'date'=>'2003-01-05T21:37:55','version'=>'0.32' },{'date'=>'2003-01-08T18:31:53','version'=>'0.33' },{'date'=>'2003-03-06T19:19:53','version'=>'0.34' },{'date'=>'2003-05-22T02:33:15','version'=>'0.34_02' },{'date'=>'2003-05-23T01:24:00','version'=>'0.34_03' },{'date'=>'2003-05-26T07:13:38','version'=>'0.35' },{'date'=>'2003-05-28T22:24:43','version'=>'0.36' },{'date'=>'2003-05-28T22:41:56','version'=>'0.37' },{'date'=>'2003-06-05T23:55:14','version'=>'0.38' },{'date'=>'2003-06-23T00:19:28','version'=>'0.38_01' },{'date'=>'2003-07-29T09:34:12','version'=>'0.38_02' },{'date'=>'2003-08-07T22:35:45','version'=>'0.39' },{'date'=>'2003-08-12T04:10:01','version'=>'0.39_01' },{'date'=>'2003-08-28T15:17:51','version'=>'0.39_02' },{'date'=>'2003-09-01T22:18:39','version'=>'0.40' },{'date'=>'2003-09-26T22:54:49','version'=>'0.40_01' },{'date'=>'2003-10-03T15:57:27','version'=>'0.41' },{'date'=>'2003-10-26T05:42:29','version'=>'0.42' },{'date'=>'2003-12-01T04:39:24','version'=>'0.42_01' },{'date'=>'2003-12-11T08:53:09','version'=>'0.42_02' },{'date'=>'2003-12-12T00:28:17','version'=>'0.43' },{'date'=>'2003-12-13T01:55:07','version'=>'0.44' },{'date'=>'2004-01-03T06:49:06','version'=>'0.44_01' },{'date'=>'2004-01-04T04:51:25','version'=>'0.44_02' },{'date'=>'2004-01-08T05:56:11','version'=>'0.45' },{'date'=>'2004-02-10T00:53:47','version'=>'0.45_01' },{'date'=>'2004-02-21T12:53:34','version'=>'0.46' },{'date'=>'2004-04-01T07:39:00','version'=>'0.47' },{'date'=>'2004-05-06T19:18:31','version'=>'0.47_01' },{'date'=>'2004-08-13T01:11:57','version'=>'0.48' },{'date'=>'2005-03-07T14:31:55','version'=>'0.48_01' },{'date'=>'2005-03-14T20:47:20','version'=>'0.48_02' },{'date'=>'2005-03-22T15:54:51','version'=>'0.48_03' },{'date'=>'2005-03-29T13:12:16','version'=>'0.49' },{'date'=>'2005-05-24T08:07:55','version'=>'0.49_01' },{'date'=>'2005-05-28T07:07:52','version'=>'0.49_02' },{'date'=>'2005-06-01T20:51:43','version'=>'0.49_03' },{'date'=>'2005-06-08T14:15:32','version'=>'0.50' },{'date'=>'2005-06-10T11:00:29','version'=>'0.51' },{'date'=>'2005-06-14T11:42:54','version'=>'0.49_01' },{'date'=>'2005-06-22T14:32:45','version'=>'0.49_01' },{'date'=>'2005-07-01T21:50:47','version'=>'0.52' },{'date'=>'2005-07-22T12:23:21','version'=>'0.53' },{'date'=>'2005-07-31T14:40:15','version'=>'0.53_01' },{'date'=>'2005-10-18T14:39:03','version'=>'0.53_02' },{'date'=>'2005-12-07T13:15:30','version'=>'0.54' },{'date'=>'2005-12-14T10:29:42','version'=>'0.55' },{'date'=>'2006-02-20T15:34:25','version'=>'0.56' },{'date'=>'2006-02-24T16:21:14','version'=>'0.57' },{'date'=>'2006-07-04T11:42:41','version'=>'0.58' },{'date'=>'2006-09-18T19:31:10','version'=>'0.59' },{'date'=>'2007-06-22T07:31:18','version'=>'0.60' },{'date'=>'2007-08-01T12:26:55','version'=>'0.61' },{'date'=>'2007-12-28T19:32:25','version'=>'0.62' },{'date'=>'2008-02-08T15:49:50','version'=>'0.63' },{'date'=>'2008-12-30T18:11:35','version'=>'0.64' },{'date'=>'2009-01-26T18:19:23','version'=>'0.65' },{'date'=>'2009-12-30T13:58:25','version'=>'0.66' },{'date'=>'2011-10-25T12:14:24','version'=>'0.66_01' },{'date'=>'2011-10-27T14:23:38','version'=>'0.66_02' },{'date'=>'2011-10-28T14:31:06','version'=>'0.66_03' },{'date'=>'2011-10-28T15:00:15','version'=>'0.66_04' },{'date'=>'2011-10-31T14:36:02','version'=>'0.66_06' },{'date'=>'2011-10-31T19:34:01','version'=>'0.66_07' },{'date'=>'2011-11-02T21:52:59','version'=>'0.66_08' },{'date'=>'2011-11-07T09:07:56','version'=>'0.67' },{'date'=>'2012-01-23T13:41:03','version'=>'0.67_01' },{'date'=>'2012-01-26T10:44:13','version'=>'0.67_03' },{'date'=>'2012-01-27T08:47:28','version'=>'0.67_04' },{'date'=>'2012-01-31T21:54:27','version'=>'0.68' },{'date'=>'2012-01-31T22:11:31','version'=>'0.68' },{'date'=>'2012-10-29T15:35:55','version'=>'0.68_01' },{'date'=>'2012-10-31T10:25:57','version'=>'0.68_02' },{'date'=>'2012-10-31T20:33:53','version'=>'0.68_03' },{'date'=>'2012-11-12T07:15:13','version'=>'0.68_04' },{'date'=>'2012-11-12T10:22:31','version'=>'0.68_05' },{'date'=>'2012-11-19T12:57:25','version'=>'0.68_06' },{'date'=>'2012-11-21T23:12:34','version'=>'0.68_07' },{'date'=>'2012-11-23T22:12:01','version'=>'0.68_08' },{'date'=>'2012-12-04T07:18:08','version'=>'0.68_09' },{'date'=>'2012-12-05T12:07:43','version'=>'0.69' },{'date'=>'2012-12-05T14:05:12','version'=>'0.69_1' },{'date'=>'2012-12-06T11:10:17','version'=>'0.70' },{'date'=>'2012-12-12T16:04:03','version'=>'0.70_1' },{'date'=>'2012-12-15T11:18:56','version'=>'0.71' },{'date'=>'2012-12-24T21:14:23','version'=>'0.71_01' },{'date'=>'2012-12-28T15:03:57','version'=>'0.72' },{'date'=>'2013-11-13T15:18:55','version'=>'0.72_01' },{'date'=>'2013-11-14T16:13:33','version'=>'0.72_02' },{'date'=>'2013-11-18T10:49:23','version'=>'0.72_03' },{'date'=>'2013-11-19T21:52:50','version'=>'0.72_04' },{'date'=>'2013-11-29T13:35:08','version'=>'0.73' },{'date'=>'2013-12-24T15:21:50','version'=>'0.73_1' },{'date'=>'2014-01-02T20:32:27','version'=>'0.73_2' },{'date'=>'2014-01-05T20:31:16','version'=>'0.73_3' },{'date'=>'2014-01-12T10:25:24','version'=>'0.73_4' },{'date'=>'2014-01-13T15:59:49','version'=>'0.73_5' },{'date'=>'2014-01-16T10:23:47','version'=>'0.74' },{'date'=>'2014-03-03T21:33:39','version'=>'0.74_1' },{'date'=>'2014-03-10T08:36:19','version'=>'0.74_2' },{'date'=>'2014-04-03T21:00:45','version'=>'0.74_3' },{'date'=>'2014-04-30T14:05:59','version'=>'0.74_4' },{'date'=>'2014-05-05T06:05:46','version'=>'0.74_5' },{'date'=>'2014-05-06T09:22:01','version'=>'0.74_6' },{'date'=>'2014-05-08T09:54:21','version'=>'0.75' },{'date'=>'2014-05-22T20:56:00','version'=>'0.75_1' },{'date'=>'2014-05-23T22:26:56','version'=>'0.76' },{'date'=>'2014-05-29T11:26:07','version'=>'0.76_1' },{'date'=>'2014-06-05T16:04:39','version'=>'0.76_2' },{'date'=>'2014-06-13T08:31:32','version'=>'0.76_3' },{'date'=>'2014-06-13T21:57:13','version'=>'0.77' },{'date'=>'2014-07-02T09:53:03','version'=>'0.77_1' },{'date'=>'2014-07-09T07:09:44','version'=>'0.77_2' },{'date'=>'2014-07-10T14:13:33','version'=>'0.78' },{'date'=>'2014-07-30T21:41:25','version'=>'0.78_1' },{'date'=>'2014-08-12T22:13:54','version'=>'0.78_2' },{'date'=>'2014-08-15T14:40:22','version'=>'0.78_3' },{'date'=>'2014-08-19T13:24:46','version'=>'0.78_5' },{'date'=>'2014-08-22T22:29:13','version'=>'0.79' },{'date'=>'2014-09-11T11:42:35','version'=>'0.79_1' },{'date'=>'2014-09-15T14:51:32','version'=>'0.79_2' },{'date'=>'2014-09-22T11:51:22','version'=>'0.80' },{'date'=>'2014-10-20T08:19:15','version'=>'0.80_1' },{'date'=>'2014-10-24T08:21:15','version'=>'0.80_2' },{'date'=>'2014-10-29T13:44:16','version'=>'0.81' },{'date'=>'2015-01-05T10:22:06','version'=>'0.81_01' },{'date'=>'2015-01-20T14:12:38','version'=>'0.82' },{'date'=>'2015-02-11T14:26:36','version'=>'0.82_01' },{'date'=>'2015-02-18T11:05:47','version'=>'0.82_02' },{'date'=>'2015-02-26T15:48:06','version'=>'0.83' },{'date'=>'2015-05-27T10:04:50','version'=>'1.00_01' },{'date'=>'2015-06-11T17:23:10','version'=>'1.00_02' },{'date'=>'2015-06-15T10:02:08','version'=>'1.00_03' },{'date'=>'2015-06-23T13:57:29','version'=>'1.00_04' },{'date'=>'2015-06-26T09:37:11','version'=>'1.00_05' },{'date'=>'2015-06-29T17:15:06','version'=>'1.00_06' },{'date'=>'2015-07-01T13:51:22','version'=>'1.00_07' },{'date'=>'2015-07-02T08:17:44','version'=>'1.00_08' },{'date'=>'2015-07-06T17:28:32','version'=>'1.01' },{'date'=>'2015-08-26T20:44:25','version'=>'1.01_01' },{'date'=>'2015-09-03T06:21:58','version'=>'1.01_02' },{'date'=>'2015-09-04T20:39:37','version'=>'1.01_03' },{'date'=>'2015-09-08T08:26:06','version'=>'1.01_04' },{'date'=>'2015-09-11T11:49:24','version'=>'1.01_05' },{'date'=>'2015-09-15T18:51:53','version'=>'1.01_06' },{'date'=>'2015-09-16T10:25:09','version'=>'1.02' },{'date'=>'2015-09-22T13:39:43','version'=>'1.02_01' },{'date'=>'2015-10-05T08:30:03','version'=>'1.02_02' },{'date'=>'2015-10-06T20:39:36','version'=>'1.02_03' },{'date'=>'2015-10-08T21:24:29','version'=>'1.02_04' },{'date'=>'2015-10-13T07:30:39','version'=>'1.02_05' },{'date'=>'2015-10-14T12:44:57','version'=>'1.02_06' },{'date'=>'2015-10-20T09:59:26','version'=>'1.02_07' },{'date'=>'2015-10-23T08:32:04','version'=>'1.02_08' },{'date'=>'2015-10-27T16:07:21','version'=>'1.02_09' },{'date'=>'2015-11-02T06:00:09','version'=>'1.02_10' },{'date'=>'2015-11-08T13:49:33','version'=>'1.03' },{'date'=>'2015-12-01T21:21:55','version'=>'1.03_01' },{'date'=>'2015-12-02T14:27:42','version'=>'1.03_02' },{'date'=>'2015-12-02T20:49:07','version'=>'1.03_03' },{'date'=>'2015-12-08T20:41:10','version'=>'1.04' },{'date'=>'2016-02-01T16:26:27','version'=>'1.04_01' },{'date'=>'2016-02-02T08:03:42','version'=>'1.04_02' },{'date'=>'2016-02-05T12:19:57','version'=>'1.04_03' },{'date'=>'2016-02-29T12:32:53','version'=>'1.04_04' },{'date'=>'2016-03-07T21:11:01','version'=>'1.05' },{'date'=>'2016-03-21T13:15:38','version'=>'1.05_01' },{'date'=>'2016-03-24T18:45:15','version'=>'1.05_02' },{'date'=>'2016-04-04T21:53:54','version'=>'1.05_03' },{'date'=>'2016-04-15T10:11:03','version'=>'1.05_04' },{'date'=>'2016-04-17T12:05:46','version'=>'1.05_05' },{'date'=>'2016-05-11T08:58:51','version'=>'1.05_06' },{'date'=>'2016-05-22T07:54:41','version'=>'1.05_07' },{'date'=>'2016-05-27T19:12:44','version'=>'1.06' },{'date'=>'2016-06-22T08:54:06','version'=>'1.06_01' },{'date'=>'2016-08-24T11:36:13','version'=>'1.06_02' },{'date'=>'2016-08-25T15:01:31','version'=>'1.06_03' },{'date'=>'2016-09-17T08:19:30','version'=>'1.06_04' },{'date'=>'2016-11-12T03:24:33','version'=>'1.06_05' },{'date'=>'2016-12-23T14:48:42','version'=>'1.06_06' },{'date'=>'2016-12-29T17:16:20','version'=>'1.07' },{'date'=>'2017-01-18T21:51:05','version'=>'1.07_01' },{'date'=>'2017-01-27T10:44:03','version'=>'1.07_02' },{'date'=>'2017-02-09T10:28:55','version'=>'1.07_03' },{'date'=>'2017-02-13T10:08:41','version'=>'1.07_04' },{'date'=>'2017-02-20T11:12:45','version'=>'1.08' },{'date'=>'2017-03-06T09:33:06','version'=>'1.08_02' },{'date'=>'2017-03-13T10:02:22','version'=>'1.08_03' },{'date'=>'2017-03-22T09:48:52','version'=>'1.08_04' },{'date'=>'2017-03-24T07:00:36','version'=>'1.09' },{'date'=>'2017-04-19T13:10:57','version'=>'1.09_01' },{'date'=>'2017-05-05T22:21:10','version'=>'1.10' },{'date'=>'2017-05-31T09:07:40','version'=>'1.10_01' },{'date'=>'2017-06-03T20:26:47','version'=>'1.10_02' },{'date'=>'2017-06-12T12:03:07','version'=>'1.10_03' },{'date'=>'2017-06-26T12:52:57','version'=>'1.11' },{'date'=>'2017-07-07T21:50:10','version'=>'1.11_01' },{'date'=>'2017-07-28T16:17:01','version'=>'1.11_02' },{'date'=>'2017-08-15T10:33:15','version'=>'1.11_03' },{'date'=>'2017-08-17T12:48:08','version'=>'1.11_04' },{'date'=>'2017-08-18T13:15:31','version'=>'1.12' },{'date'=>'2017-09-12T09:28:26','version'=>'1.12_01' },{'date'=>'2017-10-06T09:07:45','version'=>'1.12_02' },{'date'=>'2017-10-10T14:42:38','version'=>'1.12_03' },{'date'=>'2017-10-18T09:49:20','version'=>'1.13' },{'date'=>'2017-11-30T11:11:55','version'=>'1.13_01' },{'date'=>'2017-12-07T10:17:12','version'=>'1.13_02' },{'date'=>'2017-12-15T12:34:59','version'=>'1.14' },{'date'=>'2018-01-31T10:11:39','version'=>'1.14_01' },{'date'=>'2018-02-01T14:14:07','version'=>'1.14_02' },{'date'=>'2018-02-09T11:42:14','version'=>'1.15' },{'date'=>'2018-06-11T09:20:56','version'=>'1.15_01' },{'date'=>'2018-06-14T10:46:39','version'=>'1.15_02' },{'date'=>'2018-07-03T09:05:15','version'=>'1.15_03' },{'date'=>'2018-07-06T10:03:02','version'=>'1.15_04' },{'date'=>'2018-07-16T04:56:07','version'=>'1.16' },{'date'=>'2018-07-20T16:22:38','version'=>'1.16_01' },{'date'=>'2018-07-24T15:35:14','version'=>'1.16_02' },{'date'=>'2018-07-25T07:10:24','version'=>'1.17' },{'date'=>'2018-09-11T10:24:34','version'=>'1.17_01' },{'date'=>'2018-09-11T15:32:52','version'=>'1.17_02' },{'date'=>'2018-09-12T06:15:44','version'=>'1.17_03' },{'date'=>'2018-09-21T14:49:48','version'=>'1.18' },{'date'=>'2018-11-08T06:39:55','version'=>'1.18_01' },{'date'=>'2018-11-15T06:02:14','version'=>'1.19' },{'date'=>'2018-12-31T12:23:28','version'=>'1.19_01' },{'date'=>'2019-01-28T09:48:25','version'=>'1.19_02' }]},'Net-OpenID-Consumer'=>{'advisories'=>[{'affected_versions'=>'<1.12','description'=>'A potential timing attack when checking signatures.
  ','distribution'=>'Net-OpenID-Consumer','fixed_versions'=>'>=1.12','id'=>'CPANSA-Net-OpenID-Consumer-2010-01','references'=>['https://metacpan.org/changes/distribution/Net-OpenID-Consumer','https://github.com/wrog/Net-OpenID-Consumer/commit/4e82c7e4b6ad4bc40571c5cfcaa58f9365b147a5','http://lists.openid.net/pipermail/openid-security/2010-July/001156.html' ],'reported'=>'2010-11-06' },{'affected_versions'=>'<0.06','description'=>'Incorrect comparison of system openssl status when doing DSA checks.
  ','distribution'=>'Net-OpenID-Consumer','fixed_versions'=>'>=0.06','id'=>'CPANSA-Net-OpenID-Consumer-2015-05','references'=>['https://metacpan.org/changes/distribution/Net-OpenID-Consumer' ],'reported'=>'2015-05-26' }],'main_module'=>'Net::OpenID::Consumer','versions'=>[{'date'=>'2005-05-23T03:02:59','version'=>'0.02' },{'date'=>'2005-05-23T08:05:35','version'=>'0.03' },{'date'=>'2005-05-25T05:08:25','version'=>'0.04' },{'date'=>'2005-05-25T06:14:44','version'=>'0.05' },{'date'=>'2005-05-26T06:18:39','version'=>'0.06' },{'date'=>'2005-05-26T06:56:30','version'=>'0.07' },{'date'=>'2005-05-26T07:18:01','version'=>'0.08' },{'date'=>'2005-06-23T23:50:47','version'=>'0.09' },{'date'=>'2005-06-27T04:43:01','version'=>'0.10' },{'date'=>'2005-06-27T21:59:47','version'=>'0.11' },{'date'=>'2005-07-13T17:57:27','version'=>'0.12' },{'date'=>'2007-04-16T17:58:45','version'=>'0.13' },{'date'=>'2007-08-03T22:07:20','version'=>'0.14' },{'date'=>'2008-10-13T02:30:05','version'=>'1.01' },{'date'=>'2008-10-14T04:39:07','version'=>'1.02' },{'date'=>'2008-11-30T02:02:17','version'=>'1.03' },{'date'=>'2010-02-18T15:32:06','version'=>'1.04' },{'date'=>'2010-02-18T16:01:19','version'=>'1.05' },{'date'=>'2010-03-16T17:38:56','version'=>'1.06' },{'date'=>'2010-11-06T02:24:29','version'=>'1.030099_001' },{'date'=>'2010-11-07T11:21:33','version'=>'1.030099_002' },{'date'=>'2010-11-08T22:35:52','version'=>'1.030099_003' },{'date'=>'2010-12-17T21:57:03','version'=>'1.030099_004' },{'date'=>'2011-01-01T01:55:09','version'=>'1.030099_005' },{'date'=>'2011-10-23T01:35:49','version'=>'1.030099_006' },{'date'=>'2011-10-25T23:10:00','version'=>'1.100099_001' },{'date'=>'2011-11-02T10:38:05','version'=>'1.100099_002' },{'date'=>'2011-11-04T23:01:32','version'=>'1.11' },{'date'=>'2011-11-07T17:16:08','version'=>'1.12' },{'date'=>'2011-11-15T03:28:36','version'=>'1.13' },{'date'=>'2013-04-01T13:17:57','version'=>'1.14' },{'date'=>'2013-09-06T23:47:04','version'=>'1.15' },{'date'=>'2014-09-15T21:38:12','version'=>'1.16' },{'date'=>'2016-01-15T11:45:55','version'=>'1.17' },{'date'=>'2016-02-08T01:40:13','version'=>'1.18' }]},'Otogiri'=>{'advisories'=>[{'affected_versions'=>'<0.13','description'=>'A depenpendant module SQL::Maker without strict mode is vulnerable to SQL injection.
  ','distribution'=>'Otogiri','fixed_versions'=>'>=0.13','id'=>'CPANSA-Otogiri-2014-01','references'=>['https://github.com/ytnobody/Otogiri/commit/fac1592b3d153a6871ff1aed8016a6888cff9095','https://metacpan.org/changes/distribution/Otogiri' ],'reported'=>'2014-07-03' }],'main_module'=>'Otogiri','versions'=>[{'date'=>'2013-10-30T06:45:51','version'=>'0.01' },{'date'=>'2013-11-08T08:36:50','version'=>'0.02' },{'date'=>'2013-11-09T05:00:47','version'=>'0.03' },{'date'=>'2013-12-27T00:15:23','version'=>'0.04' },{'date'=>'2013-12-28T15:54:15','version'=>'0.05' },{'date'=>'2014-01-14T09:13:18','version'=>'0.06' },{'date'=>'2014-02-25T06:25:50','version'=>'0.07' },{'date'=>'2014-03-18T04:14:12','version'=>'0.08' },{'date'=>'2014-03-18T05:07:37','version'=>'0.09' },{'date'=>'2014-05-13T12:58:21','version'=>'0.10' },{'date'=>'2014-05-30T10:11:18','version'=>'0.11' },{'date'=>'2014-06-05T08:30:13','version'=>'0.12' },{'date'=>'2014-07-03T12:40:28','version'=>'0.13' },{'date'=>'2014-12-18T08:37:33','version'=>'0.14' },{'date'=>'2015-01-11T04:56:15','version'=>'0.15' },{'date'=>'2015-11-13T07:18:18','version'=>'0.16' },{'date'=>'2016-02-02T05:58:26','version'=>'0.17' },{'date'=>'2017-05-19T01:37:05','version'=>'0.18' }]},'PAR'=>{'advisories'=>[{'affected_versions'=>'<1.003','cves'=>['CVE-2011-4114' ],'description'=>'PAR packed files are extracted to unsafe and predictable temporary directories (this bug was originally reported against PAR::Packer, but it applies to PAR as well).
  ','distribution'=>'PAR','fixed_versions'=>'>=1.003','id'=>'CPANSA-PAR-2011-01','references'=>['https://metacpan.org/changes/distribution/PAR','https://rt.cpan.org/Public/Bug/Display.html?id=69560' ],'reported'=>'2011-07-18' }],'main_module'=>'PAR','versions'=>[{'date'=>'2002-10-18T20:38:24','version'=>'0.01' },{'date'=>'2002-10-18T21:07:35','version'=>'0.02' },{'date'=>'2002-10-18T22:18:06','version'=>'0.03' },{'date'=>'2002-10-19T02:46:52','version'=>'0.04' },{'date'=>'2002-10-19T14:33:26','version'=>'0.05' },{'date'=>'2002-10-19T15:31:54','version'=>'0.06' },{'date'=>'2002-10-19T17:38:40','version'=>'0.10' },{'date'=>'2002-10-19T22:30:34','version'=>'0.11' },{'date'=>'2002-10-20T13:00:43','version'=>'0.12' },{'date'=>'2002-10-21T17:29:03','version'=>'0.13' },{'date'=>'2002-10-27T10:38:32','version'=>'0.14' },{'date'=>'2002-10-27T17:52:07','version'=>'0.15' },{'date'=>'2002-11-02T02:20:38','version'=>'0.20' },{'date'=>'2002-11-02T21:26:48','version'=>'0.21' },{'date'=>'2002-11-03T13:05:06','version'=>'0.22' },{'date'=>'2002-11-05T14:36:58','version'=>'0.30' },{'date'=>'2002-11-05T22:23:36','version'=>'0.40' },{'date'=>'2002-11-06T12:25:00','version'=>'0.41' },{'date'=>'2002-11-07T00:48:34','version'=>'0.42' },{'date'=>'2002-11-07T14:41:31','version'=>'0.43' },{'date'=>'2002-11-08T15:01:18','version'=>'0.44' },{'date'=>'2002-11-08T21:01:12','version'=>'0.45' },{'date'=>'2002-11-09T23:02:45','version'=>'0.46' },{'date'=>'2002-11-10T06:56:37','version'=>'0.47' },{'date'=>'2002-11-13T11:32:10','version'=>'0.48' },{'date'=>'2002-11-23T14:45:40','version'=>'0.49' },{'date'=>'2002-12-03T01:00:23','version'=>'0.50' },{'date'=>'2002-12-11T14:30:53','version'=>'0.51' },{'date'=>'2002-12-17T04:06:52','version'=>'0.60' },{'date'=>'2002-12-17T11:49:44','version'=>'0.61' },{'date'=>'2003-01-09T11:16:42','version'=>'0.62' },{'date'=>'2003-02-06T00:38:33','version'=>'0.63' },{'date'=>'2003-03-01T15:54:25','version'=>'0.64' },{'date'=>'2003-03-09T14:31:52','version'=>'0.65' },{'date'=>'2003-03-19T15:54:32','version'=>'0.66' },{'date'=>'2003-03-31T19:58:56','version'=>'0.66' },{'date'=>'2003-05-16T17:35:22','version'=>'0.67_89' },{'date'=>'2003-05-25T19:09:58','version'=>'0.68' },{'date'=>'2003-05-31T13:12:53','version'=>'0.69' },{'date'=>'2003-07-08T15:39:11','version'=>'0.69' },{'date'=>'2003-07-16T08:20:09','version'=>'0.69_91' },{'date'=>'2003-07-27T14:13:18','version'=>'0.69_93' },{'date'=>'2003-07-29T08:21:31','version'=>'0.70' },{'date'=>'2003-07-30T13:57:01','version'=>'0.71' },{'date'=>'2003-08-02T13:11:15','version'=>'0.72' },{'date'=>'2003-08-06T09:16:17','version'=>'0.73' },{'date'=>'2003-08-25T13:39:35','version'=>'0.74' },{'date'=>'2003-09-21T10:58:00','version'=>'0.75' },{'date'=>'2003-10-23T04:45:55','version'=>'0.75_99' },{'date'=>'2003-10-28T12:21:23','version'=>'0.76' },{'date'=>'2003-12-11T23:00:26','version'=>'0.76_98' },{'date'=>'2003-12-28T02:31:29','version'=>'0.76_99' },{'date'=>'2003-12-31T15:33:24','version'=>'0.77' },{'date'=>'2004-01-03T17:36:11','version'=>'0.77_98' },{'date'=>'2004-01-04T20:30:15','version'=>'0.77_99' },{'date'=>'2004-01-06T21:26:43','version'=>'0.78' },{'date'=>'2004-01-08T11:35:51','version'=>'0.79' },{'date'=>'2004-02-15T23:25:34','version'=>'0.79_97' },{'date'=>'2004-02-27T15:58:33','version'=>'0.79_98' },{'date'=>'2004-02-27T23:54:39','version'=>'0.79_98' },{'date'=>'2004-03-03T14:49:47','version'=>'0.79_99' },{'date'=>'2004-03-16T17:04:25','version'=>'0.80' },{'date'=>'2004-03-28T14:43:14','version'=>'0.80_99' },{'date'=>'2004-05-22T19:13:38','version'=>'0.81' },{'date'=>'2004-05-24T14:59:45','version'=>'0.82' },{'date'=>'2004-05-29T16:02:03','version'=>'0.83' },{'date'=>'2004-07-02T10:59:55','version'=>'0.85' },{'date'=>'2004-08-30T22:49:15','version'=>'0.85_01' },{'date'=>'2004-12-11T03:49:09','version'=>'0.86' },{'date'=>'2005-01-30T19:04:55','version'=>'0.87' },{'date'=>'2005-06-07T09:13:43','version'=>'0.88' },{'date'=>'2005-06-10T15:49:20','version'=>'0.89' },{'date'=>'2005-11-25T23:01:00','version'=>'0.90' },{'date'=>'2006-02-15T09:33:05','version'=>'0.91' },{'date'=>'2006-03-04T20:16:36','version'=>'0.91' },{'date'=>'2006-05-19T13:37:12','version'=>'0.93' },{'date'=>'2006-06-02T10:25:51','version'=>'0.93' },{'date'=>'2006-06-20T20:44:56','version'=>'0.93' },{'date'=>'2006-07-22T19:59:13','version'=>'0.942' },{'date'=>'2006-08-05T11:28:06','version'=>'0.950' },{'date'=>'2006-08-11T15:51:56','version'=>'0.950' },{'date'=>'2006-08-12T12:35:34','version'=>'0.950' },{'date'=>'2006-08-22T14:14:35','version'=>'0.952' },{'date'=>'2006-09-26T20:18:06','version'=>'0.954' },{'date'=>'2006-10-03T12:35:05','version'=>'0.955' },{'date'=>'2006-10-03T12:58:55','version'=>'0.956' },{'date'=>'2006-10-24T16:42:26','version'=>'0.957' },{'date'=>'2006-11-11T14:33:23','version'=>'0.958' },{'date'=>'2006-11-12T11:48:37','version'=>'0.959' },{'date'=>'2006-11-21T12:02:35','version'=>'0.960' },{'date'=>'2006-12-01T14:19:55','version'=>'0.969_01' },{'date'=>'2006-12-03T17:25:33','version'=>'0.970' },{'date'=>'2007-01-10T17:58:01','version'=>'0.970_01' },{'date'=>'2007-01-12T11:02:02','version'=>'0.971' },{'date'=>'2007-01-16T15:23:38','version'=>'0.972' },{'date'=>'2007-02-03T11:40:25','version'=>'0.973' },{'date'=>'2007-07-29T11:17:27','version'=>'0.976' },{'date'=>'2007-12-20T21:17:26','version'=>'0.977' },{'date'=>'2008-05-13T12:44:22','version'=>'0.979' },{'date'=>'2008-05-22T11:41:38','version'=>'0.980' },{'date'=>'2008-08-09T22:17:14','version'=>'0.980' },{'date'=>'2008-08-10T21:39:41','version'=>'0.980' },{'date'=>'2008-09-12T15:02:23','version'=>'0.983' },{'date'=>'2009-01-25T22:31:20','version'=>'0.984' },{'date'=>'2009-02-02T01:40:36','version'=>'0.985_01' },{'date'=>'2009-02-19T16:04:27','version'=>'0.986' },{'date'=>'2009-02-20T14:30:08','version'=>'0.987_01' },{'date'=>'2009-03-02T14:47:14','version'=>'0.988' },{'date'=>'2009-03-02T14:56:44','version'=>'0.989_01' },{'date'=>'2009-03-10T15:11:05','version'=>'0.991' },{'date'=>'2009-04-05T11:32:48','version'=>'0.992' },{'date'=>'2009-07-19T16:37:30','version'=>'0.993' },{'date'=>'2009-07-23T13:08:07','version'=>'0.994' },{'date'=>'2010-04-10T14:05:52','version'=>'1.000' },{'date'=>'2010-07-25T09:32:33','version'=>'1.001' },{'date'=>'2010-07-25T10:07:06','version'=>'1.002' },{'date'=>'2011-11-28T16:53:29','version'=>'1.003' },{'date'=>'2011-11-30T22:31:25','version'=>'1.004' },{'date'=>'2011-12-02T13:53:02','version'=>'1.005' },{'date'=>'2012-10-14T22:45:17','version'=>'1.006' },{'date'=>'2012-10-22T21:50:20','version'=>'1.007' },{'date'=>'2015-01-24T14:11:44','version'=>'1.008' },{'date'=>'2015-04-22T15:26:50','version'=>'1.009' },{'date'=>'2015-07-13T10:56:21','version'=>'1.010' },{'date'=>'2016-09-18T11:33:22','version'=>'1.011' },{'date'=>'2016-11-25T16:06:43','version'=>'1.012' },{'date'=>'2016-11-27T16:51:00','version'=>'1.013' },{'date'=>'2016-12-18T16:36:08','version'=>'1.014' },{'date'=>'2017-04-13T15:29:12','version'=>'1.015' }]},'PAR-Packer'=>{'advisories'=>[{'affected_versions'=>'<1.011','cves'=>['CVE-2011-4114' ],'description'=>'PAR packed files are extracted to unsafe and predictable temporary directories.
  ','distribution'=>'PAR-Packer','fixed_versions'=>'>=1.011','id'=>'CPANSA-PAR-Packer-2011-01','references'=>['https://metacpan.org/changes/distribution/PAR-Packer','https://rt.cpan.org/Public/Bug/Display.html?id=69560' ],'reported'=>'2011-07-18' }],'main_module'=>'PAR::Packer','versions'=>[{'date'=>'2006-12-01T14:20:06','version'=>'0.969_01' },{'date'=>'2006-12-03T17:36:32','version'=>'0.970' },{'date'=>'2007-02-03T12:27:07','version'=>'0.973' },{'date'=>'2007-05-07T18:21:52','version'=>'0.975' },{'date'=>'2007-07-29T11:50:15','version'=>'0.976' },{'date'=>'2007-12-20T21:39:30','version'=>'0.977' },{'date'=>'2008-02-29T18:37:56','version'=>'0.978' },{'date'=>'2008-05-13T15:45:56','version'=>'0.979' },{'date'=>'2008-05-14T10:27:09','version'=>'0.980' },{'date'=>'2008-07-29T15:44:11','version'=>'0.982' },{'date'=>'2009-03-10T15:55:06','version'=>'0.980' },{'date'=>'2009-03-21T11:20:02','version'=>'0.991' },{'date'=>'2009-07-19T16:47:51','version'=>'0.992_01' },{'date'=>'2009-07-23T13:18:32','version'=>'0.992_02' },{'date'=>'2009-07-24T18:30:24','version'=>'0.992_03' },{'date'=>'2009-09-11T07:38:47','version'=>'0.992_04' },{'date'=>'2009-11-13T09:01:15','version'=>'0.992_05' },{'date'=>'2009-11-20T13:59:38','version'=>'0.992_06' },{'date'=>'2009-11-22T13:08:12','version'=>'1.000' },{'date'=>'2009-11-24T11:16:58','version'=>'1.001' },{'date'=>'2009-12-17T20:55:25','version'=>'1.002' },{'date'=>'2010-04-10T17:57:57','version'=>'1.003' },{'date'=>'2010-04-20T12:10:24','version'=>'1.004' },{'date'=>'2010-06-05T15:54:54','version'=>'1.005' },{'date'=>'2010-06-26T11:23:34','version'=>'1.006' },{'date'=>'2010-09-09T16:42:00','version'=>'1.007' },{'date'=>'2010-11-21T17:11:43','version'=>'1.008' },{'date'=>'2011-03-26T13:36:55','version'=>'1.009' },{'date'=>'2011-07-13T14:10:05','version'=>'1.010' },{'date'=>'2011-12-01T21:08:37','version'=>'1.011' },{'date'=>'2011-12-02T17:53:42','version'=>'1.012' },{'date'=>'2012-02-22T09:58:04','version'=>'1.013' },{'date'=>'2012-12-21T15:55:13','version'=>'1.014' },{'date'=>'2013-10-09T12:06:04','version'=>'1.015' },{'date'=>'2013-11-30T19:03:48','version'=>'1.016' },{'date'=>'2013-12-03T23:53:51','version'=>'1.017' },{'date'=>'2014-05-18T16:52:34','version'=>'1.018' },{'date'=>'2014-07-07T14:25:15','version'=>'1.019' },{'date'=>'2014-08-24T13:27:57','version'=>'1.020' },{'date'=>'2014-09-14T13:49:37','version'=>'1.021' },{'date'=>'2014-09-19T10:07:30','version'=>'1.022' },{'date'=>'2014-11-02T14:32:42','version'=>'1.023' },{'date'=>'2014-11-07T09:04:07','version'=>'1.024' },{'date'=>'2015-01-24T16:52:17','version'=>'1.025' },{'date'=>'2015-07-19T13:14:40','version'=>'1.026' },{'date'=>'2015-11-18T16:58:33','version'=>'1.027' },{'date'=>'2015-11-19T09:05:09','version'=>'1.027' },{'date'=>'2016-01-12T16:24:46','version'=>'1.029' },{'date'=>'2016-02-02T14:54:21','version'=>'1.029_01' },{'date'=>'2016-02-11T14:08:57','version'=>'1.029_02' },{'date'=>'2016-02-25T08:41:55','version'=>'1.029_03' },{'date'=>'2016-02-29T08:36:46','version'=>'1.029_04' },{'date'=>'2016-03-29T08:29:59','version'=>'1.030' },{'date'=>'2016-04-10T17:15:52','version'=>'1.031' },{'date'=>'2016-04-29T17:01:57','version'=>'1.031_01' },{'date'=>'2016-05-07T09:59:28','version'=>'1.032' },{'date'=>'2016-05-19T09:50:49','version'=>'1.033' },{'date'=>'2016-07-17T12:38:31','version'=>'1.034' },{'date'=>'2016-07-23T12:04:14','version'=>'1.035' },{'date'=>'2016-12-04T17:13:20','version'=>'1.035_001' },{'date'=>'2016-12-19T19:35:16','version'=>'1.035_002' },{'date'=>'2016-12-30T11:06:25','version'=>'1.036' },{'date'=>'2017-03-22T19:29:19','version'=>'1.036_001' },{'date'=>'2017-05-14T11:54:43','version'=>'1.036_002' },{'date'=>'2017-05-28T11:33:53','version'=>'1.037' },{'date'=>'2017-09-27T19:40:44','version'=>'1.038' },{'date'=>'2017-09-28T05:13:05','version'=>'1.039' },{'date'=>'2017-10-10T17:00:14','version'=>'1.039_001' },{'date'=>'2017-10-13T12:05:52','version'=>'1.039_002' },{'date'=>'2017-10-16T20:46:49','version'=>'1.039_003' },{'date'=>'2017-10-17T17:07:49','version'=>'1.039_004' },{'date'=>'2017-10-21T16:09:18','version'=>'1.040' },{'date'=>'2017-11-08T17:07:11','version'=>'1.041' },{'date'=>'2018-04-02T21:46:01','version'=>'1.042' },{'date'=>'2018-04-03T11:26:08','version'=>'1.043' },{'date'=>'2018-06-06T22:03:32','version'=>'1.044' },{'date'=>'2018-06-12T19:04:22','version'=>'1.045' },{'date'=>'2018-08-17T22:20:28','version'=>'1.046' },{'date'=>'2018-08-19T09:17:57','version'=>'1.047' },{'date'=>'2019-03-04T09:42:35','version'=>'1.047_001' },{'date'=>'2019-03-04T15:33:14','version'=>'1.047_002' },{'date'=>'2019-03-06T17:39:18','version'=>'1.047_003' }]},'PathTools'=>{'advisories'=>[{'affected_versions'=>'<3.65','cves'=>['CVE-2016-1238' ],'description'=>'Does not properly remove . (period) characters from the end of the includes directory array, which might allow local users to gain privileges via a Trojan horse module under the current working directory.
  ','distribution'=>'PathTools','fixed_versions'=>'>=3.65','id'=>'CPANSA-PathTools-2016-02','references'=>['https://metacpan.org/changes/distribution/PathTools' ],'reported'=>'2016-02-08' },{'affected_versions'=>'<3.62','cves'=>['CVE-2015-8607' ],'description'=>'Does not properly preserve the taint attribute of data, which might allow context-dependent attackers to bypass the taint protection mechanism via a crafted string.
  ','distribution'=>'PathTools','fixed_versions'=>'>=3.62','id'=>'CPANSA-PathTools-2016-01','references'=>['https://metacpan.org/changes/distribution/PathTools' ],'reported'=>'2016-01-11' }],'main_module'=>'Cwd','versions'=>[{'date'=>'2004-09-03T03:40:00','version'=>'3.00' },{'date'=>'2004-09-07T03:39:26','version'=>'3.01' },{'date'=>'2004-11-19T04:26:35','version'=>'3.01_01' },{'date'=>'2004-11-29T04:20:10','version'=>'3.01_02' },{'date'=>'2004-11-30T02:34:46','version'=>'3.01_03' },{'date'=>'2005-01-10T01:33:05','version'=>'3.02' },{'date'=>'2005-01-22T03:59:59','version'=>'3.03' },{'date'=>'2005-02-07T00:28:43','version'=>'3.04' },{'date'=>'2005-02-28T13:27:37','version'=>'3.05' },{'date'=>'2005-04-14T02:06:10','version'=>'3.06' },{'date'=>'2005-05-06T12:50:38','version'=>'3.07' },{'date'=>'2005-05-28T15:13:27','version'=>'3.08' },{'date'=>'2005-06-15T23:45:19','version'=>'3.09' },{'date'=>'2005-08-26T03:29:11','version'=>'3.10' },{'date'=>'2005-08-28T01:16:38','version'=>'3.11' },{'date'=>'2005-10-04T03:14:00','version'=>'3.12' },{'date'=>'2005-11-16T05:58:53','version'=>'3.13' },{'date'=>'2005-11-18T00:15:37','version'=>'3.14' },{'date'=>'2005-12-10T04:51:57','version'=>'3.14_01' },{'date'=>'2005-12-14T05:11:27','version'=>'3.14_02' },{'date'=>'2005-12-27T20:32:26','version'=>'3.15' },{'date'=>'2006-01-31T02:52:07','version'=>'3.16' },{'date'=>'2006-03-03T22:55:18','version'=>'3.17' },{'date'=>'2006-04-28T03:04:00','version'=>'3.18' },{'date'=>'2006-07-12T03:43:15','version'=>'3.19' },{'date'=>'2006-10-05T02:18:51','version'=>'3.21' },{'date'=>'2006-10-10T02:53:23','version'=>'3.22' },{'date'=>'2006-10-11T17:13:59','version'=>'3.23' },{'date'=>'2006-11-20T04:53:56','version'=>'3.24' },{'date'=>'2007-05-22T02:08:53','version'=>'3.25' },{'date'=>'2007-10-14T02:15:40','version'=>'3.25_01' },{'date'=>'2007-12-25T02:34:28','version'=>'3.2501' },{'date'=>'2008-01-14T12:02:28','version'=>'3.26' },{'date'=>'2008-01-15T23:27:33','version'=>'3.26_01' },{'date'=>'2008-01-17T02:21:47','version'=>'3.27' },{'date'=>'2008-02-12T03:46:01','version'=>'3.2701' },{'date'=>'2008-07-26T02:19:45','version'=>'3.28_01' },{'date'=>'2008-10-27T19:27:37','version'=>'3.28_02' },{'date'=>'2008-10-27T21:16:35','version'=>'3.28_03' },{'date'=>'2008-10-29T20:11:52','version'=>'3.29' },{'date'=>'2009-05-07T18:27:46','version'=>'3.29_01' },{'date'=>'2009-05-10T08:59:46','version'=>'3.30' },{'date'=>'2009-09-21T12:46:15','version'=>'3.30_01' },{'date'=>'2009-09-29T06:22:30','version'=>'3.30_02' },{'date'=>'2009-11-01T14:22:36','version'=>'3.31' },{'date'=>'2010-07-23T08:10:31','version'=>'3.31_02' },{'date'=>'2010-09-17T13:24:05','version'=>'3.31_03' },{'date'=>'2010-09-19T15:53:14','version'=>'3.32' },{'date'=>'2010-09-20T07:54:00','version'=>'3.33' },{'date'=>'2011-12-20T07:42:29','version'=>'3.39_01' },{'date'=>'2013-01-16T06:35:08','version'=>'3.40' },{'date'=>'2014-05-01T18:34:31','version'=>'3.46_01' },{'date'=>'2014-05-23T17:00:38','version'=>'3.47' },{'date'=>'2015-07-11T22:18:08','version'=>'3.56_01' },{'date'=>'2015-07-16T15:33:27','version'=>'3.56_02' },{'date'=>'2015-11-09T22:09:25','version'=>'3.58_01' },{'date'=>'2015-11-13T23:46:00','version'=>'3.59' },{'date'=>'2015-11-19T02:32:50','version'=>'3.60' },{'date'=>'2016-01-11T13:49:31','version'=>'3.62' },{'date'=>'2018-02-18T20:27:27','version'=>'3.73' },{'date'=>'2018-02-19T08:41:14','version'=>'3.74' },{'date'=>'2018-08-29T19:53:19','version'=>'3.75' }]},'Perl-Version'=>{'advisories'=>[{'affected_versions'=>'<1.013','description'=>'Insecure dependency File::Slurp is used.
  ','distribution'=>'Perl-Version','fixed_versions'=>'>=1.013','id'=>'CPANSA-Perl-Version-2014-01','references'=>['https://metacpan.org/changes/distribution/Perl-Version','https://rt.cpan.org/Public/Bug/Display.html?id=92974' ],'reported'=>'2014-02-12' }],'main_module'=>'Perl::Version','versions'=>[{'date'=>'2007-02-07T19:41:42','version'=>'v0.0.1' },{'date'=>'2007-02-23T18:03:11','version'=>'v0.0.3' },{'date'=>'2007-02-24T18:03:42','version'=>'v0.0.4' },{'date'=>'2007-02-25T12:41:13','version'=>'v0.0.5' },{'date'=>'2007-02-27T12:46:07','version'=>'v0.0.6' },{'date'=>'2007-02-28T01:27:59','version'=>'v0.0.7' },{'date'=>'2007-06-20T16:09:31','version'=>'0.0.8' },{'date'=>'2007-09-03T14:28:35','version'=>'v1.000' },{'date'=>'2007-09-07T15:42:58','version'=>'v1.001' },{'date'=>'2007-09-07T15:58:18','version'=>'v1.002' },{'date'=>'2007-11-08T12:14:27','version'=>'1.003' },{'date'=>'2007-11-08T12:24:59','version'=>'1.004' },{'date'=>'2008-04-03T14:56:16','version'=>'1.005' },{'date'=>'2008-04-07T19:14:56','version'=>'1.006' },{'date'=>'2008-04-07T19:27:24','version'=>'1.007' },{'date'=>'2009-03-07T16:40:03','version'=>'1.008' },{'date'=>'2009-03-09T16:22:08','version'=>'1.009' },{'date'=>'2010-09-19T15:37:48','version'=>'1.010' },{'date'=>'2011-02-21T21:32:17','version'=>'1.011' },{'date'=>'2014-02-12T20:58:43','version'=>'1.013' },{'date'=>'2014-02-14T16:08:42','version'=>'1.013_01' },{'date'=>'2014-02-18T16:42:57','version'=>'1.013_02' },{'date'=>'2015-11-21T06:05:48','version'=>'1.013_03' }]},'Plack-Middleware-Session'=>{'advisories'=>[{'affected_versions'=>'<=0.21','description'=>'Plack::Middleware::Session::Cookie 0.21 has a security vulnerability where it allows an attacker to execute arbitrary code on the server, when the middleware is enabled without a secret.
  ','distribution'=>'Plack-Middleware-Session','fixed_versions'=>'>0.21','id'=>'CPANSA-Plack-Middleware-Session-2014-01','references'=>['https://gist.github.com/miyagawa/2b8764af908a0dacd43d','https://metacpan.org/changes/distribution/Plack-Middleware-Session' ],'reported'=>'2014-08-11','severity'=>'critical' }],'main_module'=>'Plack::Middleware::Session','versions'=>[{'date'=>'2009-12-15T18:59:13','version'=>'0.01' },{'date'=>'2009-12-19T19:27:38','version'=>'0.02' },{'date'=>'2010-01-07T22:12:43','version'=>'0.03' },{'date'=>'2010-01-30T21:46:53','version'=>'0.09_01' },{'date'=>'2010-01-31T07:17:07','version'=>'0.09_02' },{'date'=>'2010-02-03T04:46:20','version'=>'0.09_03' },{'date'=>'2010-02-23T03:16:31','version'=>'0.10' },{'date'=>'2010-02-27T10:47:17','version'=>'0.11' },{'date'=>'2010-07-07T22:55:18','version'=>'0.12' },{'date'=>'2010-12-22T17:00:14','version'=>'0.13' },{'date'=>'2011-03-29T20:50:06','version'=>'0.14' },{'date'=>'2012-09-04T21:16:35','version'=>'0.15' },{'date'=>'2013-02-10T19:43:11','version'=>'0.16' },{'date'=>'2013-02-11T23:45:49','version'=>'0.17' },{'date'=>'2013-02-12T10:57:14','version'=>'0.17' },{'date'=>'2013-06-24T23:09:39','version'=>'0.20' },{'date'=>'2013-10-12T18:42:26','version'=>'0.21' },{'date'=>'2014-08-11T17:18:03','version'=>'0.22' },{'date'=>'2014-08-11T17:23:40','version'=>'0.23' },{'date'=>'2014-09-05T11:48:57','version'=>'0.24' },{'date'=>'2014-09-29T03:07:54','version'=>'0.25' },{'date'=>'2015-02-03T08:17:55','version'=>'0.26' },{'date'=>'2015-02-14T00:52:35','version'=>'0.27' },{'date'=>'2015-02-16T16:30:31','version'=>'0.28' },{'date'=>'2015-02-17T23:57:32','version'=>'0.29' },{'date'=>'2015-03-02T18:25:56','version'=>'0.30' },{'date'=>'2019-02-26T19:01:59','version'=>'0.31' },{'date'=>'2019-02-26T21:36:43','version'=>'0.32' }]},'RT-Authen-ExternalAuth'=>{'advisories'=>[{'affected_versions'=>'<0.27','cves'=>['CVE-2017-5361' ],'description'=>'Timing sidechannel vulnerability in password checking.
  ','distribution'=>'RT-Authen-ExternalAuth','fixed_versions'=>'>=0.27','id'=>'CPANSA-RT-Authen-ExternalAuth-2017-01','references'=>['https://metacpan.org/changes/distribution/RT-Authen-ExternalAuth' ],'reported'=>'2017-06-15' }],'main_module'=>'RT::Authen::ExternalAuth','versions'=>[{'date'=>'2008-03-13T16:16:36','version'=>'0.01' },{'date'=>'2008-03-17T13:34:40','version'=>'0.02' },{'date'=>'2008-03-31T14:55:18','version'=>'0.03' },{'date'=>'2008-04-03T14:20:36','version'=>'0.04' },{'date'=>'2008-04-09T08:57:51','version'=>'0.05' },{'date'=>'2008-10-17T13:22:11','version'=>'0.06_01' },{'date'=>'2008-10-17T16:41:34','version'=>'0.06_02' },{'date'=>'2008-10-31T12:08:54','version'=>'0.06_02' },{'date'=>'2008-11-01T18:23:27','version'=>'0.06_02' },{'date'=>'2008-11-06T21:16:42','version'=>'0.06_02' },{'date'=>'2008-12-22T22:08:06','version'=>'0.07_02' },{'date'=>'2009-01-20T21:09:48','version'=>'0.07_02' },{'date'=>'2009-01-24T13:52:42','version'=>'0.07_02' },{'date'=>'2011-02-19T00:43:35','version'=>'0.08_01' },{'date'=>'2011-04-15T19:46:43','version'=>'0.08_02' },{'date'=>'2011-05-06T21:08:52','version'=>'0.09' },{'date'=>'2012-01-23T17:51:41','version'=>'0.09_01' },{'date'=>'2012-01-26T18:48:51','version'=>'0.09_02' },{'date'=>'2012-01-27T23:07:12','version'=>'0.09_03' },{'date'=>'2012-02-17T16:34:10','version'=>'0.10' },{'date'=>'2012-02-23T16:31:54','version'=>'0.10_01' },{'date'=>'2012-07-25T08:57:21','version'=>'0.11' },{'date'=>'2012-07-25T18:36:36','version'=>'0.11' },{'date'=>'2012-10-26T19:59:54','version'=>'0.12' },{'date'=>'2013-01-31T19:22:43','version'=>'0.13' },{'date'=>'2013-05-22T21:28:15','version'=>'0.14' },{'date'=>'2013-05-23T00:20:43','version'=>'0.15' },{'date'=>'2013-06-27T19:24:37','version'=>'0.16' },{'date'=>'2013-07-10T19:43:08','version'=>'0.17' },{'date'=>'2014-03-07T22:19:49','version'=>'0.18' },{'date'=>'2014-04-04T17:21:04','version'=>'0.19' },{'date'=>'2014-04-09T19:34:29','version'=>'0.20' },{'date'=>'2014-07-02T02:20:30','version'=>'0.21' },{'date'=>'2014-08-14T04:04:28','version'=>'0.22_01' },{'date'=>'2014-08-14T17:28:53','version'=>'0.23' },{'date'=>'2014-09-30T22:04:16','version'=>'0.23_01' },{'date'=>'2014-10-09T16:24:49','version'=>'0.24' },{'date'=>'2014-10-16T20:59:29','version'=>'0.25' },{'date'=>'2016-08-02T16:14:34','version'=>'0.26' },{'date'=>'2017-06-15T18:44:24','version'=>'0.27' }]},'RT-Extension-MobileUI'=>{'advisories'=>[{'affected_versions'=>'<1.02','cves'=>['CVE-2012-2769' ],'description'=>'Multiple cross-site scripting (XSS) vulnerabilities in the topic administration page.
  ','distribution'=>'RT-Extension-MobileUI','fixed_versions'=>'>=1.02','id'=>'CPANSA-RT-Extension-MobileUI-2012-01','references'=>['https://metacpan.org/changes/distribution/RT-Extension-MobileUI' ],'reported'=>'2012-05-18' }],'main_module'=>'RT::Extension::MobileUI','versions'=>[{'date'=>'2010-08-05T20:58:09','version'=>'0.9' },{'date'=>'2010-08-06T15:38:53','version'=>'0.91' },{'date'=>'2010-08-06T15:58:11','version'=>'0.92' },{'date'=>'2010-08-06T17:55:08','version'=>'0.93' },{'date'=>'2010-08-09T13:36:43','version'=>'0.94' },{'date'=>'2010-08-09T13:44:33','version'=>'0.95' },{'date'=>'2010-08-26T21:28:07','version'=>'0.96' },{'date'=>'2010-09-06T18:11:56','version'=>'0.96' },{'date'=>'2010-10-28T15:50:29','version'=>'0.98' },{'date'=>'2010-10-29T14:08:08','version'=>'0.99' },{'date'=>'2010-11-19T18:11:43','version'=>'1.00' },{'date'=>'2010-12-08T16:36:01','version'=>'1.01' },{'date'=>'2012-07-25T08:57:33','version'=>'1.02' },{'date'=>'2012-07-25T18:36:52','version'=>'1.02' },{'date'=>'2012-08-27T16:42:55','version'=>'1.03' },{'date'=>'2013-06-12T19:09:14','version'=>'1.04' },{'date'=>'2013-08-13T18:06:54','version'=>'1.05' },{'date'=>'2014-04-23T20:25:25','version'=>'1.06' },{'date'=>'2014-04-23T20:26:56','version'=>'1.07' }]},'RTMP-Client'=>{'advisories'=>[{'affected_versions'=>'<0.04','description'=>'TBD
  ','distribution'=>'RTMP-Client','fixed_versions'=>'>=0.04','id'=>'CPANSA-RTMP-Client-2011-01','references'=>['https://metacpan.org/changes/distribution/RTMP-Client' ],'reported'=>'2011-12-01' }],'main_module'=>'RTMP::Client','versions'=>[{'date'=>'2011-07-26T08:17:20','version'=>'0.01' },{'date'=>'2011-07-27T02:09:05','version'=>'0.02' },{'date'=>'2011-07-27T02:17:06','version'=>'0.03' },{'date'=>'2011-12-01T08:59:19','version'=>'0.04' }]},'SOAP-Lite'=>{'advisories'=>[{'affected_versions'=>'<1.15','cves'=>['CVE-2015-8978' ],'description'=>'An example attack consists of defining 10 or more XML entities, each defined as consisting of 10 of the previous entity, with the document consisting of a single instance of the largest entity, which expands to one billion copies of the first entity. The amount of computer memory used for handling an external SOAP call would likely exceed that available to the process parsing the XML.
  ','distribution'=>'SOAP-Lite','fixed_versions'=>'>=1.15','id'=>'CPANSA-SOAP-Lite-2015-01','references'=>['https://metacpan.org/changes/distribution/SOAP-Lite','https://www.securityfocus.com/bid/94487','https://github.com/redhotpenguin/perl-soaplite/commit/6942fe0d281be1c32c5117605f9c4e8d44f51124' ],'reported'=>'2015-07-21' },{'affected_versions'=>'<0.55','cves'=>['CVE-2002-1742' ],'description'=>'Allows remote attackers to load arbitrary Perl functions by suppling a non-existent function in a script using a SOAP::Lite module, which causes the AUTOLOAD subroutine to trigger.
  ','distribution'=>'SOAP-Lite','fixed_versions'=>'>=0.55','id'=>'CPANSA-SOAP-Lite-2002-01','references'=>['https://metacpan.org/changes/distribution/SOAP-Lite' ],'reported'=>'2002-04-08','severity'=>'high' },{'affected_versions'=>'<0.38','description'=>'Security problem on server side (no more details).
  ','distribution'=>'SOAP-Lite','fixed_versions'=>'>=0.38','id'=>'CPANSA-SOAP-Lite-2000-01','references'=>['https://metacpan.org/changes/distribution/SOAP-Lite' ],'reported'=>'2000-10-05' }],'main_module'=>'SOAP::Lite','versions'=>[{'date'=>'2000-09-25T01:49:14','version'=>'0.36' },{'date'=>'2000-10-06T01:58:32','version'=>'0.38' },{'date'=>'2000-10-09T04:27:51','version'=>'0.39' },{'date'=>'2000-10-16T05:12:09','version'=>'0.40' },{'date'=>'2000-10-31T15:10:52','version'=>'0.41' },{'date'=>'2000-11-15T15:00:57','version'=>'0.42' },{'date'=>'2000-11-28T20:43:40','version'=>'0.43' },{'date'=>'2000-12-13T07:37:47','version'=>'0.44' },{'date'=>'2001-01-17T17:28:31','version'=>'0.45' },{'date'=>'2001-02-01T02:23:51','version'=>'0.46' },{'date'=>'2001-02-22T07:28:20','version'=>'0.47' },{'date'=>'2001-04-18T19:09:15','version'=>'0.50' },{'date'=>'2001-07-18T22:39:30','version'=>'0.51' },{'date'=>'2001-11-21T19:35:24','version'=>'0.52' },{'date'=>'2002-04-16T05:20:54','version'=>'0.55' },{'date'=>'2003-10-28T19:27:00','version'=>'0.60' },{'date'=>'2004-02-26T16:36:26','version'=>'0.60' },{'date'=>'2005-02-22T01:57:43','version'=>'0.65_3' },{'date'=>'2005-04-03T09:20:17','version'=>'0.65_4' },{'date'=>'2005-05-06T17:24:23','version'=>'0.65_5' },{'date'=>'2005-06-03T19:23:20','version'=>'0.65_6' },{'date'=>'2005-12-25T08:42:50','version'=>'0.66' },{'date'=>'2006-01-04T23:14:27','version'=>'0.66.1' },{'date'=>'2006-01-27T21:43:49','version'=>'0.67' },{'date'=>'2006-07-06T18:18:56','version'=>'0.68' },{'date'=>'2006-08-16T14:53:50','version'=>'0.69' },{'date'=>'2007-10-18T20:54:02','version'=>'0.70_01' },{'date'=>'2007-11-08T21:30:41','version'=>'0.70_02' },{'date'=>'2007-11-18T19:00:11','version'=>'0.70_03' },{'date'=>'2008-01-02T17:06:17','version'=>'0.70_04' },{'date'=>'2008-02-13T12:28:07','version'=>'0.70_05' },{'date'=>'2008-02-16T10:37:04','version'=>'0.70_06' },{'date'=>'2008-02-25T21:44:41','version'=>'0.70_07' },{'date'=>'2008-02-25T21:50:22','version'=>'0.70_08' },{'date'=>'2008-02-28T21:58:13','version'=>'0.71' },{'date'=>'2008-03-29T14:13:41','version'=>'0.71.01' },{'date'=>'2008-04-14T17:25:25','version'=>'0.71.02' },{'date'=>'2008-04-17T20:40:23','version'=>'v0.71.03' },{'date'=>'2008-04-22T06:03:55','version'=>'0.71.04' },{'date'=>'2008-05-05T21:50:36','version'=>'0.710.05' },{'date'=>'2008-06-05T18:47:08','version'=>'0.710.06' },{'date'=>'2008-06-13T20:27:05','version'=>'0.710.07' },{'date'=>'2008-07-13T20:41:11','version'=>'0.710.08' },{'date'=>'2009-09-29T21:20:02','version'=>'0.710.09' },{'date'=>'2009-09-30T18:40:30','version'=>'0.710.10' },{'date'=>'2010-03-18T20:24:42','version'=>'0.711' },{'date'=>'2010-06-03T15:41:39','version'=>'0.712' },{'date'=>'2011-08-16T17:53:28','version'=>'0.713' },{'date'=>'2011-08-18T19:51:02','version'=>'0.714' },{'date'=>'2012-07-15T09:37:20','version'=>'0.715' },{'date'=>'2013-05-11T06:44:04','version'=>'0.716' },{'date'=>'2013-07-17T06:17:00','version'=>'1.0' },{'date'=>'2013-07-29T08:26:07','version'=>'1.01' },{'date'=>'2013-07-30T02:20:34','version'=>'1.02' },{'date'=>'2013-08-04T17:49:18','version'=>'1.03' },{'date'=>'2013-08-10T03:46:49','version'=>'1.04' },{'date'=>'2013-08-19T05:31:17','version'=>'1.05' },{'date'=>'2013-08-22T04:20:29','version'=>'1.06' },{'date'=>'2013-11-08T03:09:10','version'=>'1.07' },{'date'=>'2013-11-08T17:41:10','version'=>'1.08' },{'date'=>'2014-01-14T21:41:07','version'=>'1.09' },{'date'=>'2014-01-23T18:53:42','version'=>'1.10' },{'date'=>'2014-02-22T05:18:14','version'=>'1.11' },{'date'=>'2014-11-27T07:08:11','version'=>'1.12' },{'date'=>'2014-12-30T15:58:06','version'=>'1.13' },{'date'=>'2015-03-25T05:04:34','version'=>'1.14' },{'date'=>'2015-07-21T18:12:21','version'=>'1.15' },{'date'=>'2015-07-23T07:34:59','version'=>'1.16' },{'date'=>'2015-07-31T05:59:50','version'=>'1.17' },{'date'=>'2015-08-26T04:31:24','version'=>'1.18' },{'date'=>'2015-08-26T15:38:01','version'=>'1.19' },{'date'=>'2016-06-09T21:34:36','version'=>'1.20' },{'date'=>'2017-08-16T05:18:24','version'=>'1.22' },{'date'=>'2017-12-19T02:30:48','version'=>'1.23' },{'date'=>'2017-12-19T18:36:52','version'=>'1.24' },{'date'=>'2017-12-29T18:39:43','version'=>'1.25' },{'date'=>'2017-12-30T22:19:12','version'=>'1.26' },{'date'=>'2018-05-14T20:36:08','version'=>'1.27' }]},'SVG-Sparkline'=>{'advisories'=>[{'affected_versions'=>'<1.12','description'=>'Invalid data input validation makes it possible to pass arbitrary strings to module loading eval.
  ','distribution'=>'SVG-Sparkline','fixed_versions'=>'>=1.12','id'=>'CPANSA-SVG-Sparkline-2017-01','references'=>['https://metacpan.org/changes/distribution/SVG-Sparkline','https://github.com/gwadej/svg-sparkline/commit/ca83d6eb56aa86f3ca735866ffa9aa97acc2e708' ],'reported'=>'2017-05-15' }],'main_module'=>'SVG::Sparkline','versions'=>[{'date'=>'2009-04-02T02:42:59','version'=>'0.1.0' },{'date'=>'2009-04-03T01:30:19','version'=>'0.1.1' },{'date'=>'2009-04-05T21:43:08','version'=>'0.2.0' },{'date'=>'2009-04-18T04:46:33','version'=>'0.2.5' },{'date'=>'2009-04-21T00:31:44','version'=>'0.2.6' },{'date'=>'2009-04-27T03:42:24','version'=>'0.2.7' },{'date'=>'2009-05-06T23:20:05','version'=>'0.3' },{'date'=>'2009-05-07T22:11:10','version'=>'0.31' },{'date'=>'2009-10-19T04:12:52','version'=>'0.32' },{'date'=>'2009-10-21T00:27:30','version'=>'0.33' },{'date'=>'2010-05-01T04:50:06','version'=>'0.34' },{'date'=>'2010-10-30T22:01:18','version'=>'0.35' },{'date'=>'2012-09-04T00:09:32','version'=>'0.36' },{'date'=>'2013-10-24T14:01:00','version'=>'1' },{'date'=>'2014-09-04T02:01:54','version'=>'1.1' },{'date'=>'2015-03-03T19:38:44','version'=>'1.11' },{'date'=>'2017-05-15T01:32:51','version'=>'1.12' }]},'SVN-Look'=>{'advisories'=>[{'affected_versions'=>'<0.40','description'=>'Two-arg open with a possibility of running arbitrary commands.
  ','distribution'=>'SVN-Look','fixed_versions'=>'>=0.40','id'=>'CPANSA-SVN-Look-2014-01','references'=>['https://metacpan.org/changes/distribution/SVN-Look','https://github.com/gnustavo/SVN-Look/commit/b413ac1c397dfc6b2d164fede693f7ff9a94c83c' ],'reported'=>'2014-05-31' }],'main_module'=>'SVN::Look','versions'=>[{'date'=>'2008-09-26T03:22:44','version'=>'0.08.360' },{'date'=>'2008-09-27T22:10:54','version'=>'0.09.366' },{'date'=>'2008-09-28T03:07:02','version'=>'0.10.369' },{'date'=>'2008-10-05T03:16:35','version'=>'0.11.388' },{'date'=>'2008-10-10T02:25:16','version'=>'0.12.409' },{'date'=>'2008-10-24T00:51:56','version'=>'0.12.442' },{'date'=>'2008-11-03T10:43:38','version'=>'0.12.455' },{'date'=>'2008-11-06T03:11:52','version'=>'0.13.463' },{'date'=>'2009-02-28T02:50:53','version'=>'0.14.5' },{'date'=>'2009-03-01T12:17:06','version'=>'0.14.7' },{'date'=>'2009-03-06T01:52:43','version'=>'0.14.9' },{'date'=>'2009-03-08T02:25:41','version'=>'0.14.10' },{'date'=>'2009-03-20T01:24:06','version'=>'0.14.12' },{'date'=>'2009-10-25T01:23:51','version'=>'0.15' },{'date'=>'2010-02-16T20:16:51','version'=>'0.16' },{'date'=>'2010-02-24T23:20:51','version'=>'0.17' },{'date'=>'2010-04-28T11:38:27','version'=>'0.18' },{'date'=>'2010-12-12T10:35:04','version'=>'0.19' },{'date'=>'2010-12-12T19:59:46','version'=>'0.20' },{'date'=>'2011-07-20T20:11:31','version'=>'0.21' },{'date'=>'2011-07-22T22:31:55','version'=>'0.22' },{'date'=>'2011-07-27T20:22:58','version'=>'0.23' },{'date'=>'2011-07-30T21:52:08','version'=>'0.24' },{'date'=>'2011-08-21T23:31:44','version'=>'0.25' },{'date'=>'2011-08-27T20:12:39','version'=>'0.26' },{'date'=>'2011-09-18T02:42:31','version'=>'0.27' },{'date'=>'2011-10-10T23:18:59','version'=>'0.28' },{'date'=>'2011-10-13T01:06:12','version'=>'0.29' },{'date'=>'2011-11-02T21:00:23','version'=>'0.30' },{'date'=>'2012-02-26T00:04:15','version'=>'0.31' },{'date'=>'2012-02-26T21:55:01','version'=>'0.32' },{'date'=>'2012-02-27T23:49:07','version'=>'0.33' },{'date'=>'2012-03-05T14:37:05','version'=>'0.34' },{'date'=>'2012-04-22T00:14:50','version'=>'0.35' },{'date'=>'2012-06-18T17:07:07','version'=>'0.36' },{'date'=>'2012-06-18T17:34:58','version'=>'0.37' },{'date'=>'2012-06-19T17:00:40','version'=>'0.38' },{'date'=>'2013-10-20T23:32:26','version'=>'0.39' },{'date'=>'2014-06-12T18:05:32','version'=>'0.40' },{'date'=>'2014-06-14T02:51:53','version'=>'0.41' }]},'Search-OpenSearch-Server'=>{'advisories'=>[{'affected_versions'=>'<0.17','description'=>'Arbitrary Perl methods could be called via HTTP like RPC.
  ','distribution'=>'Search-OpenSearch-Server','fixed_versions'=>'>=0.17','id'=>'CPANSA-Search-OpenSearch-Server-2012-01','references'=>['https://metacpan.org/changes/distribution/Search-OpenSearch-Server','https://github.com/karpet/search-opensearch-server/commit/69d53fde9d70fe12e1f592de482601c43c45a278' ],'reported'=>'2012-08-31' }],'main_module'=>'Search::OpenSearch::Server','versions'=>[{'date'=>'2010-05-28T03:07:46','version'=>'0.01' },{'date'=>'2010-05-29T01:11:09','version'=>'0.02' },{'date'=>'2010-06-23T01:22:53','version'=>'0.03' },{'date'=>'2010-06-26T21:08:31','version'=>'0.04' },{'date'=>'2011-01-08T04:05:22','version'=>'0.05' },{'date'=>'2011-09-26T18:12:08','version'=>'0.06' },{'date'=>'2011-09-26T18:16:12','version'=>'0.07' },{'date'=>'2011-09-30T03:15:51','version'=>'0.08' },{'date'=>'2011-10-23T01:42:30','version'=>'0.09' },{'date'=>'2012-05-01T02:22:52','version'=>'0.10' },{'date'=>'2012-07-15T03:32:57','version'=>'0.11' },{'date'=>'2012-07-27T02:42:45','version'=>'0.12' },{'date'=>'2012-08-07T01:48:25','version'=>'0.13' },{'date'=>'2012-08-10T03:10:13','version'=>'0.14' },{'date'=>'2012-08-21T02:34:37','version'=>'0.15' },{'date'=>'2012-08-21T17:47:00','version'=>'0.16' },{'date'=>'2012-09-04T01:54:00','version'=>'0.17' },{'date'=>'2012-09-12T03:42:03','version'=>'0.18' },{'date'=>'2012-09-13T14:06:58','version'=>'0.19' },{'date'=>'2012-09-20T02:21:37','version'=>'0.20' },{'date'=>'2012-10-15T04:32:38','version'=>'0.21' },{'date'=>'2012-11-08T03:20:16','version'=>'0.22' },{'date'=>'2012-11-21T19:01:22','version'=>'0.23' },{'date'=>'2012-11-26T19:37:12','version'=>'0.24' },{'date'=>'2012-12-18T19:11:36','version'=>'0.25' },{'date'=>'2013-01-04T19:08:19','version'=>'0.26' },{'date'=>'2013-06-14T02:28:09','version'=>'0.27' },{'date'=>'2014-03-02T22:22:17','version'=>'0.28' },{'date'=>'2014-04-23T18:20:52','version'=>'0.299_01' },{'date'=>'2014-04-24T02:56:24','version'=>'0.299_02' },{'date'=>'2014-06-05T07:29:19','version'=>'0.299_03' },{'date'=>'2014-06-08T04:57:40','version'=>'0.300' },{'date'=>'2015-08-14T20:04:12','version'=>'0.301' }]},'Storable'=>{'advisories'=>[{'affected_versions'=>'<3.05','description'=>'Malcrafted storable files or buffers.
  ','distribution'=>'Storable','fixed_versions'=>'>=3.05','id'=>'CPANSA-Storable-2017-01','references'=>['https://metacpan.org/changes/distribution/Storable','https://cxsecurity.com/issue/WLB-2007120031' ],'reported'=>'2017-01-29' }],'main_module'=>'Storable','versions'=>[{'date'=>'1995-10-02T10:50:02','version'=>'0.1' },{'date'=>'1997-01-13T11:42:25','version'=>'0.2' },{'date'=>'1997-01-13T17:18:01','version'=>'0.2' },{'date'=>'1997-01-14T15:12:36','version'=>'0.3' },{'date'=>'1997-01-15T18:25:57','version'=>'0.4' },{'date'=>'1997-01-22T14:47:23','version'=>'0.4' },{'date'=>'1997-02-27T15:02:37','version'=>'0.4' },{'date'=>'1997-02-27T15:38:18','version'=>'0.4' },{'date'=>'1997-03-25T10:32:00','version'=>'0.4' },{'date'=>'1997-05-16T09:24:59','version'=>'0.4' },{'date'=>'1997-06-03T09:38:38','version'=>'0.4' },{'date'=>'1997-06-10T16:47:47','version'=>'0.5' },{'date'=>'1997-11-05T10:05:11','version'=>'0.5' },{'date'=>'1998-01-13T16:59:38','version'=>'0.5' },{'date'=>'1998-01-20T08:32:03','version'=>'0.5' },{'date'=>'1998-03-06T20:52:28','version'=>'0.5' },{'date'=>'1998-03-25T14:10:24','version'=>'0.5' },{'date'=>'1998-04-08T11:20:48','version'=>'0.5' },{'date'=>'1998-04-09T16:17:05','version'=>'0.5' },{'date'=>'1998-04-24T15:29:23','version'=>'0.5' },{'date'=>'1998-04-30T13:13:58','version'=>'0.5' },{'date'=>'1998-05-12T07:15:48','version'=>'0.5' },{'date'=>'1998-06-04T16:19:02','version'=>'0.6' },{'date'=>'1998-06-12T09:54:35','version'=>'0.6' },{'date'=>'1998-06-22T09:00:32','version'=>'0.6' },{'date'=>'1998-07-03T13:53:55','version'=>'0.6' },{'date'=>'1998-07-21T12:10:39','version'=>'0.6' },{'date'=>'1999-01-31T18:01:47','version'=>'0.6' },{'date'=>'1999-07-12T13:05:25','version'=>'0.6' },{'date'=>'1999-09-02T12:47:03','version'=>'0.6' },{'date'=>'1999-09-14T20:27:23','version'=>'v0.6.5' },{'date'=>'1999-10-19T19:33:43','version'=>'v0.6.6' },{'date'=>'1999-10-20T17:10:19','version'=>'v0.6.7' },{'date'=>'2000-03-02T22:29:53','version'=>'v0.6.9' },{'date'=>'2000-03-29T18:00:09','version'=>'v0.6.10' },{'date'=>'2000-04-02T22:12:47','version'=>'v0.6.11' },{'date'=>'2000-08-03T22:12:31','version'=>'v0.7.0' },{'date'=>'2000-08-13T20:17:55','version'=>'v0.7.1' },{'date'=>'2000-08-14T07:27:17','version'=>'v0.7.2' },{'date'=>'2000-08-23T23:12:01','version'=>'v0.7.4' },{'date'=>'2000-09-01T19:44:37','version'=>'v1.0.0' },{'date'=>'2000-09-17T16:56:12','version'=>'v1.0.1' },{'date'=>'2000-09-28T21:50:42','version'=>'v1.0.2' },{'date'=>'2000-09-29T19:55:57','version'=>'v1.0.3' },{'date'=>'2000-10-23T18:12:41','version'=>'v1.0.4' },{'date'=>'2000-10-26T17:18:33','version'=>'v1.0.5' },{'date'=>'2000-11-05T17:30:34','version'=>'v1.0.6' },{'date'=>'2001-01-03T09:48:40','version'=>'v1.0.7' },{'date'=>'2001-02-17T12:43:23','version'=>'v1.0.10' },{'date'=>'2001-03-15T00:30:04','version'=>'v1.0.11' },{'date'=>'2001-07-01T11:30:39','version'=>'v1.0.12' },{'date'=>'2001-08-28T21:59:16','version'=>'v1.0.13' },{'date'=>'2001-12-01T13:48:14','version'=>'v1.0.14' },{'date'=>'2002-05-18T16:48:08','version'=>'2.00' },{'date'=>'2002-05-28T20:34:47','version'=>'2.02' },{'date'=>'2002-06-01T04:35:47','version'=>'2.03' },{'date'=>'2002-06-08T02:11:56','version'=>'2.04' },{'date'=>'2002-10-03T03:37:51','version'=>'2.05' },{'date'=>'2002-11-25T12:34:01','version'=>'2.06' },{'date'=>'2003-05-05T05:21:16','version'=>'2.07' },{'date'=>'2003-09-05T20:01:37','version'=>'2.08' },{'date'=>'2004-01-06T01:47:55','version'=>'2.09' },{'date'=>'2004-03-01T04:28:16','version'=>'2.10' },{'date'=>'2004-03-17T15:11:57','version'=>'2.11' },{'date'=>'2004-03-24T03:24:16','version'=>'2.12' },{'date'=>'2004-06-28T16:41:47','version'=>'2.13' },{'date'=>'2005-04-25T02:15:51','version'=>'2.14' },{'date'=>'2005-05-23T17:21:53','version'=>'2.15' },{'date'=>'2007-03-31T00:51:12','version'=>'2.16' },{'date'=>'2007-11-16T20:48:24','version'=>'2.17' },{'date'=>'2007-11-23T18:18:24','version'=>'2.18' },{'date'=>'2009-05-18T04:18:09','version'=>'2.20' },{'date'=>'2009-08-06T05:30:04','version'=>'2.21' },{'date'=>'2010-11-12T17:12:42','version'=>'2.23' },{'date'=>'2010-11-12T17:29:29','version'=>'2.24' },{'date'=>'2010-12-11T06:08:33','version'=>'2.25' },{'date'=>'2011-07-03T04:04:14','version'=>'2.29' },{'date'=>'2011-07-12T03:59:06','version'=>'2.30' },{'date'=>'2012-06-07T01:16:46','version'=>'2.35' },{'date'=>'2012-09-11T01:30:44','version'=>'2.38' },{'date'=>'2012-09-11T01:38:57','version'=>'2.39' },{'date'=>'2013-07-13T16:49:48','version'=>'2.45' },{'date'=>'2014-07-02T11:09:04','version'=>'2.51' },{'date'=>'2017-01-29T11:41:00','version'=>'3.05' },{'date'=>'2017-01-30T14:25:11','version'=>'3.05_01' },{'date'=>'2017-01-30T18:55:50','version'=>'3.05_02' },{'date'=>'2017-01-31T01:58:36','version'=>'3.05_03' },{'date'=>'2017-02-02T11:22:12','version'=>'3.05_04' },{'date'=>'2017-03-05T10:48:10','version'=>'3.05_06' },{'date'=>'2017-03-05T12:52:10','version'=>'3.05_07' },{'date'=>'2017-03-11T07:51:19','version'=>'3.05_09' },{'date'=>'2017-03-14T09:03:54','version'=>'3.05_10' },{'date'=>'2017-03-29T20:00:48','version'=>'3.05_11' },{'date'=>'2017-04-19T07:20:42','version'=>'3.05_12' },{'date'=>'2017-10-15T12:06:30','version'=>'3.05_14' },{'date'=>'2017-10-21T09:30:17','version'=>'3.05_15' },{'date'=>'2017-10-21T16:17:28','version'=>'3.05_16' },{'date'=>'2018-04-19T08:29:33','version'=>'3.06' },{'date'=>'2018-04-20T16:11:03','version'=>'3.05_17' },{'date'=>'2018-04-21T10:08:56','version'=>'3.08' },{'date'=>'2018-04-21T16:50:30','version'=>'3.09' },{'date'=>'2018-04-27T17:46:19','version'=>'3.11' },{'date'=>'2018-09-05T15:12:26','version'=>'3.11_01' },{'date'=>'2019-03-06T12:42:01','version'=>'3.12_03' }]},'Tk'=>{'advisories'=>[{'affected_versions'=>'<804.029','cves'=>['CVE-2006-4484' ],'description'=>'Buffer overflow in the LWZReadByte_ function in the GD extension in allows remote attackers to have an unknown impact via a GIF file with input_code_size greater than MAX_LWZ_BITS, which triggers an overflow when initializing the table array.
  ','distribution'=>'Tk','fixed_versions'=>'>=804.029','id'=>'CPANSA-Tk-2008-01','references'=>['https://metacpan.org/changes/distribution/Tk' ],'reported'=>'2008-10-01' }],'main_module'=>'Tk','versions'=>[{'date'=>'1995-08-22T23:03:30','version'=>0 },{'date'=>'1995-12-19T01:56:04','version'=>0 },{'date'=>'1996-08-29T00:19:01','version'=>0 },{'date'=>'1996-09-07T01:08:44','version'=>'400.200' },{'date'=>'1997-01-08T23:27:30','version'=>'400.201' },{'date'=>'1997-01-25T12:33:02','version'=>'400.202' },{'date'=>'1997-05-04T20:05:58','version'=>'402.000' },{'date'=>'1997-06-14T19:17:26','version'=>'402.001' },{'date'=>'1997-07-18T17:01:40','version'=>'402.002' },{'date'=>'1997-10-04T15:32:53','version'=>'402.003' },{'date'=>'1998-01-25T17:07:27','version'=>'402.004' },{'date'=>'1998-02-07T21:22:00','version'=>'402.003' },{'date'=>'1998-02-22T19:34:11','version'=>'800.000' },{'date'=>'1998-03-02T00:12:00','version'=>'800.0_01' },{'date'=>'1998-03-09T22:37:37','version'=>'800.0_02' },{'date'=>'1998-03-17T13:43:00','version'=>'402.003' },{'date'=>'1998-04-01T04:36:00','version'=>'402.003' },{'date'=>'1998-04-02T18:32:00','version'=>'402.003' },{'date'=>'1998-04-05T08:37:23','version'=>'800.003' },{'date'=>'1998-04-19T17:23:45','version'=>'800.004' },{'date'=>'1998-05-17T18:07:11','version'=>'800.005' },{'date'=>'1998-06-14T20:30:35','version'=>'800.006' },{'date'=>'1998-06-26T16:30:23','version'=>'800.007' },{'date'=>'1998-07-17T16:47:42','version'=>'800.008' },{'date'=>'1998-08-08T19:31:23','version'=>'800.010' },{'date'=>'1998-09-01T17:20:02','version'=>'800.011' },{'date'=>'1998-11-15T14:28:04','version'=>'800.012' },{'date'=>'1999-03-16T22:13:10','version'=>'800.013' },{'date'=>'1999-04-05T20:15:39','version'=>'800.014' },{'date'=>'1999-07-28T22:10:03','version'=>'800.015' },{'date'=>'2000-01-08T12:48:56','version'=>'800.017' },{'date'=>'2000-01-08T12:58:16','version'=>'800.0_16' },{'date'=>'2000-01-22T19:44:55','version'=>'800.018' },{'date'=>'2000-03-13T16:39:08','version'=>'800.019' },{'date'=>'2000-03-27T17:01:22','version'=>'800.020' },{'date'=>'2000-04-21T13:38:21','version'=>'800.021' },{'date'=>'2000-05-13T09:48:51','version'=>'800.022' },{'date'=>'2001-05-15T15:07:21','version'=>'800.023' },{'date'=>'2001-07-14T21:06:00','version'=>'800.012' },{'date'=>'2002-03-05T16:38:25','version'=>'800.024' },{'date'=>'2002-03-17T20:30:42','version'=>'800.024' },{'date'=>'2002-10-13T17:20:55','version'=>'804.0_24' },{'date'=>'2003-05-02T01:10:54','version'=>'v804.024.' },{'date'=>'2003-09-08T08:13:16','version'=>'800.025' },{'date'=>'2003-09-28T18:01:55','version'=>'804.025' },{'date'=>'2003-10-10T18:24:24','version'=>'804.025' },{'date'=>'2003-10-20T20:44:44','version'=>'804.025' },{'date'=>'2003-10-27T08:23:07','version'=>'804.025' },{'date'=>'2003-11-02T22:28:10','version'=>'804.025' },{'date'=>'2003-11-16T22:15:42','version'=>'804.025' },{'date'=>'2003-12-02T21:26:56','version'=>'804.025' },{'date'=>'2003-12-08T08:01:15','version'=>'804.025_' },{'date'=>'2003-12-11T08:03:20','version'=>'804.025' },{'date'=>'2003-12-14T20:22:05','version'=>'804.025' },{'date'=>'2003-12-19T17:42:32','version'=>'804.025' },{'date'=>'2003-12-21T21:09:10','version'=>'804.025_' },{'date'=>'2003-12-23T23:19:20','version'=>'804.025' },{'date'=>'2004-01-12T21:59:01','version'=>'804.025' },{'date'=>'2004-02-28T17:33:01','version'=>'804.025_' },{'date'=>'2004-03-07T20:33:56','version'=>'804.025_' },{'date'=>'2004-03-19T08:10:49','version'=>'804.026' },{'date'=>'2004-04-11T19:04:25','version'=>'804.026' },{'date'=>'2007-02-11T08:49:16','version'=>'804.027_500' },{'date'=>'2007-09-21T22:57:57','version'=>'804.027_501' },{'date'=>'2007-12-04T21:03:29','version'=>'804.027_502' },{'date'=>'2007-12-18T22:01:39','version'=>'804.028' },{'date'=>'2008-10-01T21:48:52','version'=>'804.0285' },{'date'=>'2008-11-04T22:27:51','version'=>'804.028501' },{'date'=>'2010-01-30T17:54:07','version'=>'804.028502' },{'date'=>'2010-05-13T00:00:04','version'=>'804.028503' },{'date'=>'2010-05-27T19:25:41','version'=>'804.029' },{'date'=>'2011-06-13T17:53:20','version'=>'804.0295' },{'date'=>'2011-10-14T19:22:48','version'=>'804.029501' },{'date'=>'2011-10-17T21:12:41','version'=>'804.029502' },{'date'=>'2011-10-20T21:08:12','version'=>'804.03' },{'date'=>'2013-05-17T22:16:24','version'=>'804.030500' },{'date'=>'2013-05-18T05:01:41','version'=>'804.030501' },{'date'=>'2013-05-21T07:30:50','version'=>'804.030502' },{'date'=>'2013-05-25T12:57:05','version'=>'804.031' },{'date'=>'2013-11-17T11:24:41','version'=>'804.031500' },{'date'=>'2013-11-18T20:19:08','version'=>'804.031501' },{'date'=>'2013-12-01T15:07:28','version'=>'804.031502' },{'date'=>'2013-12-07T13:00:14','version'=>'804.031503' },{'date'=>'2014-01-26T17:01:07','version'=>'804.032' },{'date'=>'2014-11-06T21:01:44','version'=>'804.032500' },{'date'=>'2015-01-31T10:28:08','version'=>'804.032501' },{'date'=>'2015-02-21T15:54:08','version'=>'804.033' },{'date'=>'2017-08-20T09:29:42','version'=>'804.033500' },{'date'=>'2017-08-26T15:26:56','version'=>'804.034' }]},'UI-Dialog'=>{'advisories'=>[{'affected_versions'=>'<1.11','description'=>'Allows remote attackers to execute arbitrary commands.
  ','distribution'=>'UI-Dialog','fixed_versions'=>'>=1.11','id'=>'CPANSA-UI-Dialog-2015-01','references'=>['https://metacpan.org/changes/distribution/UI-Dialog' ],'reported'=>'2015-10-10' },{'affected_versions'=>'<1.03','description'=>'CDialog and Whiptail backends usage of the temp files.
  ','distribution'=>'UI-Dialog','fixed_versions'=>'>=1.03','id'=>'CPANSA-UI-Dialog-2004-01','references'=>['https://metacpan.org/changes/distribution/UI-Dialog' ],'reported'=>'2004-02-18' }],'main_module'=>'UI::Dialog','versions'=>[{'date'=>'2004-01-04T10:51:34','version'=>'1.00' },{'date'=>'2004-01-13T00:08:39','version'=>'1.01' },{'date'=>'2004-02-15T11:03:37','version'=>'1.02' },{'date'=>'2004-02-18T16:52:59','version'=>'1.03' },{'date'=>'2004-02-22T18:34:25','version'=>'1.04' },{'date'=>'2004-03-18T02:12:03','version'=>'1.05' },{'date'=>'2004-03-18T16:01:50','version'=>'1.06' },{'date'=>'2004-07-21T19:59:51','version'=>'1.07' },{'date'=>'2004-10-05T00:46:22','version'=>'1.08' },{'date'=>'2013-08-10T09:39:07','version'=>'1.09' },{'date'=>'2013-08-10T17:09:57','version'=>'1.09' },{'date'=>'2013-08-19T17:22:00','version'=>'1.09' },{'date'=>'2016-01-19T19:05:07','version'=>'1.11' },{'date'=>'2016-01-22T06:42:45','version'=>'1.12' },{'date'=>'2016-01-30T21:24:56','version'=>'1.13' },{'date'=>'2016-02-03T02:10:12','version'=>'1.14' },{'date'=>'2016-02-09T00:11:17','version'=>'1.15' },{'date'=>'2016-02-10T02:57:43','version'=>'1.16' },{'date'=>'2016-02-12T05:25:14','version'=>'1.17' },{'date'=>'2016-02-13T02:56:26','version'=>'1.18' },{'date'=>'2016-02-21T23:33:48','version'=>'1.19' },{'date'=>'2016-03-07T02:15:26','version'=>'1.20' },{'date'=>'2016-04-02T22:17:32','version'=>'1.21' }]},'XML-LibXML'=>{'advisories'=>[{'affected_versions'=>'<2.0120','cves'=>['CVE-2015-3451' ],'description'=>'The _clone function does not properly set the expand_entities option, which allows remote attackers to conduct XML external entity (XXE) attacks via crafted XML data to the (1) new or (2) load_xml function.
  ','distribution'=>'XML-LibXML','fixed_versions'=>'>=2.0120','id'=>'CPANSA-XML-LibXML-2015-01','references'=>['https://metacpan.org/changes/distribution/XML-LibXML' ],'reported'=>'2015-04-23' }],'main_module'=>'XML::LibXML','versions'=>[{'date'=>'2001-05-18T11:31:21','version'=>'0.91' },{'date'=>'2001-06-03T07:47:14','version'=>'0.92' },{'date'=>'2001-06-09T16:52:26','version'=>'0.93' },{'date'=>'2001-06-10T08:54:23','version'=>'0.94' },{'date'=>'2001-06-21T10:07:56','version'=>'0.96' },{'date'=>'2001-06-29T20:39:47','version'=>'0.97' },{'date'=>'2001-07-20T16:08:25','version'=>'0.99' },{'date'=>'2001-08-07T10:13:29','version'=>'1.00' },{'date'=>'2001-11-14T11:39:59','version'=>'1.30' },{'date'=>'2001-11-25T17:25:52','version'=>'1.31' },{'date'=>'2002-03-13T14:24:12','version'=>'1.40' },{'date'=>'2002-05-11T21:07:22','version'=>'1.49' },{'date'=>'2002-05-20T11:33:20','version'=>'1.50' },{'date'=>'2002-05-31T16:53:50','version'=>'1.51' },{'date'=>'2002-06-12T10:16:35','version'=>'1.52' },{'date'=>'2002-09-14T21:02:38','version'=>'1.53' },{'date'=>'2002-10-26T15:21:51','version'=>'1.54_0' },{'date'=>'2002-11-08T10:03:05','version'=>'1.54_1' },{'date'=>'2002-11-08T18:15:20','version'=>'1.54_2' },{'date'=>'2002-11-15T20:14:58','version'=>'1.54_3' },{'date'=>'2003-05-22T23:44:39','version'=>'1.54_4' },{'date'=>'2003-05-30T18:46:39','version'=>'1.54' },{'date'=>'2003-08-19T21:15:43','version'=>'1.55' },{'date'=>'2003-08-25T13:39:01','version'=>'1.56' },{'date'=>'2004-02-29T16:56:42','version'=>'1.57' },{'date'=>'2004-03-31T19:49:55','version'=>'1.58' },{'date'=>'2004-04-04T11:42:03','version'=>'1.58_1' },{'date'=>'2006-08-02T10:59:49','version'=>'1.59' },{'date'=>'2006-08-26T18:11:05','version'=>'1.60' },{'date'=>'2006-09-24T15:43:20','version'=>'1.61' },{'date'=>'2006-09-25T07:21:39','version'=>'1.61' },{'date'=>'2006-09-25T07:42:26','version'=>'1.61' },{'date'=>'2006-09-25T11:38:04','version'=>'1.61' },{'date'=>'2006-11-18T09:57:51','version'=>'1.62' },{'date'=>'2006-11-25T09:10:37','version'=>'1.62' },{'date'=>'2007-04-16T11:46:21','version'=>'1.63' },{'date'=>'2007-09-09T21:51:03','version'=>'1.64' },{'date'=>'2007-09-25T16:37:46','version'=>'1.65' },{'date'=>'2008-01-29T21:10:45','version'=>'1.66' },{'date'=>'2008-11-04T14:26:16','version'=>'1.67' },{'date'=>'2008-11-05T13:32:59','version'=>'1.68' },{'date'=>'2008-11-11T21:00:56','version'=>'1.69' },{'date'=>'2009-01-23T22:30:52','version'=>'1.69_1' },{'date'=>'2009-02-06T19:12:24','version'=>'1.69_2' },{'date'=>'2009-10-07T12:31:25','version'=>'1.70' },{'date'=>'2011-06-14T17:01:30','version'=>'1.71' },{'date'=>'2011-06-16T16:40:11','version'=>'1.72' },{'date'=>'2011-06-18T08:35:40','version'=>'1.73' },{'date'=>'2011-06-23T12:27:53','version'=>'1.74' },{'date'=>'2011-06-24T16:02:54','version'=>'1.75' },{'date'=>'2011-06-30T18:20:41','version'=>'1.76' },{'date'=>'2011-07-01T19:31:51','version'=>'1.77' },{'date'=>'2011-07-06T17:27:49','version'=>'1.78' },{'date'=>'2011-07-08T17:06:33','version'=>'1.79' },{'date'=>'2011-07-12T20:39:51','version'=>'1.80' },{'date'=>'2011-07-16T15:36:21','version'=>'1.81' },{'date'=>'2011-07-20T20:49:05','version'=>'1.82' },{'date'=>'2011-07-23T11:34:22','version'=>'1.83' },{'date'=>'2011-07-23T20:17:26','version'=>'1.84' },{'date'=>'2011-08-24T14:08:28','version'=>'1.85' },{'date'=>'2011-08-25T08:46:56','version'=>'1.86' },{'date'=>'2011-08-27T11:07:44','version'=>'1.87' },{'date'=>'2011-09-21T10:01:23','version'=>'1.88' },{'date'=>'2011-12-24T07:47:30','version'=>'1.89' },{'date'=>'2012-01-08T19:01:33','version'=>'1.90' },{'date'=>'2012-02-21T12:02:10','version'=>'1.91' },{'date'=>'2012-02-21T17:03:56','version'=>'1.92' },{'date'=>'2012-02-27T09:18:12','version'=>'1.93' },{'date'=>'2012-03-03T20:10:26','version'=>'1.94' },{'date'=>'2012-03-06T08:42:27','version'=>'1.95' },{'date'=>'2012-03-16T19:05:40','version'=>'1.96' },{'date'=>'2012-04-30T17:35:11','version'=>'1.97' },{'date'=>'2012-05-13T18:06:03','version'=>'1.98' },{'date'=>'2012-05-31T07:25:35','version'=>'1.99' },{'date'=>'2012-06-19T20:07:27','version'=>'2.0000' },{'date'=>'2012-06-20T16:53:03','version'=>'2.0001' },{'date'=>'2012-07-08T15:12:36','version'=>'2.0002' },{'date'=>'2012-07-27T15:22:53','version'=>'2.0003' },{'date'=>'2012-08-07T20:06:48','version'=>'2.0004' },{'date'=>'2012-10-13T11:23:03','version'=>'2.0005' },{'date'=>'2012-10-13T20:34:57','version'=>'2.0006' },{'date'=>'2012-10-17T17:05:13','version'=>'2.0007' },{'date'=>'2012-10-22T10:13:20','version'=>'2.0008' },{'date'=>'2012-11-01T14:29:13','version'=>'2.0009' },{'date'=>'2012-11-01T18:16:34','version'=>'2.0010' },{'date'=>'2012-11-07T22:29:47','version'=>'2.0011' },{'date'=>'2012-11-09T04:42:04','version'=>'2.0012' },{'date'=>'2012-12-04T15:46:46','version'=>'2.0013' },{'date'=>'2012-12-05T09:13:26','version'=>'2.0014' },{'date'=>'2013-04-12T23:35:55','version'=>'2.0015' },{'date'=>'2013-04-13T19:39:51','version'=>'2.0016' },{'date'=>'2013-05-09T08:07:47','version'=>'2.0017' },{'date'=>'2013-05-13T10:44:19','version'=>'2.0018' },{'date'=>'2013-07-01T08:08:50','version'=>'2.0019' },{'date'=>'2013-08-14T05:27:26','version'=>'2.0100' },{'date'=>'2013-08-15T05:34:30','version'=>'2.0101' },{'date'=>'2013-08-19T12:18:31','version'=>'2.0102' },{'date'=>'2013-08-22T05:35:19','version'=>'2.0103' },{'date'=>'2013-08-30T09:38:04','version'=>'2.0104' },{'date'=>'2013-09-07T17:24:00','version'=>'2.0105' },{'date'=>'2013-09-17T16:14:51','version'=>'2.0106' },{'date'=>'2013-10-31T07:16:02','version'=>'2.0107' },{'date'=>'2013-12-17T09:10:53','version'=>'2.0108' },{'date'=>'2014-01-31T08:01:23','version'=>'2.0109' },{'date'=>'2014-02-01T14:14:02','version'=>'2.0110' },{'date'=>'2014-03-05T15:31:25','version'=>'2.0111' },{'date'=>'2014-03-13T18:19:10','version'=>'2.0112' },{'date'=>'2014-03-14T12:15:54','version'=>'2.0113' },{'date'=>'2014-04-03T13:01:06','version'=>'2.0114' },{'date'=>'2014-04-03T13:15:41','version'=>'2.0115' },{'date'=>'2014-04-12T08:10:37','version'=>'2.0116' },{'date'=>'2014-10-26T16:31:29','version'=>'2.0117' },{'date'=>'2015-02-05T10:57:03','version'=>'2.0118' },{'date'=>'2015-04-23T07:14:45','version'=>'2.0119' },{'date'=>'2015-05-01T09:50:18','version'=>'2.0120' },{'date'=>'2015-05-03T12:08:06','version'=>'2.0121' },{'date'=>'2015-09-01T09:02:29','version'=>'2.0122' },{'date'=>'2015-12-06T13:19:22','version'=>'2.0123' },{'date'=>'2016-02-27T11:21:08','version'=>'2.0124' },{'date'=>'2016-05-30T09:24:51','version'=>'2.0125' },{'date'=>'2016-06-24T16:21:00','version'=>'2.0126' },{'date'=>'2016-07-22T17:40:51','version'=>'2.0127' },{'date'=>'2016-07-24T09:15:48','version'=>'2.0128' },{'date'=>'2017-03-14T13:37:23','version'=>'2.0129' },{'date'=>'2017-10-18T08:45:49','version'=>'2.0130' },{'date'=>'2017-10-24T08:57:20','version'=>'2.0131' },{'date'=>'2017-10-28T17:58:34','version'=>'2.0132' },{'date'=>'2019-02-02T11:11:30','version'=>'2.0133' },{'date'=>'2019-02-10T15:02:55','version'=>'2.0134' }]},'libapreq2'=>{'advisories'=>[{'affected_versions'=>'<2.07','cves'=>['CVE-2006-0042' ],'description'=>'Unspecified vulnerability in apreq_parse_headers and apreq_parse_urlencoded functions in Apache2::Request (Libapreq2) allows remote attackers to cause a denial of service (CPU consumption) via unknown attack vectors that result in quadratic computational complexity.
  ','distribution'=>'libapreq2','fixed_versions'=>'>=2.07','id'=>'CPANSA-libapreq2-2006-01','references'=>['https://metacpan.org/changes/distribution/libapreq2' ],'reported'=>'2007-04-17' }],'main_module'=>'Apache2::Upload','versions'=>[{'date'=>'2003-11-11T01:28:48','version'=>'2.01_03' },{'date'=>'2003-11-16T04:16:12','version'=>'2.02_02' },{'date'=>'2004-06-12T14:52:49','version'=>'2.03_04' },{'date'=>'2004-08-30T16:13:45','version'=>'2.04_03' },{'date'=>'2005-05-04T23:38:05','version'=>'2.05' },{'date'=>'2005-07-20T17:10:48','version'=>'2.06' },{'date'=>'2006-02-12T18:10:47','version'=>'2.07' },{'date'=>'2006-08-09T04:54:07','version'=>'2.08' },{'date'=>'2009-03-13T22:47:11','version'=>'2.12' },{'date'=>'2010-12-02T18:41:57','version'=>'2.13' }]},'libwww-perl'=>{'advisories'=>[{'affected_versions'=>'<6.00','cves'=>['CVE-2011-0633' ],'description'=>'The Net::HTTPS module in libwww-perl (LWP) before 6.00, as used in WWW::Mechanize, LWP::UserAgent, and other products, when running in environments that do not set the If-SSL-Cert-Subject header, does not enable full validation of SSL certificates by default, which allows remote attackers to spoof servers via man-in-the-middle (MITM) attacks involving hostnames that are not properly validated.
  ','distribution'=>'libwww-perl','fixed_versions'=>'>=6.00','id'=>'CPANSA-libwww-perl-2011-01','references'=>['http://vttynotes.blogspot.com/2010/12/man-in-middle-fun-with-perl-lwp.html','http://vttynotes.blogspot.com/2011/03/quick-note-on-lwp-and-perl-security-cve.html' ],'reported'=>'2011-01-20' },{'affected_versions'=>'<5.835','cves'=>['CVE-2010-2253' ],'description'=>'lwp-download in libwww-perl before 5.835 does not reject downloads to filenames that begin with a . (dot) character, which allows remote servers to create or overwrite files via (1) a 3xx redirect to a URL with a crafted filename or (2) a Content-Disposition header that suggests a crafted filename, and possibly execute arbitrary code as a consequence of writing to a dotfile in a home directory.
  ','distribution'=>'libwww-perl','fixed_versions'=>'>=5.835','id'=>'CPANSA-libwww-perl-2010-01','references'=>['http://vttynotes.blogspot.com/2010/12/man-in-middle-fun-with-perl-lwp.html','http://vttynotes.blogspot.com/2011/03/quick-note-on-lwp-and-perl-security-cve.html' ],'reported'=>'2010-07-06' },{'affected_versions'=>'<5.51','description'=>'If LWP::UserAgent::env_proxy is called in a CGI environment, the case-insensitivity when looking for "http_proxy" permits "HTTP_PROXY" to be found, but this can be trivially set by the web client using the "Proxy:" header.
  ','distribution'=>'libwww-perl','fixed_versions'=>'>=5.51','id'=>'CPANSA-libwww-perl-2001-01','reported'=>'2001-03-14' }],'main_module'=>'LWP','versions'=>[{'date'=>'1995-09-16T13:51:35','version'=>'5' },{'date'=>'1995-11-06T14:29:13','version'=>'5' },{'date'=>'1996-05-09T22:43:16','version'=>'5' },{'date'=>'1996-05-26T14:01:51','version'=>'5.00' },{'date'=>'1996-08-02T16:38:58','version'=>'5.01' },{'date'=>'1996-09-11T16:19:57','version'=>'5.02' },{'date'=>'1996-09-30T22:58:37','version'=>'5.03' },{'date'=>'1996-10-22T10:39:33','version'=>'5.04' },{'date'=>'1996-12-04T23:36:17','version'=>'5.05' },{'date'=>'1997-01-27T23:53:38','version'=>'5.06' },{'date'=>'1997-02-11T14:20:18','version'=>'5.07' },{'date'=>'1997-04-05T13:10:16','version'=>'5.08' },{'date'=>'1997-06-10T11:07:01','version'=>'5.09' },{'date'=>'1997-06-20T10:51:10','version'=>'5.10' },{'date'=>'1997-08-06T08:41:11','version'=>'5.11' },{'date'=>'1997-09-05T09:38:58','version'=>'5.12' },{'date'=>'1997-09-20T12:50:59','version'=>'5.13' },{'date'=>'1997-10-12T20:55:32','version'=>'5.14' },{'date'=>'1997-11-06T20:23:06','version'=>'5.15' },{'date'=>'1997-12-12T17:44:29','version'=>'5.18' },{'date'=>'1997-12-16T22:25:00','version'=>'5.18_03' },{'date'=>'1997-12-17T10:08:54','version'=>'5.18_04' },{'date'=>'1998-01-20T18:16:51','version'=>'5.18_05' },{'date'=>'1998-01-26T23:55:39','version'=>'5.19' },{'date'=>'1998-02-12T23:43:23','version'=>'5.20' },{'date'=>'1998-03-12T18:39:08','version'=>'5.21' },{'date'=>'1998-03-24T19:42:54','version'=>'5.22' },{'date'=>'1998-03-31T22:25:14','version'=>'5.30' },{'date'=>'1998-04-10T15:07:10','version'=>'5.31' },{'date'=>'1998-04-17T05:23:45','version'=>'5.32' },{'date'=>'1998-05-07T15:10:00','version'=>'5.33' },{'date'=>'1998-07-07T16:06:51','version'=>'5.34' },{'date'=>'1998-07-09T23:05:12','version'=>'5.35' },{'date'=>'1998-08-04T15:15:44','version'=>'5.36' },{'date'=>'1998-10-12T17:42:28','version'=>'5.40_01' },{'date'=>'1998-11-19T22:17:29','version'=>'5.41' },{'date'=>'1999-03-20T07:52:48','version'=>'5.42' },{'date'=>'1999-05-09T19:26:17','version'=>'5.43' },{'date'=>'1999-06-25T20:34:40','version'=>'5.44' },{'date'=>'1999-09-20T13:36:22','version'=>'5.45' },{'date'=>'1999-10-28T12:30:45','version'=>'5.46' },{'date'=>'1999-11-16T14:59:58','version'=>'5.47' },{'date'=>'2000-04-09T19:45:32','version'=>'5.48' },{'date'=>'2001-01-01T06:35:20','version'=>'5.49' },{'date'=>'2001-01-12T20:58:43','version'=>'5.50' },{'date'=>'2001-03-14T21:33:03','version'=>'5.51' },{'date'=>'2001-03-29T21:39:12','version'=>'5.52' },{'date'=>'2001-04-10T23:15:00','version'=>'5.53' },{'date'=>'2001-04-19T06:13:35','version'=>'5.53_90' },{'date'=>'2001-04-21T05:02:13','version'=>'5.53_91' },{'date'=>'2001-04-25T17:37:11','version'=>'5.53_92' },{'date'=>'2001-04-29T06:28:31','version'=>'5.53_93' },{'date'=>'2001-05-05T13:57:20','version'=>'5.53_94' },{'date'=>'2001-08-07T00:46:18','version'=>'5.53_95' },{'date'=>'2001-08-28T05:59:46','version'=>'5.53_96' },{'date'=>'2001-09-20T00:33:20','version'=>'5.53_97' },{'date'=>'2001-10-26T23:30:57','version'=>'5.60' },{'date'=>'2001-11-17T02:56:46','version'=>'5.61' },{'date'=>'2001-11-21T19:00:47','version'=>'5.62' },{'date'=>'2001-12-14T21:01:09','version'=>'5.63' },{'date'=>'2002-02-09T18:54:35','version'=>'5.64' },{'date'=>'2002-05-31T20:59:15','version'=>'5.65' },{'date'=>'2002-12-20T19:28:34','version'=>'5.66' },{'date'=>'2003-01-01T16:53:11','version'=>'5.67' },{'date'=>'2003-01-03T05:04:44','version'=>'5.68' },{'date'=>'2003-01-24T16:55:35','version'=>'5.69' },{'date'=>'2003-10-13T20:56:35','version'=>'5.70' },{'date'=>'2003-10-14T19:12:56','version'=>'5.71' },{'date'=>'2003-10-15T19:53:47','version'=>'5.72' },{'date'=>'2003-10-19T20:04:40','version'=>'5.73' },{'date'=>'2003-10-23T19:26:57','version'=>'5.74' },{'date'=>'2003-10-26T22:10:48','version'=>'5.75' },{'date'=>'2003-11-21T19:33:09','version'=>'5.76' },{'date'=>'2004-04-06T13:41:45','version'=>'5.77' },{'date'=>'2004-04-07T11:13:36','version'=>'5.78' },{'date'=>'2004-04-13T08:09:08','version'=>'5.79' },{'date'=>'2004-06-16T10:43:42','version'=>'5.800' },{'date'=>'2004-11-12T18:32:17','version'=>'5.801' },{'date'=>'2004-11-30T13:06:01','version'=>'5.802' },{'date'=>'2004-12-11T15:48:30','version'=>'5.803' },{'date'=>'2005-12-06T09:36:12','version'=>'5.804' },{'date'=>'2005-12-08T12:29:02','version'=>'5.805' },{'date'=>'2007-07-19T21:31:44','version'=>'5.806' },{'date'=>'2007-07-31T13:14:54','version'=>'5.807' },{'date'=>'2007-08-05T13:29:17','version'=>'5.808' },{'date'=>'2008-04-08T11:47:19','version'=>'5.810' },{'date'=>'2008-04-14T08:28:19','version'=>'5.811' },{'date'=>'2008-04-16T10:32:51','version'=>'5.812' },{'date'=>'2008-06-17T20:37:17','version'=>'5.813' },{'date'=>'2008-07-25T09:09:53','version'=>'5.814' },{'date'=>'2008-09-24T18:10:11','version'=>'5.815' },{'date'=>'2008-09-29T09:27:09','version'=>'5.816' },{'date'=>'2008-10-10T21:31:27','version'=>'5.817' },{'date'=>'2008-10-16T10:32:24','version'=>'5.818' },{'date'=>'2008-10-20T11:43:37','version'=>'5.819' },{'date'=>'2008-11-05T18:07:29','version'=>'5.820' },{'date'=>'2008-11-25T00:16:49','version'=>'5.821' },{'date'=>'2008-12-05T19:18:40','version'=>'5.822' },{'date'=>'2009-01-12T16:50:02','version'=>'5.823' },{'date'=>'2009-02-13T14:12:29','version'=>'5.824' },{'date'=>'2009-02-16T10:00:35','version'=>'5.825' },{'date'=>'2009-04-24T20:42:45','version'=>'5.826' },{'date'=>'2009-06-15T19:36:37','version'=>'5.827' },{'date'=>'2009-06-25T19:44:55','version'=>'5.828' },{'date'=>'2009-07-08T20:03:11','version'=>'5.829' },{'date'=>'2009-07-26T19:39:49','version'=>'5.830' },{'date'=>'2009-08-13T20:53:34','version'=>'5.831' },{'date'=>'2009-09-21T18:24:41','version'=>'5.832' },{'date'=>'2009-10-06T21:23:39','version'=>'5.833' },{'date'=>'2009-11-21T13:09:14','version'=>'5.834' },{'date'=>'2010-05-05T21:13:47','version'=>'5.835' },{'date'=>'2010-05-13T07:34:58','version'=>'5.836' },{'date'=>'2010-09-20T21:24:38','version'=>'5.837' },{'date'=>'2010-11-04T15:16:35','version'=>'5.837' },{'date'=>'2011-03-08T19:25:05','version'=>'6.00' },{'date'=>'2011-03-09T23:30:57','version'=>'6.01' },{'date'=>'2011-03-27T11:35:01','version'=>'6.02' },{'date'=>'2011-10-15T13:38:28','version'=>'6.03' },{'date'=>'2012-02-18T22:13:13','version'=>'6.04' },{'date'=>'2013-03-11T21:47:56','version'=>'6.05' },{'date'=>'2014-04-16T18:38:49','version'=>'6.06' },{'date'=>'2014-07-02T05:10:47','version'=>'6.07' },{'date'=>'2014-07-25T03:19:43','version'=>'6.08' },{'date'=>'2015-02-10T02:58:40','version'=>'6.09' },{'date'=>'2015-02-12T17:40:48','version'=>'6.10' },{'date'=>'2015-02-13T21:38:49','version'=>'6.11' },{'date'=>'2015-02-14T00:16:15','version'=>'6.12' },{'date'=>'2015-02-14T18:45:12','version'=>'6.13' },{'date'=>'2015-11-25T20:23:47','version'=>'6.14_001' },{'date'=>'2015-12-05T06:01:09','version'=>'6.15' },{'date'=>'2016-01-05T00:29:20','version'=>'6.15_001' },{'date'=>'2016-01-14T01:52:18','version'=>'6.15_002' },{'date'=>'2016-01-14T02:01:20','version'=>'6.15_003' },{'date'=>'2016-02-13T06:18:45','version'=>'6.15_004' },{'date'=>'2017-01-18T14:22:22','version'=>'6.16' },{'date'=>'2017-01-31T19:39:10','version'=>'6.17' },{'date'=>'2017-02-03T20:31:54','version'=>'6.18' },{'date'=>'2017-02-14T19:56:20','version'=>'6.19' },{'date'=>'2017-02-21T15:19:06','version'=>'6.20' },{'date'=>'2017-02-21T20:38:03','version'=>'6.21' },{'date'=>'2017-03-01T15:27:43','version'=>'6.22' },{'date'=>'2017-03-07T03:49:52','version'=>'6.23' },{'date'=>'2017-03-14T16:36:38','version'=>'6.24' },{'date'=>'2017-04-03T17:20:06','version'=>'6.25' },{'date'=>'2017-04-12T15:36:20','version'=>'6.26' },{'date'=>'2017-09-21T22:32:37','version'=>'6.27' },{'date'=>'2017-11-06T15:43:47','version'=>'6.28' },{'date'=>'2017-11-06T20:34:56','version'=>'6.29' },{'date'=>'2017-12-08T01:57:23','version'=>'6.30' },{'date'=>'2017-12-11T01:57:47','version'=>'6.31' },{'date'=>'2018-02-20T19:41:40','version'=>'6.32' },{'date'=>'2018-02-27T04:04:55','version'=>'6.33' },{'date'=>'2018-06-05T18:50:45','version'=>'6.34' },{'date'=>'2018-07-16T04:51:16','version'=>'6.35' },{'date'=>'2018-10-10T02:21:49','version'=>'6.36' },{'date'=>'2019-03-06T20:51:05','version'=>'6.37' }]},'mod_perl'=>{'advisories'=>[{'affected_versions'=>'<1.31','cves'=>['CVE-2009-0796' ],'description'=>'XSS in Apache::Status.
  ','distribution'=>'mod_perl','fixed_versions'=>'>=1.31','id'=>'CPANSA-mod_perl-2009-01','references'=>['https://metacpan.org/changes/distribution/mod_perl' ],'reported'=>'2009-05-11' },{'affected_versions'=>'<1.30','cves'=>['CVE-2007-1349' ],'description'=>'Unescaped variable interpolation in Apache::PerlRun regular expression could cause regex engine tampering.
  ','distribution'=>'mod_perl','fixed_versions'=>'>=1.30','id'=>'CPANSA-mod_perl-2007-01','references'=>['https://metacpan.org/changes/distribution/mod_perl' ],'reported'=>'2007-03-29' }],'main_module'=>'mod_perl2','versions'=>[{'date'=>'1996-05-21T02:07:05','version'=>'0.60' },{'date'=>'1996-05-21T20:51:37','version'=>'0.60' },{'date'=>'1996-06-18T19:41:55','version'=>'0.60' },{'date'=>'1996-06-25T15:49:56','version'=>'0.60' },{'date'=>'1996-07-14T23:39:07','version'=>'0.70' },{'date'=>'1996-07-26T20:39:23','version'=>'0.76' },{'date'=>'1996-09-08T22:13:32','version'=>'0.81' },{'date'=>'1996-10-04T15:50:31','version'=>'0.83_02' },{'date'=>'1996-10-09T07:10:24','version'=>'0.83_03' },{'date'=>'1996-10-14T03:46:54','version'=>'0.83_04' },{'date'=>'1996-10-15T13:34:22','version'=>'0.83_05' },{'date'=>'1996-10-17T03:48:27','version'=>'0.83_06' },{'date'=>'1996-10-18T22:18:01','version'=>'0.83_07' },{'date'=>'1996-10-21T01:37:29','version'=>'0.83_09' },{'date'=>'1996-10-25T14:09:06','version'=>'0.83_10' },{'date'=>'1996-10-28T00:01:00','version'=>'0.84' },{'date'=>'1996-11-13T05:39:14','version'=>'0.85' },{'date'=>'1996-11-14T07:21:01','version'=>'0.85_01' },{'date'=>'1996-11-27T17:19:02','version'=>'0.85_02' },{'date'=>'1996-12-05T03:37:12','version'=>'0.85_03' },{'date'=>'1996-12-10T23:17:33','version'=>'0.85_04' },{'date'=>'1996-12-17T13:31:40','version'=>'0.85_06' },{'date'=>'1996-12-19T14:32:44','version'=>'0.86' },{'date'=>'1996-12-24T04:19:35','version'=>'0.87' },{'date'=>'1996-12-24T20:41:28','version'=>'0.88' },{'date'=>'1996-12-31T04:43:25','version'=>'0.89' },{'date'=>'1996-12-31T07:52:56','version'=>'0.90' },{'date'=>'1997-01-20T10:04:20','version'=>'0.90_01' },{'date'=>'1997-01-23T00:58:22','version'=>'0.91' },{'date'=>'1997-01-23T15:56:19','version'=>'0.92' },{'date'=>'1997-01-28T02:37:30','version'=>'0.93' },{'date'=>'1997-03-05T03:19:32','version'=>'0.93_01' },{'date'=>'1997-03-10T12:07:39','version'=>'0.94' },{'date'=>'1997-03-23T18:53:46','version'=>'0.95' },{'date'=>'1997-03-23T18:54:02','version'=>'0.95_02' },{'date'=>'1997-04-01T04:44:44','version'=>'0.95_03' },{'date'=>'1997-04-02T01:35:22','version'=>'0.95_04' },{'date'=>'1997-04-02T03:20:37','version'=>'0.95_05' },{'date'=>'1997-04-02T04:42:28','version'=>'0.95_06' },{'date'=>'1997-04-04T05:33:39','version'=>'0.96' },{'date'=>'1997-04-16T03:54:02','version'=>'0.97' },{'date'=>'1997-04-23T03:29:01','version'=>'0.97_01' },{'date'=>'1997-04-30T03:56:50','version'=>'0.97_02' },{'date'=>'1997-05-02T19:58:12','version'=>'0.98' },{'date'=>'1997-05-19T22:59:20','version'=>'0.98_03' },{'date'=>'1997-05-23T00:24:28','version'=>'0.98_05' },{'date'=>'1997-05-30T02:07:03','version'=>'0.98_08' },{'date'=>'1997-06-02T00:05:45','version'=>'0.98_09' },{'date'=>'1997-06-03T03:15:48','version'=>'0.98_10' },{'date'=>'1997-06-04T01:54:46','version'=>'0.98_11' },{'date'=>'1997-06-06T01:14:09','version'=>'0.98_12' },{'date'=>'1997-06-12T00:36:43','version'=>'0.99' },{'date'=>'1997-06-30T03:04:22','version'=>'1.00' },{'date'=>'1997-07-08T06:20:15','version'=>'1.00' },{'date'=>'1997-07-30T20:57:59','version'=>'1.00' },{'date'=>'1997-08-25T22:00:29','version'=>'0.85_05' },{'date'=>'1997-09-16T01:09:06','version'=>'1.00_02' },{'date'=>'1997-09-21T21:40:32','version'=>'1.00_03' },{'date'=>'1997-10-17T00:04:35','version'=>'1.01' },{'date'=>'1997-10-17T15:40:45','version'=>'1.02' },{'date'=>'1997-10-24T04:02:30','version'=>'1.03' },{'date'=>'1997-10-31T03:59:22','version'=>'1.04' },{'date'=>'1997-11-07T04:32:07','version'=>'1.05' },{'date'=>'1997-11-26T02:09:01','version'=>'1.07' },{'date'=>'1997-12-02T21:34:03','version'=>'1.07_01' },{'date'=>'1997-12-22T09:29:56','version'=>'1.07_02' },{'date'=>'1998-01-08T10:21:31','version'=>'1.07_03' },{'date'=>'1998-01-28T02:10:28','version'=>'1.07_03' },{'date'=>'1998-01-29T00:47:52','version'=>'1.07_03' },{'date'=>'1998-02-10T11:04:03','version'=>'1.07_04' },{'date'=>'1998-02-12T15:08:20','version'=>'1.07_04' },{'date'=>'1998-02-20T03:43:49','version'=>'1.08' },{'date'=>'1998-03-07T01:06:09','version'=>'1.08' },{'date'=>'1998-03-19T07:39:18','version'=>'1.09' },{'date'=>'1998-03-21T04:14:02','version'=>'1.10' },{'date'=>'1998-03-27T16:52:20','version'=>'1.10' },{'date'=>'1998-04-21T14:43:05','version'=>'1.11' },{'date'=>'1998-04-24T18:58:30','version'=>'1.11' },{'date'=>'1998-06-09T16:51:19','version'=>'1.11' },{'date'=>'1998-06-14T19:21:25','version'=>'1.12' },{'date'=>'1998-07-14T01:13:07','version'=>'1.13' },{'date'=>'1998-07-19T00:19:20','version'=>'1.14' },{'date'=>'1998-07-24T13:52:53','version'=>'1.15' },{'date'=>'1998-07-24T15:59:13','version'=>'1.15' },{'date'=>'1998-09-20T00:02:57','version'=>'1.15_01' },{'date'=>'1998-10-02T23:10:02','version'=>'1.16' },{'date'=>'1998-10-28T18:16:45','version'=>'1.16' },{'date'=>'1998-11-24T23:54:59','version'=>'1.16_01' },{'date'=>'1998-12-01T00:01:25','version'=>'1.16_02' },{'date'=>'1999-01-28T06:27:45','version'=>'1.18' },{'date'=>'1999-06-11T17:22:35','version'=>'1.20' },{'date'=>'1999-07-02T23:43:56','version'=>'1.21' },{'date'=>'2000-03-06T01:32:31','version'=>'1.21_01' },{'date'=>'2000-03-07T07:56:53','version'=>'1.21_02' },{'date'=>'2000-03-15T10:25:52','version'=>'1.21_03' },{'date'=>'2000-03-23T06:51:53','version'=>'1.22' },{'date'=>'2000-04-21T06:51:47','version'=>'1.23' },{'date'=>'2000-05-17T05:44:34','version'=>'1.24' },{'date'=>'2000-10-10T16:44:39','version'=>'1.24_01' },{'date'=>'2001-01-30T04:33:45','version'=>'1.25' },{'date'=>'2001-07-06T21:27:16','version'=>'1.25_01' },{'date'=>'2001-07-12T02:23:32','version'=>'1.26' },{'date'=>'2002-04-07T04:58:26','version'=>'1.99_01' },{'date'=>'2002-06-02T03:05:50','version'=>'1.27' },{'date'=>'2002-06-02T03:27:13','version'=>'1.99_02' },{'date'=>'2002-06-15T23:59:37','version'=>'1.99_03' },{'date'=>'2002-06-21T22:45:41','version'=>'1.99_04' },{'date'=>'2002-08-20T16:54:13','version'=>'1.99_05' },{'date'=>'2002-09-27T15:19:03','version'=>'1.99_06' },{'date'=>'2002-09-27T19:41:50','version'=>'1.99_07' },{'date'=>'2003-01-11T04:22:19','version'=>'1.99_08' },{'date'=>'2003-04-28T02:36:59','version'=>'1.99_09' },{'date'=>'2003-07-03T03:32:20','version'=>'1.28' },{'date'=>'2003-09-29T17:11:24','version'=>'1.99_10' },{'date'=>'2003-10-08T04:54:22','version'=>'1.29' },{'date'=>'2003-11-10T21:04:15','version'=>'1.99_11' },{'date'=>'2003-12-22T19:56:22','version'=>'1.99_12' },{'date'=>'2004-03-09T00:29:43','version'=>'1.99_13' },{'date'=>'2004-05-21T18:02:49','version'=>'1.99_14' },{'date'=>'2004-08-20T18:35:12','version'=>'1.99_15' },{'date'=>'2004-08-23T05:59:47','version'=>'1.99_16' },{'date'=>'2004-10-22T21:38:19','version'=>'1.99_17' },{'date'=>'2004-12-12T23:22:37','version'=>'v2.0.0' },{'date'=>'2004-12-23T23:38:49','version'=>'v2.0.0' },{'date'=>'2005-01-06T01:27:43','version'=>'v2.0.0' },{'date'=>'2005-01-22T08:55:19','version'=>'v2.0.0' },{'date'=>'2005-04-14T13:19:23','version'=>'v2.0.0' },{'date'=>'2005-05-04T02:48:58','version'=>'v2.0.0' },{'date'=>'2005-05-20T05:12:45','version'=>'v2.0.0' },{'date'=>'2005-06-17T21:05:23','version'=>'v2.0.1' },{'date'=>'2005-10-21T01:27:23','version'=>'v2.0.2' },{'date'=>'2006-11-29T08:29:30','version'=>'v2.0.3' },{'date'=>'2007-03-30T06:19:02','version'=>'1.30' },{'date'=>'2008-04-17T06:32:36','version'=>'v2.0.4' },{'date'=>'2009-05-13T02:29:50','version'=>'1.31' },{'date'=>'2011-02-07T23:31:36','version'=>'v2.0.5' },{'date'=>'2012-04-25T15:31:27','version'=>'v2.0.6' },{'date'=>'2012-06-06T02:40:24','version'=>'v2.0.7' },{'date'=>'2013-04-18T02:15:56','version'=>'2.0.8' },{'date'=>'2015-06-18T21:16:34','version'=>'2.0.9' },{'date'=>'2016-10-27T21:16:36','version'=>'2.0.10' }]}},'module2dist'=>{'APR'=>'mod_perl','APR::Base64'=>'mod_perl','APR::Brigade'=>'mod_perl','APR::Bucket'=>'mod_perl','APR::BucketAlloc'=>'mod_perl','APR::BucketType'=>'mod_perl','APR::Const'=>'mod_perl','APR::Date'=>'mod_perl','APR::Error'=>'mod_perl','APR::Finfo'=>'mod_perl','APR::FunctionTable'=>'mod_perl','APR::IpSubnet'=>'mod_perl','APR::OS'=>'mod_perl','APR::PerlIO'=>'mod_perl','APR::Pool'=>'mod_perl','APR::Request'=>'libapreq2','APR::Request::Apache2'=>'libapreq2','APR::Request::CGI'=>'libapreq2','APR::Request::Cookie'=>'libapreq2','APR::Request::Error'=>'libapreq2','APR::Request::Param'=>'libapreq2','APR::SockAddr'=>'mod_perl','APR::Socket'=>'mod_perl','APR::Status'=>'mod_perl','APR::String'=>'mod_perl','APR::Table'=>'mod_perl','APR::ThreadMutex'=>'mod_perl','APR::ThreadRWLock'=>'mod_perl','APR::URI'=>'mod_perl','APR::UUID'=>'mod_perl','APR::Util'=>'mod_perl','APR::XSLoader'=>'mod_perl','Apache'=>'mod_perl','Apache2::Access'=>'mod_perl','Apache2::Build'=>'mod_perl','Apache2::CmdParms'=>'mod_perl','Apache2::Command'=>'mod_perl','Apache2::Connection'=>'mod_perl','Apache2::ConnectionUtil'=>'mod_perl','Apache2::ConstantsTable'=>'mod_perl','Apache2::Cookie'=>'libapreq2','Apache2::Directive'=>'mod_perl','Apache2::Filter'=>'mod_perl','Apache2::FilterRec'=>'mod_perl','Apache2::FunctionTable'=>'mod_perl','Apache2::HookRun'=>'mod_perl','Apache2::Log'=>'mod_perl','Apache2::MPM'=>'mod_perl','Apache2::Module'=>'mod_perl','Apache2::ParseSource'=>'mod_perl','Apache2::ParseSource::Scan'=>'mod_perl','Apache2::PerlSections'=>'mod_perl','Apache2::PerlSections::Dump'=>'mod_perl','Apache2::Process'=>'mod_perl','Apache2::Provider'=>'mod_perl','Apache2::Request'=>'libapreq2','Apache2::RequestIO'=>'mod_perl','Apache2::RequestRec'=>'mod_perl','Apache2::RequestUtil'=>'mod_perl','Apache2::Resource'=>'mod_perl','Apache2::Response'=>'mod_perl','Apache2::ServerRec'=>'mod_perl','Apache2::ServerUtil'=>'mod_perl','Apache2::SourceTables'=>'mod_perl','Apache2::Status'=>'mod_perl','Apache2::Status::_version'=>'mod_perl','Apache2::StructureTable'=>'mod_perl','Apache2::SubProcess'=>'mod_perl','Apache2::SubRequest'=>'mod_perl','Apache2::URI'=>'mod_perl','Apache2::Upload'=>'libapreq2','Apache2::Util'=>'mod_perl','Apache2::XSLoader'=>'mod_perl','Apache2::compat'=>'mod_perl','Apache2::porting'=>'mod_perl','Apache::AuthCAS'=>'Apache-AuthCAS','Apache::Connection'=>'mod_perl','Apache::Constants'=>'mod_perl','Apache::Constants::Exports'=>'mod_perl','Apache::Debug'=>'mod_perl','Apache::ExtUtils'=>'mod_perl','Apache::FakeRequest'=>'mod_perl','Apache::File'=>'mod_perl','Apache::Include'=>'mod_perl','Apache::Leak'=>'mod_perl','Apache::Log'=>'mod_perl','Apache::ModuleConfig'=>'mod_perl','Apache::Opcode'=>'mod_perl','Apache::Options'=>'mod_perl','Apache::PerlRun'=>'mod_perl','Apache::PerlRunXS'=>'mod_perl','Apache::PerlSections'=>'mod_perl','Apache::ReadConfig'=>'mod_perl','Apache::RedirectLogFix'=>'mod_perl','Apache::Registry'=>'mod_perl','Apache::RegistryBB'=>'mod_perl','Apache::RegistryLoader'=>'mod_perl','Apache::RegistryNG'=>'mod_perl','Apache::Resource'=>'mod_perl','Apache::SIG'=>'mod_perl','Apache::SOAP'=>'SOAP-Lite','Apache::Server'=>'mod_perl','Apache::SessionX'=>'Apache-SessionX','Apache::SessionX::Generate::MD5'=>'Apache-SessionX','Apache::SessionX::Manager'=>'Apache-SessionX','Apache::SessionX::Store::File'=>'Apache-SessionX','Apache::StatINC'=>'mod_perl','Apache::Status'=>'mod_perl','Apache::Symbol'=>'mod_perl','Apache::Symdump'=>'mod_perl','Apache::Table'=>'mod_perl','Apache::URI'=>'mod_perl','Apache::Util'=>'mod_perl','Apache::XMLRPC::Lite'=>'SOAP-Lite','Apache::fork'=>'mod_perl','Apache::httpd_conf'=>'mod_perl','Apache::src'=>'mod_perl','Apache::testold'=>'mod_perl','App::Cpan'=>'CPAN','App::Github::Email'=>'App-Github-Email','App::Packer::Backend::PAR'=>'PAR','App::Packer::PAR'=>'PAR-Packer','App::Packer::Temp'=>'PAR','Archive::Tar'=>'Archive-Tar','Archive::Tar::Constant'=>'Archive-Tar','Archive::Tar::File'=>'Archive-Tar','Archive::Tar::Std'=>'Archive-Tar','Archive::Tar::Std::_io'=>'Archive-Tar','Archive::Tar::Win32'=>'Archive-Tar','Archive::Tar::_io'=>'Archive-Tar','Archive::Zip'=>'Archive-Zip','Archive::Zip::Archive'=>'Archive-Zip','Archive::Zip::BufferedFileHandle'=>'Archive-Zip','Archive::Zip::DirectoryMember'=>'Archive-Zip','Archive::Zip::FileMember'=>'Archive-Zip','Archive::Zip::Member'=>'Archive-Zip','Archive::Zip::MemberRead'=>'Archive-Zip','Archive::Zip::MockFileHandle'=>'Archive-Zip','Archive::Zip::NewFileMember'=>'Archive-Zip','Archive::Zip::StringMember'=>'Archive-Zip','Archive::Zip::Tree'=>'Archive-Zip','Archive::Zip::ZipFileMember'=>'Archive-Zip','Bio::DB::GFF::Aggregator::match_gap'=>'GBrowse','Bio::DB::GFF::Aggregator::reftranscript'=>'GBrowse','Bio::DB::GFF::Aggregator::waba_alignment'=>'GBrowse','Bio::DB::GFF::Aggregator::wormbase_gene'=>'GBrowse','Bio::DB::SeqFeature::Store::Alias'=>'GBrowse','Bio::DB::SeqFeature::Store::Alias::Iterator'=>'GBrowse','Bio::DB::SeqFeature::Store::Alias::Segment'=>'GBrowse','Bio::DB::SeqFeature::Store::BedLoader'=>'GBrowse','Bio::DB::Tagger'=>'GBrowse','Bio::DB::Tagger::Iterator'=>'GBrowse','Bio::DB::Tagger::Tag'=>'GBrowse','Bio::DB::Tagger::mysql'=>'GBrowse','Bio::Graphics::Browser2'=>'GBrowse','Bio::Graphics::Browser2::Action'=>'GBrowse','Bio::Graphics::Browser2::AdminTracks'=>'GBrowse','Bio::Graphics::Browser2::AuthorizedFeatureFile'=>'GBrowse','Bio::Graphics::Browser2::CAlign'=>'GBrowse','Bio::Graphics::Browser2::CachedTrack'=>'GBrowse','Bio::Graphics::Browser2::DataBase'=>'GBrowse','Bio::Graphics::Browser2::DataLoader'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::archive'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::bam'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::bed'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::bigbed'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::bigwig'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::featurefile'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::generic'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::gff'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::gff3'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::sam'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::useq'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::wig2bigwig'=>'GBrowse','Bio::Graphics::Browser2::DataLoader::wiggle'=>'GBrowse','Bio::Graphics::Browser2::DataSource'=>'GBrowse','Bio::Graphics::Browser2::ExternalData'=>'GBrowse','Bio::Graphics::Browser2::GFFhelper'=>'GBrowse','Bio::Graphics::Browser2::I18n'=>'GBrowse','Bio::Graphics::Browser2::Markup'=>'GBrowse','Bio::Graphics::Browser2::MetaDB'=>'GBrowse','Bio::Graphics::Browser2::MetaSegment'=>'GBrowse','Bio::Graphics::Browser2::MetaSegment::Iterator'=>'GBrowse','Bio::Graphics::Browser2::OptionPick'=>'GBrowse','Bio::Graphics::Browser2::PadAlignment'=>'GBrowse','Bio::Graphics::Browser2::Plugin'=>'GBrowse','Bio::Graphics::Browser2::Plugin::AuthPlugin'=>'GBrowse','Bio::Graphics::Browser2::PluginSet'=>'GBrowse','Bio::Graphics::Browser2::Realign'=>'GBrowse','Bio::Graphics::Browser2::Region'=>'GBrowse','Bio::Graphics::Browser2::RegionSearch'=>'GBrowse','Bio::Graphics::Browser2::RemoteSet'=>'GBrowse','Bio::Graphics::Browser2::Render'=>'GBrowse','Bio::Graphics::Browser2::Render::HTML'=>'GBrowse','Bio::Graphics::Browser2::Render::HTML::TrackListing'=>'GBrowse','Bio::Graphics::Browser2::Render::HTML::TrackListing::Categories'=>'GBrowse','Bio::Graphics::Browser2::Render::Login'=>'GBrowse','Bio::Graphics::Browser2::Render::Slave'=>'GBrowse','Bio::Graphics::Browser2::Render::Slave::AWS_Balancer'=>'GBrowse','Bio::Graphics::Browser2::Render::Slave::StagingServer'=>'GBrowse','Bio::Graphics::Browser2::Render::Slave::Status'=>'GBrowse','Bio::Graphics::Browser2::Render::SnapshotManager'=>'GBrowse','Bio::Graphics::Browser2::Render::TrackConfig'=>'GBrowse','Bio::Graphics::Browser2::RenderPanels'=>'GBrowse','Bio::Graphics::Browser2::SendMail'=>'GBrowse','Bio::Graphics::Browser2::Session'=>'GBrowse','Bio::Graphics::Browser2::Shellwords'=>'GBrowse','Bio::Graphics::Browser2::SubtrackTable'=>'GBrowse','Bio::Graphics::Browser2::TrackDumper'=>'GBrowse','Bio::Graphics::Browser2::TrackDumper::RichSeqMaker'=>'GBrowse','Bio::Graphics::Browser2::UserConf'=>'GBrowse','Bio::Graphics::Browser2::UserDB'=>'GBrowse','Bio::Graphics::Browser2::UserTracks'=>'GBrowse','Bio::Graphics::Browser2::UserTracks::Database'=>'GBrowse','Bio::Graphics::Browser2::UserTracks::Filesystem'=>'GBrowse','Bio::Graphics::Browser2::Util'=>'GBrowse','Bio::Graphics::GBrowseFeature'=>'GBrowse','Bio::Graphics::Karyotype'=>'GBrowse','Bio::Graphics::Wiggle::Loader::Nosample'=>'GBrowse','Bundle::Apache'=>'mod_perl','Bundle::Apache2'=>'mod_perl','Bundle::DBD::mysql'=>'DBD-mysql','Bundle::DBI'=>'DBI','Bundle::LWP'=>'libwww-perl','CBC'=>'Crypt-CBC','CGI'=>'CGI','CGI::Application::Dispatch'=>'CGI-Application-Dispatch','CGI::Application::Dispatch::PSGI'=>'CGI-Application-Dispatch','CGI::Application::Dispatch::Regexp'=>'CGI-Application-Dispatch','CGI::Application::Plugin::AutoRunmode'=>'CGI-Application-Plugin-AutoRunmode','CGI::Application::Plugin::AutoRunmode::FileDelegate'=>'CGI-Application-Plugin-AutoRunmode','CGI::Application::Plugin::RunmodeDeclare'=>'CGI-Application-Plugin-RunmodeDeclare','CGI::Auth::Basic'=>'CGI-Auth-Basic','CGI::Carp'=>'CGI','CGI::Cookie'=>'CGI','CGI::File::Temp'=>'CGI','CGI::HTML::Functions'=>'CGI','CGI::MultipartBuffer'=>'CGI','CGI::Pretty'=>'CGI','CGI::Push'=>'CGI','CGI::Simple'=>'CGI-Simple','CGI::Simple::Cookie'=>'CGI-Simple','CGI::Simple::Standard'=>'CGI-Simple','CGI::Simple::Util'=>'CGI-Simple','CGI::Toggle'=>'GBrowse','CGI::Util'=>'CGI','CGI::apacheSSI'=>'CGI-apacheSSI','CGI::apacheSSI::Gmt'=>'CGI-apacheSSI','CGI::apacheSSI::LMOD'=>'CGI-apacheSSI','CGI::apacheSSI::Local'=>'CGI-apacheSSI','CGI::mod_perl'=>'mod_perl','CPAN'=>'CPAN','CPAN::Admin'=>'CPAN','CPAN::Author'=>'CPAN','CPAN::Bundle'=>'CPAN','CPAN::CacheMgr'=>'CPAN','CPAN::Complete'=>'CPAN','CPAN::Debug'=>'CPAN','CPAN::DeferredCode'=>'CPAN','CPAN::Distribution'=>'CPAN','CPAN::Distroprefs'=>'CPAN','CPAN::Distroprefs::Iterator'=>'CPAN','CPAN::Distroprefs::Pref'=>'CPAN','CPAN::Distroprefs::Result'=>'CPAN','CPAN::Distroprefs::Result::Error'=>'CPAN','CPAN::Distroprefs::Result::Fatal'=>'CPAN','CPAN::Distroprefs::Result::Success'=>'CPAN','CPAN::Distroprefs::Result::Warning'=>'CPAN','CPAN::Distrostatus'=>'CPAN','CPAN::Eval'=>'CPAN','CPAN::Exception::RecursiveDependency'=>'CPAN','CPAN::Exception::RecursiveDependency::na'=>'CPAN','CPAN::Exception::blocked_urllist'=>'CPAN','CPAN::Exception::yaml_not_installed'=>'CPAN','CPAN::Exception::yaml_process_error'=>'CPAN','CPAN::FTP'=>'CPAN','CPAN::FTP::netrc'=>'CPAN','CPAN::FirstTime'=>'CPAN','CPAN::HTTP::Client'=>'CPAN','CPAN::HTTP::Credentials'=>'CPAN','CPAN::HandleConfig'=>'CPAN','CPAN::Index'=>'CPAN','CPAN::InfoObj'=>'CPAN','CPAN::Kwalify'=>'CPAN','CPAN::LWP::UserAgent'=>'CPAN','CPAN::Mirrored::By'=>'CPAN','CPAN::Mirrors'=>'CPAN','CPAN::Module'=>'CPAN','CPAN::Nox'=>'CPAN','CPAN::Plugin'=>'CPAN','CPAN::Plugin::Specfile'=>'CPAN','CPAN::Prompt'=>'CPAN','CPAN::Queue'=>'CPAN','CPAN::Queue::Item'=>'CPAN','CPAN::Shell'=>'CPAN','CPAN::Tarzip'=>'CPAN','CPAN::URL'=>'CPAN','CPAN::Version'=>'CPAN','Catalyst'=>'Catalyst-Runtime','Catalyst::Action'=>'Catalyst-Runtime','Catalyst::ActionChain'=>'Catalyst-Runtime','Catalyst::ActionContainer'=>'Catalyst-Runtime','Catalyst::ActionRole::ConsumesContent'=>'Catalyst-Runtime','Catalyst::ActionRole::HTTPMethods'=>'Catalyst-Runtime','Catalyst::ActionRole::QueryMatching'=>'Catalyst-Runtime','Catalyst::ActionRole::Scheme'=>'Catalyst-Runtime','Catalyst::Authentication::Store::LDAP'=>'Catalyst-Authentication-Store-LDAP','Catalyst::Authentication::Store::LDAP::Backend'=>'Catalyst-Authentication-Store-LDAP','Catalyst::Authentication::Store::LDAP::User'=>'Catalyst-Authentication-Store-LDAP','Catalyst::Base'=>'Catalyst-Runtime','Catalyst::ClassData'=>'Catalyst-Runtime','Catalyst::Component'=>'Catalyst-Runtime','Catalyst::Component::ApplicationAttribute'=>'Catalyst-Runtime','Catalyst::Component::ContextClosure'=>'Catalyst-Runtime','Catalyst::Controller'=>'Catalyst-Runtime','Catalyst::Controller::Combine'=>'Catalyst-Controller-Combine','Catalyst::DispatchType'=>'Catalyst-Runtime','Catalyst::DispatchType::Chained'=>'Catalyst-Runtime','Catalyst::DispatchType::Default'=>'Catalyst-Runtime','Catalyst::DispatchType::Index'=>'Catalyst-Runtime','Catalyst::DispatchType::Path'=>'Catalyst-Runtime','Catalyst::Dispatcher'=>'Catalyst-Runtime','Catalyst::Engine'=>'Catalyst-Runtime','Catalyst::Engine::CGI'=>'Catalyst-Runtime','Catalyst::Engine::FastCGI'=>'Catalyst-Runtime','Catalyst::Engine::HTTP'=>'Catalyst-Runtime','Catalyst::Engine::HTTP::Restarter'=>'Catalyst-Runtime','Catalyst::Engine::HTTP::Restarter::Watcher'=>'Catalyst-Runtime','Catalyst::EngineLoader'=>'Catalyst-Runtime','Catalyst::Exception'=>'Catalyst-Runtime','Catalyst::Exception::Base'=>'Catalyst-Runtime','Catalyst::Exception::Basic'=>'Catalyst-Runtime','Catalyst::Exception::Detach'=>'Catalyst-Runtime','Catalyst::Exception::Go'=>'Catalyst-Runtime','Catalyst::Exception::Interface'=>'Catalyst-Runtime','Catalyst::Helper::Controller::Combine'=>'Catalyst-Controller-Combine','Catalyst::Log'=>'Catalyst-Runtime','Catalyst::Middleware::Stash'=>'Catalyst-Runtime','Catalyst::Model'=>'Catalyst-Runtime','Catalyst::Plugin::Static'=>'Catalyst-Plugin-Static','Catalyst::Plugin::Unicode::Encoding'=>'Catalyst-Runtime','Catalyst::Request'=>'Catalyst-Runtime','Catalyst::Request::PartData'=>'Catalyst-Runtime','Catalyst::Request::Upload'=>'Catalyst-Runtime','Catalyst::Response'=>'Catalyst-Runtime','Catalyst::Response::Writer'=>'Catalyst-Runtime','Catalyst::Runtime'=>'Catalyst-Runtime','Catalyst::Script::CGI'=>'Catalyst-Runtime','Catalyst::Script::Create'=>'Catalyst-Runtime','Catalyst::Script::FastCGI'=>'Catalyst-Runtime','Catalyst::Script::Server'=>'Catalyst-Runtime','Catalyst::Script::Test'=>'Catalyst-Runtime','Catalyst::ScriptRole'=>'Catalyst-Runtime','Catalyst::ScriptRunner'=>'Catalyst-Runtime','Catalyst::Stats'=>'Catalyst-Runtime','Catalyst::Test'=>'Catalyst-Runtime','Catalyst::Utils'=>'Catalyst-Runtime','Catalyst::View'=>'Catalyst-Runtime','CatalystX::Controller::OpenSearch'=>'Search-OpenSearch-Server','Cmd::Dwarf'=>'Cmd-Dwarf','Compress::LZ4'=>'Compress-LZ4','Compress::Raw::Bunzip2'=>'Compress-Raw-Bzip2','Compress::Raw::Bzip2'=>'Compress-Raw-Bzip2','Compress::Raw::Zlib'=>'Compress-Raw-Zlib','Config::Model'=>'Config-Model','Config::Model::Annotation'=>'Config-Model','Config::Model::AnyId'=>'Config-Model','Config::Model::AnyThing'=>'Config-Model','Config::Model::Backend::Any'=>'Config-Model','Config::Model::Backend::CdsFile'=>'Config-Model','Config::Model::Backend::Fstab'=>'Config-Model','Config::Model::Backend::IniFile'=>'Config-Model','Config::Model::Backend::Json'=>'Config-Model','Config::Model::Backend::PerlFile'=>'Config-Model','Config::Model::Backend::PlainFile'=>'Config-Model','Config::Model::Backend::ShellVar'=>'Config-Model','Config::Model::BackendMgr'=>'Config-Model','Config::Model::BackendTrackOrder'=>'Config-Model','Config::Model::CheckList'=>'Config-Model','Config::Model::DeprecatedHandle'=>'Config-Model','Config::Model::Describe'=>'Config-Model','Config::Model::DumpAsData'=>'Config-Model','Config::Model::Dumper'=>'Config-Model','Config::Model::Exception'=>'Config-Model','Config::Model::Exception::AncestorClass'=>'Config-Model','Config::Model::Exception::Any'=>'Config-Model','Config::Model::Exception::ConfigFile'=>'Config-Model','Config::Model::Exception::ConfigFile::Missing'=>'Config-Model','Config::Model::Exception::Fatal'=>'Config-Model','Config::Model::Exception::Formula'=>'Config-Model','Config::Model::Exception::Internal'=>'Config-Model','Config::Model::Exception::Load'=>'Config-Model','Config::Model::Exception::LoadData'=>'Config-Model','Config::Model::Exception::Model'=>'Config-Model','Config::Model::Exception::ModelDeclaration'=>'Config-Model','Config::Model::Exception::ObsoleteElement'=>'Config-Model','Config::Model::Exception::Syntax'=>'Config-Model','Config::Model::Exception::UnavailableElement'=>'Config-Model','Config::Model::Exception::UnknownElement'=>'Config-Model','Config::Model::Exception::UnknownId'=>'Config-Model','Config::Model::Exception::User'=>'Config-Model','Config::Model::Exception::WarpError'=>'Config-Model','Config::Model::Exception::WrongType'=>'Config-Model','Config::Model::Exception::WrongValue'=>'Config-Model','Config::Model::FuseUI'=>'Config-Model','Config::Model::HashId'=>'Config-Model','Config::Model::IdElementReference'=>'Config-Model','Config::Model::Instance'=>'Config-Model','Config::Model::Iterator'=>'Config-Model','Config::Model::ListId'=>'Config-Model','Config::Model::Lister'=>'Config-Model','Config::Model::Loader'=>'Config-Model','Config::Model::Node'=>'Config-Model','Config::Model::ObjTreeScanner'=>'Config-Model','Config::Model::Report'=>'Config-Model','Config::Model::Role::ComputeFunction'=>'Config-Model','Config::Model::Role::FileHandler'=>'Config-Model','Config::Model::Role::Grab'=>'Config-Model','Config::Model::Role::HelpAsText'=>'Config-Model','Config::Model::Role::NodeLoader'=>'Config-Model','Config::Model::Role::WarpMaster'=>'Config-Model','Config::Model::SearchElement'=>'Config-Model','Config::Model::SimpleUI'=>'Config-Model','Config::Model::TermUI'=>'Config-Model','Config::Model::TreeSearcher'=>'Config-Model','Config::Model::Utils::GenClassPod'=>'Config-Model','Config::Model::Value'=>'Config-Model','Config::Model::Value::LayeredInclude'=>'Config-Model','Config::Model::ValueComputer'=>'Config-Model','Config::Model::WarpedNode'=>'Config-Model','Config::Model::Warper'=>'Config-Model','Cpanel::JSON::XS'=>'Cpanel-JSON-XS','Cpanel::JSON::XS::Type'=>'Cpanel-JSON-XS','Crypt::CBC'=>'Crypt-CBC','Crypt::OpenSSL::DSA'=>'Crypt-OpenSSL-DSA','Crypt::Passwd::XS'=>'Crypt-Passwd-XS','Cwd'=>'PathTools','DBD::DBM'=>'DBI','DBD::DBM::Statement'=>'DBI','DBD::DBM::Table'=>'DBI','DBD::DBM::db'=>'DBI','DBD::DBM::dr'=>'DBI','DBD::DBM::st'=>'DBI','DBD::ExampleP'=>'DBI','DBD::ExampleP::db'=>'DBI','DBD::ExampleP::dr'=>'DBI','DBD::ExampleP::st'=>'DBI','DBD::File'=>'DBI','DBD::File::DataSource::File'=>'DBI','DBD::File::DataSource::Stream'=>'DBI','DBD::File::Statement'=>'DBI','DBD::File::Table'=>'DBI','DBD::File::TableSource::FileSystem'=>'DBI','DBD::File::db'=>'DBI','DBD::File::dr'=>'DBI','DBD::File::st'=>'DBI','DBD::Gofer'=>'DBI','DBD::Gofer::Policy::Base'=>'DBI','DBD::Gofer::Policy::classic'=>'DBI','DBD::Gofer::Policy::pedantic'=>'DBI','DBD::Gofer::Policy::rush'=>'DBI','DBD::Gofer::Transport::Base'=>'DBI','DBD::Gofer::Transport::corostream'=>'DBI','DBD::Gofer::Transport::null'=>'DBI','DBD::Gofer::Transport::pipeone'=>'DBI','DBD::Gofer::Transport::stream'=>'DBI','DBD::Gofer::db'=>'DBI','DBD::Gofer::dr'=>'DBI','DBD::Gofer::st'=>'DBI','DBD::MariaDB'=>'DBD-MariaDB','DBD::Mem'=>'DBI','DBD::Mem::DataSource'=>'DBI','DBD::Mem::Statement'=>'DBI','DBD::Mem::Table'=>'DBI','DBD::Mem::db'=>'DBI','DBD::Mem::dr'=>'DBI','DBD::Mem::st'=>'DBI','DBD::NullP'=>'DBI','DBD::NullP::db'=>'DBI','DBD::NullP::dr'=>'DBI','DBD::NullP::st'=>'DBI','DBD::Proxy'=>'DBI','DBD::Proxy::RPC::PlClient'=>'DBI','DBD::Proxy::db'=>'DBI','DBD::Proxy::dr'=>'DBI','DBD::Proxy::st'=>'DBI','DBD::Sponge'=>'DBI','DBD::Sponge::db'=>'DBI','DBD::Sponge::dr'=>'DBI','DBD::Sponge::st'=>'DBI','DBD::mysql'=>'DBD-mysql','DBD::mysql::GetInfo'=>'DBD-mysql','DBD::mysql::db'=>'DBD-mysql','DBD::mysql::dr'=>'DBD-mysql','DBD::mysql::st'=>'DBD-mysql','DBD::mysqlPP'=>'DBD-mysqlPP','DBD::mysqlPP::db'=>'DBD-mysqlPP','DBD::mysqlPP::dr'=>'DBD-mysqlPP','DBD::mysqlPP::st'=>'DBD-mysqlPP','DBDI'=>'DBI','DBI'=>'DBI','DBI::Const::GetInfo::ANSI'=>'DBI','DBI::Const::GetInfo::ODBC'=>'DBI','DBI::Const::GetInfoReturn'=>'DBI','DBI::Const::GetInfoType'=>'DBI','DBI::DBD'=>'DBI','DBI::DBD::Metadata'=>'DBI','DBI::DBD::SqlEngine'=>'DBI','DBI::DBD::SqlEngine::DataSource'=>'DBI','DBI::DBD::SqlEngine::Statement'=>'DBI','DBI::DBD::SqlEngine::Table'=>'DBI','DBI::DBD::SqlEngine::TableSource'=>'DBI','DBI::DBD::SqlEngine::TieMeta'=>'DBI','DBI::DBD::SqlEngine::TieTables'=>'DBI','DBI::DBD::SqlEngine::db'=>'DBI','DBI::DBD::SqlEngine::dr'=>'DBI','DBI::DBD::SqlEngine::st'=>'DBI','DBI::FAQ'=>'DBI','DBI::Gofer::Execute'=>'DBI','DBI::Gofer::Request'=>'DBI','DBI::Gofer::Response'=>'DBI','DBI::Gofer::Serializer::Base'=>'DBI','DBI::Gofer::Serializer::DataDumper'=>'DBI','DBI::Gofer::Serializer::Storable'=>'DBI','DBI::Gofer::Transport::Base'=>'DBI','DBI::Gofer::Transport::pipeone'=>'DBI','DBI::Gofer::Transport::stream'=>'DBI','DBI::Profile'=>'DBI','DBI::ProfileData'=>'DBI','DBI::ProfileDumper'=>'DBI','DBI::ProfileDumper::Apache'=>'DBI','DBI::ProfileSubs'=>'DBI','DBI::ProxyServer'=>'DBI','DBI::ProxyServer::db'=>'DBI','DBI::ProxyServer::dr'=>'DBI','DBI::ProxyServer::st'=>'DBI','DBI::SQL::Nano'=>'DBI','DBI::SQL::Nano::Statement_'=>'DBI','DBI::SQL::Nano::Table_'=>'DBI','DBI::Util::CacheMemory'=>'DBI','DBI::Util::_accessor'=>'DBI','DBI::common'=>'DBI','DBIx::Custom'=>'DBIx-Custom','DBIx::Custom::Mapper'=>'DBIx-Custom','DBIx::Custom::Model'=>'DBIx-Custom','DBIx::Custom::NotExists'=>'DBIx-Custom','DBIx::Custom::Order'=>'DBIx-Custom','DBIx::Custom::Query'=>'DBIx-Custom','DBIx::Custom::QueryBuilder'=>'DBIx-Custom','DBIx::Custom::Result'=>'DBIx-Custom','DBIx::Custom::Tag'=>'DBIx-Custom','DBIx::Custom::Util'=>'DBIx-Custom','DBIx::Custom::Where'=>'DBIx-Custom','DBIx::Otogiri'=>'Otogiri','DBIx::Otogiri::Iterator'=>'Otogiri','Dancer'=>'Dancer','Dancer2'=>'Dancer2','Dancer2::CLI'=>'Dancer2','Dancer2::CLI::Command::gen'=>'Dancer2','Dancer2::CLI::Command::version'=>'Dancer2','Dancer2::Core'=>'Dancer2','Dancer2::Core::App'=>'Dancer2','Dancer2::Core::Cookie'=>'Dancer2','Dancer2::Core::DSL'=>'Dancer2','Dancer2::Core::Dispatcher'=>'Dancer2','Dancer2::Core::Error'=>'Dancer2','Dancer2::Core::Factory'=>'Dancer2','Dancer2::Core::HTTP'=>'Dancer2','Dancer2::Core::Hook'=>'Dancer2','Dancer2::Core::MIME'=>'Dancer2','Dancer2::Core::Request'=>'Dancer2','Dancer2::Core::Request::Upload'=>'Dancer2','Dancer2::Core::Response'=>'Dancer2','Dancer2::Core::Response::Delayed'=>'Dancer2','Dancer2::Core::Role::ConfigReader'=>'Dancer2','Dancer2::Core::Role::DSL'=>'Dancer2','Dancer2::Core::Role::Engine'=>'Dancer2','Dancer2::Core::Role::Handler'=>'Dancer2','Dancer2::Core::Role::HasLocation'=>'Dancer2','Dancer2::Core::Role::Hookable'=>'Dancer2','Dancer2::Core::Role::Logger'=>'Dancer2','Dancer2::Core::Role::Serializer'=>'Dancer2','Dancer2::Core::Role::SessionFactory'=>'Dancer2','Dancer2::Core::Role::SessionFactory::File'=>'Dancer2','Dancer2::Core::Role::StandardResponses'=>'Dancer2','Dancer2::Core::Role::Template'=>'Dancer2','Dancer2::Core::Route'=>'Dancer2','Dancer2::Core::Runner'=>'Dancer2','Dancer2::Core::Session'=>'Dancer2','Dancer2::Core::Time'=>'Dancer2','Dancer2::Core::Types'=>'Dancer2','Dancer2::FileUtils'=>'Dancer2','Dancer2::Handler::AutoPage'=>'Dancer2','Dancer2::Handler::File'=>'Dancer2','Dancer2::Logger::Capture'=>'Dancer2','Dancer2::Logger::Capture::Trap'=>'Dancer2','Dancer2::Logger::Console'=>'Dancer2','Dancer2::Logger::Diag'=>'Dancer2','Dancer2::Logger::File'=>'Dancer2','Dancer2::Logger::Note'=>'Dancer2','Dancer2::Logger::Null'=>'Dancer2','Dancer2::Plugin'=>'Dancer2','Dancer2::Serializer::Dumper'=>'Dancer2','Dancer2::Serializer::JSON'=>'Dancer2','Dancer2::Serializer::Mutable'=>'Dancer2','Dancer2::Serializer::YAML'=>'Dancer2','Dancer2::Session::Simple'=>'Dancer2','Dancer2::Session::YAML'=>'Dancer2','Dancer2::Template::Implementation::ForkedTiny'=>'Dancer2','Dancer2::Template::Simple'=>'Dancer2','Dancer2::Template::TemplateToolkit'=>'Dancer2','Dancer2::Template::Tiny'=>'Dancer2','Dancer2::Test'=>'Dancer2','Dancer::App'=>'Dancer','Dancer::Config'=>'Dancer','Dancer::Config::Object'=>'Dancer','Dancer::Continuation'=>'Dancer','Dancer::Continuation::Halted'=>'Dancer','Dancer::Continuation::Route'=>'Dancer','Dancer::Continuation::Route::ErrorSent'=>'Dancer','Dancer::Continuation::Route::FileSent'=>'Dancer','Dancer::Continuation::Route::Forwarded'=>'Dancer','Dancer::Continuation::Route::Passed'=>'Dancer','Dancer::Continuation::Route::Templated'=>'Dancer','Dancer::Cookie'=>'Dancer','Dancer::Cookies'=>'Dancer','Dancer::Deprecation'=>'Dancer','Dancer::Engine'=>'Dancer','Dancer::Error'=>'Dancer','Dancer::Exception'=>'Dancer','Dancer::Exception::Base'=>'Dancer','Dancer::Exceptions'=>'Dancer','Dancer::Factory::Hook'=>'Dancer','Dancer::FileUtils'=>'Dancer','Dancer::GetOpt'=>'Dancer','Dancer::HTTP'=>'Dancer','Dancer::Handler'=>'Dancer','Dancer::Handler::Debug'=>'Dancer','Dancer::Handler::PSGI'=>'Dancer','Dancer::Handler::Standalone'=>'Dancer','Dancer::Hook'=>'Dancer','Dancer::Hook::Properties'=>'Dancer','Dancer::Logger'=>'Dancer','Dancer::Logger::Abstract'=>'Dancer','Dancer::Logger::Capture'=>'Dancer','Dancer::Logger::Capture::Trap'=>'Dancer','Dancer::Logger::Console'=>'Dancer','Dancer::Logger::Diag'=>'Dancer','Dancer::Logger::File'=>'Dancer','Dancer::Logger::Note'=>'Dancer','Dancer::Logger::Null'=>'Dancer','Dancer::MIME'=>'Dancer','Dancer::ModuleLoader'=>'Dancer','Dancer::Object'=>'Dancer','Dancer::Object::Singleton'=>'Dancer','Dancer::Plugin'=>'Dancer','Dancer::Plugin::Ajax'=>'Dancer','Dancer::Renderer'=>'Dancer','Dancer::Request'=>'Dancer','Dancer::Request::Upload'=>'Dancer','Dancer::Response'=>'Dancer','Dancer::Route'=>'Dancer','Dancer::Route::Cache'=>'Dancer','Dancer::Route::Registry'=>'Dancer','Dancer::Serializer'=>'Dancer','Dancer::Serializer::Abstract'=>'Dancer','Dancer::Serializer::Dumper'=>'Dancer','Dancer::Serializer::JSON'=>'Dancer','Dancer::Serializer::JSONP'=>'Dancer','Dancer::Serializer::Mutable'=>'Dancer','Dancer::Serializer::XML'=>'Dancer','Dancer::Serializer::YAML'=>'Dancer','Dancer::Session'=>'Dancer','Dancer::Session::Abstract'=>'Dancer','Dancer::Session::Simple'=>'Dancer','Dancer::Session::YAML'=>'Dancer','Dancer::SharedData'=>'Dancer','Dancer::Template'=>'Dancer','Dancer::Template::Abstract'=>'Dancer','Dancer::Template::Simple'=>'Dancer','Dancer::Template::TemplateToolkit'=>'Dancer','Dancer::Test'=>'Dancer','Dancer::Timer'=>'Dancer','Data::Dumper'=>'Data-Dumper','Dezi'=>'Dezi','Dezi::Config'=>'Dezi','Dezi::Server'=>'Dezi','Dezi::Server::About'=>'Dezi','Dwarf'=>'Cmd-Dwarf','Email::Address'=>'Email-Address','Encode'=>'Encode','Encode::Alias'=>'Encode','Encode::Byte'=>'Encode','Encode::CJKConstants'=>'Encode','Encode::CN'=>'Encode','Encode::CN::HZ'=>'Encode','Encode::Config'=>'Encode','Encode::EBCDIC'=>'Encode','Encode::Encoder'=>'Encode','Encode::Encoding'=>'Encode','Encode::GSM0338'=>'Encode','Encode::Guess'=>'Encode','Encode::Internal'=>'Encode','Encode::JP'=>'Encode','Encode::JP::H2Z'=>'Encode','Encode::JP::JIS7'=>'Encode','Encode::KR'=>'Encode','Encode::KR::2022_KR'=>'Encode','Encode::MIME::Header'=>'Encode','Encode::MIME::Header::ISO_2022_JP'=>'Encode','Encode::MIME::Name'=>'Encode','Encode::Symbol'=>'Encode','Encode::TW'=>'Encode','Encode::UTF_EBCDIC'=>'Encode','Encode::Unicode'=>'Encode','Encode::Unicode::UTF7'=>'Encode','Encode::XS'=>'Encode','Encode::utf8'=>'Encode','ExtUtils::Command'=>'ExtUtils-MakeMaker','ExtUtils::Command::MM'=>'ExtUtils-MakeMaker','ExtUtils::Liblist'=>'ExtUtils-MakeMaker','ExtUtils::Liblist::Kid'=>'ExtUtils-MakeMaker','ExtUtils::MM'=>'ExtUtils-MakeMaker','ExtUtils::MM_AIX'=>'ExtUtils-MakeMaker','ExtUtils::MM_Any'=>'ExtUtils-MakeMaker','ExtUtils::MM_BeOS'=>'ExtUtils-MakeMaker','ExtUtils::MM_Cygwin'=>'ExtUtils-MakeMaker','ExtUtils::MM_DOS'=>'ExtUtils-MakeMaker','ExtUtils::MM_Darwin'=>'ExtUtils-MakeMaker','ExtUtils::MM_MacOS'=>'ExtUtils-MakeMaker','ExtUtils::MM_NW5'=>'ExtUtils-MakeMaker','ExtUtils::MM_OS2'=>'ExtUtils-MakeMaker','ExtUtils::MM_QNX'=>'ExtUtils-MakeMaker','ExtUtils::MM_UWIN'=>'ExtUtils-MakeMaker','ExtUtils::MM_Unix'=>'ExtUtils-MakeMaker','ExtUtils::MM_VMS'=>'ExtUtils-MakeMaker','ExtUtils::MM_VOS'=>'ExtUtils-MakeMaker','ExtUtils::MM_Win32'=>'ExtUtils-MakeMaker','ExtUtils::MM_Win95'=>'ExtUtils-MakeMaker','ExtUtils::MY'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::Config'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::Locale'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::_version'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::charstar'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::version'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::version::regex'=>'ExtUtils-MakeMaker','ExtUtils::MakeMaker::version::vpp'=>'ExtUtils-MakeMaker','ExtUtils::Mkbootstrap'=>'ExtUtils-MakeMaker','ExtUtils::Mksymlists'=>'ExtUtils-MakeMaker','ExtUtils::testlib'=>'ExtUtils-MakeMaker','FCGI'=>'FCGI','FCGI::Stream'=>'FCGI','Fake::Encode'=>'Fake-Encode','Fake::Our'=>'Fake-Our','FakeHomol'=>'GBrowse','Fh'=>'CGI','File::DataClass'=>'File-DataClass','File::DataClass::Cache'=>'File-DataClass','File::DataClass::Constants'=>'File-DataClass','File::DataClass::Exception'=>'File-DataClass','File::DataClass::Functions'=>'File-DataClass','File::DataClass::IO'=>'File-DataClass','File::DataClass::List'=>'File-DataClass','File::DataClass::Result'=>'File-DataClass','File::DataClass::ResultSet'=>'File-DataClass','File::DataClass::ResultSource'=>'File-DataClass','File::DataClass::Schema'=>'File-DataClass','File::DataClass::Storage'=>'File-DataClass','File::DataClass::Storage::Any'=>'File-DataClass','File::DataClass::Storage::JSON'=>'File-DataClass','File::DataClass::Types'=>'File-DataClass','File::Path'=>'File-Path','File::Spec'=>'PathTools','File::Spec::AmigaOS'=>'PathTools','File::Spec::Cygwin'=>'PathTools','File::Spec::Epoc'=>'PathTools','File::Spec::Functions'=>'PathTools','File::Spec::Mac'=>'PathTools','File::Spec::OS2'=>'PathTools','File::Spec::Unix'=>'PathTools','File::Spec::VMS'=>'PathTools','File::Spec::Win32'=>'PathTools','HTML::Perlinfo'=>'HTML-Perlinfo','HTML::Perlinfo::Apache'=>'HTML-Perlinfo','HTML::Perlinfo::Base'=>'HTML-Perlinfo','HTML::Perlinfo::Common'=>'HTML-Perlinfo','HTML::Perlinfo::General'=>'HTML-Perlinfo','HTML::Perlinfo::Loaded'=>'HTML-Perlinfo','HTML::Perlinfo::Modules'=>'HTML-Perlinfo','HTML::Perlinfo::_version'=>'HTML-Perlinfo','HTML::Scrubber'=>'HTML-Scrubber','HTTP::Body'=>'HTTP-Body','HTTP::Body::MultiPart'=>'HTTP-Body','HTTP::Body::OctetStream'=>'HTTP-Body','HTTP::Body::UrlEncoded'=>'HTTP-Body','HTTP::Body::XForms'=>'HTTP-Body','HTTP::Body::XFormsMultipart'=>'HTTP-Body','HTTP::Session2'=>'HTTP-Session2','HTTP::Session2::Base'=>'HTTP-Session2','HTTP::Session2::ClientStore'=>'HTTP-Session2','HTTP::Session2::ClientStore2'=>'HTTP-Session2','HTTP::Session2::Expired'=>'HTTP-Session2','HTTP::Session2::Random'=>'HTTP-Session2','HTTP::Session2::ServerStore'=>'HTTP-Session2','HTTP::Tiny'=>'HTTP-Tiny','HTTP::Tiny::NoProxy'=>'Dancer','Imager'=>'Imager','Imager::Color'=>'Imager','Imager::Color::Float'=>'Imager','Imager::Color::Table'=>'Imager','Imager::CountColor'=>'Imager','Imager::Expr'=>'Imager','Imager::Expr::Assem'=>'Imager','Imager::Expr::Infix'=>'Imager','Imager::Expr::Postfix'=>'Imager','Imager::ExtUtils'=>'Imager','Imager::FORMATS'=>'Imager','Imager::File::CUR'=>'Imager','Imager::File::ICO'=>'Imager','Imager::File::SGI'=>'Imager','Imager::Fill'=>'Imager','Imager::Filter::DynTest'=>'Imager','Imager::Filter::Flines'=>'Imager','Imager::Filter::Mandelbrot'=>'Imager','Imager::Font'=>'Imager','Imager::Font::BBox'=>'Imager','Imager::Font::FreeType2'=>'Imager','Imager::Font::Image'=>'Imager','Imager::Font::Test'=>'Imager','Imager::Font::Truetype'=>'Imager','Imager::Font::Type1'=>'Imager','Imager::Font::Wrap'=>'Imager','Imager::Fountain'=>'Imager','Imager::IO'=>'Imager','Imager::Matrix2d'=>'Imager','Imager::Preprocess'=>'Imager','Imager::Probe'=>'Imager','Imager::Regops'=>'Imager','Imager::Test'=>'Imager','Imager::Test::OverUtf8'=>'Imager','Imager::Transform'=>'Imager','LRUCache'=>'GBrowse','LWP'=>'libwww-perl','LWP::Authen::Basic'=>'libwww-perl','LWP::Authen::Digest'=>'libwww-perl','LWP::Authen::Ntlm'=>'libwww-perl','LWP::ConnCache'=>'libwww-perl','LWP::Debug'=>'libwww-perl','LWP::Debug::TraceHTTP'=>'libwww-perl','LWP::DebugFile'=>'libwww-perl','LWP::MemberMixin'=>'libwww-perl','LWP::Protocol'=>'libwww-perl','LWP::Protocol::Net::Curl'=>'LWP-Protocol-Net-Curl','LWP::Protocol::cpan'=>'libwww-perl','LWP::Protocol::data'=>'libwww-perl','LWP::Protocol::file'=>'libwww-perl','LWP::Protocol::ftp'=>'libwww-perl','LWP::Protocol::gopher'=>'libwww-perl','LWP::Protocol::http'=>'libwww-perl','LWP::Protocol::loopback'=>'libwww-perl','LWP::Protocol::mailto'=>'libwww-perl','LWP::Protocol::nntp'=>'libwww-perl','LWP::Protocol::nogo'=>'libwww-perl','LWP::RobotUA'=>'libwww-perl','LWP::Simple'=>'libwww-perl','LWP::UserAgent'=>'libwww-perl','Legacy::DB::SyntenyBlock'=>'GBrowse','Legacy::DB::SyntenyIO'=>'GBrowse','Legacy::Graphics::Browser'=>'GBrowse','Legacy::Graphics::Browser::I18n'=>'GBrowse','Legacy::Graphics::Browser::PageSettings'=>'GBrowse','Legacy::Graphics::Browser::Synteny'=>'GBrowse','Legacy::Graphics::Browser::Util'=>'GBrowse','Legacy::Graphics::BrowserConfig'=>'GBrowse','Lemonldap::NG::Portal'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Engines::Default'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Ext2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Mail2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Register::TOTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Register::U2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Register::Yubikey'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::TOTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::U2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::UTOTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::2F::Yubikey'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::AD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Apache'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Combination'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Custom'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Demo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Facebook'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::GPG'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Kerberos'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::LinkedIn'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Null'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::OpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::PAM'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Proxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Radius'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Remote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::SSL'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Slave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::Twitter'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::WebID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Auth::_WebForm'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthAD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthApache'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthBrowserID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthCAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthChoice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthDBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthDemo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthFacebook'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthGoogle'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthKerberos'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthLDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthLinkedIn'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthMulti'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthOpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthOpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthProxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthRadius'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthRemote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthSAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthSSL'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthSlave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthTwitter'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthWebID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::AuthYubikey'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::CDA'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::CDC'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Display'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::Get'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::OpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Issuer::SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBCAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBGet'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBOpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBOpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::IssuerDBSAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Captcha'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Combination::UserLogger'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Net::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Notifications::JSON'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Notifications::XML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OneTimeToken'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OpenID::SREG'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OpenID::Server'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OtherSessions'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::OverConf'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::RESTProxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Remote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::SMTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::SOAPProxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Slave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::U2F'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Lib::Wrapper'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::MailReset'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Auth'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Constants'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Display'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Init'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Issuer'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Menu'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Plugin'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Plugins'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Process'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Request'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::Run'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Main::SecondFactor'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Menu'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::OpenID::SREG'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::OpenID::Server'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::AD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Base'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Custom'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Demo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::Null'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Password::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBAD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBChoice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBDBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBDemo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBLDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::PasswordDBNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::AutoSignin'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::BruteForceProtection'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::CDA'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::CheckState'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::ForceAuthn'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::GrantSession'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::History'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::MailPasswordReset'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::MailReset'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::Notifications'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::PublicPages'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::RESTServer'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::Register'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::SOAPServer'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::SingleSession'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::Status'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::StayConnected'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Plugins::Upgrade'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register::AD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register::Custom'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register::Demo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Register::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::RegisterDBAD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::RegisterDBDemo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::RegisterDBLDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::RegisterDBNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::SharedConf'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::Simple'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::AD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Combination'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Custom'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Demo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Facebook'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Null'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::OpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Proxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::REST'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Remote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::Slave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDB::WebID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBAD'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBChoice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBDBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBDemo'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBFacebook'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBGoogle'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBLDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBMulti'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBNull'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBOpenID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBOpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBProxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBRemote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBSAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBSlave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::UserDBWebID'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Browser'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_CAS'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Choice'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_DBI'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_LDAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_LibAccess'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Multi'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_OpenIDConnect'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Proxy'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Remote'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_SAML'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_SMTP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_SOAP'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_Slave'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_WebForm'=>'Lemonldap-NG-Portal','Lemonldap::NG::Portal::_i18n'=>'Lemonldap-NG-Portal','MHonArc::Char'=>'MHonArc','MHonArc::Char::JP'=>'MHonArc','MHonArc::Char::KR'=>'MHonArc','MHonArc::CharEnt'=>'MHonArc','MHonArc::CharEnt::AppleArabic'=>'MHonArc','MHonArc::CharEnt::AppleCenteuro'=>'MHonArc','MHonArc::CharEnt::AppleCroatian'=>'MHonArc','MHonArc::CharEnt::AppleCyrillic'=>'MHonArc','MHonArc::CharEnt::AppleGreek'=>'MHonArc','MHonArc::CharEnt::AppleHebrew'=>'MHonArc','MHonArc::CharEnt::AppleIceland'=>'MHonArc','MHonArc::CharEnt::AppleRoman'=>'MHonArc','MHonArc::CharEnt::AppleRomanian'=>'MHonArc','MHonArc::CharEnt::AppleThai'=>'MHonArc','MHonArc::CharEnt::AppleTurkish'=>'MHonArc','MHonArc::CharEnt::BIG5_ETEN'=>'MHonArc','MHonArc::CharEnt::BIG5_HKSCS'=>'MHonArc','MHonArc::CharEnt::CP1250'=>'MHonArc','MHonArc::CharEnt::CP1251'=>'MHonArc','MHonArc::CharEnt::CP1252'=>'MHonArc','MHonArc::CharEnt::CP1253'=>'MHonArc','MHonArc::CharEnt::CP1254'=>'MHonArc','MHonArc::CharEnt::CP1255'=>'MHonArc','MHonArc::CharEnt::CP1256'=>'MHonArc','MHonArc::CharEnt::CP1257'=>'MHonArc','MHonArc::CharEnt::CP1258'=>'MHonArc','MHonArc::CharEnt::CP866'=>'MHonArc','MHonArc::CharEnt::CP932'=>'MHonArc','MHonArc::CharEnt::CP936'=>'MHonArc','MHonArc::CharEnt::CP949'=>'MHonArc','MHonArc::CharEnt::CP950'=>'MHonArc','MHonArc::CharEnt::EUC_JP'=>'MHonArc','MHonArc::CharEnt::GB2312'=>'MHonArc','MHonArc::CharEnt::GOST19768_87'=>'MHonArc','MHonArc::CharEnt::HP_ROMAN8'=>'MHonArc','MHonArc::CharEnt::ISO8859_1'=>'MHonArc','MHonArc::CharEnt::ISO8859_10'=>'MHonArc','MHonArc::CharEnt::ISO8859_11'=>'MHonArc','MHonArc::CharEnt::ISO8859_13'=>'MHonArc','MHonArc::CharEnt::ISO8859_14'=>'MHonArc','MHonArc::CharEnt::ISO8859_15'=>'MHonArc','MHonArc::CharEnt::ISO8859_16'=>'MHonArc','MHonArc::CharEnt::ISO8859_2'=>'MHonArc','MHonArc::CharEnt::ISO8859_3'=>'MHonArc','MHonArc::CharEnt::ISO8859_4'=>'MHonArc','MHonArc::CharEnt::ISO8859_5'=>'MHonArc','MHonArc::CharEnt::ISO8859_6'=>'MHonArc','MHonArc::CharEnt::ISO8859_7'=>'MHonArc','MHonArc::CharEnt::ISO8859_8'=>'MHonArc','MHonArc::CharEnt::ISO8859_9'=>'MHonArc','MHonArc::CharEnt::KOI8_A'=>'MHonArc','MHonArc::CharEnt::KOI8_B'=>'MHonArc','MHonArc::CharEnt::KOI8_E'=>'MHonArc','MHonArc::CharEnt::KOI8_F'=>'MHonArc','MHonArc::CharEnt::KOI8_R'=>'MHonArc','MHonArc::CharEnt::KOI8_U'=>'MHonArc','MHonArc::CharEnt::KOI_0'=>'MHonArc','MHonArc::CharEnt::KOI_7'=>'MHonArc','MHonArc::CharEnt::VISCII'=>'MHonArc','MHonArc::CharMaps'=>'MHonArc','MHonArc::Encode'=>'MHonArc','MHonArc::RFC822'=>'MHonArc','MHonArc::UTF8'=>'MHonArc','MHonArc::UTF8::AppleArabic'=>'MHonArc','MHonArc::UTF8::AppleCenteuro'=>'MHonArc','MHonArc::UTF8::AppleCroatian'=>'MHonArc','MHonArc::UTF8::AppleCyrillic'=>'MHonArc','MHonArc::UTF8::AppleGreek'=>'MHonArc','MHonArc::UTF8::AppleHebrew'=>'MHonArc','MHonArc::UTF8::AppleIceland'=>'MHonArc','MHonArc::UTF8::AppleRoman'=>'MHonArc','MHonArc::UTF8::AppleRomanian'=>'MHonArc','MHonArc::UTF8::AppleThai'=>'MHonArc','MHonArc::UTF8::AppleTurkish'=>'MHonArc','MHonArc::UTF8::BIG5_ETEN'=>'MHonArc','MHonArc::UTF8::BIG5_HKSCS'=>'MHonArc','MHonArc::UTF8::CP1250'=>'MHonArc','MHonArc::UTF8::CP1251'=>'MHonArc','MHonArc::UTF8::CP1252'=>'MHonArc','MHonArc::UTF8::CP1253'=>'MHonArc','MHonArc::UTF8::CP1254'=>'MHonArc','MHonArc::UTF8::CP1255'=>'MHonArc','MHonArc::UTF8::CP1256'=>'MHonArc','MHonArc::UTF8::CP1257'=>'MHonArc','MHonArc::UTF8::CP1258'=>'MHonArc','MHonArc::UTF8::CP866'=>'MHonArc','MHonArc::UTF8::CP932'=>'MHonArc','MHonArc::UTF8::CP936'=>'MHonArc','MHonArc::UTF8::CP949'=>'MHonArc','MHonArc::UTF8::CP950'=>'MHonArc','MHonArc::UTF8::EUC_JP'=>'MHonArc','MHonArc::UTF8::Encode'=>'MHonArc','MHonArc::UTF8::GB2312'=>'MHonArc','MHonArc::UTF8::GOST19768_87'=>'MHonArc','MHonArc::UTF8::HP_ROMAN8'=>'MHonArc','MHonArc::UTF8::ISO8859_1'=>'MHonArc','MHonArc::UTF8::ISO8859_10'=>'MHonArc','MHonArc::UTF8::ISO8859_11'=>'MHonArc','MHonArc::UTF8::ISO8859_13'=>'MHonArc','MHonArc::UTF8::ISO8859_14'=>'MHonArc','MHonArc::UTF8::ISO8859_15'=>'MHonArc','MHonArc::UTF8::ISO8859_16'=>'MHonArc','MHonArc::UTF8::ISO8859_2'=>'MHonArc','MHonArc::UTF8::ISO8859_3'=>'MHonArc','MHonArc::UTF8::ISO8859_4'=>'MHonArc','MHonArc::UTF8::ISO8859_5'=>'MHonArc','MHonArc::UTF8::ISO8859_6'=>'MHonArc','MHonArc::UTF8::ISO8859_7'=>'MHonArc','MHonArc::UTF8::ISO8859_8'=>'MHonArc','MHonArc::UTF8::ISO8859_9'=>'MHonArc','MHonArc::UTF8::KOI8_A'=>'MHonArc','MHonArc::UTF8::KOI8_B'=>'MHonArc','MHonArc::UTF8::KOI8_E'=>'MHonArc','MHonArc::UTF8::KOI8_F'=>'MHonArc','MHonArc::UTF8::KOI8_R'=>'MHonArc','MHonArc::UTF8::KOI8_U'=>'MHonArc','MHonArc::UTF8::KOI_0'=>'MHonArc','MHonArc::UTF8::KOI_7'=>'MHonArc','MHonArc::UTF8::MapUTF8'=>'MHonArc','MHonArc::UTF8::MhaEncode'=>'MHonArc','MHonArc::UTF8::VISCII'=>'MHonArc','MM'=>'ExtUtils-MakeMaker','MY'=>'ExtUtils-MakeMaker','ModPerl::BuildMM'=>'mod_perl','ModPerl::BuildOptions'=>'mod_perl','ModPerl::CScan'=>'mod_perl','ModPerl::Code'=>'mod_perl','ModPerl::Config'=>'mod_perl','ModPerl::FunctionMap'=>'mod_perl','ModPerl::FunctionTable'=>'mod_perl','ModPerl::Global'=>'mod_perl','ModPerl::InterpPool'=>'mod_perl','ModPerl::Interpreter'=>'mod_perl','ModPerl::MM'=>'mod_perl','ModPerl::Manifest'=>'mod_perl','ModPerl::MapBase'=>'mod_perl','ModPerl::MapUtil'=>'mod_perl','ModPerl::MethodLookup'=>'mod_perl','ModPerl::ParseSource'=>'mod_perl','ModPerl::PerlRun'=>'mod_perl','ModPerl::PerlRunPrefork'=>'mod_perl','ModPerl::Registry'=>'mod_perl','ModPerl::RegistryBB'=>'mod_perl','ModPerl::RegistryCooker'=>'mod_perl','ModPerl::RegistryLoader'=>'mod_perl','ModPerl::RegistryPrefork'=>'mod_perl','ModPerl::StructureMap'=>'mod_perl','ModPerl::TestConfig'=>'mod_perl','ModPerl::TestReport'=>'mod_perl','ModPerl::TestRun'=>'mod_perl','ModPerl::TiPool'=>'mod_perl','ModPerl::TiPoolConfig'=>'mod_perl','ModPerl::TypeMap'=>'mod_perl','ModPerl::Util'=>'mod_perl','ModPerl::WrapXS'=>'mod_perl','Module::Signature'=>'Module-Signature','Mojo'=>'Mojolicious','Mojo::Asset'=>'Mojolicious','Mojo::Asset::File'=>'Mojolicious','Mojo::Asset::Memory'=>'Mojolicious','Mojo::Base'=>'Mojolicious','Mojo::ByteStream'=>'Mojolicious','Mojo::Cache'=>'Mojolicious','Mojo::Collection'=>'Mojolicious','Mojo::Content'=>'Mojolicious','Mojo::Content::MultiPart'=>'Mojolicious','Mojo::Content::Single'=>'Mojolicious','Mojo::Cookie'=>'Mojolicious','Mojo::Cookie::Request'=>'Mojolicious','Mojo::Cookie::Response'=>'Mojolicious','Mojo::DOM'=>'Mojolicious','Mojo::DOM::CSS'=>'Mojolicious','Mojo::DOM::HTML'=>'Mojolicious','Mojo::Date'=>'Mojolicious','Mojo::DynamicMethods'=>'Mojolicious','Mojo::EventEmitter'=>'Mojolicious','Mojo::Exception'=>'Mojolicious','Mojo::File'=>'Mojolicious','Mojo::Headers'=>'Mojolicious','Mojo::HelloWorld'=>'Mojolicious','Mojo::Home'=>'Mojolicious','Mojo::IOLoop'=>'Mojolicious','Mojo::IOLoop::Client'=>'Mojolicious','Mojo::IOLoop::Delay'=>'Mojolicious','Mojo::IOLoop::Server'=>'Mojolicious','Mojo::IOLoop::Stream'=>'Mojolicious','Mojo::IOLoop::Subprocess'=>'Mojolicious','Mojo::IOLoop::TLS'=>'Mojolicious','Mojo::JSON'=>'Mojolicious','Mojo::JSON::Pointer'=>'Mojolicious','Mojo::Loader'=>'Mojolicious','Mojo::Log'=>'Mojolicious','Mojo::Message'=>'Mojolicious','Mojo::Message::Request'=>'Mojolicious','Mojo::Message::Response'=>'Mojolicious','Mojo::Parameters'=>'Mojolicious','Mojo::Path'=>'Mojolicious','Mojo::Promise'=>'Mojolicious','Mojo::Reactor'=>'Mojolicious','Mojo::Reactor::EV'=>'Mojolicious','Mojo::Reactor::Poll'=>'Mojolicious','Mojo::Server'=>'Mojolicious','Mojo::Server::CGI'=>'Mojolicious','Mojo::Server::Daemon'=>'Mojolicious','Mojo::Server::Hypnotoad'=>'Mojolicious','Mojo::Server::Morbo'=>'Mojolicious','Mojo::Server::Morbo::Backend'=>'Mojolicious','Mojo::Server::Morbo::Backend::Poll'=>'Mojolicious','Mojo::Server::PSGI'=>'Mojolicious','Mojo::Server::PSGI::_IO'=>'Mojolicious','Mojo::Server::Prefork'=>'Mojolicious','Mojo::Template'=>'Mojolicious','Mojo::Transaction'=>'Mojolicious','Mojo::Transaction::HTTP'=>'Mojolicious','Mojo::Transaction::WebSocket'=>'Mojolicious','Mojo::URL'=>'Mojolicious','Mojo::Upload'=>'Mojolicious','Mojo::UserAgent'=>'Mojolicious','Mojo::UserAgent::CookieJar'=>'Mojolicious','Mojo::UserAgent::Proxy'=>'Mojolicious','Mojo::UserAgent::Server'=>'Mojolicious','Mojo::UserAgent::Transactor'=>'Mojolicious','Mojo::Util'=>'Mojolicious','Mojo::WebSocket'=>'Mojolicious','MojoMojo'=>'MojoMojo','MojoMojo::Controller::Admin'=>'MojoMojo','MojoMojo::Controller::Attachment'=>'MojoMojo','MojoMojo::Controller::Comment'=>'MojoMojo','MojoMojo::Controller::Export'=>'MojoMojo','MojoMojo::Controller::Gallery'=>'MojoMojo','MojoMojo::Controller::Image'=>'MojoMojo','MojoMojo::Controller::JSON'=>'MojoMojo','MojoMojo::Controller::Journal'=>'MojoMojo','MojoMojo::Controller::Jsrpc'=>'MojoMojo','MojoMojo::Controller::Page'=>'MojoMojo','MojoMojo::Controller::PageAdmin'=>'MojoMojo','MojoMojo::Controller::Root'=>'MojoMojo','MojoMojo::Controller::Tag'=>'MojoMojo','MojoMojo::Controller::User'=>'MojoMojo','MojoMojo::Declaw'=>'MojoMojo','MojoMojo::Extension'=>'MojoMojo','MojoMojo::Extensions::Counter'=>'MojoMojo','MojoMojo::Formatter'=>'MojoMojo','MojoMojo::Formatter::Amazon'=>'MojoMojo','MojoMojo::Formatter::CPANHyperlink'=>'MojoMojo','MojoMojo::Formatter::Comment'=>'MojoMojo','MojoMojo::Formatter::Defang'=>'MojoMojo','MojoMojo::Formatter::Dir'=>'MojoMojo','MojoMojo::Formatter::DocBook'=>'MojoMojo','MojoMojo::Formatter::DocBook::Colorize'=>'MojoMojo','MojoMojo::Formatter::Emote'=>'MojoMojo','MojoMojo::Formatter::File'=>'MojoMojo','MojoMojo::Formatter::File::DocBook'=>'MojoMojo','MojoMojo::Formatter::File::Image'=>'MojoMojo','MojoMojo::Formatter::File::Pod'=>'MojoMojo','MojoMojo::Formatter::File::Test'=>'MojoMojo','MojoMojo::Formatter::File::Text'=>'MojoMojo','MojoMojo::Formatter::Gist'=>'MojoMojo','MojoMojo::Formatter::GoogleCalendar'=>'MojoMojo','MojoMojo::Formatter::GoogleSearch'=>'MojoMojo','MojoMojo::Formatter::IDLink'=>'MojoMojo','MojoMojo::Formatter::IRCLog'=>'MojoMojo','MojoMojo::Formatter::Include'=>'MojoMojo','MojoMojo::Formatter::Main'=>'MojoMojo','MojoMojo::Formatter::Markdown'=>'MojoMojo','MojoMojo::Formatter::Pod'=>'MojoMojo','MojoMojo::Formatter::Pod::Simple::HTML'=>'MojoMojo','MojoMojo::Formatter::RSS'=>'MojoMojo','MojoMojo::Formatter::Redirect'=>'MojoMojo','MojoMojo::Formatter::SyntaxHighlight'=>'MojoMojo','MojoMojo::Formatter::TOC'=>'MojoMojo','MojoMojo::Formatter::Text'=>'MojoMojo','MojoMojo::Formatter::Textile'=>'MojoMojo','MojoMojo::Formatter::Wiki'=>'MojoMojo','MojoMojo::Formatter::WikipediaLink'=>'MojoMojo','MojoMojo::Formatter::YouTube'=>'MojoMojo','MojoMojo::I18N'=>'MojoMojo','MojoMojo::Model::DBIC'=>'MojoMojo','MojoMojo::Model::Search'=>'MojoMojo','MojoMojo::Model::Themes'=>'MojoMojo','MojoMojo::Schema'=>'MojoMojo','MojoMojo::Schema::Base::Result'=>'MojoMojo','MojoMojo::Schema::Base::ResultSet'=>'MojoMojo','MojoMojo::Schema::Result::Attachment'=>'MojoMojo','MojoMojo::Schema::Result::Comment'=>'MojoMojo','MojoMojo::Schema::Result::Content'=>'MojoMojo','MojoMojo::Schema::Result::Entry'=>'MojoMojo','MojoMojo::Schema::Result::Journal'=>'MojoMojo','MojoMojo::Schema::Result::Link'=>'MojoMojo','MojoMojo::Schema::Result::Page'=>'MojoMojo','MojoMojo::Schema::Result::PageVersion'=>'MojoMojo','MojoMojo::Schema::Result::PathPermissions'=>'MojoMojo','MojoMojo::Schema::Result::Person'=>'MojoMojo','MojoMojo::Schema::Result::Photo'=>'MojoMojo','MojoMojo::Schema::Result::Preference'=>'MojoMojo','MojoMojo::Schema::Result::Role'=>'MojoMojo','MojoMojo::Schema::Result::RoleMember'=>'MojoMojo','MojoMojo::Schema::Result::RolePrivilege'=>'MojoMojo','MojoMojo::Schema::Result::Tag'=>'MojoMojo','MojoMojo::Schema::Result::WantedPage'=>'MojoMojo','MojoMojo::Schema::ResultSet::Attachment'=>'MojoMojo','MojoMojo::Schema::ResultSet::Content'=>'MojoMojo','MojoMojo::Schema::ResultSet::Page'=>'MojoMojo','MojoMojo::Schema::ResultSet::Person'=>'MojoMojo','MojoMojo::Schema::ResultSet::Role'=>'MojoMojo','MojoMojo::Schema::ResultSet::Tag'=>'MojoMojo','MojoMojo::View::Email'=>'MojoMojo','MojoMojo::View::JSON'=>'MojoMojo','MojoMojo::View::TT'=>'MojoMojo','MojoMojo::WordDiff'=>'MojoMojo','Mojolicious'=>'Mojolicious','Mojolicious::Command'=>'Mojolicious','Mojolicious::Command::Author::cpanify'=>'Mojolicious','Mojolicious::Command::Author::generate'=>'Mojolicious','Mojolicious::Command::Author::generate::app'=>'Mojolicious','Mojolicious::Command::Author::generate::lite_app'=>'Mojolicious','Mojolicious::Command::Author::generate::makefile'=>'Mojolicious','Mojolicious::Command::Author::generate::plugin'=>'Mojolicious','Mojolicious::Command::Author::inflate'=>'Mojolicious','Mojolicious::Command::cgi'=>'Mojolicious','Mojolicious::Command::cpanify'=>'Mojolicious','Mojolicious::Command::daemon'=>'Mojolicious','Mojolicious::Command::eval'=>'Mojolicious','Mojolicious::Command::generate'=>'Mojolicious','Mojolicious::Command::generate::app'=>'Mojolicious','Mojolicious::Command::generate::lite_app'=>'Mojolicious','Mojolicious::Command::generate::makefile'=>'Mojolicious','Mojolicious::Command::generate::plugin'=>'Mojolicious','Mojolicious::Command::get'=>'Mojolicious','Mojolicious::Command::inflate'=>'Mojolicious','Mojolicious::Command::prefork'=>'Mojolicious','Mojolicious::Command::psgi'=>'Mojolicious','Mojolicious::Command::routes'=>'Mojolicious','Mojolicious::Command::test'=>'Mojolicious','Mojolicious::Command::version'=>'Mojolicious','Mojolicious::Commands'=>'Mojolicious','Mojolicious::Controller'=>'Mojolicious','Mojolicious::Lite'=>'Mojolicious','Mojolicious::Plugin'=>'Mojolicious','Mojolicious::Plugin::Config'=>'Mojolicious','Mojolicious::Plugin::Config::Sandbox'=>'Mojolicious','Mojolicious::Plugin::DefaultHelpers'=>'Mojolicious','Mojolicious::Plugin::EPLRenderer'=>'Mojolicious','Mojolicious::Plugin::EPRenderer'=>'Mojolicious','Mojolicious::Plugin::HeaderCondition'=>'Mojolicious','Mojolicious::Plugin::JSONConfig'=>'Mojolicious','Mojolicious::Plugin::Mount'=>'Mojolicious','Mojolicious::Plugin::OAuth2'=>'Mojolicious-Plugin-OAuth2','Mojolicious::Plugin::PODRenderer'=>'Mojolicious','Mojolicious::Plugin::TagHelpers'=>'Mojolicious','Mojolicious::Plugins'=>'Mojolicious','Mojolicious::Renderer'=>'Mojolicious','Mojolicious::Routes'=>'Mojolicious','Mojolicious::Routes::Match'=>'Mojolicious','Mojolicious::Routes::Pattern'=>'Mojolicious','Mojolicious::Routes::Route'=>'Mojolicious','Mojolicious::Sessions'=>'Mojolicious','Mojolicious::Static'=>'Mojolicious','Mojolicious::Types'=>'Mojolicious','Mojolicious::Validator'=>'Mojolicious','Mojolicious::Validator::Validation'=>'Mojolicious','MultipartBuffer'=>'CGI','My::Chat'=>'SOAP-Lite','My::Examples'=>'SOAP-Lite','My::Parameters'=>'SOAP-Lite','My::PersistentIterator'=>'SOAP-Lite','My::PingPong'=>'SOAP-Lite','My::SessionIterator'=>'SOAP-Lite','MyFeatureFileLoader'=>'GBrowse','Mysql'=>'DBD-mysql','Mysql::Statement'=>'DBD-mysql','Mysql::db'=>'DBD-mysql','Mysql::dr'=>'DBD-mysql','Mysql::st'=>'DBD-mysql','Net::DNS'=>'Net-DNS','Net::DNS::Domain'=>'Net-DNS','Net::DNS::DomainName'=>'Net-DNS','Net::DNS::DomainName1035'=>'Net-DNS','Net::DNS::DomainName2535'=>'Net-DNS','Net::DNS::Header'=>'Net-DNS','Net::DNS::Mailbox'=>'Net-DNS','Net::DNS::Mailbox1035'=>'Net-DNS','Net::DNS::Mailbox2535'=>'Net-DNS','Net::DNS::Nameserver'=>'Net-DNS','Net::DNS::Packet'=>'Net-DNS','Net::DNS::Parameters'=>'Net-DNS','Net::DNS::Question'=>'Net-DNS','Net::DNS::RR'=>'Net-DNS','Net::DNS::RR::A'=>'Net-DNS','Net::DNS::RR::AAAA'=>'Net-DNS','Net::DNS::RR::AFSDB'=>'Net-DNS','Net::DNS::RR::APL'=>'Net-DNS','Net::DNS::RR::APL::Item'=>'Net-DNS','Net::DNS::RR::CAA'=>'Net-DNS','Net::DNS::RR::CDNSKEY'=>'Net-DNS','Net::DNS::RR::CDS'=>'Net-DNS','Net::DNS::RR::CERT'=>'Net-DNS','Net::DNS::RR::CNAME'=>'Net-DNS','Net::DNS::RR::CSYNC'=>'Net-DNS','Net::DNS::RR::DHCID'=>'Net-DNS','Net::DNS::RR::DLV'=>'Net-DNS','Net::DNS::RR::DNAME'=>'Net-DNS','Net::DNS::RR::DNSKEY'=>'Net-DNS','Net::DNS::RR::DS'=>'Net-DNS','Net::DNS::RR::EUI48'=>'Net-DNS','Net::DNS::RR::EUI64'=>'Net-DNS','Net::DNS::RR::GPOS'=>'Net-DNS','Net::DNS::RR::HINFO'=>'Net-DNS','Net::DNS::RR::HIP'=>'Net-DNS','Net::DNS::RR::IPSECKEY'=>'Net-DNS','Net::DNS::RR::ISDN'=>'Net-DNS','Net::DNS::RR::KEY'=>'Net-DNS','Net::DNS::RR::KX'=>'Net-DNS','Net::DNS::RR::L32'=>'Net-DNS','Net::DNS::RR::L64'=>'Net-DNS','Net::DNS::RR::LOC'=>'Net-DNS','Net::DNS::RR::LP'=>'Net-DNS','Net::DNS::RR::MB'=>'Net-DNS','Net::DNS::RR::MG'=>'Net-DNS','Net::DNS::RR::MINFO'=>'Net-DNS','Net::DNS::RR::MR'=>'Net-DNS','Net::DNS::RR::MX'=>'Net-DNS','Net::DNS::RR::NAPTR'=>'Net-DNS','Net::DNS::RR::NID'=>'Net-DNS','Net::DNS::RR::NS'=>'Net-DNS','Net::DNS::RR::NSEC'=>'Net-DNS','Net::DNS::RR::NSEC3'=>'Net-DNS','Net::DNS::RR::NSEC3PARAM'=>'Net-DNS','Net::DNS::RR::NULL'=>'Net-DNS','Net::DNS::RR::OPENPGPKEY'=>'Net-DNS','Net::DNS::RR::OPT'=>'Net-DNS','Net::DNS::RR::OPT::CHAIN'=>'Net-DNS','Net::DNS::RR::OPT::CLIENT_SUBNET'=>'Net-DNS','Net::DNS::RR::OPT::COOKIE'=>'Net-DNS','Net::DNS::RR::OPT::DAU'=>'Net-DNS','Net::DNS::RR::OPT::DHU'=>'Net-DNS','Net::DNS::RR::OPT::EXPIRE'=>'Net-DNS','Net::DNS::RR::OPT::KEY_TAG'=>'Net-DNS','Net::DNS::RR::OPT::N3U'=>'Net-DNS','Net::DNS::RR::OPT::PADDING'=>'Net-DNS','Net::DNS::RR::OPT::TCP_KEEPALIVE'=>'Net-DNS','Net::DNS::RR::PTR'=>'Net-DNS','Net::DNS::RR::PX'=>'Net-DNS','Net::DNS::RR::RP'=>'Net-DNS','Net::DNS::RR::RRSIG'=>'Net-DNS','Net::DNS::RR::RT'=>'Net-DNS','Net::DNS::RR::SIG'=>'Net-DNS','Net::DNS::RR::SMIMEA'=>'Net-DNS','Net::DNS::RR::SOA'=>'Net-DNS','Net::DNS::RR::SPF'=>'Net-DNS','Net::DNS::RR::SRV'=>'Net-DNS','Net::DNS::RR::SSHFP'=>'Net-DNS','Net::DNS::RR::TKEY'=>'Net-DNS','Net::DNS::RR::TLSA'=>'Net-DNS','Net::DNS::RR::TSIG'=>'Net-DNS','Net::DNS::RR::TXT'=>'Net-DNS','Net::DNS::RR::URI'=>'Net-DNS','Net::DNS::RR::X25'=>'Net-DNS','Net::DNS::Resolver'=>'Net-DNS','Net::DNS::Resolver::Base'=>'Net-DNS','Net::DNS::Resolver::MSWin32'=>'Net-DNS','Net::DNS::Resolver::Recurse'=>'Net-DNS','Net::DNS::Resolver::UNIX'=>'Net-DNS','Net::DNS::Resolver::android'=>'Net-DNS','Net::DNS::Resolver::cygwin'=>'Net-DNS','Net::DNS::Resolver::os2'=>'Net-DNS','Net::DNS::Resolver::os390'=>'Net-DNS','Net::DNS::Text'=>'Net-DNS','Net::DNS::Update'=>'Net-DNS','Net::DNS::ZoneFile'=>'Net-DNS','Net::DNS::ZoneFile::Generator'=>'Net-DNS','Net::DNS::ZoneFile::Text'=>'Net-DNS','Net::OpenID::Association'=>'Net-OpenID-Consumer','Net::OpenID::ClaimedIdentity'=>'Net-OpenID-Consumer','Net::OpenID::Consumer'=>'Net-OpenID-Consumer','Net::OpenID::VerifiedIdentity'=>'Net-OpenID-Consumer','Otogiri'=>'Otogiri','PAR'=>'PAR','PAR::Filter'=>'PAR-Packer','PAR::Filter::Bleach'=>'PAR-Packer','PAR::Filter::Bytecode'=>'PAR-Packer','PAR::Filter::Obfuscate'=>'PAR-Packer','PAR::Filter::PatchContent'=>'PAR-Packer','PAR::Filter::PodStrip'=>'PAR-Packer','PAR::Heavy'=>'PAR','PAR::Packer'=>'PAR-Packer','PAR::SetupProgname'=>'PAR','PAR::SetupTemp'=>'PAR','PAR::StrippedPARL::Base'=>'PAR-Packer','Perl::Version'=>'Perl-Version','Plack::Middleware::Session'=>'Plack-Middleware-Session','Plack::Middleware::Session::Cookie'=>'Plack-Middleware-Session','Plack::Session'=>'Plack-Middleware-Session','Plack::Session::Cleanup'=>'Plack-Middleware-Session','Plack::Session::State'=>'Plack-Middleware-Session','Plack::Session::State::Cookie'=>'Plack-Middleware-Session','Plack::Session::Store'=>'Plack-Middleware-Session','Plack::Session::Store::Cache'=>'Plack-Middleware-Session','Plack::Session::Store::DBI'=>'Plack-Middleware-Session','Plack::Session::Store::File'=>'Plack-Middleware-Session','Plack::Session::Store::Null'=>'Plack-Middleware-Session','RT::Authen::ExternalAuth'=>'RT-Authen-ExternalAuth','RT::Authen::ExternalAuth::DBI'=>'RT-Authen-ExternalAuth','RT::Authen::ExternalAuth::DBI::Cookie'=>'RT-Authen-ExternalAuth','RT::Authen::ExternalAuth::LDAP'=>'RT-Authen-ExternalAuth','RT::Extension::MobileUI'=>'RT-Extension-MobileUI','RTMP::Client'=>'RTMP-Client','SOAP::Apache'=>'SOAP-Lite','SOAP::Cloneable'=>'SOAP-Lite','SOAP::Constants'=>'SOAP-Lite','SOAP::Custom::XML::Data'=>'SOAP-Lite','SOAP::Custom::XML::Deserializer'=>'SOAP-Lite','SOAP::Data'=>'SOAP-Lite','SOAP::Deserializer'=>'SOAP-Lite','SOAP::Fault'=>'SOAP-Lite','SOAP::Header'=>'SOAP-Lite','SOAP::Lite'=>'SOAP-Lite','SOAP::Lite::COM'=>'SOAP-Lite','SOAP::Lite::Deserializer::XMLSchema1999'=>'SOAP-Lite','SOAP::Lite::Deserializer::XMLSchema2001'=>'SOAP-Lite','SOAP::Lite::Deserializer::XMLSchemaSOAP1_1'=>'SOAP-Lite','SOAP::Lite::Deserializer::XMLSchemaSOAP1_2'=>'SOAP-Lite','SOAP::Lite::Packager'=>'SOAP-Lite','SOAP::Lite::Packager::DIME'=>'SOAP-Lite','SOAP::Lite::Packager::MIME'=>'SOAP-Lite','SOAP::Lite::Utils'=>'SOAP-Lite','SOAP::MIMEParser'=>'SOAP-Lite','SOAP::Packager'=>'SOAP-Lite','SOAP::Packager::DIME'=>'SOAP-Lite','SOAP::Packager::MIME'=>'SOAP-Lite','SOAP::SOM'=>'SOAP-Lite','SOAP::Schema'=>'SOAP-Lite','SOAP::Schema::Deserializer'=>'SOAP-Lite','SOAP::Schema::WSDL'=>'SOAP-Lite','SOAP::Server'=>'SOAP-Lite','SOAP::Server::Object'=>'SOAP-Lite','SOAP::Server::Parameters'=>'SOAP-Lite','SOAP::Test'=>'SOAP-Lite','SOAP::Test::Server'=>'SOAP-Lite','SOAP::Trace'=>'SOAP-Lite','SOAP::Transport'=>'SOAP-Lite','SOAP::Transport::HTTP'=>'SOAP-Lite','SOAP::Transport::HTTP::Daemon'=>'SOAP-Lite','SOAP::Transport::HTTP::Daemon::ForkAfterProcessing'=>'SOAP-Lite','SOAP::Transport::HTTP::Daemon::ForkOnAccept'=>'SOAP-Lite','SOAP::Transport::HTTP::FCGI'=>'SOAP-Lite','SOAP::Transport::IO'=>'SOAP-Lite','SOAP::Transport::IO::Server'=>'SOAP-Lite','SOAP::Transport::LOCAL'=>'SOAP-Lite','SOAP::Transport::LOCAL::Client'=>'SOAP-Lite','SOAP::Transport::LOOPBACK'=>'SOAP-Lite','SOAP::Transport::LOOPBACK::Client'=>'SOAP-Lite','SOAP::Transport::MAILTO'=>'SOAP-Lite','SOAP::Transport::MAILTO::Client'=>'SOAP-Lite','SOAP::Transport::POP3'=>'SOAP-Lite','SOAP::Transport::POP3::Server'=>'SOAP-Lite','SOAP::Transport::TCP'=>'SOAP-Lite','SOAP::Transport::TCP::Client'=>'SOAP-Lite','SOAP::Transport::TCP::Server'=>'SOAP-Lite','SOAP::Utils'=>'SOAP-Lite','SOAP::XMLSchema1999::Deserializer'=>'SOAP-Lite','SOAP::XMLSchema1999::Serializer'=>'SOAP-Lite','SOAP::XMLSchema2001::Deserializer'=>'SOAP-Lite','SOAP::XMLSchema2001::Serializer'=>'SOAP-Lite','SOAP::XMLSchema::Serializer'=>'SOAP-Lite','SOAP::XMLSchemaApacheSOAP::Deserializer'=>'SOAP-Lite','SOAP::XMLSchemaSOAP1_1::Deserializer'=>'SOAP-Lite','SOAP::XMLSchemaSOAP1_2::Deserializer'=>'SOAP-Lite','SVG::Sparkline'=>'SVG-Sparkline','SVG::Sparkline::Area'=>'SVG-Sparkline','SVG::Sparkline::Bar'=>'SVG-Sparkline','SVG::Sparkline::Line'=>'SVG-Sparkline','SVG::Sparkline::RangeArea'=>'SVG-Sparkline','SVG::Sparkline::RangeBar'=>'SVG-Sparkline','SVG::Sparkline::Utils'=>'SVG-Sparkline','SVG::Sparkline::Whisker'=>'SVG-Sparkline','SVN::Look'=>'SVN-Look','Search::OpenSearch::Result'=>'Search-OpenSearch-Server','Search::OpenSearch::Server'=>'Search-OpenSearch-Server','Search::OpenSearch::Server::Catalyst'=>'Search-OpenSearch-Server','Search::OpenSearch::Server::Plack'=>'Search-OpenSearch-Server','Storable'=>'Storable','TempFile'=>'CGI','Test::Mojo'=>'Mojolicious','Test::Simply'=>'Fake-Our','Text::SmartyPants'=>'MojoMojo','Text::Wikispaces2Markdown'=>'MojoMojo','Tie::Watch'=>'Tk','Tk'=>'Tk','Tk::Adjuster'=>'Tk','Tk::Adjuster::Item'=>'Tk','Tk::After'=>'Tk','Tk::Animation'=>'Tk','Tk::Balloon'=>'Tk','Tk::Bitmap'=>'Tk','Tk::BrowseEntry'=>'Tk','Tk::Button'=>'Tk','Tk::Canvas'=>'Tk','Tk::Checkbutton'=>'Tk','Tk::Clipboard'=>'Tk','Tk::CmdLine'=>'Tk','Tk::ColorDialog'=>'Tk','Tk::ColorEditor'=>'Tk','Tk::ColorSelect'=>'Tk','Tk::Compound'=>'Tk','Tk::Configure'=>'Tk','Tk::Derived'=>'Tk','Tk::Dialog'=>'Tk','Tk::DialogBox'=>'Tk','Tk::DirTree'=>'Tk','Tk::DirTreeDialog'=>'Tk','Tk::Dirlist'=>'Tk','Tk::DragDrop'=>'Tk','Tk::DragDrop::Common'=>'Tk','Tk::DragDrop::Local'=>'Tk','Tk::DragDrop::Rect'=>'Tk','Tk::DragDrop::SunConst'=>'Tk','Tk::DragDrop::SunDrop'=>'Tk','Tk::DragDrop::SunSite'=>'Tk','Tk::DragDrop::Win32Drop'=>'Tk','Tk::DragDrop::Win32Site'=>'Tk','Tk::DragDrop::XDNDDrop'=>'Tk','Tk::DragDrop::XDNDSite'=>'Tk','Tk::DropSite'=>'Tk','Tk::DummyEncode'=>'Tk','Tk::DummyEncode::iso8859_1'=>'Tk','Tk::English'=>'Tk','Tk::Entry'=>'Tk','Tk::ErrorDialog'=>'Tk','Tk::Event'=>'Tk','Tk::Event::IO'=>'Tk','Tk::FBox'=>'Tk','Tk::FileSelect'=>'Tk','Tk::FloatEntry'=>'Tk','Tk::Font'=>'Tk','Tk::Frame'=>'Tk','Tk::HList'=>'Tk','Tk::IO'=>'Tk','Tk::IconList'=>'Tk','Tk::Image'=>'Tk','Tk::InputO'=>'Tk','Tk::ItemStyle'=>'Tk','Tk::JPEG'=>'Tk','Tk::LabEntry'=>'Tk','Tk::LabFrame'=>'Tk','Tk::LabRadiobutton'=>'Tk','Tk::Label'=>'Tk','Tk::LabeledEntryLabeledRadiobutton'=>'Tk','Tk::Labelframe'=>'Tk','Tk::Listbox'=>'Tk','Tk::MMtry'=>'Tk','Tk::MMutil'=>'Tk','Tk::MainWindow'=>'Tk','Tk::MakeDepend'=>'Tk','Tk::Menu'=>'Tk','Tk::Menu::Button'=>'Tk','Tk::Menu::Cascade'=>'Tk','Tk::Menu::Checkbutton'=>'Tk','Tk::Menu::Item'=>'Tk','Tk::Menu::Radiobutton'=>'Tk','Tk::Menu::Separator'=>'Tk','Tk::Menubar'=>'Tk','Tk::Menubutton'=>'Tk','Tk::Message'=>'Tk','Tk::MsgBox'=>'Tk','Tk::Mwm'=>'Tk','Tk::NBFrame'=>'Tk','Tk::NoteBook'=>'Tk','Tk::Optionmenu'=>'Tk','Tk::PNG'=>'Tk','Tk::Pane'=>'Tk','Tk::Panedwindow'=>'Tk','Tk::Photo'=>'Tk','Tk::Pixmap'=>'Tk','Tk::Pretty'=>'Tk','Tk::ProgressBar'=>'Tk','Tk::ROText'=>'Tk','Tk::Radiobutton'=>'Tk','Tk::Region'=>'Tk','Tk::Reindex'=>'Tk','Tk::ReindexedROText'=>'Tk','Tk::ReindexedText'=>'Tk','Tk::Scale'=>'Tk','Tk::Scrollbar'=>'Tk','Tk::Spinbox'=>'Tk','Tk::Stats'=>'Tk','Tk::Stdio'=>'PAR','Tk::Stdio::Handle'=>'PAR','Tk::Submethods'=>'Tk','Tk::TList'=>'Tk','Tk::Table'=>'Tk','Tk::Text'=>'Tk','Tk::Text::Tag'=>'Tk','Tk::TextEdit'=>'Tk','Tk::TextList'=>'Tk','Tk::TextUndo'=>'Tk','Tk::Tiler'=>'Tk','Tk::TixGrid'=>'Tk','Tk::Toplevel'=>'Tk','Tk::Trace'=>'Tk','Tk::Tree'=>'Tk','Tk::Widget'=>'Tk','Tk::WinPhoto'=>'Tk','Tk::Wm'=>'Tk','Tk::X'=>'Tk','Tk::X11Font'=>'Tk','Tk::Xlib'=>'Tk','Tk::Xrm'=>'Tk','Tk::install'=>'Tk','Tk::widgets'=>'Tk','UDDI::Constants'=>'SOAP-Lite','UI::Dialog'=>'UI-Dialog','UI::Dialog::Backend'=>'UI-Dialog','UI::Dialog::Backend::ASCII'=>'UI-Dialog','UI::Dialog::Backend::CDialog'=>'UI-Dialog','UI::Dialog::Backend::GDialog'=>'UI-Dialog','UI::Dialog::Backend::KDialog'=>'UI-Dialog','UI::Dialog::Backend::Nautilus'=>'UI-Dialog','UI::Dialog::Backend::NotifySend'=>'UI-Dialog','UI::Dialog::Backend::Whiptail'=>'UI-Dialog','UI::Dialog::Backend::XDialog'=>'UI-Dialog','UI::Dialog::Backend::XOSD'=>'UI-Dialog','UI::Dialog::Backend::Zenity'=>'UI-Dialog','UI::Dialog::Console'=>'UI-Dialog','UI::Dialog::GNOME'=>'UI-Dialog','UI::Dialog::Gauged'=>'UI-Dialog','UI::Dialog::KDE'=>'UI-Dialog','UI::Dialog::Screen::Druid'=>'UI-Dialog','UI::Dialog::Screen::Menu'=>'UI-Dialog','URI::jabber'=>'SOAP-Lite','WidgetDemo'=>'Tk','XML::LibXML'=>'XML-LibXML','XML::LibXML::Attr'=>'XML-LibXML','XML::LibXML::AttributeHash'=>'XML-LibXML','XML::LibXML::Boolean'=>'XML-LibXML','XML::LibXML::CDATASection'=>'XML-LibXML','XML::LibXML::Comment'=>'XML-LibXML','XML::LibXML::Common'=>'XML-LibXML','XML::LibXML::Devel'=>'XML-LibXML','XML::LibXML::Document'=>'XML-LibXML','XML::LibXML::DocumentFragment'=>'XML-LibXML','XML::LibXML::Dtd'=>'XML-LibXML','XML::LibXML::Element'=>'XML-LibXML','XML::LibXML::ErrNo'=>'XML-LibXML','XML::LibXML::Error'=>'XML-LibXML','XML::LibXML::InputCallback'=>'XML-LibXML','XML::LibXML::Literal'=>'XML-LibXML','XML::LibXML::NamedNodeMap'=>'XML-LibXML','XML::LibXML::Namespace'=>'XML-LibXML','XML::LibXML::Node'=>'XML-LibXML','XML::LibXML::NodeList'=>'XML-LibXML','XML::LibXML::Number'=>'XML-LibXML','XML::LibXML::PI'=>'XML-LibXML','XML::LibXML::Pattern'=>'XML-LibXML','XML::LibXML::Reader'=>'XML-LibXML','XML::LibXML::RegExp'=>'XML-LibXML','XML::LibXML::RelaxNG'=>'XML-LibXML','XML::LibXML::SAX'=>'XML-LibXML','XML::LibXML::SAX::AttributeNode'=>'XML-LibXML','XML::LibXML::SAX::Builder'=>'XML-LibXML','XML::LibXML::SAX::Generator'=>'XML-LibXML','XML::LibXML::SAX::Parser'=>'XML-LibXML','XML::LibXML::Schema'=>'XML-LibXML','XML::LibXML::Text'=>'XML-LibXML','XML::LibXML::XPathContext'=>'XML-LibXML','XML::LibXML::XPathExpression'=>'XML-LibXML','XML::LibXML::_SAXParser'=>'XML-LibXML','back_tick_a_command'=>'PAR','encoding'=>'Encode','mod_perl'=>'mod_perl','mod_perl2'=>'mod_perl','ojo'=>'Mojolicious','pipe_a_command'=>'PAR','pp'=>'PAR-Packer','prior_to_test'=>'PAR','remove_file_and_try_executable_again'=>'PAR','test_in_further_subdir'=>'PAR' }}}1;
CPAN_AUDIT_DB

$fatpacked{"CPAN/Audit/Discover.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_DISCOVER';
  package CPAN::Audit::Discover;use strict;use warnings;use CPAN::Audit::Discover::Cpanfile;use CPAN::Audit::Discover::CpanfileSnapshot;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub discover {my$self=shift;my ($path)=@_;if (-f "$path/cpanfile.snapshot"){return CPAN::Audit::Discover::CpanfileSnapshot->new->discover("$path/cpanfile.snapshot")}elsif (-f "$path/cpanfile"){return CPAN::Audit::Discover::Cpanfile->new->discover("$path/cpanfile")}else {}return}1;
CPAN_AUDIT_DISCOVER

$fatpacked{"CPAN/Audit/Discover/Cpanfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_DISCOVER_CPANFILE';
  package CPAN::Audit::Discover::Cpanfile;use strict;use warnings;use Module::CPANfile;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub discover {my$self=shift;my ($cpanfile_path)=@_;my$cpanfile=Module::CPANfile->load($cpanfile_path);my$prereqs=$cpanfile->prereqs->as_string_hash;my@deps;for my$phase (keys %$prereqs){for my$type (keys %{$prereqs->{$phase}}){for my$module (keys %{$prereqs->{$phase}->{$type}}){my$version=$prereqs->{$phase}->{$type}->{$module};next if$module eq 'perl';push@deps,{module=>$module,version=>$version,}}}}return@deps}1;
CPAN_AUDIT_DISCOVER_CPANFILE

$fatpacked{"CPAN/Audit/Discover/CpanfileSnapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_DISCOVER_CPANFILESNAPSHOT';
  package CPAN::Audit::Discover::CpanfileSnapshot;use strict;use warnings;use CPAN::DistnameInfo;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub discover {my$self=shift;my ($cpanfile_snapshot_path)=@_;open my$fh,'<',$cpanfile_snapshot_path or die $!;my@deps;while (defined(my$line=<$fh>)){if ($line =~ m/pathname: ([^\s]+)/){next unless my$d=CPAN::DistnameInfo->new($1);next unless$d->dist && $d->version;push@deps,{dist=>$d->dist,version=>$d->version,}}}close$fh;return@deps}1;
CPAN_AUDIT_DISCOVER_CPANFILESNAPSHOT

$fatpacked{"CPAN/Audit/Installed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_INSTALLED';
  package CPAN::Audit::Installed;use strict;use warnings;use File::Find ();use Cwd ();sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{db}=$params{db};$self->{cb}=$params{cb};return$self}sub find {my$self=shift;my (@inc)=@_;@inc=@INC unless@inc;@inc=grep {defined && -d $_}map {Cwd::realpath($_)}@inc;my%seen;my@deps;File::Find::find({wanted=>sub {my$path=$File::Find::name;if ($path && -f $path && m/\.pm$/){return unless my$module=module_from_file($path);return unless my$distname=$self->{db}->{module2dist}->{$module};my$dist=$self->{db}->{dists}->{$distname};if ($dist->{main_module}eq $module){return if$seen{$module}++;return unless my$version=module_version($path);push@deps,{dist=>$distname,version=>$version };if ($self->{cb}){$self->{cb}->({path=>$path,distname=>$distname,version=>$version })}}}},follow=>1,follow_skip=>2,},@inc);return@deps}sub module_version {my ($parsefile)=@_;open my$mod,'<',$parsefile or die $!;my$inpod=0;my$result;local $_;while (<$mod>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;chomp;next unless m/([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;my$eval=qq{
              package CPAN::Audit::_version;
              no strict;
  
              local $1$2;
              \$$2=undef; do {
                  $_
              }; \$$2
          };local $^W=0;$result=eval($eval);warn "Could not eval '$eval' in $parsefile: $@" if $@;$result="undef" unless defined$result;last}close$mod;return$result}sub module_from_file {my ($path)=@_;my$module;open my$fh,'<',$path or return;while (my$line=<$fh>){if ($line =~ m/package\s+(.*?)\s*;/ms){$module=$1;last}}close$fh;return unless$module}1;
CPAN_AUDIT_INSTALLED

$fatpacked{"CPAN/Audit/Query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_QUERY';
  package CPAN::Audit::Query;use strict;use warnings;use CPAN::Audit::Version;sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{db}=$params{db}|| {};return$self}sub advisories_for {my$self=shift;my ($distname,$version_range)=@_;my$dist=$self->{db}->{dists}->{$distname};return unless$dist;my@advisories=@{$dist->{advisories}};my@versions=@{$dist->{versions}};if (!$version_range){return@advisories}my$version_checker=CPAN::Audit::Version->new;my@all_versions=map {$_->{version}}@versions;my@selected_versions;for my$version (@all_versions){if ($version_checker->in_range($version,$version_range)){push@selected_versions,$version}}if (!@selected_versions){return}my@matched_advisories;for my$advisory (@advisories){my@affected_versions=$version_checker->affected_versions(\@all_versions,$advisory->{affected_versions});next unless@affected_versions;for my$affected_version (reverse@affected_versions){if ($version_checker->in_range($affected_version,$version_range)){push@matched_advisories,$advisory;last}}}if (!@matched_advisories){return}return@matched_advisories}1;
CPAN_AUDIT_QUERY

$fatpacked{"CPAN/Audit/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_AUDIT_VERSION';
  package CPAN::Audit::Version;use strict;use warnings;use version;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub in_range {my$self=shift;my ($version,$range)=@_;return unless defined$version && defined$range;my@ands=split /\s*,\s*/,$range;return unless defined($version=eval {version->parse($version)});for my$and (@ands){my ($op,$range_version)=$and =~ m/^(<=|<|>=|>|==|!=)?\s*([^\s]+)$/;return unless defined($range_version=eval {version->parse($range_version)});$op='>=' unless defined$op;if ($op eq '<'){return unless$version < $range_version}elsif ($op eq '<='){return unless$version <= $range_version}elsif ($op eq '>'){return unless$version > $range_version}elsif ($op eq '>='){return unless$version >= $range_version}elsif ($op eq '=='){return unless$version==$range_version}elsif ($op eq '!='){return unless$version!=$range_version}else {return 0}}return 1}sub affected_versions {my$self=shift;my ($available_versions,$range)=@_;my@affected_versions;for my$version (@$available_versions){if ($self->in_range($version,$range)){push@affected_versions,$version}}return@affected_versions}1;
CPAN_AUDIT_VERSION

$fatpacked{"CPAN/Changes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_CHANGES';
  package CPAN::Changes;use strict;use warnings;use CPAN::Changes::Release;use Scalar::Util ();use version ();use Encode qw(decode FB_CROAK LEAVE_SRC);our$VERSION='0.400002';our$W3CDTF_REGEX=qr{(\d\d\d\d) # Year
                   (?:-(\d\d) # -Month
                   (?:-(\d\d) # -Day
                   (?:[T\s]
                     (\d\d):(\d\d) # Hour:Minute
                     (?:
                       :(\d\d)     # :Second
                       (\.\d+)?    # .Fractional_Second
                     )?
                     ( Z          # UTC
                     | [+-]\d\d:\d\d    # Hour:Minute TZ offset
                       (?::\d\d)?       # :Second TZ offset
                   )?)?)?)?}x;my@m=qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);my%months=map {$m[$_ ]=>$_ + 1}0 .. 11;our$UNKNOWN_VALS=join('|',('Unknown Release Date','Unknown','Not Released','Development Release','Development','Developer Release',));sub new {my$class=shift;return bless {preamble=>'',releases=>{},months=>\%months,@_,},$class}sub load {my ($class,$file,@args)=@_;open(my$fh,'<:raw',$file)or die $!;my$content=do {local $/;<$fh>};close$fh;eval {$content=decode('UTF-8',$content,FB_CROAK | LEAVE_SRC)};return$class->load_string($content,@args)}sub load_string {my ($class,$string,@args)=@_;my$changes=$class->new(@args);my$preamble='';my (@releases,$ingroup,$indent);$string =~ s/(?:\015{1,2}\012|\015|\012)/\n/gs;my@lines=split("\n",$string);my$version_line_re =$changes->{next_token }? qr/^(?:$version::LAX|$changes->{next_token})/ : qr/^$version::LAX/;$preamble .= shift(@lines)."\n" while@lines && $lines[0 ]!~ $version_line_re;for my$l (@lines){if ($l =~ $version_line_re){my ($v,$n)=split m{\s[\W\s]*},$l,2;my$match='';my$d;if ($n){if ($n =~ m{^($UNKNOWN_VALS)}i){$d=$1;$match=$d}elsif ($n =~ m{^(\D{3}\s+(\D{3})\s+(\d{1,2})\s+([\d:]+)?\D*(\d{4}))}){$match=$1;if ($4){$d=sprintf('%d-%02d-%02dT%sZ',$5,$changes->{months }->{$2 },$3,$4)}else {$d=sprintf('%d-%02d-%02d',$5,$changes->{months }->{$2 },$3)}}elsif ($n =~ m{^(\D{3}, (\d{1,2}) (\D{3}) (\d{4}) (\d\d:\d\d:\d\d) ([+-])(\d{2})(\d{2}))}){$match=$1;$d=sprintf('%d-%02d-%02dT%s%s%02d:%02d',$4,$changes->{months }->{$3 },$2,$5,$6,$7,$8)}elsif ($n =~ m{^((\d{4}-\d\d-\d\d)\s+(\d\d:\d\d(?::\d\d)?))(?:\s+[A-Za-z]+/[A-Za-z_-]+)}){$match=$1;$d=sprintf('%sT%sZ',$2,$3)}elsif ($n =~ m{^($W3CDTF_REGEX)}){$match=$1;$d=$match;$d =~ s{ }{T};$d .= 'Z' if length($d)==16 || length($d)==19 || $d =~ m{\.\d+$}}$n =~ s{^\Q$match\E\s*}{}}undef$d unless length$d;undef$n unless length$n;push@releases,CPAN::Changes::Release->new(version=>$v,date=>$d,_parsed_date=>$match,note=>$n,);$ingroup=undef;$indent=undef;next}if ($l =~ m{^\s+\[\s*([^\[\]]+?)\s*\]\s*$}){$ingroup=$1;$releases[-1 ]->add_group($1);next}$ingroup='' if!defined$ingroup;next if$l =~ m{^\s*$};if (!defined$indent){$indent =$l =~ m{^(\s+)} ? '\s' x length $1 : ''}$l =~ s{^$indent}{};if ($l =~ m{^\s} &&!@{$releases[-1 ]->changes($ingroup)}){$l =~ m{^(\s+)};$indent=$1;$l =~ s{^\s+}{}}if ($l =~ m{^\s}){$l =~ s{^\s+}{};my$changeset=$releases[-1 ]->changes($ingroup);$changeset->[-1 ].= " $l"}else {$l =~ s{^[^[:alnum:]]+\s}{};$releases[-1 ]->add_changes({group=>$ingroup },$l)}}$changes->preamble($preamble);$changes->releases(@releases);return$changes}sub preamble {my$self=shift;if (@_){my$preamble=shift;$preamble =~ s{\s+$}{}s;$self->{preamble }=$preamble}return$self->{preamble }}sub releases {my$self=shift;if (@_){$self->{releases }={};$self->add_release(@_)}my$sort_function=sub {(eval {(my$v=$a->version)=~ s/-TRIAL$//;version->parse($v)}|| 0)<=> (eval {(my$v=$b->version)=~ s/-TRIAL$//;version->parse($v)}|| 0)or ($a->date || '')cmp($b->date || '')};my$next_token=$self->{next_token };my$token_sort_function=sub {$a->version =~ $next_token - $b->version =~ $next_token or $sort_function->()};my$sort=$next_token ? $token_sort_function : $sort_function;return sort$sort values %{$self->{releases }}}sub add_release {my$self=shift;for my$release (@_){my$new=Scalar::Util::blessed$release ? $release : CPAN::Changes::Release->new(%$release);$self->{releases }->{$new->version }=$new}}sub delete_release {my$self=shift;delete$self->{releases }->{$_ }for @_}sub release {my ($self,$version)=@_;return unless exists$self->{releases }->{$version };return$self->{releases }->{$version }}sub delete_empty_groups {my$self=shift;$_->delete_empty_groups for$self->releases}sub serialize {my$self=shift;my%args=@_;my%release_args;$release_args{group_sort }=$args{group_sort }if$args{group_sort };my$output;$output=$self->preamble ."\n\n" if$self->preamble;my@r=$self->releases;@r=reverse@r unless$args{reverse};$output .= $_->serialize(%release_args)for@r;$output =~ s/\n\n+\z/\n/;return$output}1;
CPAN_CHANGES

$fatpacked{"CPAN/Changes/Group.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_CHANGES_GROUP';
  package CPAN::Changes::Group;use strict;use warnings;use Text::Wrap ();sub new {my$class=shift;return bless {changes=>[],@_,},$class}sub name {my$self=shift;if (not exists$self->{name }){$self->{name }=q[]}return$self->{name }}sub changes {my$self=shift;return$self->{changes }}sub add_changes {my$self=shift;push @{$self->{changes }},@_}sub set_changes {my$self=shift;$self->{changes }=\@_}sub clear_changes {my$self=shift;$self->{changes }=[]}sub is_empty {my$self=shift;return!@{$self->changes}}sub serialize {my$self=shift;my%args=@_;my$output='';my$name=$self->name;$output .= sprintf " [%s]\n",$name if length$name;local$Text::Wrap::break='[\t ]';local$Text::Wrap::huge='overflow';$output .= Text::Wrap::wrap(' - ','   ',$_)."\n" for @{$self->changes};return$output}1;
CPAN_CHANGES_GROUP

$fatpacked{"CPAN/Changes/Release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_CHANGES_RELEASE';
  package CPAN::Changes::Release;use strict;use warnings;use Text::Wrap ();use CPAN::Changes::Group;use Scalar::Util qw(blessed);sub new {my$class=shift;return bless {changes=>{},@_,},$class}sub version {my$self=shift;if (@_){$self->{version }=shift}return$self->{version }}sub date {my$self=shift;if (@_){$self->{date }=shift}return$self->{date }}sub note {my$self=shift;if (@_){$self->{note }=shift}return$self->{note }}sub changes {my$self=shift;if (@_){my$group=shift;return unless exists$self->{changes }->{$group };return$self->{changes }->{$group }->changes}return {map {$_=>$self->{changes }->{$_}->changes}keys %{$self->{changes }}}}sub add_changes {my$self=shift;my$group='';if (ref $_[0 ]){$group=shift->{group }}$self->get_group($group)->add_changes(@_)}sub set_changes {my$self=shift;my$group='';if (ref $_[0 ]){$group=shift->{group }}$self->get_group($group)->set_changes(@_)}sub clear_changes {my$self=shift;$self->{changes }={}}sub groups {my$self=shift;my%args=@_;$args{sort }||= sub {sort @_};return$args{sort }->(keys %{$self->{changes }})}sub get_group {my$self=shift;my$group='';if ($_[0 ]){$group=shift}if (!exists$self->{changes }->{$group }){$self->{changes }->{$group }=CPAN::Changes::Group->new(name=>$group)}if (not blessed$self->{changes}->{$group}){$self->{changes }->{$group }=CPAN::Changes::Group->new(name=>$group,changes=>$self->{changes}->{$group})}return$self->{changes }->{$group }}sub attach_group {my$self=shift;my$group=shift;die "Not a group" unless blessed$group;my$name=$group->name;$self->{changes}->{$name}=$group}sub group_values {my$self=shift;return map {$self->get_group($_)}$self->groups(@_)}sub add_group {my$self=shift;$self->{changes }->{$_ }=CPAN::Changes::Group->new(name=>$_)for @_}sub delete_group {my$self=shift;my@groups=@_;@groups=('')unless@groups;delete$self->{changes }->{$_ }for@groups}sub delete_empty_groups {my$self=shift;$self->delete_group($_->name)for grep {$_->is_empty}$self->group_values}sub serialize {my$self=shift;my%args=@_;my$output=join(' ',grep {defined && length}($self->version,$self->date,$self->note))."\n";$output .= join "\n",map {$_->serialize}$self->group_values(sort=>$args{group_sort });$output .= "\n";return$output}1;
CPAN_CHANGES_RELEASE

$fatpacked{"CPAN/Common/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index;our$VERSION='0.010';use Carp ();use Class::Tiny;sub index_age {time}sub refresh_index {1}sub attributes {{}}sub validate_attributes {1}1;
CPAN_COMMON_INDEX

$fatpacked{"CPAN/Common/Index/LocalPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_LOCALPACKAGE';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::LocalPackage;our$VERSION='0.010';use parent 'CPAN::Common::Index::Mirror';use Class::Tiny qw/source/;use Carp;use File::Basename ();use File::Copy ();use File::Spec;use File::stat ();sub BUILD {my$self=shift;my$file=$self->source;if (!defined$file){Carp::croak("'source' parameter must be provided")}elsif (!-f $file){Carp::croak("index file '$file' does not exist")}return}sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($self->source));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub refresh_index {my ($self)=@_;my$source=$self->source;my$basename=File::Basename::basename($source);if ($source =~ /\.gz$/){Carp::croak "can't load gz source files without IO::Uncompress::Gunzip\n" unless$CPAN::Common::Index::Mirror::HAS_IO_UNCOMPRESS_GUNZIP;(my$uncompressed=$basename)=~ s/\.gz$//;$uncompressed=File::Spec->catfile($self->cache,$uncompressed);if (!-f $uncompressed or File::stat::stat($source)->mtime > File::stat::stat($uncompressed)->mtime){no warnings 'once';IO::Uncompress::Gunzip::gunzip(map {"$_"}$source,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}else {my$dest=File::Spec->catfile($self->cache,$basename);File::Copy::copy($source,$dest)if!-e $dest || File::stat::stat($source)->mtime > File::stat::stat($dest)->mtime}return 1}sub search_authors {return};1;
CPAN_COMMON_INDEX_LOCALPACKAGE

$fatpacked{"CPAN/Common/Index/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_METADB';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::MetaDB;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/uri/;use Carp;use CPAN::Meta::YAML;use HTTP::Tiny;sub BUILD {my$self=shift;my$uri=$self->uri;$uri="http://cpanmetadb.plackperl.org/v1.0/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';return unless keys %$args==1 && exists$args->{package}&& ref$args->{package}eq '';my$mod=$args->{package};my$res=HTTP::Tiny->new->get($self->uri ."package/$mod");return unless$res->{success};if (my$yaml=CPAN::Meta::YAML->read_string($res->{content})){my$meta=$yaml->[0];if ($meta && $meta->{distfile}){my$file=$meta->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$meta->{version},uri=>"cpan:///distfile/$file",}}}return}sub index_age {return time};sub search_authors {return};1;
CPAN_COMMON_INDEX_METADB

$fatpacked{"CPAN/Common/Index/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MIRROR';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mirror;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/cache mirror/;use Carp;use CPAN::DistnameInfo;use File::Basename ();use File::Fetch;use File::Temp 0.19;use Search::Dict 1.07;use Tie::Handle::SkipHeader;use URI;our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};sub BUILD {my$self=shift;my$cache=$self->cache;$cache=File::Temp->newdir unless defined$cache;if (!-d $cache){Carp::croak("Cache directory '$cache' does not exist")}$self->cache($cache);my$mirror=$self->mirror;$mirror="http://www.cpan.org/" unless defined$mirror;$mirror =~ s{/?$}{/};$self->mirror($mirror);return}my%INDICES=(mailrc=>'authors/01mailrc.txt.gz',packages=>'modules/02packages.details.txt.gz',);my%TEST_GENERATORS=(regexp_nocase=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/i;return sub {$_[0]=~ $re}},regexp=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/;return sub {$_[0]=~ $re}},version=>sub {my$arg=shift;my$v=version->parse($arg);return sub {eval {version->parse($_[0])==$v}}},);my%QUERY_TYPES=(package=>'regexp',version=>'version',dist=>'regexp',id=>'regexp_nocase',fullname=>'regexp_nocase',email=>'regexp_nocase',);sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{packages}));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub cached_mailrc {my ($self)=@_;my$mailrc=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{mailrc}));$mailrc =~ s/\.gz$//;$self->refresh_index unless -r $mailrc;return$mailrc}sub refresh_index {my ($self)=@_;for my$file (values%INDICES){my$remote=URI->new_abs($file,$self->mirror);$remote =~ s/\.gz$// unless$HAS_IO_UNCOMPRESS_GUNZIP;my$ff=File::Fetch->new(uri=>$remote);my$where=$ff->fetch(to=>$self->cache)or Carp::croak($ff->error);if ($HAS_IO_UNCOMPRESS_GUNZIP){(my$uncompressed=$where)=~ s/\.gz$//;no warnings 'once';IO::Uncompress::Gunzip::gunzip($where,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}return 1}sub index_age {my ($self)=@_;my$package=$self->cached_package;return (-r $package ? (stat($package))[9]: 0)}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_package;die "Can't read $index_path" unless -r $index_path;my$fh=IO::Handle->new;tie *$fh,'Tie::Handle::SkipHeader',"<",$index_path or die "Can't tie $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{package}and ref$args->{package}eq ''){my$pos=look$fh,$args->{package},{xfrm=>\&_xform_package,fold=>1 };return if$pos==-1;LINE: while (my$line=<$fh>){last unless$line =~ /\A\Q$args->{package}\E\s+/i;push@found,_match_package_line($line,$rules)}}else {LINE: while (my$line=<$fh>){push@found,_match_package_line($line,$rules)}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_mailrc;die "Can't read $index_path" unless -r $index_path;open my$fh,$index_path or die "Can't open $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{id}and ref$args->{id}eq ''){my$pos=look$fh,$args->{id},{xfrm=>\&_xform_mailrc,fold=>1 };return if$pos==-1;my$line=<$fh>;push@found,_match_mailrc_line($line,$rules)}else {LINE: while (my$line=<$fh>){push@found,_match_mailrc_line($line,$rules)}}return wantarray ? @found : $found[0]}sub _rulify {my ($key,$arg)=@_;return$arg if ref($arg)eq 'CODE';return$TEST_GENERATORS{$QUERY_TYPES{$key}}->($arg)}sub _xform_package {my@fields=split " ",$_[0],2;return$fields[0]}sub _xform_mailrc {my@fields=split " ",$_[0],3;return$fields[1]}sub _match_package_line {my ($line,$rules)=@_;return unless defined$line;my ($mod,$version,$dist,$comment)=split " ",$line,4;if ($rules->{package}){return unless$rules->{package}->($mod)}if ($rules->{version}){return unless$rules->{version}->($version)}if ($rules->{dist}){return unless$rules->{dist}->($dist)}$dist =~ s{\A./../}{};return {package=>$mod,version=>$version,uri=>"cpan:///distfile/$dist",}}sub _match_mailrc_line {my ($line,$rules)=@_;return unless defined$line;my ($id,$address)=$line =~ m{\Aalias\s+(\S+)\s+"(.*)"};my ($fullname,$email)=$address =~ m{([^<]+)<([^>]+)>};$fullname =~ s/\s*$//;if ($rules->{id}){return unless$rules->{id}->($id)}if ($rules->{fullname}){return unless$rules->{fullname}->($fullname)}if ($rules->{email}){return unless$rules->{email}->($email)}return {id=>$id,fullname=>$fullname,email=>$email,}}1;
CPAN_COMMON_INDEX_MIRROR

$fatpacked{"CPAN/Common/Index/Mux/Ordered.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MUX_ORDERED';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mux::Ordered;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/resolvers/;use Module::Load ();sub BUILD {my$self=shift;my$resolvers=$self->resolvers;$resolvers=[]unless defined$resolvers;if (ref$resolvers ne 'ARRAY'){Carp::croak("The 'resolvers' argument must be an array reference")}for my$r (@$resolvers){if (!eval {$r->isa("CPAN::Common::Index")}){Carp::croak("Resolver '$r' is not a CPAN::Common::Index object")}}$self->resolvers($resolvers);return}sub assemble {my ($class,@backends)=@_;my@resolvers;while (@backends){my ($subclass,$config)=splice@backends,0,2;my$full_class="CPAN::Common::Index::${subclass}";eval {Module::Load::load($full_class);1}or Carp::croak($@);my$object=$full_class->new($config);push@resolvers,$object}return$class->new({resolvers=>\@resolvers })}sub validate_attributes {my ($self)=@_;my$resolvers=$self->resolvers;return 1}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_packages($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_packages($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_authors($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_authors($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}1;
CPAN_COMMON_INDEX_MUX_ORDERED

$fatpacked{"CPAN/DistnameInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_DISTNAMEINFO';
  package CPAN::DistnameInfo;$VERSION="0.12";use strict;sub distname_info {my$file=shift or return;my ($dist,$version)=$file =~ /^
      ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
       (?:
  	[A-Za-z](?=[^A-Za-z]|$)
  	|
  	\d(?=-)
       )(?<![._-][vV])
      )+)(.*)
    $/xs or return ($file,undef,undef);if ($dist =~ /-undef\z/ and!length$version){$dist =~ s/-undef\z//}$version =~ s/-withoutworldwriteables$//;if ($version =~ /^(-[Vv].*)-(\d.*)/){$dist .= $1;$version=$2}if ($version =~ /(.+_.*)-(\d.*)/){$dist .= $1;$version=$2}$dist =~ s{\.pm$}{};$version=$1 if!length$version and $dist =~ s/-(\d+\w)$//;$version=$1 .$version if$version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;if ($version =~ /\d\.\d/){$version =~ s/^[-_.]+//}else {$version =~ s/^[-_]+//}my$dev;if (length$version){if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/){$dev=1 if (($1 > 6 and $1 & 1)or ($2 and $2 >= 50))or $3}elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/){$dev=1}}else {$version=undef}($dist,$version,$dev)}sub new {my$class=shift;my$distfile=shift;$distfile =~ s,//+,/,g;my%info=(pathname=>$distfile);($info{filename}=$distfile)=~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,, and $info{cpanid}=$6;if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i){$info{distvname}=$1;$info{extension}=$2}@info{qw(dist version beta)}=distname_info($info{distvname});$info{maturity}=delete$info{beta}? 'developer' : 'released';return bless \%info,$class}sub dist {shift->{dist}}sub version {shift->{version}}sub maturity {shift->{maturity}}sub filename {shift->{filename}}sub cpanid {shift->{cpanid}}sub distvname {shift->{distvname}}sub extension {shift->{extension}}sub pathname {shift->{pathname}}sub properties {%{$_[0]}}1;
CPAN_DISTNAMEINFO

$fatpacked{"CPAN/Meta/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CHECK';
  package CPAN::Meta::Check;$CPAN::Meta::Check::VERSION='0.014';use strict;use warnings;use base 'Exporter';our@EXPORT=qw//;our@EXPORT_OK=qw/check_requirements requirements_for verify_dependencies/;our%EXPORT_TAGS=(all=>[@EXPORT,@EXPORT_OK ]);use CPAN::Meta::Prereqs '2.132830';use CPAN::Meta::Requirements 2.121;use Module::Metadata 1.000023;sub _check_dep {my ($reqs,$module,$dirs)=@_;$module eq 'perl' and return ($reqs->accepts_module($module,$])? (): sprintf "Your Perl (%s) is not in the range '%s'",$],$reqs->requirements_for_module($module));my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return "Module '$module' is not installed" if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is not in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if not $reqs->accepts_module($module,$version || 0);return}sub _check_conflict {my ($reqs,$module,$dirs)=@_;my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if$reqs->accepts_module($module,$version);return}sub requirements_for {my ($meta,$phases,$type)=@_;my$prereqs=ref($meta)eq 'CPAN::Meta' ? $meta->effective_prereqs : $meta;return$prereqs->merged_requirements(ref($phases)? $phases : [$phases ],[$type ])}sub check_requirements {my ($reqs,$type,$dirs)=@_;return +{map {$_=>$type ne 'conflicts' ? scalar _check_dep($reqs,$_,$dirs): scalar _check_conflict($reqs,$_,$dirs)}$reqs->required_modules }}sub verify_dependencies {my ($meta,$phases,$type,$dirs)=@_;my$reqs=requirements_for($meta,$phases,$type);my$issues=check_requirements($reqs,$type,$dirs);return grep {defined}values %{$issues}}1;
CPAN_META_CHECK

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;use strict;use warnings;package Capture::Tiny;our$VERSION='0.48';use Carp ();use Exporter ();use IO::Handle ();use File::Spec ();use File::Temp qw/tempfile tmpnam/;use Scalar::Util qw/reftype blessed/;BEGIN {local $@;eval {require PerlIO;PerlIO->can('get_layers')}or *PerlIO::get_layers=sub {return ()}}my%api=(capture=>[1,1,0,0],capture_stdout=>[1,0,0,0],capture_stderr=>[0,1,0,0],capture_merged=>[1,1,1,0],tee=>[1,1,0,1],tee_stdout=>[1,0,0,1],tee_stderr=>[0,1,0,1],tee_merged=>[1,1,1,1],);for my$sub (keys%api){my$args=join q{, },@{$api{$sub}};eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"}our@ISA=qw/Exporter/;our@EXPORT_OK=keys%api;our%EXPORT_TAGS=('all'=>\@EXPORT_OK);my$IS_WIN32=$^O eq 'MSWin32';our$TIMEOUT=30;my@cmd=($^X,'-C0','-e',<<'HERE');sub _relayer {my ($fh,$apply_layers)=@_;binmode($fh,":raw");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")}my@to_apply=@$apply_layers;shift@to_apply;binmode($fh,":" .join(":",@to_apply))}sub _name {my$glob=shift;no strict 'refs';return *{$glob}{NAME}}sub _open {open $_[0],$_[1]or Carp::confess "Error from open(" .join(q{, },@_)."): $!"}sub _close {close $_[0]or Carp::confess "Error from close(" .join(q{, },@_)."): $!"}my%dup;my%proxy_count;sub _proxy_std {my%proxies;if (!defined fileno STDIN){$proxy_count{stdin}++;if (defined$dup{stdin}){_open \*STDIN,"<&=" .fileno($dup{stdin})}else {_open \*STDIN,"<" .File::Spec->devnull;_open$dup{stdin}=IO::Handle->new,"<&=STDIN"}$proxies{stdin}=\*STDIN;binmode(STDIN,':utf8')if $] >= 5.008}if (!defined fileno STDOUT){$proxy_count{stdout}++;if (defined$dup{stdout}){_open \*STDOUT,">&=" .fileno($dup{stdout})}else {_open \*STDOUT,">" .File::Spec->devnull;_open$dup{stdout}=IO::Handle->new,">&=STDOUT"}$proxies{stdout}=\*STDOUT;binmode(STDOUT,':utf8')if $] >= 5.008}if (!defined fileno STDERR){$proxy_count{stderr}++;if (defined$dup{stderr}){_open \*STDERR,">&=" .fileno($dup{stderr})}else {_open \*STDERR,">" .File::Spec->devnull;_open$dup{stderr}=IO::Handle->new,">&=STDERR"}$proxies{stderr}=\*STDERR;binmode(STDERR,':utf8')if $] >= 5.008}return%proxies}sub _unproxy {my (%proxies)=@_;for my$p (keys%proxies){$proxy_count{$p}--;if (!$proxy_count{$p}){_close$proxies{$p};_close$dup{$p}unless $] < 5.008;delete$dup{$p}}}}sub _copy_std {my%handles;for my$h (qw/stdout stderr stdin/){next if$h eq 'stdin' &&!$IS_WIN32;my$redir=$h eq 'stdin' ? "<&" : ">&";_open$handles{$h}=IO::Handle->new(),$redir .uc($h)}return \%handles}sub _open_std {my ($handles)=@_;_open \*STDIN,"<&" .fileno$handles->{stdin}if defined$handles->{stdin};_open \*STDOUT,">&" .fileno$handles->{stdout}if defined$handles->{stdout};_open \*STDERR,">&" .fileno$handles->{stderr}if defined$handles->{stderr}}sub _start_tee {my ($which,$stash)=@_;$stash->{$_}{$which}=IO::Handle->new for qw/tee reader/;pipe$stash->{reader}{$which},$stash->{tee}{$which};select((select($stash->{tee}{$which}),$|=1)[0]);$stash->{new}{$which}=$stash->{tee}{$which};$stash->{child}{$which}={stdin=>$stash->{reader}{$which},stdout=>$stash->{old}{$which},stderr=>$stash->{capture}{$which},};$stash->{flag_files}{$which}=scalar(tmpnam()).$$;if ($IS_WIN32){my$old_eval_err=$@;undef $@;eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";my$os_fhandle=GetOsFHandle($stash->{tee}{$which});my$result=SetHandleInformation($os_fhandle,HANDLE_FLAG_INHERIT(),0);_open_std($stash->{child}{$which});$stash->{pid}{$which}=system(1,@cmd,$stash->{flag_files}{$which});$@=$old_eval_err}else {_fork_exec($which,$stash)}}sub _fork_exec {my ($which,$stash)=@_;my$pid=fork;if (not defined$pid){Carp::confess "Couldn't fork(): $!"}elsif ($pid==0){untie*STDIN;untie*STDOUT;untie*STDERR;_close$stash->{tee}{$which};_open_std($stash->{child}{$which});exec@cmd,$stash->{flag_files}{$which}}$stash->{pid}{$which}=$pid}my$have_usleep=eval "use Time::HiRes 'usleep'; 1";sub _files_exist {return 1 if @_==grep {-f}@_;Time::HiRes::usleep(1000)if$have_usleep;return 0}sub _wait_for_tees {my ($stash)=@_;my$start=time;my@files=values %{$stash->{flag_files}};my$timeout=defined$ENV{PERL_CAPTURE_TINY_TIMEOUT}? $ENV{PERL_CAPTURE_TINY_TIMEOUT}: $TIMEOUT;1 until _files_exist(@files)|| ($timeout && (time - $start > $timeout));Carp::confess "Timed out waiting for subprocesses to start" if!_files_exist(@files);unlink $_ for@files}sub _kill_tees {my ($stash)=@_;if ($IS_WIN32){close($_)for values %{$stash->{tee}};my$start=time;1 until wait==-1 || (time - $start > 30)}else {_close $_ for values %{$stash->{tee}};waitpid $_,0 for values %{$stash->{pid}}}}sub _slurp {my ($name,$stash)=@_;my ($fh,$pos)=map {$stash->{$_}{$name}}qw/capture pos/;seek($fh,$pos,0)or die "Couldn't seek on capture handle for $name\n";my$text=do {local $/;scalar readline$fh};return defined($text)? $text : ""}sub _capture_tee {my ($do_stdout,$do_stderr,$do_merge,$do_tee,$code,@opts)=@_;my%do=($do_stdout ? (stdout=>1): (),$do_stderr ? (stderr=>1): ());Carp::confess("Custom capture options must be given as key/value pairs\n")unless@opts % 2==0;my$stash={capture=>{@opts }};for (keys %{$stash->{capture}}){my$fh=$stash->{capture}{$_};Carp::confess "Custom handle for $_ must be seekable\n" unless ref($fh)eq 'GLOB' || (blessed($fh)&& $fh->isa("IO::Seekable"))}local*CT_ORIG_STDIN=*STDIN ;local*CT_ORIG_STDOUT=*STDOUT;local*CT_ORIG_STDERR=*STDERR;my%layers=(stdin=>[PerlIO::get_layers(\*STDIN)],stdout=>[PerlIO::get_layers(\*STDOUT,output=>1)],stderr=>[PerlIO::get_layers(\*STDERR,output=>1)],);$layers{stdout}=[PerlIO::get_layers(tied*STDOUT)]if tied(*STDOUT)&& (reftype tied*STDOUT eq 'GLOB');$layers{stderr}=[PerlIO::get_layers(tied*STDERR)]if tied(*STDERR)&& (reftype tied*STDERR eq 'GLOB');my%localize;$localize{stdin}++,local(*STDIN)if grep {$_ eq 'scalar'}@{$layers{stdin}};$localize{stdout}++,local(*STDOUT)if$do_stdout && grep {$_ eq 'scalar'}@{$layers{stdout}};$localize{stderr}++,local(*STDERR)if ($do_stderr || $do_merge)&& grep {$_ eq 'scalar'}@{$layers{stderr}};$localize{stdin}++,local(*STDIN),_open(\*STDIN,"<&=0")if tied*STDIN && $] >= 5.008;$localize{stdout}++,local(*STDOUT),_open(\*STDOUT,">&=1")if$do_stdout && tied*STDOUT && $] >= 5.008;$localize{stderr}++,local(*STDERR),_open(\*STDERR,">&=2")if ($do_stderr || $do_merge)&& tied*STDERR && $] >= 5.008;my%proxy_std=_proxy_std();$layers{stdout}=[PerlIO::get_layers(\*STDOUT,output=>1)]if$proxy_std{stdout};$layers{stderr}=[PerlIO::get_layers(\*STDERR,output=>1)]if$proxy_std{stderr};$stash->{old}=_copy_std();$stash->{new}={%{$stash->{old}}};for (keys%do){$stash->{new}{$_}=($stash->{capture}{$_}||= File::Temp->new);seek($stash->{capture}{$_},0,2)or die "Could not seek on capture handle for $_\n";$stash->{pos}{$_}=tell$stash->{capture}{$_};_start_tee($_=>$stash)if$do_tee}_wait_for_tees($stash)if$do_tee;$stash->{new}{stderr}=$stash->{new}{stdout}if$do_merge;_open_std($stash->{new});my ($exit_code,$inner_error,$outer_error,$orig_pid,@result);{$orig_pid=$$;local*STDIN=*CT_ORIG_STDIN if$localize{stdin};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;my$old_eval_err=$@;undef $@;eval {@result=$code->();$inner_error=$@};$exit_code=$?;$outer_error=$@;STDOUT->flush if$do_stdout;STDERR->flush if$do_stderr;$@=$old_eval_err}_open_std($stash->{old});_close($_)for values %{$stash->{old}};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;_unproxy(%proxy_std);_kill_tees($stash)if$do_tee;my%got;if ($orig_pid==$$ and (defined wantarray or ($do_tee && keys%localize))){for (keys%do){_relayer($stash->{capture}{$_},$layers{$_});$got{$_}=_slurp($_,$stash)}print CT_ORIG_STDOUT$got{stdout}if$do_stdout && $do_tee && $localize{stdout};print CT_ORIG_STDERR$got{stderr}if$do_stderr && $do_tee && $localize{stderr}}$?=$exit_code;$@=$inner_error if$inner_error;die$outer_error if$outer_error;return unless defined wantarray;my@return;push@return,$got{stdout}if$do_stdout;push@return,$got{stderr}if$do_stderr &&!$do_merge;push@return,@result;return wantarray ? @return : $return[0]}1;
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
CAPTURE_TINY

$fatpacked{"Carton.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON';
  package Carton;use strict;use 5.008_005;use version;our$VERSION=version->declare("v1.0.34");1;
CARTON

$fatpacked{"Carton/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_BUILDER';
  package Carton::Builder;use strict;use Class::Tiny {mirror=>undef,index=>undef,cascade=>sub {1},without=>sub {[]},cpanfile=>undef,};sub effective_mirrors {my$self=shift;my@mirrors=($self->mirror);push@mirrors,Carton::Mirror->default if$self->custom_mirror;push@mirrors,Carton::Mirror->new('http://backpan.perl.org/');@mirrors}sub custom_mirror {my$self=shift;!$self->mirror->is_default}sub bundle {my($self,$path,$cache_path,$snapshot)=@_;for my$dist ($snapshot->distributions){my$source=$path->child("cache/authors/id/" .$dist->pathname);my$target=$cache_path->child("authors/id/" .$dist->pathname);if ($source->exists){warn "Copying ",$dist->pathname,"\n";$target->parent->mkpath;$source->copy($target)or warn "$target: $!"}else {warn "Couldn't find @{[ $dist->pathname ]}\n"}}my$has_io_gzip=eval {require IO::Compress::Gzip;1};my$ext=$has_io_gzip ? ".txt.gz" : ".txt";my$index=$cache_path->child("modules/02packages.details$ext");$index->parent->mkpath;warn "Writing $index\n";my$out=$index->openw;if ($has_io_gzip){$out=IO::Compress::Gzip->new($out)or die "gzip failed: $IO::Compress::Gzip::GzipError"}$snapshot->index->write($out);close$out;unless ($has_io_gzip){unlink "$index.gz";!system 'gzip',$index or die "Running gzip command failed: $!"}}sub install {my($self,$path)=@_;$self->run_install("-L",$path,(map {("--mirror",$_->url)}$self->effective_mirrors),($self->index ? ("--mirror-index",$self->index): ()),($self->cascade ? "--cascade-search" : ()),($self->custom_mirror ? "--mirror-only" : ()),"--save-dists","$path/cache",$self->groups,"--cpanfile",$self->cpanfile,"--installdeps",$self->cpanfile->dirname,)or die "Installing modules failed\n"}sub groups {my$self=shift;my@options=('--with-all-features','--with-develop');for my$group (@{$self->without}){push@options,'--without-develop' if$group eq 'develop';push@options,"--without-feature=$group"}return@options}sub update {my($self,$path,@modules)=@_;$self->run_install("-L",$path,(map {("--mirror",$_->url)}$self->effective_mirrors),($self->custom_mirror ? "--mirror-only" : ()),"--save-dists","$path/cache",@modules)or die "Updating modules failed\n"}sub run_install {my($self,@args)=@_;require Menlo::CLI::Compat;local$ENV{PERL_CPANM_OPT};my$cli=Menlo::CLI::Compat->new;$cli->parse_options("--quiet","--notest",@args);$cli->run;!$cli->status}1;
CARTON_BUILDER

$fatpacked{"Carton/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CLI';
  package Carton::CLI;use strict;use warnings;use Config;use Getopt::Long;use Path::Tiny;use Try::Tiny;use Module::CoreList;use Scalar::Util qw(blessed);use Carton;use Carton::Builder;use Carton::Mirror;use Carton::Snapshot;use Carton::Util;use Carton::Environment;use Carton::Error;use constant {SUCCESS=>0,INFO=>1,WARN=>2,ERROR=>3 };our$UseSystem=0;use Class::Tiny {verbose=>undef,carton=>sub {$_[0]->_build_carton},mirror=>sub {$_[0]->_build_mirror},};sub _build_mirror {my$self=shift;Carton::Mirror->new($ENV{PERL_CARTON_MIRROR}|| $Carton::Mirror::DefaultMirror)}sub run {my($self,@args)=@_;my@commands;my$p=Getopt::Long::Parser->new(config=>["no_ignore_case","pass_through" ],);$p->getoptionsfromarray(\@args,"h|help"=>sub {unshift@commands,'help'},"v|version"=>sub {unshift@commands,'version'},"verbose!"=>sub {$self->verbose($_[1])},);push@commands,@args;my$cmd=shift@commands || 'install';my$code=try {my$call=$self->can("cmd_$cmd")or Carton::Error::CommandNotFound->throw(error=>"Could not find command '$cmd'");$self->$call(@commands);return 0}catch {die $_ unless blessed $_ && $_->can('rethrow');if ($_->isa('Carton::Error::CommandExit')){return $_->code || 255}elsif ($_->isa('Carton::Error::CommandNotFound')){warn $_->error,"\n\n";$self->cmd_usage;return 255}elsif ($_->isa('Carton::Error')){warn $_->error,"\n";return 255}};return$code}sub commands {my$self=shift;no strict 'refs';map {s/^cmd_//;$_}grep {/^cmd_.*/ && $self->can($_)}sort keys %{__PACKAGE__."::"}}sub cmd_usage {my$self=shift;$self->print(<<HELP)}sub parse_options {my($self,$args,@spec)=@_;my$p=Getopt::Long::Parser->new(config=>["no_auto_abbrev","no_ignore_case" ],);$p->getoptionsfromarray($args,@spec)}sub parse_options_pass_through {my($self,$args,@spec)=@_;my$p=Getopt::Long::Parser->new(config=>["no_auto_abbrev","no_ignore_case","pass_through" ],);$p->getoptionsfromarray($args,@spec);shift @$args if$args->[0]&& $args->[0]eq '--'}sub printf {my$self=shift;my$type=pop;my($temp,@args)=@_;$self->print(sprintf($temp,@args),$type)}sub print {my($self,$msg,$type)=@_;my$fh=$type && $type >= WARN ? *STDERR : *STDOUT;print {$fh}$msg}sub error {my($self,$msg)=@_;$self->print($msg,ERROR);Carton::Error::CommandExit->throw}sub cmd_help {my$self=shift;my$module=$_[0]? ("Carton::Doc::" .ucfirst $_[0]): "Carton.pm";system "perldoc",$module}sub cmd_version {my$self=shift;$self->print("carton $Carton::VERSION\n")}sub cmd_bundle {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;$self->print("Bundling modules using @{[$env->cpanfile]}\n");my$builder=Carton::Builder->new(mirror=>$self->mirror,cpanfile=>$env->cpanfile,);$builder->bundle($env->install_path,$env->vendor_cache,$env->snapshot);$self->printf("Complete! Modules were bundled into %s\n",$env->vendor_cache,SUCCESS)}sub cmd_fatpack {my($self,@args)=@_;my$env=Carton::Environment->build;require Carton::Packer;Carton::Packer->new->fatpack_carton($env->vendor_bin)}sub cmd_install {my($self,@args)=@_;my($install_path,$cpanfile_path,@without);$self->parse_options(\@args,"p|path=s"=>\$install_path,"cpanfile=s"=>\$cpanfile_path,"without=s"=>sub {push@without,split /,/,$_[1]},"deployment!"=>\my$deployment,"cached!"=>\my$cached,);my$env=Carton::Environment->build($cpanfile_path,$install_path);$env->snapshot->load_if_exists;if ($deployment &&!$env->snapshot->loaded){$self->error("--deployment requires cpanfile.snapshot: Run `carton install` and make sure cpanfile.snapshot is checked into your version control.\n")}my$builder=Carton::Builder->new(cascade=>1,mirror=>$self->mirror,without=>\@without,cpanfile=>$env->cpanfile,);if ($deployment){$self->print("Installing modules using @{[$env->cpanfile]} (deployment mode)\n");$builder->cascade(0)}else {$self->print("Installing modules using @{[$env->cpanfile]}\n")}if ($env->snapshot->loaded){my$index_file=$env->install_path->child("cache/modules/02packages.details.txt");$index_file->parent->mkpath;$env->snapshot->write_index($index_file);$builder->index($index_file)}if ($cached){$builder->mirror(Carton::Mirror->new($env->vendor_cache))}$builder->install($env->install_path);unless ($deployment){$env->cpanfile->load;$env->snapshot->find_installs($env->install_path,$env->cpanfile->requirements);$env->snapshot->save}$self->print("Complete! Modules were installed into @{[$env->install_path]}\n",SUCCESS)}sub cmd_show {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;for my$module (@args){my$dist=$env->snapshot->find($module)or $self->error("Couldn't locate $module in cpanfile.snapshot\n");$self->print($dist->name ."\n")}}sub cmd_list {my($self,@args)=@_;my$format='name';$self->parse_options(\@args,"distfile"=>sub {$format='distfile'},);my$env=Carton::Environment->build;$env->snapshot->load;for my$dist ($env->snapshot->distributions){$self->print($dist->$format ."\n")}}sub cmd_tree {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;$env->cpanfile->load;my%seen;my$dumper=sub {my($dependency,$reqs,$level)=@_;return if$level==0;return Carton::Tree::STOP if$dependency->dist->is_core;return Carton::Tree::STOP if$seen{$dependency->distname}++;$self->printf("%s%s (%s)\n"," " x ($level - 1),$dependency->module,$dependency->distname,INFO)};$env->tree->walk_down($dumper)}sub cmd_check {my($self,@args)=@_;my$cpanfile_path;$self->parse_options(\@args,"cpanfile=s"=>\$cpanfile_path,);my$env=Carton::Environment->build($cpanfile_path);$env->snapshot->load;$env->cpanfile->load;my$merged_reqs=$env->tree->merged_requirements;my@missing;for my$module ($merged_reqs->required_modules){my$install=$env->snapshot->find_or_core($module);if ($install){unless ($merged_reqs->accepts_module($module=>$install->version_for($module))){push@missing,[$module,1,$install->version_for($module)]}}else {push@missing,[$module,0 ]}}if (@missing){$self->print("Following dependencies are not satisfied.\n",INFO);for my$missing (@missing){my($module,$unsatisfied,$version)=@$missing;if ($unsatisfied){$self->printf("  %s has version %s. Needs %s\n",$module,$version,$merged_reqs->requirements_for_module($module),INFO)}else {$self->printf("  %s is not installed. Needs %s\n",$module,$merged_reqs->requirements_for_module($module),INFO)}}$self->printf("Run `carton install` to install them.\n",INFO);Carton::Error::CommandExit->throw}else {$self->print("cpanfile's dependencies are satisfied.\n",INFO)}}sub cmd_update {my($self,@args)=@_;my$env=Carton::Environment->build;$env->cpanfile->load;my$cpanfile=Module::CPANfile->load($env->cpanfile);@args=grep {$_ ne 'perl'}$env->cpanfile->required_modules unless@args;$env->snapshot->load;my@modules;for my$module (@args){my$dist=$env->snapshot->find_or_core($module)or $self->error("Could not find module $module.\n");next if$dist->is_core;push@modules,"$module~" .$env->cpanfile->requirements_for_module($module)}return unless@modules;my$builder=Carton::Builder->new(mirror=>$self->mirror,cpanfile=>$env->cpanfile,);$builder->update($env->install_path,@modules);$env->snapshot->find_installs($env->install_path,$env->cpanfile->requirements);$env->snapshot->save}sub cmd_run {my($self,@args)=@_;local$UseSystem=1;$self->cmd_exec(@args)}sub cmd_exec {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;@args=map {/^(-[I])(.+)/ ? ($1,$2): $_}@args;while (@args){if ($args[0]eq '-I'){warn "exec -Ilib is deprecated. You might want to run: carton exec perl -Ilib ...\n";splice(@args,0,2)}else {last}}$self->parse_options_pass_through(\@args);unless (@args){$self->error("carton exec needs a command to run.\n")}my$path=$env->install_path;local$ENV{PERL5LIB}="$path/lib/perl5";local$ENV{PATH}="$path/bin:$ENV{PATH}";if ($UseSystem){system@args}else {exec@args;exit 127}}1;
  Usage: carton <command>
  
  where <command> is one of:
    @{[ join ", ", $self->commands ]}
  
  Run carton -h <command> for help.
  HELP
CARTON_CLI

$fatpacked{"Carton/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CPANFILE';
  package Carton::CPANfile;use Path::Tiny ();use Module::CPANfile;use overload q{""}=>sub {$_[0]->stringify},fallback=>1;use subs 'path';use Class::Tiny {path=>undef,_cpanfile=>undef,requirements=>sub {$_[0]->_build_requirements},};sub stringify {shift->path->stringify(@_)}sub dirname {shift->path->dirname(@_)}sub prereqs {shift->_cpanfile->prereqs(@_)}sub required_modules {shift->requirements->required_modules(@_)}sub requirements_for_module {shift->requirements->requirements_for_module(@_)}sub path {my$self=shift;if (@_){$self->{path}=Path::Tiny->new($_[0])}else {$self->{path}}}sub load {my$self=shift;$self->_cpanfile(Module::CPANfile->load($self->path))}sub _build_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;$reqs->add_requirements($self->prereqs->requirements_for($_,'requires'))for qw(configure build runtime test develop);$reqs->clear_requirement('perl');$reqs}1;
CARTON_CPANFILE

$fatpacked{"Carton/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DEPENDENCY';
  package Carton::Dependency;use strict;use Class::Tiny {module=>undef,requirement=>undef,dist=>undef,};sub requirements {shift->dist->requirements(@_)}sub distname {my$self=shift;$self->dist->name}sub version {my$self=shift;$self->dist->version_for($self->module)}1;
CARTON_DEPENDENCY

$fatpacked{"Carton/Dist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST';
  package Carton::Dist;use strict;use Class::Tiny {name=>undef,pathname=>undef,provides=>sub {+{}},requirements=>sub {$_[0]->_build_requirements},};use CPAN::Meta;sub add_string_requirement {shift->requirements->add_string_requirement(@_)}sub required_modules {shift->requirements->required_modules(@_)}sub requirements_for_module {shift->requirements->requirements_for_module(@_)}sub is_core {0}sub distfile {my$self=shift;$self->pathname}sub _build_requirements {CPAN::Meta::Requirements->new}sub provides_module {my($self,$module)=@_;exists$self->provides->{$module}}sub version_for {my($self,$module)=@_;$self->provides->{$module}{version}}1;
CARTON_DIST

$fatpacked{"Carton/Dist/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST_CORE';
  package Carton::Dist::Core;use strict;use parent 'Carton::Dist';use Class::Tiny qw(module_version);sub BUILDARGS {my($class,%args)=@_;$args{name}=~ s/::/-/g;\%args}sub is_core {1}sub version_for {my($self,$module)=@_;$self->module_version}1;
CARTON_DIST_CORE

$fatpacked{"Carton/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ENVIRONMENT';
  package Carton::Environment;use strict;use Carton::CPANfile;use Carton::Snapshot;use Carton::Error;use Carton::Tree;use Path::Tiny;use Class::Tiny {cpanfile=>undef,snapshot=>sub {$_[0]->_build_snapshot},install_path=>sub {$_[0]->_build_install_path},vendor_cache=>sub {$_[0]->_build_vendor_cache},tree=>sub {$_[0]->_build_tree},};sub _build_snapshot {my$self=shift;Carton::Snapshot->new(path=>$self->cpanfile .".snapshot")}sub _build_install_path {my$self=shift;if ($ENV{PERL_CARTON_PATH}){return Path::Tiny->new($ENV{PERL_CARTON_PATH})}else {return$self->cpanfile->path->parent->child("local")}}sub _build_vendor_cache {my$self=shift;Path::Tiny->new($self->install_path->dirname ."/vendor/cache")}sub _build_tree {my$self=shift;Carton::Tree->new(cpanfile=>$self->cpanfile,snapshot=>$self->snapshot)}sub vendor_bin {my$self=shift;$self->vendor_cache->parent->child('bin')}sub build_with {my($class,$cpanfile)=@_;$cpanfile=Path::Tiny->new($cpanfile)->absolute;if ($cpanfile->is_file){return$class->new(cpanfile=>Carton::CPANfile->new(path=>$cpanfile))}else {Carton::Error::CPANfileNotFound->throw(error=>"Can't locate cpanfile: $cpanfile")}}sub build {my($class,$cpanfile_path,$install_path)=@_;my$self=$class->new;$cpanfile_path &&= Path::Tiny->new($cpanfile_path)->absolute;my$cpanfile=$self->locate_cpanfile($cpanfile_path || $ENV{PERL_CARTON_CPANFILE});if ($cpanfile && $cpanfile->is_file){$self->cpanfile(Carton::CPANfile->new(path=>$cpanfile))}else {Carton::Error::CPANfileNotFound->throw(error=>"Can't locate cpanfile: (@{[ $cpanfile_path || 'cpanfile' ]})")}$self->install_path(Path::Tiny->new($install_path)->absolute)if$install_path;$self}sub locate_cpanfile {my($self,$path)=@_;if ($path){return Path::Tiny->new($path)->absolute}my$current=Path::Tiny->cwd;my$previous='';until ($current eq '/' or $current eq $previous){my$try=$current->child('cpanfile');if ($try->is_file){return$try->absolute}($previous,$current)=($current,$current->parent)}return}1;
CARTON_ENVIRONMENT

$fatpacked{"Carton/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ERROR';
  package Carton::Error;use strict;use overload '""'=>sub {$_[0]->error};use Carp;sub throw {my($class,@args)=@_;die$class->new(@args)}sub rethrow {die $_[0]}sub new {my($class,%args)=@_;bless \%args,$class}sub error {$_[0]->{error}|| ref $_[0]}package Carton::Error::CommandNotFound;use parent 'Carton::Error';package Carton::Error::CommandExit;use parent 'Carton::Error';sub code {$_[0]->{code}}package Carton::Error::CPANfileNotFound;use parent 'Carton::Error';package Carton::Error::SnapshotParseError;use parent 'Carton::Error';sub path {$_[0]->{path}}package Carton::Error::SnapshotNotFound;use parent 'Carton::Error';sub path {$_[0]->{path}}1;
CARTON_ERROR

$fatpacked{"Carton/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_INDEX';
  package Carton::Index;use strict;use Class::Tiny {_packages=>sub {+{}},generator=>sub {require Carton;"Carton $Carton::VERSION"},};sub add_package {my($self,$package)=@_;$self->_packages->{$package->name}=$package}sub count {my$self=shift;scalar keys %{$self->_packages}}sub packages {my$self=shift;sort {lc$a->name cmp lc$b->name}values %{$self->_packages}}sub write {my($self,$fh)=@_;print$fh <<EOF;for my$p ($self->packages){print$fh $self->_format_line($p->name,$p->version_format,$p->pathname)}}sub _format_line {my($self,@row)=@_;my$one=30;my$two=8;if (length$row[0]> $one){$one += 8 - length$row[1];$two=length$row[1]}sprintf "%-${one}s %${two}s  %s\n",@row}sub pad {my($str,$len,$left)=@_;my$howmany=$len - length($str);return$str if$howmany <= 0;my$pad=" " x $howmany;return$left ? "$pad$str" : "$str$pad"}1;
  File:         02packages.details.txt
  URL:          http://www.perl.com/CPAN/modules/02packages.details.txt
  Description:  Package names found in cpanfile.snapshot
  Columns:      package name, version, path
  Intended-For: Automated fetch routines, namespace documentation.
  Written-By:   @{[ $self->generator ]}
  Line-Count:   @{[ $self->count ]}
  Last-Updated: @{[ scalar localtime ]}
  
  EOF
CARTON_INDEX

$fatpacked{"Carton/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_MIRROR';
  package Carton::Mirror;use strict;use Class::Tiny qw(url);our$DefaultMirror='http://cpan.metacpan.org/';sub BUILDARGS {my($class,$url)=@_;return {url=>$url }}sub default {my$class=shift;$class->new($DefaultMirror)}sub is_default {my$self=shift;$self->url eq $DefaultMirror}1;
CARTON_MIRROR

$fatpacked{"Carton/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKAGE';
  package Carton::Package;use strict;use Class::Tiny qw(name version pathname);sub BUILDARGS {my($class,@args)=@_;return {name=>$args[0],version=>$args[1],pathname=>$args[2]}}sub version_format {my$self=shift;defined$self->version ? $self->version : 'undef'}1;
CARTON_PACKAGE

$fatpacked{"Carton/Packer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKER';
  package Carton::Packer;use Class::Tiny;use warnings NONFATAL=>'all';use App::FatPacker;use File::pushd ();use Path::Tiny ();use CPAN::Meta ();use File::Find ();sub fatpack_carton {my($self,$dir)=@_;my$temp=Path::Tiny->tempdir;my$pushd=File::pushd::pushd$temp;my$file=$temp->child('carton.pre.pl');$file->spew(<<'EOF');my$fatpacked=$self->do_fatpack($file);my$executable=$dir->child('carton');warn "Bundling $executable\n";$dir->mkpath;$executable->spew($fatpacked);chmod 0755,$executable}sub do_fatpack {my($self,$file)=@_;my$packer=App::FatPacker->new;my@modules=split /\r?\n/,$packer->trace(args=>[$file],use=>$self->required_modules);my@packlists=$packer->packlists_containing(\@modules);$packer->packlists_to_tree(Path::Tiny->new('fatlib')->absolute,\@packlists);my$fatpacked=do {local$SIG{__WARN__}=sub {};$packer->fatpack_file($file)};use Config;$fatpacked =~ s/\$fatpacked\{"$Config{archname}\/(Cwd|File)/\$fatpacked{"$1/g;$fatpacked}sub required_modules {my$self=shift;my%requirements;for my$dist (qw(Carton Menlo-Legacy Menlo)){$requirements{$_}=1 for$self->required_modules_for($dist)}my@extra=qw(Menlo::Index::Mirror);[keys%requirements,@extra ]}sub required_modules_for {my($self,$dist)=@_;my$meta=$self->installed_meta($dist)or die "Couldn't find install metadata for $dist";my%excludes=(perl=>1,'ExtUtils::MakeMaker'=>1,'Module::Build'=>1,);grep!$excludes{$_},$meta->effective_prereqs->requirements_for('runtime','requires')->required_modules}sub installed_meta {my($self,$dist)=@_;my@meta;my$finder=sub {if (m!\b$dist-.*[\\/]MYMETA.json!){my$meta=CPAN::Meta->load_file($_);push@meta,$meta if$meta->name eq $dist}};my@meta_dirs=grep -d,map "$_/.meta",@INC;File::Find::find({wanted=>$finder,no_chdir=>1 },@meta_dirs)if@meta_dirs;@meta=sort {version->new($b->version)cmp version->new($a->version)}@meta;return$meta[0]}1;
  #!/usr/bin/env perl
  use strict;
  use 5.008001;
  use Carton::CLI;
  $Carton::Fatpacked = 1;
  exit Carton::CLI->new->run(@ARGV);
  EOF
CARTON_PACKER

$fatpacked{"Carton/Snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT';
  package Carton::Snapshot;use strict;use Config;use Carton::Dist;use Carton::Dist::Core;use Carton::Error;use Carton::Package;use Carton::Index;use Carton::Util;use Carton::Snapshot::Emitter;use Carton::Snapshot::Parser;use CPAN::Meta;use CPAN::Meta::Requirements;use File::Find ();use Try::Tiny;use Path::Tiny ();use Module::CoreList;use constant CARTON_SNAPSHOT_VERSION=>'1.0';use subs 'path';use Class::Tiny {path=>undef,version=>sub {CARTON_SNAPSHOT_VERSION},loaded=>undef,_distributions=>sub {+[]},};sub BUILD {my$self=shift;$self->path($self->{path})}sub path {my$self=shift;if (@_){$self->{path}=Path::Tiny->new($_[0])}else {$self->{path}}}sub load_if_exists {my$self=shift;$self->load if$self->path->is_file}sub load {my$self=shift;return 1 if$self->loaded;if ($self->path->is_file){my$parser=Carton::Snapshot::Parser->new;$parser->parse($self->path->slurp_utf8,$self);$self->loaded(1);return 1}else {Carton::Error::SnapshotNotFound->throw(error=>"Can't find cpanfile.snapshot: Run `carton install` to build the snapshot file.",path=>$self->path,)}}sub save {my$self=shift;$self->path->spew_utf8(Carton::Snapshot::Emitter->new->emit($self))}sub find {my($self,$module)=@_;(grep $_->provides_module($module),$self->distributions)[0]}sub find_or_core {my($self,$module)=@_;$self->find($module)|| $self->find_in_core($module)}sub find_in_core {my($self,$module)=@_;if (exists$Module::CoreList::version{$]}{$module}){my$version=$Module::CoreList::version{$]}{$module};return Carton::Dist::Core->new(name=>$module,module_version=>$version)}return}sub index {my$self=shift;my$index=Carton::Index->new;for my$package ($self->packages){$index->add_package($package)}return$index}sub distributions {@{$_[0]->_distributions}}sub add_distribution {my($self,$dist)=@_;push @{$self->_distributions},$dist}sub packages {my$self=shift;my@packages;for my$dist ($self->distributions){while (my($package,$provides)=each %{$dist->provides}){push@packages,Carton::Package->new($package,$provides->{version},$dist->pathname)}}return@packages}sub write_index {my($self,$file)=@_;open my$fh,">",$file or die $!;$self->index->write($fh)}sub find_installs {my($self,$path,$reqs)=@_;my$libdir="$path/lib/perl5/$Config{archname}/.meta";return {}unless -e $libdir;my@installs;my$wanted=sub {if ($_ eq 'install.json'){push@installs,[$File::Find::name,"$File::Find::dir/MYMETA.json" ]}};File::Find::find($wanted,$libdir);my%installs;my$accepts=sub {my$module=shift;return 0 unless$reqs->accepts_module($module->{name},$module->{provides}{$module->{name}}{version});if (my$exist=$installs{$module->{name}}){my$old_ver=version::->new($exist->{provides}{$module->{name}}{version});my$new_ver=version::->new($module->{provides}{$module->{name}}{version});return$new_ver >= $old_ver}else {return 1}};for my$file (@installs){my$module=Carton::Util::load_json($file->[0]);my$prereqs=-f $file->[1]? CPAN::Meta->load_file($file->[1])->effective_prereqs : CPAN::Meta::Prereqs->new;my$reqs=CPAN::Meta::Requirements->new;$reqs->add_requirements($prereqs->requirements_for($_,'requires'))for qw(configure build runtime);if ($accepts->($module)){$installs{$module->{name}}=Carton::Dist->new(name=>$module->{dist},pathname=>$module->{pathname},provides=>$module->{provides},version=>$module->{version},requirements=>$reqs,)}}my@new_dists;for my$module (sort keys%installs){push@new_dists,$installs{$module}}$self->_distributions(\@new_dists)}1;
CARTON_SNAPSHOT

$fatpacked{"Carton/Snapshot/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_EMITTER';
  package Carton::Snapshot::Emitter;use Class::Tiny;use warnings NONFATAL=>'all';sub emit {my($self,$snapshot)=@_;my$data='';$data .= "# carton snapshot format: version @{[$snapshot->version]}\n";$data .= "DISTRIBUTIONS\n";for my$dist (sort {$a->name cmp $b->name}$snapshot->distributions){$data .= "  @{[$dist->name]}\n";$data .= "    pathname: @{[$dist->pathname]}\n";$data .= "    provides:\n";for my$package (sort keys %{$dist->provides}){my$version=$dist->provides->{$package}{version};$version='undef' unless defined$version;$data .= "      $package $version\n"}$data .= "    requirements:\n";for my$module (sort$dist->required_modules){$data .= "      $module @{[ $dist->requirements_for_module($module) || '0' ]}\n"}}$data}1;
CARTON_SNAPSHOT_EMITTER

$fatpacked{"Carton/Snapshot/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_PARSER';
  package Carton::Snapshot::Parser;use Class::Tiny;use warnings NONFATAL=>'all';use Carton::Dist;use Carton::Error;my$machine={init=>[{re=>qr/^\# carton snapshot format: version (1\.0)/,code=>sub {my($stash,$snapshot,$ver)=@_;$snapshot->version($ver)},goto=>'section',},],section=>[{re=>qr/^DISTRIBUTIONS$/,goto=>'dists',},{re=>qr/^__EOF__$/,done=>1,},],dists=>[{re=>qr/^  (\S+)$/,code=>sub {$_[0]->{dist}=Carton::Dist->new(name=>$1)},goto=>'distmeta',},{re=>qr/^\S/,goto=>'section',redo=>1,},],distmeta=>[{re=>qr/^    pathname: (.*)$/,code=>sub {$_[0]->{dist}->pathname($1)},},{re=>qr/^\s{4}provides:$/,code=>sub {$_[0]->{property}='provides'},goto=>'properties',},{re=>qr/^\s{4}requirements:$/,code=>sub {$_[0]->{property}='requirements'},goto=>'properties',},{re=>qr/^\s{0,2}\S/,code=>sub {my($stash,$snapshot)=@_;$snapshot->add_distribution($stash->{dist});%$stash=()},goto=>'dists',redo=>1,},],properties=>[{re=>qr/^\s{6}([0-9A-Za-z_:]+) ([v0-9\._,=\!<>\s]+|undef)/,code=>sub {my($stash,$snapshot,$module,$version)=@_;if ($stash->{property}eq 'provides'){$stash->{dist}->provides->{$module}={version=>$version }}else {$stash->{dist}->add_string_requirement($module,$version)}},},{re=>qr/^\s{0,4}\S/,goto=>'distmeta',redo=>1,},],};sub parse {my($self,$data,$snapshot)=@_;my@lines=split /\r?\n/,$data;my$state=$machine->{init};my$stash={};LINE: for my$line (@lines,'__EOF__'){last LINE unless @$state;STATE: {for my$trans (@{$state}){if (my@match=$line =~ $trans->{re}){if (my$code=$trans->{code}){$code->($stash,$snapshot,@match)}if (my$goto=$trans->{goto}){$state=$machine->{$goto};if ($trans->{redo}){redo STATE}else {next LINE}}last STATE}}Carton::Error::SnapshotParseError->throw(error=>"Could not parse snapshot file: $line")}}}1;
CARTON_SNAPSHOT_PARSER

$fatpacked{"Carton/Tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_TREE';
  package Carton::Tree;use strict;use Carton::Dependency;use Class::Tiny qw(cpanfile snapshot);use constant STOP=>-1;sub walk_down {my($self,$cb)=@_;my$dumper;$dumper=sub {my($dependency,$reqs,$level,$parent)=@_;my$ret=$cb->($dependency,$reqs,$level);return if$ret && $ret==STOP;local$parent->{$dependency->distname}=1 if$dependency;for my$module (sort$reqs->required_modules){my$dependency=$self->dependency_for($module,$reqs);if ($dependency->dist){next if$parent->{$dependency->distname};$dumper->($dependency,$dependency->requirements,$level + 1,$parent)}else {}}};$dumper->(undef,$self->cpanfile->requirements,0,{});undef$dumper}sub dependency_for {my($self,$module,$reqs)=@_;my$requirement=$reqs->requirements_for_module($module);my$dep=Carton::Dependency->new;$dep->module($module);$dep->requirement($requirement);if (my$dist=$self->snapshot->find_or_core($module)){$dep->dist($dist)}return$dep}sub merged_requirements {my$self=shift;my$merged_reqs=CPAN::Meta::Requirements->new;my%seen;$self->walk_down(sub {my($dependency,$reqs,$level)=@_;return Carton::Tree::STOP if$dependency && $seen{$dependency->distname}++;$merged_reqs->add_requirements($reqs)});$merged_reqs->clear_requirement('perl');$merged_reqs->finalize;$merged_reqs}1;
CARTON_TREE

$fatpacked{"Carton/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_UTIL';
  package Carton::Util;use strict;use warnings;sub load_json {my$file=shift;open my$fh,"<",$file or die "$file: $!";from_json(join '',<$fh>)}sub dump_json {my($data,$file)=@_;open my$fh,">",$file or die "$file: $!";binmode$fh;print$fh to_json($data)}sub from_json {require JSON::PP;JSON::PP->new->utf8->decode($_[0])}sub to_json {my($data)=@_;require JSON::PP;JSON::PP->new->utf8->pretty->canonical->encode($data)}1;
CARTON_UTIL

$fatpacked{"Class/Method/Modifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_METHOD_MODIFIERS';
  use strict;use warnings;package Class::Method::Modifiers;our$VERSION='2.12';use base 'Exporter';our@EXPORT=qw(before after around);our@EXPORT_OK=(@EXPORT,qw(fresh install_modifier));our%EXPORT_TAGS=(moose=>[qw(before after around)],all=>\@EXPORT_OK,);BEGIN {*_HAS_READONLY=$] >= 5.008 ? sub(){1}: sub(){0}}our%MODIFIER_CACHE;sub _install_modifier;*_install_modifier=\&install_modifier;sub install_modifier {my$into=shift;my$type=shift;my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';return _fresh($into,$code,@names)if$type eq 'fresh';for my$name (@names){my$hit=$into->can($name)or do {require Carp;Carp::confess("The method '$name' is not found in the inheritance hierarchy for class $into")};my$qualified=$into.'::'.$name;my$cache=$MODIFIER_CACHE{$into}{$name}||= {before=>[],after=>[],around=>[],};if (!exists($cache->{"orig"})){no strict 'refs';$cache->{"orig"}=*{$qualified}{CODE};$cache->{"wrapped"}=$cache->{"orig"}|| $hit}if ($type eq 'after'){push @{$cache->{$type}},$code}else {unshift @{$cache->{$type}},$code}if ($type eq 'around'){my$method=$cache->{wrapped};my$attrs=_sub_attrs($code);$cache->{wrapped}=eval "package $into; +sub $attrs { \$code->(\$method, \@_); };"}if (@{$cache->{$type}}==1){my$before=$cache->{"before"};my$after=$cache->{"after"};my$wrapped=\$cache->{"wrapped"};my$attrs=_sub_attrs($cache->{wrapped});my$generated="package $into;\n";$generated .= "sub $name $attrs {";if (@$before){$generated .= '
                      for my $method (@$before) {
                          $method->(@_);
                      }
                  '}if (@$after){$generated .= '
                      my $ret;
                      if (wantarray) {
                          $ret = [$$wrapped->(@_)];
                          '.(_HAS_READONLY ? 'Internals::SvREADONLY(@$ret, 1);' : '').'
                      }
                      elsif (defined wantarray) {
                          $ret = \($$wrapped->(@_));
                      }
                      else {
                          $$wrapped->(@_);
                      }
  
                      for my $method (@$after) {
                          $method->(@_);
                      }
  
                      wantarray ? @$ret : $ret ? $$ret : ();
                  '}else {$generated .= '$$wrapped->(@_);'}$generated .= '}';no strict 'refs';no warnings 'redefine';no warnings 'closure';eval$generated}}}sub before {_install_modifier(scalar(caller),'before',@_)}sub after {_install_modifier(scalar(caller),'after',@_)}sub around {_install_modifier(scalar(caller),'around',@_)}sub fresh {my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';_fresh(scalar(caller),$code,@names)}sub _fresh {my ($into,$code,@names)=@_;for my$name (@names){if ($name !~ /\A [a-zA-Z_] [a-zA-Z0-9_]* \z/xms){require Carp;Carp::confess("Invalid method name '$name'")}if ($into->can($name)){require Carp;Carp::confess("Class $into already has a method named '$name'")}if (_is_in_package($code,$into)){no strict 'refs';*{"$into\::$name"}=$code}else {no warnings 'closure';my$attrs=_sub_attrs($code);eval "package $into; sub $name $attrs { \$code->(\@_) }"}}}sub _sub_attrs {my ($coderef)=@_;local*_sub=$coderef;local $@;(eval 'sub { _sub = 1 }')? ':lvalue' : ''}sub _is_in_package {my ($coderef,$package)=@_;require B;my$cv=B::svref_2object($coderef);return$cv->GV->STASH->NAME eq $package}1;
CLASS_METHOD_MODIFIERS

$fatpacked{"Class/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_TINY';
  use 5.006;use strict;no strict 'refs';use warnings;package Class::Tiny;our$VERSION='1.006';use Carp ();require($] >= 5.010 ? "mro.pm" : "MRO/Compat.pm");my%CLASS_ATTRIBUTES;sub import {my$class=shift;my$pkg=caller;$class->prepare_class($pkg);$class->create_attributes($pkg,@_)if @_}sub prepare_class {my ($class,$pkg)=@_;@{"${pkg}::ISA"}="Class::Tiny::Object" unless @{"${pkg}::ISA"}}sub create_attributes {my ($class,$pkg,@spec)=@_;my%defaults=map {ref $_ eq 'HASH' ? %$_ : ($_=>undef)}@spec;my@attr=grep {defined and!ref and /^[^\W\d]\w*$/s or Carp::croak "Invalid accessor name '$_'"}keys%defaults;$CLASS_ATTRIBUTES{$pkg}{$_}=$defaults{$_}for@attr;$class->_gen_accessor($pkg,$_)for grep {!*{"$pkg\::$_"}{CODE}}@attr;Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub _gen_accessor {my ($class,$pkg,$name)=@_;my$outer_default=$CLASS_ATTRIBUTES{$pkg}{$name};my$sub=$class->__gen_sub_body($name,defined($outer_default),ref($outer_default));eval "package $pkg; my \$default=\$outer_default; $sub";Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub __gen_sub_body {my ($self,$name,$has_default,$default_type)=@_;if ($has_default && $default_type eq 'CODE'){return << "HERE"}elsif ($has_default){return << "HERE"}else {return << "HERE"}}sub get_all_attributes_for {my ($class,$pkg)=@_;my%attr=map {$_=>undef}map {keys %{$CLASS_ATTRIBUTES{$_}|| {}}}@{mro::get_linear_isa($pkg)};return keys%attr}sub get_all_attribute_defaults_for {my ($class,$pkg)=@_;my$defaults={};for my$p (reverse @{mro::get_linear_isa($pkg)}){while (my ($k,$v)=each %{$CLASS_ATTRIBUTES{$p}|| {}}){$defaults->{$k}=$v}}return$defaults}package Class::Tiny::Object;our$VERSION='1.006';my (%HAS_BUILDARGS,%BUILD_CACHE,%DEMOLISH_CACHE,%ATTR_CACHE);my$_PRECACHE=sub {no warnings 'once';my ($class)=@_;my$linear_isa=@{"$class\::ISA"}==1 && ${"$class\::ISA"}[0]eq "Class::Tiny::Object" ? [$class]: mro::get_linear_isa($class);$DEMOLISH_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::DEMOLISH"}@$linear_isa ];$BUILD_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::BUILD"}reverse @$linear_isa ];$HAS_BUILDARGS{$class}=$class->can("BUILDARGS");return$ATTR_CACHE{$class}={map {$_=>1}Class::Tiny->get_all_attributes_for($class)}};sub new {my$class=shift;my$valid_attrs=$ATTR_CACHE{$class}|| $_PRECACHE->($class);my$args;if ($HAS_BUILDARGS{$class}){$args=$class->BUILDARGS(@_)}else {if (@_==1 && ref $_[0]){my%copy=eval {%{$_[0]}};Carp::croak("Argument to $class->new() could not be dereferenced as a hash")if $@;$args=\%copy}elsif (@_ % 2==0){$args={@_}}else {Carp::croak("$class->new() got an odd number of elements")}}my$self=bless {map {$_=>$args->{$_}}grep {exists$valid_attrs->{$_}}keys %$args },$class;$self->BUILDALL($args)if!delete$args->{__no_BUILD__}&& @{$BUILD_CACHE{$class}};return$self}sub BUILDALL {$_->(@_)for @{$BUILD_CACHE{ref $_[0]}}}require Devel::GlobalDestruction unless defined ${^GLOBAL_PHASE};sub DESTROY {my$self=shift;my$class=ref$self;my$in_global_destruction=defined ${^GLOBAL_PHASE} ? ${^GLOBAL_PHASE} eq 'DESTRUCT' : Devel::GlobalDestruction::in_global_destruction();for my$demolisher (@{$DEMOLISH_CACHE{$class}}){my$e=do {local ($?,$@);eval {$demolisher->($self,$in_global_destruction)};$@};no warnings 'misc';die$e if$e}}1;
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default->( \$_[0] ) )
      );
  }
  HERE
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default )
      );
  }
  HERE
  sub $name {
      return \@_ == 1 ? \$_[0]{$name} : ( \$_[0]{$name} =  \$_[1] );
  }
  HERE
CLASS_TINY

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.14';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;use strict;use Exporter 5.57 'import';use vars qw($VERSION @EXPORT_OK);use if $] > 5.017,'deprecate';$VERSION='0.4';@EXPORT_OK=qw(list_packages);sub list_packages {my$pack=shift;$pack .= "::" unless$pack =~ m!::$!;no strict 'refs';my@packs;my@stuff=grep!/^(main|)::$/,keys %{$pack};for my$cand (grep /::$/,@stuff){$cand =~ s!::$!!;my@children=list_packages($pack.$cand);push@packs,"$pack$cand" unless$cand =~ /^::/ || !__PACKAGE__->_loaded($pack.$cand);push@packs,@children}return grep {$_ !~ /::(::ISA::CACHE|SUPER)/}@packs}sub _loaded {my ($class,$name)=@_;no strict 'refs';return 1 if defined ${"${name}::VERSION"};return 1 if @{"${name}::ISA"};for (keys %{"${name}::"}){next if substr($_,-2,2)eq '::';return 1 if defined &{"${name}::$_"}}my$filename=join('/',split /(?:'|::)/,$name).'.pm';return 1 if defined$INC{$filename};''}1;
DEVEL_INNERPACKAGE

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.012';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$dirs)=@_;my%localdir_for;if ($dirs && %$dirs){%localdir_for=%$dirs}else {for my$type ($self->install_types){$localdir_for{$type}=File::Spec->catdir('blib',$type)}}my (%map,@skipping);for my$type (keys%localdir_for){next if not -e $localdir_for{$type};if (my$dest=$self->install_destination($type)){$map{$localdir_for{$type}}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use Exporter ();use File::Spec ();our$VERSION='1.23';our@ISA='Exporter';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if($^O eq 'MSWin32'){@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"HTTP/Tinyish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.15';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my($self,$url)=@_;my($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

$fatpacked{"HTTP/Tinyish/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if(/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

$fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version'],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my($self,$url,$opts)=@_;my@options=('--location','--silent','--max-time',($self->{timeout}|| 60),'--max-redirs',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

$fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

$fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field}=$hdrs->header($field)}\%headers}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(delete$attr{max_redirect}|| 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

$fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my(undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

$fatpacked{"IPC/Run3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

$fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

$fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

$fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

$fatpacked{"IPC/Run3/ProfPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

$fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time)}=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

$fatpacked{"Import/Into.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IMPORT_INTO';
  package Import::Into;use strict;use warnings FATAL=>'all';use Module::Runtime;our$VERSION='1.002005';sub _prelude {my$target=shift;my ($package,$file,$line,$level)=ref$target ? @{$target}{qw(package filename line level)}: $target =~ /[^0-9]/ ? ($target): (undef,undef,undef,$target);if (defined$level){my ($p,$fn,$ln)=caller($level + 2);$package ||= $p;$file ||= $fn;$line ||= $ln}qq{package $package;\n} .($file ? "#line $line \"$file\"\n" : '')}sub _make_action {my ($action,$target)=@_;my$version=ref$target && $target->{version};eval _prelude($target).q[sub {] .q[  my $module = shift;] .q[  Module::Runtime::require_module($module);] .(ref$target && exists$target->{version}? q[  $module->VERSION($version);] : q[]).q[  $module->].$action.q[(@_);] .q[}] or die "Failed to build action sub to ${action} for ${target}: $@"}sub import::into {my ($class,$target,@args)=@_;_make_action(import=>$target)->($class,@args)}sub unimport::out_of {my ($class,$target,@args)=@_;_make_action(unimport=>$target)->($class,@args)}1;
IMPORT_INTO

$fatpacked{"Importer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IMPORTER';
  package Importer;use strict qw/vars subs/;use warnings;no warnings 'once';our$VERSION='0.025';my%SIG_TO_SLOT=('&'=>'CODE','$'=>'SCALAR','%'=>'HASH','@'=>'ARRAY','*'=>'GLOB',);our%IMPORTED;my%NUMERIC=map +($_=>1),0 .. 9;sub IMPORTER_MENU() {return (export_ok=>[qw/optimal_import/],export_anon=>{import=>sub {my$from=shift;my@caller=caller(0);_version_check($from,\@caller,shift @_)if @_ && $NUMERIC{substr($_[0],0,1)};my$file=_mod_to_file($from);_load_file(\@caller,$file)unless$INC{$file};return if optimal_import($from,$caller[0],\@caller,@_);my$self=__PACKAGE__->new(from=>$from,caller=>\@caller,);$self->do_import($caller[0],@_)},},)}sub import {my$class=shift;my@caller=caller(0);_version_check($class,\@caller,shift @_)if @_ && $NUMERIC{substr($_[0],0,1)};return unless @_;my ($from,@args)=@_;my$file=_mod_to_file($from);_load_file(\@caller,$file)unless$INC{$file};return if optimal_import($from,$caller[0],\@caller,@args);my$self=$class->new(from=>$from,caller=>\@caller,);$self->do_import($caller[0],@args)}sub unimport {my$class=shift;my@caller=caller(0);my$self=$class->new(from=>$caller[0],caller=>\@caller,);$self->do_unimport(@_)}sub import_into {my$class=shift;my ($from,$into,@args)=@_;my@caller;if (ref($into)){@caller=@$into;$into=$caller[0]}elsif ($into =~ m/^\d+$/){@caller=caller($into + 1);$into=$caller[0]}else {@caller=caller(0)}my$file=_mod_to_file($from);_load_file(\@caller,$file)unless$INC{$file};return if optimal_import($from,$into,\@caller,@args);my$self=$class->new(from=>$from,caller=>\@caller,);$self->do_import($into,@args)}sub unimport_from {my$class=shift;my ($from,@args)=@_;my@caller;if ($from =~ m/^\d+$/){@caller=caller($from + 1);$from=$caller[0]}else {@caller=caller(0)}my$self=$class->new(from=>$from,caller=>\@caller,);$self->do_unimport(@args)}sub new {my$class=shift;my%params=@_;my$caller=$params{caller}|| [caller()];die "You must specify a package to import from at $caller->[1] line $caller->[2].\n" unless$params{from};return bless {from=>$params{from},caller=>$params{caller},},$class}sub get {my$proto=shift;my@caller=caller(1);my$self=ref($proto)? $proto : $proto->new(from=>shift(@_),caller=>\@caller,);my%result;$self->do_import($caller[0],@_,sub {$result{$_[0]}=$_[1]});return \%result}sub get_list {my$proto=shift;my@caller=caller(1);my$self=ref($proto)? $proto : $proto->new(from=>shift(@_),caller=>\@caller,);my@result;$self->do_import($caller[0],@_,sub {push@result=>$_[1]});return@result}sub get_one {my$proto=shift;my@caller=caller(1);my$self=ref($proto)? $proto : $proto->new(from=>shift(@_),caller=>\@caller,);my$result;$self->do_import($caller[0],@_,sub {$result=$_[1]});return$result}sub do_import {my$self=shift;my ($into,$versions,$exclude,$import,$set)=$self->parse_args(@_);_version_check($self->from,$self->get_caller,@$versions)if @$versions;return unless @$import;$self->_handle_fail($into,$import)if$self->menu($into)->{fail};$self->_set_symbols($into,$exclude,$import,$set)}sub do_unimport {my$self=shift;my$from=$self->from;my$imported=$IMPORTED{$from}or $self->croak("'$from' does not have any imports to remove");my%allowed=map {$_=>1}@$imported;my@args=@_ ? @_ : @$imported;my$stash=\%{"$from\::"};for my$name (@args){$name =~ s/^&//;$self->croak("Sub '$name' was not imported using " .ref($self))unless$allowed{$name};my$glob=delete$stash->{$name};local*GLOBCLONE=*$glob;for my$type (qw/SCALAR HASH ARRAY FORMAT IO/){next unless defined(*{$glob}{$type});*{"$from\::$name"}=*{$glob}{$type}}}}sub from {$_[0]->{from}}sub from_file {my$self=shift;$self->{from_file}||= _mod_to_file($self->{from});return$self->{from_file}}sub load_from {my$self=shift;my$from_file=$self->from_file;my$this_file=__FILE__;return if$INC{$from_file};my$caller=$self->get_caller;_load_file($caller,$from_file)}sub get_caller {my$self=shift;return$self->{caller}if$self->{caller};my$level=1;while(my@caller=caller($level++)){return \@caller if@caller &&!$caller[0]->isa(__PACKAGE__);last unless@caller}return [caller(0)]}sub croak {my$self=shift;my ($msg)=@_;my$caller=$self->get_caller;my$file=$caller->[1]|| 'unknown file';my$line=$caller->[2]|| 'unknown line';die "$msg at $file line $line.\n"}sub carp {my$self=shift;my ($msg)=@_;my$caller=$self->get_caller;my$file=$caller->[1]|| 'unknown file';my$line=$caller->[2]|| 'unknown line';warn "$msg at $file line $line.\n"}sub menu {my$self=shift;my ($into)=@_;$self->croak("menu() requires the name of the destination package")unless$into;my$for=$self->{menu_for};delete$self->{menu}if$for && $for ne $into;return$self->{menu}|| $self->reload_menu($into)}sub reload_menu {my$self=shift;my ($into)=@_;$self->croak("reload_menu() requires the name of the destination package")unless$into;my$from=$self->from;if (my$menu_sub=*{"$from\::IMPORTER_MENU"}{CODE}){my%got=$from->$menu_sub($into,$self->get_caller);$got{export}||= [];$got{export_ok}||= [];$got{export_tags}||= {};$got{export_fail}||= [];$got{export_anon}||= {};$got{export_magic}||= {};$self->croak("'$from' provides both 'generate' and 'export_gen' in its IMPORTER_MENU (They are exclusive, module must pick 1)")if$got{export_gen}&& $got{generate};$got{export_gen}||= {};$self->{menu}=$self->_build_menu($into=>\%got,1)}else {my%got;$got{export}=\@{"$from\::EXPORT"};$got{export_ok}=\@{"$from\::EXPORT_OK"};$got{export_tags}=\%{"$from\::EXPORT_TAGS"};$got{export_fail}=\@{"$from\::EXPORT_FAIL"};$got{export_gen}=\%{"$from\::EXPORT_GEN"};$got{export_anon}=\%{"$from\::EXPORT_ANON"};$got{export_magic}=\%{"$from\::EXPORT_MAGIC"};$self->{menu}=$self->_build_menu($into=>\%got,0)}$self->{menu_for}=$into;return$self->{menu}}sub _build_menu {my$self=shift;my ($into,$got,$new_style)=@_;my$from=$self->from;my$export=$got->{export}|| [];my$export_ok=$got->{export_ok}|| [];my$export_tags=$got->{export_tags}|| {};my$export_fail=$got->{export_fail}|| [];my$export_anon=$got->{export_anon}|| {};my$export_gen=$got->{export_gen}|| {};my$export_magic=$got->{export_magic}|| {};my$generate=$got->{generate};$generate ||= sub {my$symbol=shift;my ($sig,$name)=($symbol =~ m/^(\W?)(.*)$/);$sig ||= '&';my$do=$export_gen->{"${sig}${name}"};$do ||= $export_gen->{$name}if!$sig || $sig eq '&';return undef unless$do;$from->$do($into,$symbol)}if$export_gen && keys %$export_gen;my$lookup={};my$exports={};for my$sym (@$export,@$export_ok,keys %$export_gen,keys %$export_anon){my ($sig,$name)=($sym =~ m/^(\W?)(.*)$/);$sig ||= '&';$lookup->{"${sig}${name}"}=1;$lookup->{$name}=1 if$sig eq '&';next if$export_gen->{"${sig}${name}"};next if$sig eq '&' && $export_gen->{$name};next if$got->{generate}&& $generate->("${sig}${name}");my$fqn="$from\::$name";$exports->{"${sig}${name}"}=$export_anon->{$sym}|| ($sig eq '&' ? \&{$fqn}: $sig eq '$' ? \${$fqn}: $sig eq '@' ? \@{$fqn}: $sig eq '%' ? \%{$fqn}: $sig eq '*' ? \*{$fqn}: next)}my$f_import=$new_style || $from->can('import');$self->croak("'$from' does not provide any exports")unless$new_style || keys %$exports || $from->isa('Exporter')|| ($INC{'Exporter.pm'}&& $f_import && $f_import==\&Exporter::import);my$tags={%$export_tags,'DEFAULT'=>[@$export ],};$tags->{ALL}||= [sort grep {m/^[\&\$\@\%\*]/}keys %$lookup ];my$fail=@$export_fail ? {map {my ($sig,$name)=(m/^(\W?)(.*)$/);$sig ||= '&';("${sig}${name}"=>1,$sig eq '&' ? ($name=>1): ())}@$export_fail }: undef;my$menu={lookup=>$lookup,exports=>$exports,tags=>$tags,fail=>$fail,generate=>$generate,magic=>$export_magic,};return$menu}sub parse_args {my$self=shift;my ($into,@args)=@_;my$menu=$self->menu($into);my@out=$self->_parse_args($into,$menu,\@args);pop@out;return@out}sub _parse_args {my$self=shift;my ($into,$menu,$args,$is_tag)=@_;my$from=$self->from;my$main_menu=$self->menu($into);$menu ||= $main_menu;my@sets;my@versions;my@leftover;for my$arg (@$args){no warnings 'void';push@sets=>$arg and next if ref($arg)eq 'CODE';push@versions=>$arg xor next if$NUMERIC{substr($arg,0,1)};push@leftover=>$arg}$self->carp("Multiple setters specified, only 1 will be used")if@sets > 1;my$set=pop@sets;$args=\@leftover;@$args=(':DEFAULT')unless$is_tag || @$args || @versions;my%exclude;my@import;while(my$full_arg=shift @$args){my$arg=$full_arg;my$lead=substr($arg,0,1);my ($spec,$exc);if ($lead eq '!'){$exc=$lead;if ($arg eq '!'){$arg=shift @$args}else {substr($arg,0,1,'')}unshift @$args=>':DEFAULT' unless@import || keys%exclude || @versions;$lead=substr($arg,0,1)}else {$spec=ref($args->[0])eq 'HASH' ? shift @$args : {}}if($lead eq ':'){substr($arg,0,1,'');my$tag=$menu->{tags}->{$arg}or $self->croak("$from does not export the :$arg tag");my (undef,$cvers,$cexc,$cimp,$cset,$newmenu)=$self->_parse_args($into,$menu,$tag,$arg);$self->croak("Exporter specified version numbers (" .join(', ',@$cvers).") in the :$arg tag!")if @$cvers;$self->croak("Exporter specified a custom symbol setter in the :$arg tag!")if$cset;%exclude=(%exclude,%$cexc);if ($exc){$exclude{$_}=1 for grep {!ref($_)&& substr($_,0,1)ne '+'}map {$_->[0]}@$cimp}elsif ($spec && keys %$spec){$self->croak("Cannot use '-as' to rename multiple symbols included by: $full_arg")if$spec->{'-as'}&& @$cimp > 1;for my$set (@$cimp){my ($sym,$cspec)=@$set;my$nspec={%$cspec,%$spec};$nspec->{'-prefix'}="$spec->{'-prefix'}$cspec->{'-prefix'}" if$spec->{'-prefix'}&& $cspec->{'-prefix'};$nspec->{'-postfix'}="$cspec->{'-postfix'}$spec->{'-postfix'}" if$spec->{'-postfix'}&& $cspec->{'-postfix'};push@import=>[$sym,$nspec]}}else {push@import=>@$cimp}$menu=$newmenu;next}my@list;if(ref($arg)eq 'Regexp'){@list=sort grep /$arg/,keys %{$menu->{lookup}}}elsif($lead eq '/' && $arg =~ m{^/(.*)/$}){my$pattern=$1;@list=sort grep /$1/,keys %{$menu->{lookup}}}else {@list=($arg)}@list=map {m/^\W/ ? $_ : "\&$_"}@list;if ($exc){$exclude{$_}=1 for@list}else {$self->croak("Cannot use '-as' to rename multiple symbols included by: $full_arg")if$spec->{'-as'}&& @list > 1;push@import=>[$_,$spec]for@list}}return ($into,\@versions,\%exclude,\@import,$set,$menu)}sub _handle_fail {my$self=shift;my ($into,$import)=@_;my$from=$self->from;my$menu=$self->menu($into);my@fail=map {my$x=$_->[0];$x =~ s/^&//;$x}grep$menu->{fail}->{$_->[0]},@$import or return;my@real_fail=$from->can('export_fail')? $from->export_fail(@fail): @fail;if (@real_fail){$self->carp(qq["$_" is not implemented by the $from module on this architecture])for@real_fail;$self->croak("Can't continue after import errors")}$self->reload_menu($menu);return}sub _set_symbols {my$self=shift;my ($into,$exclude,$import,$custom_set)=@_;my$from=$self->from;my$menu=$self->menu($into);my$caller=$self->get_caller();my$set_symbol=$custom_set || eval <<"    EOT" || die $@;for my$set (@$import){my ($symbol,$spec)=@$set;my ($sig,$name)=($symbol =~ m/^(\W)(.*)$/)or die "Invalid symbol: $symbol";my$ref=$menu->{exports}->{$symbol};$ref ||= $menu->{generate}->($symbol)if$menu->{generate};$self->croak("$from does not export $symbol")unless$ref || $menu->{lookup}->{"${sig}${name}"};next unless$ref;my$type=ref($ref);$type='SCALAR' if$type eq 'REF';$self->croak("Symbol '$sig$name' requested, but reference (" .ref($ref).") does not match sigil ($sig)")if$ref && $type ne $SIG_TO_SLOT{$sig};next if$exclude->{"${sig}${name}"}&&!$spec->{'-as'};my$new_name=join ''=>($spec->{'-prefix'}|| '',$spec->{'-as'}|| $name,$spec->{'-postfix'}|| '');$set_symbol->($new_name,$ref,sig=>$sig,symbol=>$symbol,into=>$into,from=>$from,spec=>$spec);next if$custom_set;push @{$IMPORTED{$into}}=>$new_name if$sig eq '&';my$magic=$menu->{magic}->{$symbol};$magic ||= $menu->{magic}->{$name}if$sig eq '&';$from->$magic(into=>$into,orig_name=>$name,new_name=>$new_name,ref=>$ref)if$magic}}sub _version_check {my ($mod,$caller,@versions)=@_;eval <<"    EOT" or die $@}sub _mod_to_file {my$file=shift;$file =~ s{::}{/}g;$file .= '.pm';return$file}sub _load_file {my ($caller,$file)=@_;eval <<"    EOT" || die $@}my%HEAVY_VARS=(IMPORTER_MENU=>'CODE',EXPORT_FAIL=>'ARRAY',EXPORT_GEN=>'HASH',EXPORT_ANON=>'HASH',EXPORT_MAGIC=>'HASH',);sub optimal_import {my ($from,$into,$caller,@args)=@_;defined(*{"$from\::$_"}{$HEAVY_VARS{$_}})and return 0 for keys%HEAVY_VARS;@args=@{"$from\::EXPORT"}unless@args;my%allowed=map +(substr($_,0,1)eq '&' ? substr($_,1): $_=>1),@{"$from\::EXPORT"},@{"$from\::EXPORT_OK"};my%final=map +((!ref($_)&& ($allowed{$_}|| (substr($_,0,1,"")eq '&' && $allowed{$_})))? ($_=>*{"$from\::$_"}{CODE}|| return 0): return 0),@args;eval <<"    EOT" || die $@}1;
  # Inherit the callers warning settings. If they have warnings and we
  # redefine their subs they will hear about it. If they do not have warnings
  # on they will not.
  BEGIN { \${^WARNING_BITS} = \$caller->[9] if defined \$caller->[9] }
  #line $caller->[2] "$caller->[1]"
  sub { *{"$into\\::\$_[0]"} = \$_[1] }
      EOT
  #line $caller->[2] "$caller->[1]"
  \$mod->VERSION(\$_) for \@versions;
  1;
      EOT
  #line $caller->[2] "$caller->[1]"
  require \$file;
      EOT
  # If the caller has redefine warnings enabled then we want to warn them if
  # their import redefines things.
  BEGIN { \${^WARNING_BITS} = \$caller->[9] if defined \$caller->[9] };
  #line $caller->[2] "$caller->[1]"
  (*{"$into\\::\$_"} = \$final{\$_}, push \@{\$Importer::IMPORTED{\$into}} => \$_) for keys %final;
  1;
      EOT
IMPORTER

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::PP::ISA=('Exporter')}use overload ();use JSON::PP::Boolean;use Carp ();$JSON::PP::VERSION='4.04';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true;return ($false,$true)}else {delete$self->{false};delete$self->{true};return}}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($props->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){if (!$relaxed or $ch ne "\t"){$at--;decode_error('invalid character encountered while parsing JSON string')}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::PP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> 0x20){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20"){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::PP::Boolean::VERSION='4.04';1;
JSON_PP_BOOLEAN

$fatpacked{"Menlo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO';
  package Menlo;our$VERSION="1.9019";1;
MENLO

$fatpacked{"Menlo/Builder/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_BUILDER_STATIC';
  package Menlo::Builder::Static;use strict;use warnings;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/dirname/;use File::Find ();use File::Path qw/mkpath/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;sub new {my($class,%args)=@_;bless {meta=>$args{meta},},$class}sub meta {my$self=shift;$self->{meta}}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared },catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}1},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and return;1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/});1},);sub build {my$self=shift;my$action=@_ && $_[0]=~ /\A\w+\z/ ? shift @_ : 'build';die "No such action '$action'\n" if not $actions{$action};my%opt;GetOptionsFromArray([@$_],\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($self->{env},$self->{configure_args},\@_);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),$self->meta);$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub configure {my$self=shift;$self->{env}=defined$ENV{PERL_MB_OPT}? [split_like_shell($ENV{PERL_MB_OPT})]: [];$self->{configure_args}=[@_];$self->meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MENLO_BUILDER_STATIC

$fatpacked{"Menlo/CLI/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_CLI_COMPAT';
  package Menlo::CLI::Compat;use strict;use Config;use Cwd ();use Menlo;use Menlo::Dependency;use Menlo::Util qw(WIN32);use File::Basename ();use File::Find ();use File::Path ();use File::Spec ();use File::Copy ();use File::Temp ();use File::Which qw(which);use Getopt::Long ();use Symbol ();use version ();use constant BAD_TAR=>($^O eq 'solaris' || $^O eq 'hpux');use constant CAN_SYMLINK=>eval {symlink("","");1};our$VERSION='1.9022';if ($INC{"App/FatPacker/Trace.pm"}){require version::vpp}sub qs($) {Menlo::Util::shell_quote($_[0])}sub determine_home {my$class=shift;my$homedir=$ENV{HOME}|| eval {require File::HomeDir;File::HomeDir->my_home}|| join('',@ENV{qw(HOMEDRIVE HOMEPATH)});if (WIN32){require Win32;$homedir=Win32::GetShortPathName($homedir)}return "$homedir/.cpanm"}sub new {my$class=shift;my$self=bless {name=>"Menlo",home=>$class->determine_home,cmd=>'install',seen=>{},notest=>undef,test_only=>undef,installdeps=>undef,force=>undef,sudo=>undef,make=>undef,verbose=>undef,quiet=>undef,interactive=>undef,log=>undef,mirrors=>[],mirror_only=>undef,mirror_index=>undef,cpanmetadb=>"http://cpanmetadb.plackperl.org/v1.0/",perl=>$^X,argv=>[],local_lib=>undef,self_contained=>undef,exclude_vendor=>undef,prompt_timeout=>0,prompt=>undef,configure_timeout=>60,build_timeout=>3600,test_timeout=>1800,try_lwp=>1,try_wget=>1,try_curl=>1,uninstall_shadows=>($] < 5.012),skip_installed=>1,skip_satisfied=>0,static_install=>1,auto_cleanup=>7,pod2man=>1,installed_dists=>0,install_types=>['requires'],with_develop=>0,with_configure=>0,showdeps=>0,scandeps=>0,scandeps_tree=>[],format=>'tree',save_dists=>undef,skip_configure=>0,verify=>0,report_perl_version=>!$class->maybe_ci,build_args=>{},features=>{},pure_perl=>0,cpanfile_path=>'cpanfile',@_,},$class;$self}sub env {my($self,$key)=@_;$ENV{"PERL_CPANM_" .$key}}sub maybe_ci {my$class=shift;grep$ENV{$_},qw(TRAVIS CI AUTOMATED_TESTING AUTHOR_TESTING)}sub install_type_handlers {my$self=shift;my@handlers;for my$type (qw(recommends suggests)){push@handlers,"with-$type"=>sub {my%uniq;$self->{install_types}=[grep!$uniq{$_}++,@{$self->{install_types}},$type ]};push@handlers,"without-$type"=>sub {$self->{install_types}=[grep $_ ne $type,@{$self->{install_types}}]}}@handlers}sub build_args_handlers {my$self=shift;my@handlers;for my$phase (qw(configure build test install)){push@handlers,"$phase-args=s"=>\($self->{build_args}{$phase})}@handlers}sub parse_options {my$self=shift;local@ARGV=@{$self->{argv}};push@ARGV,grep length,split /\s+/,$self->env('OPT');push@ARGV,@_;Getopt::Long::Configure("bundling");Getopt::Long::GetOptions('f|force'=>sub {$self->{skip_installed}=0;$self->{force}=1},'n|notest!'=>\$self->{notest},'test-only'=>sub {$self->{notest}=0;$self->{skip_installed}=0;$self->{test_only}=1},'S|sudo!'=>\$self->{sudo},'v|verbose'=>\$self->{verbose},'verify!'=>\$self->{verify},'q|quiet!'=>\$self->{quiet},'h|help'=>sub {$self->{action}='show_help'},'V|version'=>sub {$self->{action}='show_version'},'perl=s'=>sub {$self->diag("--perl is deprecated since it's known to be fragile in figuring out dependencies. Run `$_[1] -S cpanm` instead.\n",1);$self->{perl}=$_[1]},'l|local-lib=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1])},'L|local-lib-contained=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1]);$self->{self_contained}=1;$self->{pod2man}=undef},'self-contained!'=>\$self->{self_contained},'exclude-vendor!'=>\$self->{exclude_vendor},'mirror=s@'=>$self->{mirrors},'mirror-only!'=>\$self->{mirror_only},'mirror-index=s'=>sub {$self->{mirror_index}=$self->maybe_abs($_[1])},'M|from=s'=>sub {$self->{mirrors}=[$_[1]];$self->{mirror_only}=1},'cpanmetadb=s'=>\$self->{cpanmetadb},'cascade-search!'=>\$self->{cascade_search},'prompt!'=>\$self->{prompt},'installdeps'=>\$self->{installdeps},'skip-installed!'=>\$self->{skip_installed},'skip-satisfied!'=>\$self->{skip_satisfied},'reinstall'=>sub {$self->{skip_installed}=0},'interactive!'=>\$self->{interactive},'i|install'=>sub {$self->{cmd}='install'},'info'=>sub {$self->{cmd}='info'},'look'=>sub {$self->{cmd}='look';$self->{skip_installed}=0},'U|uninstall'=>sub {$self->{cmd}='uninstall'},'self-upgrade'=>sub {$self->{action}='self_upgrade'},'uninst-shadows!'=>\$self->{uninstall_shadows},'lwp!'=>\$self->{try_lwp},'wget!'=>\$self->{try_wget},'curl!'=>\$self->{try_curl},'auto-cleanup=s'=>\$self->{auto_cleanup},'man-pages!'=>\$self->{pod2man},'scandeps'=>\$self->{scandeps},'showdeps'=>sub {$self->{showdeps}=1;$self->{skip_installed}=0},'format=s'=>\$self->{format},'save-dists=s'=>sub {$self->{save_dists}=$self->maybe_abs($_[1])},'skip-configure!'=>\$self->{skip_configure},'static-install!'=>\$self->{static_install},'dev!'=>\$self->{dev_release},'metacpan!'=>\$self->{metacpan},'report-perl-version!'=>\$self->{report_perl_version},'configure-timeout=i'=>\$self->{configure_timeout},'build-timeout=i'=>\$self->{build_timeout},'test-timeout=i'=>\$self->{test_timeout},'with-develop'=>\$self->{with_develop},'without-develop'=>sub {$self->{with_develop}=0},'with-configure'=>\$self->{with_configure},'without-configure'=>sub {$self->{with_configure}=0},'with-feature=s'=>sub {$self->{features}{$_[1]}=1},'without-feature=s'=>sub {$self->{features}{$_[1]}=0},'with-all-features'=>sub {$self->{features}{__all}=1},'pp|pureperl!'=>\$self->{pure_perl},"cpanfile=s"=>\$self->{cpanfile_path},$self->install_type_handlers,$self->build_args_handlers,);if (!@ARGV && $0 ne '-' &&!-t STDIN){push@ARGV,$self->load_argv_from_fh(\*STDIN);$self->{load_from_stdin}=1}$self->{argv}=\@ARGV}sub check_upgrade {my$self=shift;my$install_base=$ENV{PERL_LOCAL_LIB_ROOT}? $self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}): $Config{installsitebin};if ($0 eq '-'){return}elsif ($0 !~ /^$install_base/){if ($0 =~ m!perlbrew/bin!){die <<DIE}else {die <<DIE}}}sub check_libs {my$self=shift;return if$self->{_checked}++;$self->bootstrap_local_lib}sub setup_verify {my$self=shift;my$has_modules=eval {require Module::Signature;require Digest::SHA;1};$self->{cpansign}=which('cpansign');unless ($has_modules && $self->{cpansign}){warn "WARNING: Module::Signature and Digest::SHA is required for distribution verifications.\n";$self->{verify}=0}}sub parse_module_args {my($self,$module)=@_;$module =~ s/^([A-Za-z0-9_:]+)@([v\d\._]+)$/$1~== $2/;if ($module =~ /\~[v\d\._,\!<>= ]+$/){return split '~',$module,2}else {return$module,undef}}sub run {my$self=shift;my$code;eval {$code=($self->_doit==0)};if (my$e=$@){warn$e;$code=1}$self->{status}=$code}sub status {$_[0]->{status}}sub _doit {my$self=shift;$self->setup_home;$self->init_tools;$self->setup_verify if$self->{verify};if (my$action=$self->{action}){$self->$action()and return 1}return$self->show_help(1)unless @{$self->{argv}}or $self->{load_from_stdin};$self->configure_mirrors;my$cwd=Cwd::cwd;my@fail;for my$module (@{$self->{argv}}){if ($module =~ s/\.pm$//i){my ($volume,$dirs,$file)=File::Spec->splitpath($module);$module=join '::',grep {$_}File::Spec->splitdir($dirs),$file}($module,my$version)=$self->parse_module_args($module);$self->chdir($cwd);if ($self->{cmd}eq 'uninstall'){$self->uninstall_module($module)or push@fail,$module}else {$self->install_module($module,0,$version)or push@fail,$module}}if ($self->{base}&& $self->{auto_cleanup}){$self->cleanup_workdirs}if ($self->{installed_dists}){my$dists=$self->{installed_dists}> 1 ? "distributions" : "distribution";$self->diag("$self->{installed_dists} $dists installed\n",1)}if ($self->{scandeps}){$self->dump_scandeps()}$self->chdir($cwd);return!@fail}sub setup_home {my$self=shift;$self->{home}=$self->env('HOME')if$self->env('HOME');unless (_writable($self->{home})){die "Can't write to cpanm home '$self->{home}': You should fix it with chown/chmod first.\n"}$self->{base}="$self->{home}/work/" .time .".$$";File::Path::mkpath([$self->{base}],0,0777);$self->{log}=File::Spec->catfile($self->{base},"build.log");my$final_log="$self->{home}/build.log";{open my$out,">$self->{log}" or die "$self->{log}: $!"}if (CAN_SYMLINK){my$build_link="$self->{home}/latest-build";unlink$build_link;symlink$self->{base},$build_link;unlink$final_log;symlink$self->{log},$final_log}else {my$log=$self->{log};my$home=$self->{home};$self->{at_exit}=sub {my$self=shift;my$temp_log="$home/build.log." .time .".$$";File::Copy::copy($log,$temp_log)&& unlink($final_log);rename($temp_log,$final_log)}}$self->chat("cpanm ($self->{name}) $Menlo::VERSION on perl $] built for $Config{archname}\n" ."Work directory is $self->{base}\n")}sub search_mirror_index_local {my ($self,$local,$module,$version)=@_;require CPAN::Common::Index::LocalPackage;my$index=CPAN::Common::Index::LocalPackage->new({source=>$local });$self->search_common($index,{package=>$module },$version)}sub search_mirror_index {my ($self,$mirror,$module,$version)=@_;require Menlo::Index::Mirror;my$index=Menlo::Index::Mirror->new({mirror=>$mirror,cache=>$self->source_for($mirror),fetcher=>sub {$self->mirror(@_)},});$self->search_common($index,{package=>$module },$version)}sub search_common {my($self,$index,$search_args,$want_version)=@_;$index->refresh_index;my$found=$index->search_packages($search_args);$found=$self->cpan_module_common($found)if$found;return$found unless$self->{cascade_search};if ($found){if ($self->satisfy_version($found->{module},$found->{module_version},$want_version)){return$found}else {$self->chat("Found $found->{module} $found->{module_version} which doesn't satisfy $want_version.\n")}}return}sub with_version_range {my($self,$version)=@_;defined($version)&& $version =~ /(?:<|!=|==)/}sub search_metacpan {my($self,$module,$version,$dev_release)=@_;require Menlo::Index::MetaCPAN;$self->chat("Searching $module ($version) on metacpan ...\n");my$index=Menlo::Index::MetaCPAN->new({include_dev=>$self->{dev_release}});my$pkg=$self->search_common($index,{package=>$module,version_range=>$version },$version);return$pkg if$pkg;$self->diag_fail("Finding $module ($version) on metacpan failed.");return}sub search_database {my($self,$module,$version)=@_;my$found;if ($self->{dev_release}or $self->{metacpan}){$found=$self->search_metacpan($module,$version,$self->{dev_release})and return$found;$found=$self->search_cpanmetadb($module,$version,$self->{dev_release})and return$found}else {$found=$self->search_cpanmetadb($module,$version)and return$found;$found=$self->search_metacpan($module,$version)and return$found}}sub search_cpanmetadb {my($self,$module,$version,$dev_release)=@_;require Menlo::Index::MetaDB;$self->chat("Searching $module ($version) on cpanmetadb ...\n");my$args={package=>$module };if ($self->with_version_range($version)){$args->{version_range}=$version}my$index=Menlo::Index::MetaDB->new({uri=>$self->{cpanmetadb}});my$pkg=$self->search_common($index,$args,$version);return$pkg if$pkg;$self->diag_fail("Finding $module on cpanmetadb failed.");return}sub search_module {my($self,$module,$version)=@_;if ($self->{mirror_index}){$self->mask_output(chat=>"Searching $module on mirror index $self->{mirror_index} ...\n");my$pkg=$self->search_mirror_index_local($self->{mirror_index},$module,$version);return$pkg if$pkg;unless ($self->{cascade_search}){$self->mask_output(diag_fail=>"Finding $module ($version) on mirror index $self->{mirror_index} failed.");return}}unless ($self->{mirror_only}){my$found=$self->search_database($module,$version);return$found if$found}MIRROR: for my$mirror (@{$self->{mirrors}}){$self->mask_output(chat=>"Searching $module on mirror $mirror ...\n");my$pkg=$self->search_mirror_index($mirror,$module,$version);return$pkg if$pkg;$self->mask_output(diag_fail=>"Finding $module ($version) on mirror $mirror failed.")}return}sub source_for {my($self,$mirror)=@_;$mirror =~ s/[^\w\.\-]+/%/g;my$dir="$self->{home}/sources/$mirror";File::Path::mkpath([$dir ],0,0777);return$dir}sub load_argv_from_fh {my($self,$fh)=@_;my@argv;while(defined(my$line=<$fh>)){chomp$line;$line =~ s/#.+$//;$line =~ s/^\s+//;$line =~ s/\s+$//;push@argv,split ' ',$line if$line}return@argv}sub show_version {my$self=shift;print "cpanm ($self->{name}) version $VERSION ($0)\n";print "perl version $] ($^X)\n\n";print "  \%Config:\n";for my$key (qw(archname installsitelib installsitebin installman1dir installman3dir sitearchexp sitelibexp vendorarch vendorlibexp archlibexp privlibexp)){print "    $key=$Config{$key}\n" if$Config{$key}}print "  \%ENV:\n";for my$key (grep /^PERL/,sort keys%ENV){print "    $key=$ENV{$key}\n"}print "  \@INC:\n";for my$inc (@INC){print "    $inc\n" unless ref($inc)eq 'CODE'}return 1}sub show_help {my$self=shift;if ($_[0]){print <<USAGE;return}print <<HELP;return 1}sub _writable {my$dir=shift;my@dir=File::Spec->splitdir($dir);while (@dir){$dir=File::Spec->catdir(@dir);if (-e $dir){return -w _}pop@dir}return}sub maybe_abs {my($self,$lib)=@_;if ($lib eq '_' or $lib =~ /^~/ or File::Spec->file_name_is_absolute($lib)){return$lib}else {return File::Spec->canonpath(File::Spec->catdir(Cwd::cwd(),$lib))}}sub local_lib_target {my($self,$root)=@_;(grep {$_ ne ''}split /\Q$Config{path_sep}/,$root)[0]}sub bootstrap_local_lib {my$self=shift;if ($self->{local_lib}){return$self->setup_local_lib($self->{local_lib})}if ($ENV{PERL_LOCAL_LIB_ROOT}&& $ENV{PERL_MM_OPT}){return$self->setup_local_lib($self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}),1)}return if$self->{sudo}or (_writable($Config{installsitelib})and _writable($Config{installsitebin}));if ($ENV{PERL_MM_OPT}and ($ENV{MODULEBUILDRC}or $ENV{PERL_MB_OPT})){return}$self->setup_local_lib;$self->diag(<<DIAG,1);sleep 2}sub upgrade_toolchain {my($self,$config_deps)=@_;my%deps=map {$_->module=>$_}@$config_deps;my$reqs=CPAN::Meta::Requirements->from_string_hash({'Module::Build'=>'0.38','ExtUtils::MakeMaker'=>'6.58','ExtUtils::Install'=>'1.46',});if ($deps{"ExtUtils::MakeMaker"}){$deps{"ExtUtils::MakeMaker"}->merge_with($reqs)}elsif ($deps{"Module::Build"}){$deps{"Module::Build"}->merge_with($reqs);$deps{"ExtUtils::Install"}||= Menlo::Dependency->new("ExtUtils::Install",0,'configure');$deps{"ExtUtils::Install"}->merge_with($reqs)}@$config_deps=values%deps}sub _core_only_inc {my($self,$base)=@_;require local::lib;(local::lib->resolve_path(local::lib->install_base_arch_path($base)),local::lib->resolve_path(local::lib->install_base_perl_path($base)),(!$self->{exclude_vendor}? grep {$_}@Config{qw(vendorarch vendorlibexp)}: ()),@Config{qw(archlibexp privlibexp)},)}sub _setup_local_lib_env {my($self,$base)=@_;$self->diag(<<WARN,1)if$base =~ /\s/;local$SIG{__WARN__}=sub {};local::lib->setup_env_hash_for($base,0)}sub setup_local_lib {my($self,$base,$no_env)=@_;$base=undef if$base eq '_';require local::lib;{local $0='cpanm';$base ||= "~/perl5";$base=local::lib->resolve_path($base);if ($self->{self_contained}){my@inc=$self->_core_only_inc($base);$self->{search_inc}=[@inc ]}else {$self->{search_inc}=[local::lib->install_base_arch_path($base),local::lib->install_base_perl_path($base),@INC,]}$self->_setup_local_lib_env($base)unless$no_env;$self->{local_lib}=$base}}sub prompt_bool {my($self,$mess,$def)=@_;my$val=$self->prompt($mess,$def);return lc$val eq 'y'}sub prompt {my($self,$mess,$def)=@_;my$isa_tty=-t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT));my$dispdef=defined$def ? "[$def] " : " ";$def=defined$def ? $def : "";if (!$self->{prompt}|| (!$isa_tty && eof STDIN)){return$def}local $|=1;local $\;my$ans;eval {local$SIG{ALRM}=sub {undef$ans;die "alarm\n"};print STDOUT "$mess $dispdef";alarm$self->{prompt_timeout}if$self->{prompt_timeout};$ans=<STDIN>;alarm 0};if (defined$ans){chomp$ans}else {print STDOUT "\n"}return (!defined$ans || $ans eq '')? $def : $ans}sub diag_ok {my($self,$msg)=@_;chomp$msg;$msg ||= "OK";if ($self->{in_progress}){$self->_diag("$msg\n");$self->{in_progress}=0}$self->log("-> $msg\n")}sub diag_fail {my($self,$msg,$always)=@_;chomp$msg;if ($self->{in_progress}){$self->_diag("FAIL\n");$self->{in_progress}=0}if ($msg){$self->_diag("! $msg\n",$always,1);$self->log("-> FAIL $msg\n")}}sub diag_progress {my($self,$msg)=@_;chomp$msg;$self->{in_progress}=1;$self->_diag("$msg ... ");$self->log("$msg\n")}sub _diag {my($self,$msg,$always,$error)=@_;my$fh=$error ? *STDERR : *STDOUT;print {$fh}$msg if$always or $self->{verbose}or!$self->{quiet}}sub diag {my($self,$msg,$always)=@_;$self->_diag($msg,$always);$self->log($msg)}sub chat {my$self=shift;print STDERR @_ if$self->{verbose};$self->log(@_)}sub mask_output {my$self=shift;my$method=shift;$self->$method($self->mask_uri_passwords(@_))}sub log {my$self=shift;open my$out,">>$self->{log}";print$out @_}sub run_command {my($self,$cmd)=@_;if (ref$cmd eq 'CODE'){if ($self->{verbose}){return$cmd->()}else {require Capture::Tiny;open my$logfh,">>",$self->{log};my$ret;Capture::Tiny::capture(sub {$ret=$cmd->()},stdout=>$logfh,stderr=>$logfh);return$ret}}if (WIN32){$cmd=Menlo::Util::shell_quote(@$cmd)if ref$cmd eq 'ARRAY';unless ($self->{verbose}){$cmd .= " >> " .Menlo::Util::shell_quote($self->{log})." 2>&1"}!system$cmd}else {my$pid=fork;if ($pid){waitpid$pid,0;return!$?}else {$self->run_exec($cmd)}}}sub run_exec {my($self,$cmd)=@_;if (ref$cmd eq 'ARRAY'){unless ($self->{verbose}){open my$logfh,">>",$self->{log};open STDERR,'>&',$logfh;open STDOUT,'>&',$logfh;close$logfh}exec @$cmd}else {unless ($self->{verbose}){$cmd .= " >> " .Menlo::Util::shell_quote($self->{log})." 2>&1"}exec$cmd}}sub run_timeout {my($self,$cmd,$timeout)=@_;return$self->run_command($cmd)if ref($cmd)eq 'CODE' || WIN32 || $self->{verbose}||!$timeout;my$pid=fork;if ($pid){eval {local$SIG{ALRM}=sub {die "alarm\n"};alarm$timeout;waitpid$pid,0;alarm 0};if ($@ && $@ eq "alarm\n"){$self->diag_fail("Timed out (> ${timeout}s). Use --verbose to retry.");local$SIG{TERM}='IGNORE';kill TERM=>0;waitpid$pid,0;return}return!$?}elsif ($pid==0){$self->run_exec($cmd)}else {$self->chat("! fork failed: falling back to system()\n");$self->run_command($cmd)}}sub append_args {my($self,$cmd,$phase)=@_;return$cmd if ref$cmd ne 'ARRAY';if (my$args=$self->{build_args}{$phase}){$cmd=join ' ',Menlo::Util::shell_quote(@$cmd),$args}$cmd}sub _use_unsafe_inc {my($self,$dist)=@_;if (exists$ENV{PERL_USE_UNSAFE_INC}){return$ENV{PERL_USE_UNSAFE_INC}}if (exists$dist->{meta}{x_use_unsafe_inc}){$self->chat("Distribution opts in x_use_unsafe_inc: $dist->{meta}{x_use_unsafe_inc}\n");return$dist->{meta}{x_use_unsafe_inc}}return 1}sub configure {my($self,$cmd,$dist,$depth)=@_;local$ENV{PERL5_CPAN_IS_RUNNING}=local$ENV{PERL5_CPANPLUS_IS_RUNNING}=$$;local$ENV{PERL5_CPANM_IS_RUNNING}=$$;my$use_default=!$self->{interactive};local$ENV{PERL_MM_USE_DEFAULT}=$use_default;local$ENV{PERL_MM_OPT}=$ENV{PERL_MM_OPT};local$ENV{PERL_MB_OPT}=$ENV{PERL_MB_OPT};unless ($self->{pod2man}){$ENV{PERL_MM_OPT}.= " INSTALLMAN1DIR=none INSTALLMAN3DIR=none";$ENV{PERL_MB_OPT}.= " --config installman1dir= --config installsiteman1dir= --config installman3dir= --config installsiteman3dir="}if ($self->{pure_perl}){$ENV{PERL_MM_OPT}.= " PUREPERL_ONLY=1";$ENV{PERL_MB_OPT}.= " --pureperl-only"}local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'configure')if$depth==0;local$self->{verbose}=$self->{verbose}|| $self->{interactive};$self->run_timeout($cmd,$self->{configure_timeout})}sub build {my($self,$cmd,$distname,$dist,$depth)=@_;local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'build')if$depth==0;return 1 if$self->run_timeout($cmd,$self->{build_timeout});while (1){my$ans=lc$self->prompt("Building $distname failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->build($cmd,$distname,$dist,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}sub test {my($self,$cmd,$distname,$dist,$depth)=@_;return 1 if$self->{notest};local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{NONINTERACTIVE_TESTING}=!$self->{interactive};local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'test')if$depth==0;return 1 if$self->run_timeout($cmd,$self->{test_timeout});if ($self->{force}){$self->diag_fail("Testing $distname failed but installing it anyway.");return 1}else {$self->diag_fail;while (1){my$ans=lc$self->prompt("Testing $distname failed.\nYou can s)kip, r)etry, f)orce install, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->test($cmd,$distname,$dist,$depth)if$ans eq 'r';return 1 if$ans eq 'f';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}}sub install {my($self,$cmd,$uninst_opts,$dist,$depth)=@_;if ($depth==0 && $self->{test_only}){return 1}return$self->run_command($cmd)if ref$cmd eq 'CODE';local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);if ($self->{sudo}){unshift @$cmd,"sudo"}if ($self->{uninstall_shadows}&&!$ENV{PERL_MM_OPT}){push @$cmd,@$uninst_opts}$cmd=$self->append_args($cmd,'install')if$depth==0;$self->run_command($cmd)}sub look {my$self=shift;my$shell=$ENV{SHELL};$shell ||= $ENV{COMSPEC}if WIN32;if ($shell){my$cwd=Cwd::cwd;$self->diag("Entering $cwd with $shell\n");system$shell}else {$self->diag_fail("You don't seem to have a SHELL :/")}}sub show_build_log {my$self=shift;my@pagers=($ENV{PAGER},(WIN32 ? (): ('less')),'more');my$pager;while (@pagers){$pager=shift@pagers;next unless$pager;$pager=which($pager);next unless$pager;last}if ($pager){if (WIN32){system "@{[ qs $pager ]} < @{[ qs $self->{log}]}"}else {system$pager,$self->{log}}}else {$self->diag_fail("You don't seem to have a PAGER :/")}}sub chdir {my$self=shift;Cwd::chdir(File::Spec->canonpath($_[0]))or die "$_[0]: $!"}sub configure_mirrors {my$self=shift;unless (@{$self->{mirrors}}){$self->{mirrors}=['http://www.cpan.org' ]}for (@{$self->{mirrors}}){s!^/!file:///!;s!/$!!}}sub self_upgrade {my$self=shift;$self->check_upgrade;$self->{argv}=['Menlo' ];return}sub install_module {my($self,$module,$depth,$version,$dep)=@_;$self->check_libs;if ($self->{seen}{$module}++){$self->chat("Already tried $module. Skipping.\n");return 1}if ($self->{skip_satisfied}){my($ok,$local)=$self->check_module($module,$version || 0);if ($ok){$self->diag("You have $module ($local)\n",1);return 1}}my$dist=$self->resolve_name($module,$version,$dep);unless ($dist){my$what=$module .($version ? " ($version)" : "");$self->diag_fail("Couldn't find module or a distribution $what",1);return}if ($dist->{distvname}&& $self->{seen}{$dist->{distvname}}++){$self->chat("Already tried $dist->{distvname}. Skipping.\n");return 1}if ($self->{cmd}eq 'info'){print$self->format_dist($dist),"\n";return 1}$dist->{depth}=$depth;if ($dist->{module}){unless ($self->satisfy_version($dist->{module},$dist->{module_version},$version)){$self->diag("Found $dist->{module} $dist->{module_version} which doesn't satisfy $version.\n",1);return}my$cmp=$version ? "==" : "";my$requirement=$dist->{module_version}? "$cmp$dist->{module_version}" : 0;my($ok,$local)=$self->check_module($dist->{module},$requirement);if ($self->{skip_installed}&& $ok){$self->diag("$dist->{module} is up to date. ($local)\n",1);return 1}}if ($dist->{dist}eq 'perl'){$self->diag("skipping $dist->{pathname}\n");return 1}$self->diag("--> Working on $module\n");$dist->{dir}||= $self->fetch_module($dist);unless ($dist->{dir}){$self->diag_fail("Failed to fetch distribution $dist->{distvname}",1);return}$self->chat("Entering $dist->{dir}\n");$self->chdir($self->{base});$self->chdir($dist->{dir});if ($self->{cmd}eq 'look'){$self->look;return 1}return$self->build_stuff($module,$dist,$depth)}sub uninstall_search_path {my$self=shift;$self->{local_lib}? (local::lib->install_base_arch_path($self->{local_lib}),local::lib->install_base_perl_path($self->{local_lib})): @Config{qw(installsitearch installsitelib)}}sub uninstall_module {my ($self,$module)=@_;$self->check_libs;my@inc=$self->uninstall_search_path;my($metadata,$packlist)=$self->packlists_containing($module,\@inc);unless ($packlist){$self->diag_fail(<<DIAG,1);return}my@uninst_files=$self->uninstall_target($metadata,$packlist);$self->ask_permission($module,\@uninst_files)or return;$self->uninstall_files(@uninst_files,$packlist);$self->diag("Successfully uninstalled $module\n",1);return 1}sub packlists_containing {my($self,$module,$inc)=@_;require Module::Metadata;my$metadata=Module::Metadata->new_from_module($module,inc=>$inc)or return;my$packlist;my$wanted=sub {return unless $_ eq '.packlist' && -f $_;for my$file ($self->unpack_packlist($File::Find::name)){$packlist ||= $File::Find::name if$file eq $metadata->filename}};{require File::pushd;my$pushd=File::pushd::pushd();my@search=grep -d $_,map File::Spec->catdir($_,'auto'),@$inc;File::Find::find($wanted,@search)}return$metadata,$packlist}sub uninstall_target {my($self,$metadata,$packlist)=@_;if ($self->has_shadow_install($metadata)or $self->{local_lib}){grep$self->should_unlink($_),$self->unpack_packlist($packlist)}else {$self->unpack_packlist($packlist)}}sub has_shadow_install {my($self,$metadata)=@_;my@shadow=grep defined,map Module::Metadata->new_from_module($metadata->name,inc=>[$_]),@INC;@shadow >= 2}sub should_unlink {my($self,$file)=@_;if ($self->{local_lib}){$file =~ /^\Q$self->{local_lib}\E/}else {!(grep$file =~ /^\Q$_\E/,@Config{qw(installbin installscript installman1dir installman3dir)})}}sub ask_permission {my ($self,$module,$files)=@_;$self->diag("$module contains the following files:\n\n");for my$file (@$files){$self->diag("  $file\n")}$self->diag("\n");return 'force uninstall' if$self->{force};local$self->{prompt}=1;return$self->prompt_bool("Are you sure you want to uninstall $module?",'y')}sub unpack_packlist {my ($self,$packlist)=@_;open my$fh,'<',$packlist or die "$packlist: $!";map {chomp;$_}<$fh>}sub uninstall_files {my ($self,@files)=@_;$self->diag("\n");for my$file (@files){$self->diag("Unlink: $file\n");unlink$file or $self->diag_fail("$!: $file")}$self->diag("\n");return 1}sub format_dist {my($self,$dist)=@_;return "$dist->{cpanid}/$dist->{filename}"}sub trim {local $_=shift;tr/\n/ /d;s/^\s*|\s*$//g;$_}sub fetch_module {my($self,$dist)=@_;$self->chdir($self->{base});for my$uri (@{$dist->{uris}}){$self->mask_output(diag_progress=>"Fetching $uri");my$filename=$dist->{filename}|| $uri;my$name=File::Basename::basename($filename);my$cancelled;my$fetch=sub {my$file;eval {local$SIG{INT}=sub {$cancelled=1;die "SIGINT\n"};$self->mirror($uri,$name);$file=$name if -e $name};$self->diag("ERROR: " .trim("$@")."\n",1)if $@ && $@ ne "SIGINT\n";return$file};my($try,$file);while ($try++ < 3){$file=$fetch->();last if$cancelled or $file;$self->mask_output(diag_fail=>"Download $uri failed. Retrying ... ")}if ($cancelled){$self->diag_fail("Download cancelled.");return}unless ($file){$self->mask_output(diag_fail=>"Failed to download $uri");next}$self->diag_ok;$dist->{local_path}=File::Spec->rel2abs($name);my$dir=$self->unpack($file,$uri,$dist);next unless$dir;if (my$save=$self->{save_dists}){my$path=$dist->{pathname}? "$save/authors/id/$dist->{pathname}" : "$save/vendor/$file";$self->chat("Copying $name to $path\n");File::Path::mkpath([File::Basename::dirname($path)],0,0777);File::Copy::copy($file,$path)or warn $!}return$dist,$dir}}sub unpack {my($self,$file,$uri,$dist)=@_;if ($self->{verify}){$self->verify_archive($file,$uri,$dist)or return}$self->chat("Unpacking $file\n");my$dir=$file =~ /\.zip/i ? $self->unzip($file): $self->untar($file);unless ($dir){$self->diag_fail("Failed to unpack $file: no directory")}return$dir}sub verify_checksums_signature {my($self,$chk_file)=@_;require Module::Signature;$self->chat("Verifying the signature of CHECKSUMS\n");my$rv=eval {local$SIG{__WARN__}=sub {};my$v=Module::Signature::_verify($chk_file);$v==Module::Signature::SIGNATURE_OK()};if ($rv){$self->chat("Verified OK!\n")}else {$self->diag_fail("Verifying CHECKSUMS signature failed: $rv\n");return}return 1}sub verify_archive {my($self,$file,$uri,$dist)=@_;unless ($dist->{cpanid}){$self->chat("Archive '$file' does not seem to be from PAUSE. Skip verification.\n");return 1}(my$mirror=$uri)=~ s!/authors/id.*$!!;(my$chksum_uri=$uri)=~ s!/[^/]*$!/CHECKSUMS!;my$chk_file=$self->source_for($mirror)."/$dist->{cpanid}.CHECKSUMS";$self->mask_output(diag_progress=>"Fetching $chksum_uri");$self->mirror($chksum_uri,$chk_file);unless (-e $chk_file){$self->diag_fail("Fetching $chksum_uri failed.\n");return}$self->diag_ok;$self->verify_checksums_signature($chk_file)or return;$self->verify_checksum($file,$chk_file)}sub verify_checksum {my($self,$file,$chk_file)=@_;$self->chat("Verifying the SHA1 for $file\n");open my$fh,"<$chk_file" or die "$chk_file: $!";my$data=join '',<$fh>;$data =~ s/\015?\012/\n/g;require Safe;my$chksum=Safe->new->reval($data);if (!ref$chksum or ref$chksum ne 'HASH'){$self->diag_fail("! Checksum file downloaded from $chk_file is broken.\n");return}if (my$sha=$chksum->{$file}{sha256}){my$hex=$self->sha_for(256,$file);if ($hex eq $sha){$self->chat("Checksum for $file: Verified!\n")}else {$self->diag_fail("Checksum mismatch for $file\n");return}}else {$self->chat("Checksum for $file not found in CHECKSUMS.\n");return}}sub sha_for {my($self,$alg,$file)=@_;require Digest::SHA;open my$fh,"<",$file or die "$file: $!";my$dg=Digest::SHA->new($alg);my($data);while (read($fh,$data,4096)){$dg->add($data)}return$dg->hexdigest}sub verify_signature {my($self,$dist)=@_;$self->diag_progress("Verifying the SIGNATURE file");my$out=`@{[ qs $self->{cpansign} ]} -v --skip 2>&1`;$self->log($out);if ($out =~ /Signature verified OK/){$self->diag_ok("Verified OK");return 1}else {$self->diag_fail("SIGNATURE verification for $dist->{filename} failed\n");return}}sub resolve_name {my($self,$module,$version,$dep)=@_;if ($dep && $dep->url){if ($dep->url =~ m!authors/id/(.*)!){return$self->cpan_dist($1,$dep->url)}else {return {uris=>[$dep->url ]}}}if ($dep && $dep->dist){return$self->cpan_dist($dep->dist,undef,$dep->mirror)}if ($module =~ /(?:^git:|\.git(?:@.+)?$)/){return$self->git_uri($module)}if ($module =~ /^(ftp|https?|file):/){if ($module =~ m!authors/id/(.*)!){return$self->cpan_dist($1,$module)}else {return {uris=>[$module ]}}}if ($module =~ m!^[\./]! && -d $module){return {source=>'local',dir=>Cwd::abs_path($module),}}if (-f $module){return {source=>'local',uris=>["file://" .Cwd::abs_path($module)],}}if ($module =~ s!^cpan:///distfile/!!){return$self->cpan_dist($module)}if ($module =~ m!^(?:[A-Z]/[A-Z]{2}/)?([A-Z]{2}[\-A-Z0-9]*/.*)$!){return$self->cpan_dist($1)}return$self->search_module($module,$version)}sub cpan_module_common {my($self,$match)=@_;(my$distfile=$match->{uri})=~ s!^cpan:///distfile/!!;my$mirrors=$self->{mirrors};if ($match->{download_uri}){(my$mirror=$match->{download_uri})=~ s!/authors/id/.*$!!;$mirrors=[$mirror]}local$self->{mirrors}=$mirrors;return$self->cpan_module($match->{package},$distfile,$match->{version})}sub cpan_module {my($self,$module,$dist_file,$version)=@_;my$dist=$self->cpan_dist($dist_file);$dist->{module}=$module;$dist->{module_version}=$version if$version && $version ne 'undef';return$dist}sub cpan_dist {my($self,$dist,$url,$mirror)=@_;$mirror =~ s!/$!! if$mirror;$dist =~ s!^([A-Z]{2})!substr($1,0,1)."/".substr($1,0,2)."/".$1!e;require CPAN::DistnameInfo;my$d=CPAN::DistnameInfo->new($dist);if ($url){$url=[$url ]unless ref$url eq 'ARRAY'}else {my$id=$d->cpanid;my$fn=substr($id,0,1)."/" .substr($id,0,2)."/" .$id ."/" .$d->filename;my@mirrors=$mirror ? ($mirror): @{$self->{mirrors}};my@urls=map "$_/authors/id/$fn",@mirrors;$url=\@urls,}return {$d->properties,source=>'cpan',uris=>$url,}}sub git_uri {my ($self,$uri)=@_;($uri,my$commitish)=split /(?<=\.git)@/i,$uri,2;my$dir=File::Temp::tempdir(CLEANUP=>1);$self->mask_output(diag_progress=>"Cloning $uri");$self->run_command(['git','clone',$uri,$dir ]);unless (-e "$dir/.git"){$self->diag_fail("Failed cloning git repository $uri",1);return}if ($commitish){require File::pushd;my$dir=File::pushd::pushd($dir);unless ($self->run_command(['git','checkout',$commitish ])){$self->diag_fail("Failed to checkout '$commitish' in git repository $uri\n");return}}$self->diag_ok;return {source=>'local',dir=>$dir,}}sub core_version_for {my($self,$module)=@_;require Module::CoreList;unless (exists$Module::CoreList::version{$]+0}){die sprintf("Module::CoreList %s (loaded from %s) doesn't seem to have entries for perl $]. " ."You're strongly recommended to upgrade Module::CoreList from CPAN.\n",$Module::CoreList::VERSION,$INC{"Module/CoreList.pm"})}unless (exists$Module::CoreList::version{$]+0}{$module}){return -1}return$Module::CoreList::version{$]+0}{$module}}sub search_inc {my$self=shift;$self->{search_inc}||= do {if (defined$::Bin){[grep!/^\Q$::Bin\E\/..\/(?:fat)?lib$/,@INC]}else {[@INC]}}}sub check_module {my($self,$mod,$want_ver)=@_;require Module::Metadata;my$meta=Module::Metadata->new_from_module($mod,inc=>$self->search_inc)or return 0,undef;my$version=$meta->version;if ($self->{self_contained}&& $self->loaded_from_perl_lib($meta)){$version=$self->core_version_for($mod);return 0,undef if$version && $version==-1}$self->{local_versions}{$mod}=$version;if ($self->is_deprecated($meta)){return 0,$version}elsif ($self->satisfy_version($mod,$version,$want_ver)){return 1,($version || 'undef')}else {return 0,$version}}sub satisfy_version {my($self,$mod,$version,$want_ver)=@_;$want_ver='0' unless defined($want_ver)&& length($want_ver);require CPAN::Meta::Requirements;my$requirements=CPAN::Meta::Requirements->new;$requirements->add_string_requirement($mod,$want_ver);$requirements->accepts_module($mod,$version)}sub unsatisfy_how {my($self,$ver,$want_ver)=@_;if ($want_ver =~ /^[v0-9\.\_]+$/){return "$ver < $want_ver"}else {return "$ver doesn't satisfy $want_ver"}}sub is_deprecated {my($self,$meta)=@_;my$deprecated=eval {require Module::CoreList;Module::CoreList::is_deprecated($meta->{module})};return$deprecated && $self->loaded_from_perl_lib($meta)}sub loaded_from_perl_lib {my($self,$meta)=@_;require Config;my@dirs=qw(archlibexp privlibexp);if ($self->{self_contained}&&!$self->{exclude_vendor}&& $Config{vendorarch}){unshift@dirs,qw(vendorarch vendorlibexp)}for my$dir (@dirs){my$confdir=$Config{$dir};if ($confdir eq substr($meta->filename,0,length($confdir))){return 1}}return}sub should_install {my($self,$mod,$ver)=@_;$self->chat("Checking if you have $mod $ver ... ");my($ok,$local)=$self->check_module($mod,$ver);if ($ok){$self->chat("Yes ($local)\n")}elsif ($local){$self->chat("No (" .$self->unsatisfy_how($local,$ver).")\n")}else {$self->chat("No\n")}return$mod unless$ok;return}sub check_perl_version {my($self,$version)=@_;require CPAN::Meta::Requirements;my$req=CPAN::Meta::Requirements->from_string_hash({perl=>$version });$req->accepts_module(perl=>$])}sub install_deps {my($self,$dir,$depth,@deps)=@_;my(@install,%seen,@fail);for my$dep (@deps){next if$seen{$dep->module};if ($dep->module eq 'perl'){if ($dep->is_requirement &&!$self->check_perl_version($dep->version)){$self->diag("Needs perl @{[$dep->version]}, you have $]\n");push@fail,'perl'}}elsif ($self->should_install($dep->module,$dep->version)){push@install,$dep;$seen{$dep->module}=1}}if (@install){$self->diag("==> Found dependencies: " .join(", ",map $_->module,@install)."\n")}for my$dep (@install){$self->install_module($dep->module,$depth + 1,$dep->version,$dep)}$self->chdir($self->{base});$self->chdir($dir)if$dir;if ($self->{scandeps}){return 1}my@not_ok=$self->unsatisfied_deps(@deps);if (@not_ok){return 0,\@not_ok}else {return 1}}sub unsatisfied_deps {my($self,@deps)=@_;require CPAN::Meta::Check;require CPAN::Meta::Requirements;my$reqs=CPAN::Meta::Requirements->new;for my$dep (grep $_->is_requirement,@deps){$reqs->add_string_requirement($dep->module=>$dep->requires_version || '0')}my$ret=CPAN::Meta::Check::check_requirements($reqs,'requires',$self->{search_inc});grep defined,values %$ret}sub install_deps_bailout {my($self,$target,$dir,$depth,@deps)=@_;my($ok,$fail)=$self->install_deps($dir,$depth,@deps);if (!$ok){$self->diag_fail("Installing the dependencies failed: " .join(", ",@$fail),1);unless ($self->prompt_bool("Do you want to continue building $target anyway?","n")){$self->diag_fail("Bailing out the installation for $target.",1);return}}return 1}sub build_stuff {my($self,$stuff,$dist,$depth)=@_;if ($self->{verify}&& -e 'SIGNATURE'){$self->verify_signature($dist)or return}require CPAN::Meta;my($meta_file)=grep -f,qw(META.json META.yml);if ($meta_file){$self->chat("Checking configure dependencies from $meta_file\n");$dist->{cpanmeta}=eval {CPAN::Meta->load_file($meta_file)}}elsif ($dist->{dist}&& $dist->{version}){$self->chat("META.yml/json not found. Creating skeleton for it.\n");$dist->{cpanmeta}=CPAN::Meta->new({name=>$dist->{dist},version=>$dist->{version}})}$dist->{meta}=$dist->{cpanmeta}? $dist->{cpanmeta}->as_struct : {};if ($self->opts_in_static_install($dist->{cpanmeta})){$dist->{static_install}=1}my@config_deps;if ($dist->{cpanmeta}){push@config_deps,Menlo::Dependency->from_prereqs($dist->{cpanmeta}->effective_prereqs,['configure'],$self->{install_types},)}if (-e 'Build.PL' &&!@config_deps){push@config_deps,Menlo::Dependency->from_versions({'Module::Build'=>'0.38' },'configure',)}$self->merge_with_cpanfile($dist,\@config_deps);$self->upgrade_toolchain(\@config_deps);my$target=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $dist->{dir};unless ($self->skip_configure($dist,$depth)){$self->install_deps_bailout($target,$dist->{dir},$depth,@config_deps)or return}$self->diag_progress("Configuring $target");my$configure_state=$self->configure_this($dist,$depth);$self->diag_ok($configure_state->{configured_ok}? "OK" : "N/A");if ($dist->{cpanmeta}&& $dist->{source}eq 'cpan'){$dist->{provides}=$dist->{cpanmeta}{provides}|| $self->extract_packages($dist->{cpanmeta},".")}my$deps_only=$self->deps_only($depth);$dist->{want_phases}=$self->{notest}&&!$self->deps_only($depth)? [qw(build runtime)]: [qw(build test runtime)];push @{$dist->{want_phases}},'develop' if$self->{with_develop}&& $depth==0;push @{$dist->{want_phases}},'configure' if$self->{with_configure}&& $depth==0;my@deps=$self->find_prereqs($dist);my$module_name=$self->find_module_name($configure_state)|| $dist->{meta}{name};$module_name =~ s/-/::/g;if ($self->{showdeps}){for my$dep (@config_deps,@deps){print$dep->module,($dep->version ? ("~".$dep->version): ""),"\n"}return 1}my$distname=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $stuff;my$walkup;if ($self->{scandeps}){$walkup=$self->scandeps_append_child($dist)}$self->install_deps_bailout($distname,$dist->{dir},$depth,@deps)or return;if ($self->{scandeps}){unless ($configure_state->{configured_ok}){my$diag=<<DIAG;if (@config_deps){my@tree=@{$self->{scandeps_tree}};$diag .= "!\n" .join("",map "! * $_->[0]{module}\n",@tree[0..$#tree-1])if@tree}$self->diag("!\n$diag!\n",1)}$walkup->();return 1}if ($self->{installdeps}&& $depth==0){if ($configure_state->{configured_ok}){$self->diag("<== Installed dependencies for $stuff. Finishing.\n");return 1}else {$self->diag("! Configuring $distname failed. See $self->{log} for details.\n",1);return}}my$installed;if ($configure_state->{static_install}){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build(sub {$configure_state->{static_install}->build},$distname,$dist,$depth)&& $self->test(sub {$configure_state->{static_install}->build("test")},$distname,$dist,$depth)&& $self->install(sub {$configure_state->{static_install}->build("install")},[],$dist,$depth)&& $installed++}elsif ($configure_state->{use_module_build}&& -e 'Build' && -f _){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{perl},"./Build" ],$distname,$dist,$depth)&& $self->test([$self->{perl},"./Build","test" ],$distname,$dist,$depth)&& $self->install([$self->{perl},"./Build","install" ],["--uninst",1 ],$dist,$depth)&& $installed++}elsif ($self->{make}&& -e 'Makefile'){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{make}],$distname,$dist,$depth)&& $self->test([$self->{make},"test" ],$distname,$dist,$depth)&& $self->install([$self->{make},"install" ],["UNINST=1" ],$dist,$depth)&& $installed++}else {my$why;my$configure_failed=$configure_state->{configured}&&!$configure_state->{configured_ok};if ($configure_failed){$why="Configure failed for $distname."}elsif ($self->{make}){$why="The distribution doesn't have a proper Makefile.PL/Build.PL"}else {$why="Can't configure the distribution. You probably need to have 'make'."}$self->diag_fail("$why See $self->{log} for details.",1);return}if ($installed && $self->{test_only}){$self->diag_ok;$self->diag("Successfully tested $distname\n",1)}elsif ($installed){my$local=$self->{local_versions}{$dist->{module}|| ''};my$version=$dist->{module_version}|| $dist->{meta}{version}|| $dist->{version};my$reinstall=$local && ($local eq $version);my$action=$local &&!$reinstall ? $self->is_downgrade($version,$local)? "downgraded" : "upgraded" : undef;my$how=$reinstall ? "reinstalled $distname" : $local ? "installed $distname ($action from $local)" : "installed $distname" ;my$msg="Successfully $how";$self->diag_ok;$self->diag("$msg\n",1);$self->{installed_dists}++;$self->save_meta($stuff,$dist,$module_name,\@config_deps,\@deps);return 1}else {my$what=$self->{test_only}? "Testing" : "Installing";$self->diag_fail("$what $stuff failed. See $self->{log} for details. Retry with --force to force install it.",1);return}}sub is_downgrade {my($self,$va,$vb)=@_;eval {version::->new($va)< $vb}}sub opts_in_static_install {my($self,$meta)=@_;return if!$self->{static_install};return if$self->{sudo}or $self->{uninstall_shadows};return$meta->{x_static_install}&& $meta->{x_static_install}==1}sub skip_configure {my($self,$dist,$depth)=@_;return 1 if$self->{skip_configure};return 1 if$dist->{static_install};return 1 if$self->no_dynamic_config($dist->{meta})&& $self->deps_only($depth);return}sub no_dynamic_config {my($self,$meta)=@_;exists$meta->{dynamic_config}&& $meta->{dynamic_config}==0}sub deps_only {my($self,$depth)=@_;($self->{installdeps}&& $depth==0)or $self->{showdeps}or $self->{scandeps}}sub perl_requirements {my($self,@requires)=@_;my@perl;for my$requires (grep defined,@requires){if (exists$requires->{perl}){push@perl,Menlo::Dependency->new(perl=>$requires->{perl})}}return@perl}sub configure_this {my($self,$dist,$depth)=@_;my$deps_only=$self->deps_only($depth);if (-e $self->{cpanfile_path}&& $deps_only){require Module::CPANfile;$dist->{cpanfile}=eval {Module::CPANfile->load($self->{cpanfile_path})};$self->diag_fail($@,1)if $@;$self->{cpanfile_global}||= $dist->{cpanfile};return {configured=>1,configured_ok=>!!$dist->{cpanfile},use_module_build=>0,}}if ($self->{skip_configure}){my$eumm=-e 'Makefile';my$mb=-e 'Build' && -f _;return {configured=>1,configured_ok=>$eumm || $mb,use_module_build=>$mb,}}if ($deps_only && $self->no_dynamic_config($dist->{meta})){return {configured=>1,configured_ok=>exists$dist->{meta}{prereqs},use_module_build=>0,}}my$state={};my$try_static=sub {if ($dist->{static_install}){$self->chat("Distribution opts in x_static_install: $dist->{meta}{x_static_install}\n");$self->static_install_configure($state,$dist,$depth)}};my$try_eumm=sub {if (-e 'Makefile.PL'){$self->chat("Running Makefile.PL\n");if ($self->configure([$self->{perl},"Makefile.PL" ],$dist,$depth)){$state->{configured_ok}=-e 'Makefile'}$state->{configured}++}};my$try_mb=sub {if (-e 'Build.PL'){$self->chat("Running Build.PL\n");if ($self->configure([$self->{perl},"Build.PL" ],$dist,$depth)){$state->{configured_ok}=-e 'Build' && -f _}$state->{use_module_build}++;$state->{configured}++}};for my$try ($try_static,$try_mb,$try_eumm){$try->();last if$state->{configured_ok}}unless ($state->{configured_ok}){while (1){my$ans=lc$self->prompt("Configuring $dist->{dist} failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");last if$ans eq 's';return$self->configure_this($dist,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}return$state}sub static_install_configure {my($self,$state,$dist,$depth)=@_;my$args=$depth==0 ? $self->{build_args}{configure}: [];require Menlo::Builder::Static;my$builder=Menlo::Builder::Static->new(meta=>$dist->{cpanmeta});$self->configure(sub {$builder->configure($args || [])},$dist,$depth);$state->{configured_ok}=1;$state->{static_install}=$builder;$state->{configured}++}sub find_module_name {my($self,$state)=@_;return unless$state->{configured_ok};if ($state->{use_module_build}&& -e "_build/build_params"){my$params=do {open my$in,"_build/build_params";eval(join "",<$in>)};return eval {$params->[2]{module_name}}|| undef}elsif (-e "Makefile"){open my$mf,"Makefile";while (<$mf>){if (/^\#\s+NAME\s+=>\s+(.*)/){return eval($1)}}}return}sub list_files {my$self=shift;if (-e 'MANIFEST'){require ExtUtils::Manifest;my$manifest=eval {ExtUtils::Manifest::manifind()}|| {};return sort {lc$a cmp lc$b}keys %$manifest}else {require File::Find;my@files;my$finder=sub {my$name=$File::Find::name;$name =~ s!\.[/\\]!!;push@files,$name};File::Find::find($finder,".");return sort {lc$a cmp lc$b}@files}}sub extract_packages {my($self,$meta,$dir)=@_;my$try=sub {my$file=shift;return 0 if$file =~ m!^(?:x?t|inc|local|perl5|fatlib|_build)/!;return 1 unless$meta->{no_index};return 0 if grep {$file =~ m!^$_/!}@{$meta->{no_index}{directory}|| []};return 0 if grep {$file eq $_}@{$meta->{no_index}{file}|| []};return 1};require Parse::PMFile;my@files=grep {/\.pm(?:\.PL)?$/ && $try->($_)}$self->list_files;my$provides={};for my$file (@files){my$parser=Parse::PMFile->new($meta,{UNSAFE=>1,ALLOW_DEV_VERSION=>1 });my$packages=$parser->parse($file);while (my($package,$meta)=each %$packages){$provides->{$package}||= {file=>$meta->{infile},($meta->{version}eq 'undef')? (): (version=>$meta->{version}),}}}return$provides}sub save_meta {my($self,$module,$dist,$module_name,$config_deps,$build_deps)=@_;return unless$dist->{distvname}&& $dist->{source}eq 'cpan';my$base=($ENV{PERL_MM_OPT}|| '')=~ /INSTALL_BASE=/ ? ($self->install_base($ENV{PERL_MM_OPT})."/lib/perl5"): $Config{sitelibexp};my$provides=$dist->{provides};File::Path::mkpath("blib/meta",0,0777);my$local={name=>$module_name,target=>$module,version=>exists$provides->{$module_name}? ($provides->{$module_name}{version}|| $dist->{version}): $dist->{version},dist=>$dist->{distvname},pathname=>$dist->{pathname},provides=>$provides,};require JSON::PP;open my$fh,">","blib/meta/install.json" or die $!;print$fh JSON::PP::encode_json($local);File::Copy::copy("MYMETA.json","blib/meta/MYMETA.json");my@cmd=(($self->{sudo}? 'sudo' : ()),$^X,'-MExtUtils::Install=install','-e',qq[install({ 'blib/meta' => '$base/$Config{archname}/.meta/$dist->{distvname}' })],);$self->run_command(\@cmd)}sub install_base {my($self,$mm_opt)=@_;$mm_opt =~ /INSTALL_BASE=(\S+)/ and return $1;die "Your PERL_MM_OPT doesn't contain INSTALL_BASE"}sub configure_features {my($self,$dist,@features)=@_;map $_->identifier,grep {$self->effective_feature($dist,$_)}@features}sub effective_feature {my($self,$dist,$feature)=@_;if ($dist->{depth}==0){my$value=$self->{features}{$feature->identifier};return$value if defined$value;return 1 if$self->{features}{__all}}if ($self->{interactive}){require CPAN::Meta::Requirements;$self->diag("[@{[ $feature->description ]}]\n",1);my$req=CPAN::Meta::Requirements->new;for my$phase (@{$dist->{want_phases}}){for my$type (@{$self->{install_types}}){$req->add_requirements($feature->prereqs->requirements_for($phase,$type))}}my$reqs=$req->as_string_hash;my@missing;for my$module (keys %$reqs){if ($self->should_install($module,$req->{$module})){push@missing,$module}}if (@missing){my$howmany=@missing;$self->diag("==> Found missing dependencies: " .join(", ",@missing)."\n",1);local$self->{prompt}=1;return$self->prompt_bool("Install the $howmany optional module(s)?","y")}}return}sub find_prereqs {my($self,$dist)=@_;my@deps=$self->extract_meta_prereqs($dist);if ($dist->{module}=~ /^Bundle::/i){push@deps,$self->bundle_deps($dist)}$self->merge_with_cpanfile($dist,\@deps);return@deps}sub merge_with_cpanfile {my($self,$dist,$deps)=@_;if ($self->{cpanfile_requirements}&&!$dist->{cpanfile}){for my$dep (@$deps){$dep->merge_with($self->{cpanfile_requirements})}}if ($self->{cpanfile_global}){for my$dep (@$deps){my$opts=$self->{cpanfile_global}->options_for_module($dep->module)or next;$dep->dist($opts->{dist})if$opts->{dist};$dep->mirror($opts->{mirror})if$opts->{mirror};$dep->url($opts->{url})if$opts->{url}}}}sub extract_meta_prereqs {my($self,$dist)=@_;if ($dist->{cpanfile}){my@features=$self->configure_features($dist,$dist->{cpanfile}->features);my$prereqs=$dist->{cpanfile}->prereqs_with(@features);$self->{cpanfile_requirements}=$prereqs->merged_requirements($dist->{want_phases},['requires']);return Menlo::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}require CPAN::Meta;my@meta=qw(MYMETA.json MYMETA.yml);if ($self->no_dynamic_config($dist->{meta})){push@meta,qw(META.json META.yml)}my@deps;my($meta_file)=grep -f,@meta;if ($meta_file){$self->chat("Checking dependencies from $meta_file ...\n");my$mymeta=eval {CPAN::Meta->load_file($meta_file,{lazy_validation=>1 })};if ($mymeta){$dist->{meta}{name}=$mymeta->name;$dist->{meta}{version}=$mymeta->version;return$self->extract_prereqs($mymeta,$dist)}}$self->diag_fail("No MYMETA file is found after configure. Your toolchain is too old?");return}sub bundle_deps {my($self,$dist)=@_;my$match;if ($dist->{module}){$match=sub {my$meta=Module::Metadata->new_from_file($_[0]);$meta && ($meta->name eq $dist->{module})}}else {$match=sub {1}}my@files;File::Find::find({wanted=>sub {push@files,File::Spec->rel2abs($_)if /\.pm$/i && $match->($_)},no_chdir=>1,},'.');my@deps;for my$file (@files){open my$pod,"<",$file or next;my$in_contents;while (<$pod>){if (/^=head\d\s+CONTENTS/){$in_contents=1}elsif (/^=/){$in_contents=0}elsif ($in_contents){/^(\S+)\s*(\S+)?/ and push@deps,Menlo::Dependency->new($1,$self->maybe_version($2))}}}return@deps}sub maybe_version {my($self,$string)=@_;return$string && $string =~ /^\.?\d/ ? $string : undef}sub extract_prereqs {my($self,$meta,$dist)=@_;my@features=$self->configure_features($dist,$meta->features);my$prereqs=$meta->effective_prereqs(\@features)->clone;$self->adjust_prereqs($dist,$prereqs);return Menlo::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}sub adjust_prereqs {my($self,$dist,$prereqs)=@_;if (-e "inc/Module/Install.pm"){for my$phase (qw(build test runtime)){my$reqs=$prereqs->requirements_for($phase,'requires');if ($reqs->requirements_for_module('ExtUtils::MakeMaker')){$reqs->clear_requirement('ExtUtils::MakeMaker');$reqs->add_minimum('ExtUtils::MakeMaker'=>0)}}}if ($dist->{static_install}){my$reqs=$prereqs->requirements_for('test'=>'requires');$reqs->add_minimum('TAP::Harness::Env'=>0)}}sub cleanup_workdirs {my$self=shift;my$expire=time - 24 * 60 * 60 * $self->{auto_cleanup};my@targets;opendir my$dh,"$self->{home}/work";while (my$e=readdir$dh){next if$e !~ /^(\d+)\.\d+$/;my$time=$1;if ($time < $expire){push@targets,"$self->{home}/work/$e"}}if (@targets){if (@targets >= 64){$self->diag("Expiring " .scalar(@targets)." work directories. This might take a while...\n")}else {$self->chat("Expiring " .scalar(@targets)." work directories.\n")}File::Path::rmtree(\@targets,0,0)}}sub scandeps_append_child {my($self,$dist)=@_;my$new_node=[$dist,[]];my$curr_node=$self->{scandeps_current}|| [undef,$self->{scandeps_tree}];push @{$curr_node->[1]},$new_node;$self->{scandeps_current}=$new_node;return sub {$self->{scandeps_current}=$curr_node}}sub dump_scandeps {my$self=shift;if ($self->{format}eq 'tree'){$self->walk_down(sub {my($dist,$depth)=@_;if ($depth==0){print "$dist->{distvname}\n"}else {print " " x ($depth - 1);print "\\_ $dist->{distvname}\n"}},1)}elsif ($self->{format}=~ /^dists?$/){$self->walk_down(sub {my($dist,$depth)=@_;print$self->format_dist($dist),"\n"},0)}elsif ($self->{format}eq 'json'){require JSON::PP;print JSON::PP::encode_json($self->{scandeps_tree})}elsif ($self->{format}eq 'yaml'){require CPAN::Meta::YAML;print CPAN::Meta::YAML::Dump($self->{scandeps_tree})}else {$self->diag("Unknown format: $self->{format}\n")}}sub walk_down {my($self,$cb,$pre)=@_;$self->_do_walk_down($self->{scandeps_tree},$cb,0,$pre)}sub _do_walk_down {my($self,$children,$cb,$depth,$pre)=@_;for my$node (@$children){$cb->($node->[0],$depth)if$pre;$self->_do_walk_down($node->[1],$cb,$depth + 1,$pre);$cb->($node->[0],$depth)unless$pre}}sub DESTROY {my$self=shift;$self->{at_exit}->($self)if$self->{at_exit}}sub mirror {my($self,$uri,$local)=@_;if ($uri =~ /^file:/){$self->file_mirror($uri,$local)}else {$self->{http}->mirror($uri,$local)}}sub untar {$_[0]->{_backends}{untar}->(@_)};sub unzip {$_[0]->{_backends}{unzip}->(@_)};sub uri_to_file {my($self,$uri)=@_;if ($uri =~ s!file:/+!!){$uri="/$uri" unless$uri =~ m![a-zA-Z]:!}return$uri}sub file_get {my($self,$uri)=@_;my$file=$self->uri_to_file($uri);open my$fh,"<$file" or return;join '',<$fh>}sub file_mirror {my($self,$uri,$path)=@_;my$file=$self->uri_to_file($uri);my$source_mtime=(stat$file)[9];return 1 if -e $path && (stat$path)[9]>= $source_mtime;File::Copy::copy($file,$path);utime$source_mtime,$source_mtime,$path}sub configure_http {my$self=shift;require HTTP::Tinyish;my@try=qw(HTTPTiny);unshift@try,'Wget' if$self->{try_wget};unshift@try,'Curl' if$self->{try_curl};unshift@try,'LWP' if$self->{try_lwp};my@protocol=('http');push@protocol,'https' if grep /^https:/,@{$self->{mirrors}};my$backend;for my$try (map "HTTP::Tinyish::$_",@try){if (my$meta=HTTP::Tinyish->configure_backend($try)){if ((grep$try->supports($_),@protocol)==@protocol){for my$tool (sort keys %$meta){(my$desc=$meta->{$tool})=~ s/^(.*?)\n.*/$1/s;$self->chat("You have $tool: $desc\n")}$backend=$try;last}}}$backend->new(agent=>"Menlo/$Menlo::VERSION",verify_SSL=>1)}sub init_tools {my$self=shift;return if$self->{initialized}++;if ($self->{make}=which($Config{make})){$self->chat("You have make $self->{make}\n")}$self->{http}=$self->configure_http;my$tar=which('tar');my$tar_ver;my$maybe_bad_tar=sub {WIN32 || BAD_TAR || (($tar_ver=`@{[ qs $tar ]} --version 2>/dev/null`)=~ /GNU.*1\.13/i)};if ($tar &&!$maybe_bad_tar->()){chomp$tar_ver;$self->chat("You have $tar: $tar_ver\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$xf=($self->{verbose}? 'v' : '')."xf";my$ar=$tarfile =~ /bz2$/ ? 'j' : 'z';my($root,@others)=`@{[ qs $tar ]} ${ar}tf @{[ qs $tarfile ]}` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$self->run_command([$tar,$ar.$xf,$tarfile ]);return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif ($tar and my$gzip=which('gzip')and my$bzip2=which('bzip2')){$self->chat("You have $tar, $gzip and $bzip2\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$x="x" .($self->{verbose}? 'v' : '')."f -";my$ar=$tarfile =~ /bz2$/ ? $bzip2 : $gzip;my($root,@others)=`@{[ qs $ar ]} -dc @{[ qs $tarfile ]} | @{[ qs $tar ]} tf -` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}system "@{[ qs $ar ]} -dc @{[ qs $tarfile ]} | @{[ qs $tar ]} $x";return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif (eval {require Archive::Tar}){$self->chat("Falling back to Archive::Tar $Archive::Tar::VERSION\n");$self->{_backends}{untar}=sub {my$self=shift;my$t=Archive::Tar->new($_[0]);my($root,@others)=$t->list_files;FILE: {$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$t->extract;return -d $root ? $root : undef}}else {$self->{_backends}{untar}=sub {die "Failed to extract $_[1] - You need to have tar or Archive::Tar installed.\n"}}if (my$unzip=which('unzip')){$self->chat("You have $unzip\n");$self->{_backends}{unzip}=sub {my($self,$zipfile)=@_;my@opt=$self->{verbose}? (): ('-q');my(undef,$root,@others)=`@{[ qs $unzip ]} -t @{[ qs $zipfile ]}` or return undef;FILE: {chomp$root;if ($root !~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1}){$root=shift(@others);redo FILE if$root}}$self->run_command([$unzip,@opt,$zipfile ]);return$root if -d $root;$self->diag_fail("Bad archive: '$root' $zipfile");return undef}}else {$self->{_backends}{unzip}=sub {eval {require Archive::Zip}or die "Failed to extract $_[1] - You need to have unzip or Archive::Zip installed.\n";my($self,$file)=@_;my$zip=Archive::Zip->new();my$status;$status=$zip->read($file);$self->diag_fail("Read of file '$file' failed")if$status!=Archive::Zip::AZ_OK();my@members=$zip->members();for my$member (@members){my$af=$member->fileName();next if ($af =~ m!^(/|\.\./)!);$status=$member->extractToFileNamed($af);$self->diag_fail("Extracting of file 'af' from zipfile '$file' failed")if$status!=Archive::Zip::AZ_OK()}my ($root)=$zip->membersMatching(qr<^[^/]+/$>);$root &&= $root->fileName;return -d $root ? $root : undef}}}sub mask_uri_passwords {my($self,@strings)=@_;s{ (https?://) ([^:/]+) : [^@/]+ @ }{$1$2:********@}gx for@strings;return@strings}1;
  It appears your cpanm executable was installed via `perlbrew install-cpanm`.
  cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
  Run the following command to get it upgraded.
  
    perlbrew install-cpanm
  
  DIE
  You are running cpanm from the path where your current perl won't install executables to.
  Because of that, cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
    cpanm path   : $0
    Install path : $Config{installsitebin}
  
  It means you either installed cpanm globally with system perl, or use distro packages such
  as rpm or apt-get, and you have to use them again to upgrade cpanm.
  DIE
  Usage: cpanm [options] Module [...]
  
  Try `cpanm --help` or `man cpanm` for more options.
  USAGE
  Usage: cpanm [options] Module [...]
  
  Options:
    -v,--verbose              Turns on chatty output
    -q,--quiet                Turns off the most output
    --interactive             Turns on interactive configure (required for Task:: modules)
    -f,--force                force install
    -n,--notest               Do not run unit tests
    --test-only               Run tests only, do not install
    -S,--sudo                 sudo to run install commands
    --installdeps             Only install dependencies
    --showdeps                Only display direct dependencies
    --reinstall               Reinstall the distribution even if you already have the latest version installed
    --mirror                  Specify the base URL for the mirror (e.g. http://cpan.cpantesters.org/)
    --mirror-only             Use the mirror's index file instead of the CPAN Meta DB
    -M,--from                 Use only this mirror base URL and its index file
    --prompt                  Prompt when configure/build/test fails
    -l,--local-lib            Specify the install base to install modules
    -L,--local-lib-contained  Specify the install base to install all non-core modules
    --self-contained          Install all non-core modules, even if they're already installed.
    --auto-cleanup            Number of days that cpanm's work directories expire in. Defaults to 7
  
  Commands:
    --self-upgrade            upgrades itself
    --info                    Displays distribution info on CPAN
    --look                    Opens the distribution with your SHELL
    -U,--uninstall            Uninstalls the modules (EXPERIMENTAL)
    -V,--version              Displays software version
  
  Examples:
  
    cpanm Test::More                                          # install Test::More
    cpanm MIYAGAWA/Plack-0.99_05.tar.gz                       # full distribution path
    cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz           # install from URL
    cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz            # install from a local file
    cpanm --interactive Task::Kensho                          # Configure interactively
    cpanm .                                                   # install from local directory
    cpanm --installdeps .                                     # install all the deps for the current directory
    cpanm -L extlib Plack                                     # install Plack and all non-core deps into extlib
    cpanm --mirror http://cpan.cpantesters.org/ DBI           # use the fast-syncing mirror
    cpanm -M https://cpan.metacpan.org App::perlbrew          # use only this secure mirror and its index
  
  You can also specify the default options in PERL_CPANM_OPT environment variable in the shell rc:
  
    export PERL_CPANM_OPT="--prompt --reinstall -l ~/perl --mirror http://cpan.cpantesters.org"
  
  Type `man cpanm` or `perldoc cpanm` for the more detailed explanation of the options.
  
  HELP
  !
  ! Can't write to $Config{installsitelib} and $Config{installsitebin}: Installing modules to $ENV{HOME}/perl5
  ! To turn off this warning, you have to do one of the following:
  !   - run me as a root or with --sudo option (to install to $Config{installsitelib} and $Config{installsitebin})
  !   - Configure local::lib in your existing shell to set PERL_MM_OPT etc.
  !   - Install local::lib by running the following commands
  !
  !         cpanm --local-lib=~/perl5 local::lib && eval \$(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
  !
  DIAG
  WARNING: Your lib directory name ($base) contains a space in it. It's known to cause issues with perl builder tools such as local::lib and MakeMaker. You're recommended to rename your directory.
  WARN
  $module is not found in the following directories and can't be uninstalled.
  
  @{[ join("  \n", map "  $_", @inc) ]}
  
  DIAG
  ! Configuring $distname failed. See $self->{log} for details.
  ! You might have to install the following modules first to get --scandeps working correctly.
  DIAG
MENLO_CLI_COMPAT

$fatpacked{"Menlo/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_DEPENDENCY';
  package Menlo::Dependency;use strict;use CPAN::Meta::Requirements;use Class::Tiny qw(module version type original_version dist mirror url);sub BUILDARGS {my($class,$module,$version,$type)=@_;return {module=>$module,version=>$version,type=>$type || 'requires',}}sub from_prereqs {my($class,$prereqs,$phases,$types)=@_;my@deps;for my$type (@$types){push@deps,$class->from_versions($prereqs->merged_requirements($phases,[$type])->as_string_hash,$type,)}return@deps}sub from_versions {my($class,$versions,$type)=@_;my@deps;while (my($module,$version)=each %$versions){push@deps,$class->new($module,$version,$type)}@deps}sub merge_with {my($self,$requirements)=@_;$self->original_version($self->version);eval {$requirements->add_string_requirement($self->module,$self->version)};if ($@ =~ /illegal requirements/){warn sprintf("Can't merge requirements for %s: '%s' and '%s'",$self->module,$self->version,$requirements->requirements_for_module($self->module))}$self->version($requirements->requirements_for_module($self->module))}sub requires_version {my$self=shift;if (defined$self->original_version){return$self->original_version}$self->version}sub is_requirement {$_[0]->type eq 'requires'}1;
MENLO_DEPENDENCY

$fatpacked{"Menlo/Index/MetaCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_METACPAN';
  use 5.008001;use strict;use warnings;package Menlo::Index::MetaCPAN;use parent 'CPAN::Common::Index';use Class::Tiny qw/uri include_dev/;use Carp;use HTTP::Tinyish;use JSON::PP ();use Time::Local ();sub BUILD {my$self=shift;my$uri=$self->uri;$uri="https://fastapi.metacpan.org/v1/download_url/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my$range;if ($args->{version}){$range="== $args->{version}"}elsif ($args->{version_range}){$range=$args->{version_range}}my%query=(($self->include_dev ? (dev=>1): ()),($range ? (version=>$range): ()),);my$query=join "&",map {"$_=" .$self->_uri_escape($query{$_})}sort keys%query;my$uri=$self->uri .$args->{package}.($query ? "?$query" : "");my$res=HTTP::Tinyish->new->get($uri);return unless$res->{success};my$dist_meta=eval {JSON::PP::decode_json($res->{content})};if ($dist_meta && $dist_meta->{download_url}){(my$distfile=$dist_meta->{download_url})=~ s!.+/authors/id/\w/\w\w/!!;return {package=>$args->{package},version=>$dist_meta->{version},uri=>"cpan:///distfile/$distfile",download_uri=>$self->_download_uri("http://cpan.metacpan.org",$distfile),}}return}sub _parse_date {my($self,$date)=@_;my@date=$date =~ /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)$/;Time::Local::timegm($date[5],$date[4],$date[3],$date[2],$date[1]- 1,$date[0]- 1900)}sub _uri_escape {my($self,$string)=@_;$string =~ s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;$string}sub _download_uri {my($self,$base,$distfile)=@_;join "/",$base,"authors/id",substr($distfile,0,1),substr($distfile,0,2),$distfile}sub index_age {return time}sub search_authors {return}1;
MENLO_INDEX_METACPAN

$fatpacked{"Menlo/Index/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_METADB';
  use 5.008001;use strict;use warnings;package Menlo::Index::MetaDB;our$VERSION="1.9019";use parent 'CPAN::Common::Index';use Class::Tiny qw/uri/;use Carp;use CPAN::Meta::YAML;use CPAN::Meta::Requirements;use HTTP::Tiny;sub BUILD {my$self=shift;my$uri=$self->uri;$uri="http://cpanmetadb.plackperl.org/v1.0/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';return unless exists$args->{package}&& ref$args->{package}eq '';my$mod=$args->{package};if ($args->{version}|| $args->{version_range}){my$res=HTTP::Tiny->new->get($self->uri ."history/$mod");return unless$res->{success};my$range=defined$args->{version}? "== $args->{version}" : $args->{version_range};my$reqs=CPAN::Meta::Requirements->from_string_hash({$mod=>$range });my@found;for my$line (split /\r?\n/,$res->{content}){if ($line =~ /^$mod\s+(\S+)\s+(\S+)$/){push@found,{version=>$1,version_o=>version::->parse($1),distfile=>$2,}}}return unless@found;$found[-1]->{latest}=1;my$match;for my$try (sort {$b->{version_o}<=> $a->{version_o}}@found){if ($reqs->accepts_module($mod=>$try->{version_o})){$match=$try,last}}if ($match){my$file=$match->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$match->{version},uri=>"cpan:///distfile/$file",($match->{latest}? (): (download_uri=>"http://backpan.perl.org/authors/id/$match->{distfile}")),}}}else {my$res=HTTP::Tiny->new->get($self->uri ."package/$mod");return unless$res->{success};if (my$yaml=CPAN::Meta::YAML->read_string($res->{content})){my$meta=$yaml->[0];if ($meta && $meta->{distfile}){my$file=$meta->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$meta->{version},uri=>"cpan:///distfile/$file",}}}}return}sub index_age {return time};sub search_authors {return};1;
MENLO_INDEX_METADB

$fatpacked{"Menlo/Index/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_MIRROR';
  package Menlo::Index::Mirror;use strict;use parent qw(CPAN::Common::Index::Mirror);use Class::Tiny qw(fetcher);use File::Basename ();use File::Spec ();use URI ();our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};my%INDICES=(packages=>'modules/02packages.details.txt.gz',);sub refresh_index {my$self=shift;for my$file (values%INDICES){my$remote=URI->new_abs($file,$self->mirror);$remote =~ s/\.gz$// unless$HAS_IO_UNCOMPRESS_GUNZIP;my$local=File::Spec->catfile($self->cache,File::Basename::basename($file));$self->fetcher->($remote,$local)or Carp::croak("Cannot fetch $remote to $local");if ($HAS_IO_UNCOMPRESS_GUNZIP){(my$uncompressed=$local)=~ s/\.gz$//;IO::Uncompress::Gunzip::gunzip($local,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}}1;
MENLO_INDEX_MIRROR

$fatpacked{"Menlo/Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_LEGACY';
  package Menlo::Legacy;use strict;our$VERSION='1.9022';1;
MENLO_LEGACY

$fatpacked{"Menlo/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_UTIL';
  package Menlo::Util;use strict;use Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(WIN32);use constant WIN32=>$^O eq 'MSWin32';if (WIN32){require Win32::ShellQuote;*shell_quote=\&Win32::ShellQuote::quote_native}else {require String::ShellQuote;*shell_quote=\&String::ShellQuote::shell_quote_best_effort}1;
MENLO_UTIL

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;use Moo::_strictures;use Moo::_Utils qw(_load_module _maybe_load_module _install_coderef);use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quoted_from_sub quotify sanitize_identifier);use Scalar::Util 'blessed';use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::_Utils)}BEGIN {*_CAN_WEAKEN_READONLY=("$]" < 5.008_003 or $ENV{MOO_TEST_PRE_583})? sub(){0}: sub(){1};our$CAN_HAZ_XS=!$ENV{MOO_XS_DISABLE}&& _maybe_load_module('Class::XSAccessor')&& (eval {Class::XSAccessor->VERSION('1.07')});our$CAN_HAZ_XS_PRED=$CAN_HAZ_XS && (eval {Class::XSAccessor->VERSION('1.17')})}BEGIN {package Method::Generate::Accessor::_Generated;$Carp::Internal{+__PACKAGE__}=1}my$module_name_only=qr/\A$Module::Runtime::module_name_rx\z/;sub _die_overwrite {my ($pkg,$method,$type)=@_;croak "You cannot overwrite a locally defined method ($method) with " .($type || 'an accessor')}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={no_defer=>1,package=>'Method::Generate::Accessor::_Generated',%{$quote_opts||{}},};$spec->{allow_overwrite}++ if$name =~ s/^\+//;croak "Must have an is" unless my$is=$spec->{is};if ($is eq 'ro'){$spec->{reader}=$name unless exists$spec->{reader}}elsif ($is eq 'rw'){$spec->{accessor}=$name unless exists$spec->{accessor}or ($spec->{reader}and $spec->{writer})}elsif ($is eq 'lazy'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{lazy}=1;$spec->{builder}||= '_build_'.$name unless exists$spec->{default}}elsif ($is eq 'rwp'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{writer}="_set_${name}" unless exists$spec->{writer}}elsif ($is ne 'bare'){croak "Unknown is ${is}"}if (exists$spec->{builder}){if(ref$spec->{builder}){$self->_validate_codulatable('builder',$spec->{builder},"$into->$name",'or a method name');$spec->{builder_sub}=$spec->{builder};$spec->{builder}=1}$spec->{builder}='_build_'.$name if ($spec->{builder}||0)eq 1;croak "Invalid builder for $into->$name - not a valid method name" if$spec->{builder}!~ $module_name_only}if (($spec->{predicate}||0)eq 1){$spec->{predicate}=$name =~ /^_/ ? "_has${name}" : "has_${name}"}if (($spec->{clearer}||0)eq 1){$spec->{clearer}=$name =~ /^_/ ? "_clear${name}" : "clear_${name}"}if (($spec->{trigger}||0)eq 1){$spec->{trigger}=quote_sub('shift->_trigger_'.$name.'(@_)')}if (($spec->{coerce}||0)eq 1){my$isa=$spec->{isa};if (blessed$isa and $isa->can('coercion')){$spec->{coerce}=$isa->coercion}elsif (blessed$isa and $isa->can('coerce')){$spec->{coerce}=sub {$isa->coerce(@_)}}else {croak "Invalid coercion for $into->$name - no appropriate type constraint"}}for my$setting (qw(isa coerce)){next if!exists$spec->{$setting};$self->_validate_codulatable($setting,$spec->{$setting},"$into->$name")}if (exists$spec->{default}){if (ref$spec->{default}){$self->_validate_codulatable('default',$spec->{default},"$into->$name",'or a non-ref')}}if (exists$spec->{moosify}){if (ref$spec->{moosify}ne 'ARRAY'){$spec->{moosify}=[$spec->{moosify}]}for my$spec (@{$spec->{moosify}}){$self->_validate_codulatable('moosify',$spec,"$into->$name")}}my%methods;if (my$reader=$spec->{reader}){_die_overwrite($into,$reader,'a reader')if!$spec->{allow_overwrite}&& defined &{"${into}::${reader}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)){$methods{$reader}=$self->_generate_xs(getters=>$into,$reader,$name,$spec)}else {$self->{captures}={};$methods{$reader}=quote_sub "${into}::${reader}" =>'    Carp::croak("'.$reader.' is a read-only accessor") if @_ > 1;'."\n" .$self->_generate_get($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$accessor=$spec->{accessor}){_die_overwrite($into,$accessor,'an accessor')if!$spec->{allow_overwrite}&& defined &{"${into}::${accessor}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)&& $self->is_simple_set($name,$spec)){$methods{$accessor}=$self->_generate_xs(accessors=>$into,$accessor,$name,$spec)}else {$self->{captures}={};$methods{$accessor}=quote_sub "${into}::${accessor}" =>$self->_generate_getset($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$writer=$spec->{writer}){_die_overwrite($into,$writer,'a writer')if!$spec->{allow_overwrite}&& defined &{"${into}::${writer}"};if (our$CAN_HAZ_XS && $self->is_simple_set($name,$spec)){$methods{$writer}=$self->_generate_xs(setters=>$into,$writer,$name,$spec)}else {$self->{captures}={};$methods{$writer}=quote_sub "${into}::${writer}" =>$self->_generate_set($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$pred=$spec->{predicate}){_die_overwrite($into,$pred,'a predicate')if!$spec->{allow_overwrite}&& defined &{"${into}::${pred}"};if (our$CAN_HAZ_XS && our$CAN_HAZ_XS_PRED){$methods{$pred}=$self->_generate_xs(exists_predicates=>$into,$pred,$name,$spec)}else {$self->{captures}={};$methods{$pred}=quote_sub "${into}::${pred}" =>$self->_generate_simple_has('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }}if (my$builder=delete$spec->{builder_sub}){_install_coderef("${into}::$spec->{builder}"=>$builder)}if (my$cl=$spec->{clearer}){_die_overwrite($into,$cl,'a clearer')if!$spec->{allow_overwrite}&& defined &{"${into}::${cl}"};$self->{captures}={};$methods{$cl}=quote_sub "${into}::${cl}" =>$self->_generate_simple_clear('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }if (my$hspec=$spec->{handles}){my$asserter=$spec->{asserter}||= '_assert_'.$name;my@specs=do {if (ref($hspec)eq 'ARRAY'){map [$_=>$_ ],@$hspec}elsif (ref($hspec)eq 'HASH'){map [$_=>ref($hspec->{$_})? @{$hspec->{$_}}: $hspec->{$_}],keys %$hspec}elsif (!ref($hspec)){require Moo::Role;_load_module$hspec;map [$_=>$_ ],Moo::Role->methods_provided_by($hspec)}else {croak "You gave me a handles of ${hspec} and I have no idea why"}};for my$delegation_spec (@specs){my ($proxy,$target,@args)=@$delegation_spec;_die_overwrite($into,$proxy,'a delegation')if!$spec->{allow_overwrite}&& defined &{"${into}::${proxy}"};$self->{captures}={};$methods{$proxy}=quote_sub "${into}::${proxy}" =>$self->_generate_delegation($asserter,$target,\@args)=>delete$self->{captures}=>$quote_opts }}if (my$asserter=$spec->{asserter}){_die_overwrite($into,$asserter,'an asserter')if!$spec->{allow_overwrite}&& defined &{"${into}::${asserter}"};local$self->{captures}={};$methods{$asserter}=quote_sub "${into}::${asserter}" =>$self->_generate_asserter($name,$spec)=>delete$self->{captures}=>$quote_opts }\%methods}sub merge_specs {my ($self,@specs)=@_;my$spec=shift@specs;for my$old_spec (@specs){for my$key (keys %$old_spec){if ($key eq 'handles'){}elsif ($key eq 'moosify'){$spec->{$key}=[map {ref $_ eq 'ARRAY' ? @$_ : $_}grep defined,($old_spec->{$key},$spec->{$key})]}elsif (!exists$spec->{$key}){$spec->{$key}=$old_spec->{$key}}}}$spec}sub is_simple_attribute {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(lazy default builder coerce isa trigger predicate weak_ref)}sub is_simple_get {my ($self,$name,$spec)=@_;!($spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub is_simple_set {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(coerce isa trigger weak_ref)}sub has_default {my ($self,$name,$spec)=@_;$spec->{builder}or exists$spec->{default}or (($spec->{is}||'')eq 'lazy')}sub has_eager_default {my ($self,$name,$spec)=@_;(!$spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub _generate_get {my ($self,$name,$spec)=@_;my$simple=$self->_generate_simple_get('$_[0]',$name,$spec);if ($self->is_simple_get($name,$spec)){$simple}else {$self->_generate_use_default('$_[0]',$name,$spec,$self->_generate_simple_has('$_[0]',$name,$spec),)}}sub generate_simple_has {my$self=shift;$self->{captures}={};my$code=$self->_generate_simple_has(@_);($code,delete$self->{captures})}sub _generate_simple_has {my ($self,$me,$name)=@_;"exists ${me}->{${\quotify $name}}"}sub _generate_simple_clear {my ($self,$me,$name)=@_;"    delete ${me}->{${\quotify $name}}\n"}sub generate_get_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_get_default(@_);($code,delete$self->{captures})}sub generate_use_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_use_default(@_);($code,delete$self->{captures})}sub _generate_use_default {my ($self,$me,$name,$spec,$test)=@_;my$get_value=$self->_generate_get_default($me,$name,$spec);if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce})}$test." ? \n" .$self->_generate_simple_get($me,$name,$spec)."\n:" .($spec->{isa}? "    do {\n      my \$value = ".$get_value.";\n" ."      ".$self->_generate_isa_check($name,'$value',$spec->{isa}).";\n" ."      ".$self->_generate_simple_set($me,$name,$spec,'$value')."\n" ."    }\n" : '    ('.$self->_generate_simple_set($me,$name,$spec,$get_value).")\n")}sub _generate_get_default {my ($self,$me,$name,$spec)=@_;if (exists$spec->{default}){ref$spec->{default}? $self->_generate_call_code($name,'default',$me,$spec->{default}): quotify$spec->{default}}else {"${me}->${\$spec->{builder}}"}}sub generate_simple_get {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_simple_get(@args);($code,delete$self->{captures})}sub _generate_simple_get {my ($self,$me,$name)=@_;my$name_str=quotify$name;"${me}->{${name_str}}"}sub _generate_set {my ($self,$name,$spec)=@_;my ($me,$source)=('$_[0]','$_[1]');if ($self->is_simple_set($name,$spec)){return$self->_generate_simple_set($me,$name,$spec,$source)}my ($coerce,$trigger,$isa_check)=@{$spec}{qw(coerce trigger isa)};if ($coerce){$source=$self->_generate_coerce($name,$source,$coerce)}if ($isa_check){'scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$isa_check)."),\n" .'  ('.$self->_generate_simple_set($me,$name,$spec,'$value')."),\n" .($trigger ? '('.$self->_generate_trigger($name,$me,'$value',$trigger)."),\n" : '').'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" ."}"}elsif ($trigger){my$set=$self->_generate_simple_set($me,$name,$spec,$source);"scalar (\n" .'  ('.$self->_generate_trigger($name,$me,"($set)",$trigger)."),\n" .'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" .")"}else {'('.$self->_generate_simple_set($me,$name,$spec,$source).')'}}sub generate_coerce {my$self=shift;$self->{captures}={};my$code=$self->_generate_coerce(@_);($code,delete$self->{captures})}sub _attr_desc {my ($name,$init_arg)=@_;return quotify($name)if!defined($init_arg)or $init_arg eq $name;return quotify($name).' (constructor argument: '.quotify($init_arg).')'}sub _generate_coerce {my ($self,$name,$value,$coerce,$init_arg)=@_;$self->_wrap_attr_exception($name,"coercion",$init_arg,$self->_generate_call_code($name,'coerce',"${value}",$coerce),1,)}sub generate_trigger {my$self=shift;$self->{captures}={};my$code=$self->_generate_trigger(@_);($code,delete$self->{captures})}sub _generate_trigger {my ($self,$name,$obj,$value,$trigger)=@_;$self->_generate_call_code($name,'trigger',"${obj}, ${value}",$trigger)}sub generate_isa_check {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_isa_check(@args);($code,delete$self->{captures})}sub _wrap_attr_exception {my ($self,$name,$step,$arg,$code,$want_return)=@_;my$prefix=quotify("${step} for "._attr_desc($name,$arg).' failed: ');"do {\n" .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n" .'    init_arg => '.quotify($arg).",\n" .'    name     => '.quotify($name).",\n" .'    step     => '.quotify($step).",\n" ."  };\n" .($want_return ? '  (my $_return),'."\n" : '').'  (my $_error), (my $_old_error = $@);'."\n" ."  (eval {\n" .'    ($@ = $_old_error),'."\n" .'    (' .($want_return ? '$_return ='."\n" : '').$code."),\n" ."    1\n" ."  } or\n" .'    $_error = CORE::ref $@ ? $@ : '.$prefix.'.$@);'."\n" .'  ($@ = $_old_error),'."\n" .'  (defined $_error and CORE::die $_error);'."\n" .($want_return ? '  $_return;'."\n" : '')."}\n"}sub _generate_isa_check {my ($self,$name,$value,$check,$init_arg)=@_;$self->_wrap_attr_exception($name,"isa check",$init_arg,$self->_generate_call_code($name,'isa_check',$value,$check))}sub _generate_call_code {my ($self,$name,$type,$values,$sub)=@_;$sub=\&{$sub}if blessed($sub);if (my$quoted=quoted_from_sub($sub)){my$local=1;if ($values eq '@_' || $values eq '$_[0]'){$local=0;$values='@_'}my$code=$quoted->[1];if (my$captures=$quoted->[2]){my$cap_name=qq{\$${type}_captures_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$captures;Sub::Quote::inlinify($code,$values,Sub::Quote::capture_unroll($cap_name,$captures,6),$local)}else {Sub::Quote::inlinify($code,$values,undef,$local)}}else {my$cap_name=qq{\$${type}_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$sub;"${cap_name}->(${values})"}}sub _sanitize_name {sanitize_identifier($_[1])}sub generate_populate_set {my$self=shift;$self->{captures}={};my$code=$self->_generate_populate_set(@_);($code,delete$self->{captures})}sub _generate_populate_set {my ($self,$me,$name,$spec,$source,$test,$init_arg)=@_;my$has_default=$self->has_eager_default($name,$spec);if (!($has_default || $test)){return ''}if ($has_default){my$get_default=$self->_generate_get_default($me,$name,$spec);$source=$test ? "(\n  ${test}\n" ."   ? ${source}\n   : " .$get_default .")" : $get_default}if ($spec->{coerce}){$source=$self->_generate_coerce($name,$source,$spec->{coerce},$init_arg)}if ($spec->{isa}){$source='scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$spec->{isa},$init_arg)."),\n" ."  \$value\n" ."}\n"}my$set=$self->_generate_simple_set($me,$name,$spec,$source);my$trigger=$spec->{trigger}? $self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger}): undef;if ($has_default){"($set)," .($trigger && $test ? "($test and $trigger)," : '')."\n"}else {"($test and ($set)" .($trigger ? ", ($trigger)" : '')."),\n"}}sub _generate_core_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;"${me}->{${name_str}} = ${value}"}sub _generate_simple_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;my$simple=$self->_generate_core_set($me,$name,$spec,$value);if ($spec->{weak_ref}){require Scalar::Util;my$get=$self->_generate_simple_get($me,$name,$spec);my$weak_simple=_CAN_WEAKEN_READONLY ? "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }" : <<"EOC"}else {$simple}}sub _generate_getset {my ($self,$name,$spec)=@_;q{(@_ > 1}."\n      ? ".$self->_generate_set($name,$spec)."\n      : ".$self->_generate_get($name,$spec)."\n    )"}sub _generate_asserter {my ($self,$name,$spec)=@_;my$name_str=quotify($name);"do {\n" ."  my \$val = ".$self->_generate_get($name,$spec).";\n" ."  ".$self->_generate_simple_has('$_[0]',$name,$spec)."\n" ."    or Carp::croak(q{Attempted to access '}.${name_str}.q{' but it is not set});\n" ."  \$val;\n" ."}\n"}sub _generate_delegation {my ($self,$asserter,$target,$args)=@_;my$arg_string=do {if (@$args){$self->{captures}{'@curries'}=$args;'@curries, @_'}else {'@_'}};"shift->${asserter}->${target}(${arg_string});"}sub _generate_xs {my ($self,$type,$into,$name,$slot)=@_;Class::XSAccessor->import(class=>$into,$type=>{$name=>$slot },replace=>1,);$into->can($name)}sub default_construction_string {'{}'}sub _validate_codulatable {my ($self,$setting,$value,$into,$appended)=@_;my$error;if (blessed$value){local $@;no warnings 'void';eval {\&$value;1}and return 1;$error="could not be converted to a coderef: $@"}elsif (ref$value eq 'CODE'){return 1}else {$error='is not a coderef or code-convertible object'}croak "Invalid $setting '" .($INC{'overload.pm'}? overload::StrVal($value): $value)."' for $into " .$error .($appended ? " $appended" : '')}1;
          ( eval { Scalar::Util::weaken($simple); 1 }
            ? do { no warnings 'void'; $get }
            : do {
              if( \$@ =~ /Modification of a read-only value attempted/) {
                require Carp;
                Carp::croak( sprintf (
                  'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                  $name_str,
                ) );
              } else {
                die \$@;
              }
            }
          )
  EOC
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;sub generate_method {my ($self,$into)=@_;quote_sub "${into}::BUILDALL" =>join('',$self->_handle_subbuild($into),qq{    my \$self = shift;\n},$self->buildall_body_for($into,'$self','@_'),qq{    return \$self\n},)=>{}=>{no_defer=>1 }}sub _handle_subbuild {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n".'      return shift->Moo::Object::BUILDALL(@_)'.";\n".'    }'."\n"}sub buildall_body_for {my ($self,$into,$me,$args)=@_;my@builds=grep *{_getglob($_)}{CODE},map "${_}::BUILD",reverse @{mro::get_linear_isa($into)};'    (('.$args.')[0]->{__no_BUILD__} or ('."\n" .join('',map qq{      ${me}->${_}(${args}),\n},@builds)."    )),\n"}1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;use Moo::_strictures;use Sub::Quote qw(quote_sub quotify);use Sub::Defer;use Moo::_Utils qw(_getstash _getglob);use Moo::_mro;use Scalar::Util qw(weaken);use Carp qw(croak);use Carp::Heavy ();BEGIN {our@CARP_NOT=qw(Sub::Defer)}BEGIN {local$Moo::sification::disabled=1;require Moo;Moo->import}sub register_attribute_specs {my ($self,@new_specs)=@_;$self->assert_constructor;my$specs=$self->{attribute_specs}||={};my$ag=$self->accessor_generator;while (my ($name,$new_spec)=splice@new_specs,0,2){if ($name =~ s/^\+//){croak "has '+${name}' given but no ${name} attribute already exists" unless my$old_spec=$specs->{$name};$ag->merge_specs($new_spec,$old_spec)}if ($new_spec->{required}&&!($ag->has_default($name,$new_spec)||!exists$new_spec->{init_arg}|| defined$new_spec->{init_arg})){croak "You cannot have a required attribute (${name})" ." without a default, builder, or an init_arg"}$new_spec->{index}=scalar keys %$specs unless defined$new_spec->{index};$specs->{$name}=$new_spec}$self}sub all_attribute_specs {$_[0]->{attribute_specs}}sub accessor_generator {$_[0]->{accessor_generator}}sub construction_string {my ($self)=@_;$self->{construction_string}||= $self->_build_construction_string}sub buildall_generator {require Method::Generate::BuildAll;Method::Generate::BuildAll->new}sub _build_construction_string {my ($self)=@_;my$builder=$self->{construction_builder};$builder ? $self->$builder : 'bless(' .$self->accessor_generator->default_construction_string .', $class);'}sub install_delayed {my ($self)=@_;$self->assert_constructor;my$package=$self->{package};my (undef,@isa)=@{mro::get_linear_isa($package)};my$isa=join ',',@isa;my (undef,$from_file,$from_line)=caller(Carp::short_error_loc());my$constructor=defer_sub "${package}::new"=>sub {my (undef,@new_isa)=@{mro::get_linear_isa($package)};if (join(',',@new_isa)ne $isa){my ($expected_new)=grep {*{_getglob($_.'::new')}{CODE}}@isa;my ($found_new)=grep {*{_getglob($_.'::new')}{CODE}}@new_isa;if (($found_new||'')ne ($expected_new||'')){$found_new ||= 'none';$expected_new ||= 'none';croak "Expected parent constructor of $package to be" ." $expected_new, but found $found_new: changing the inheritance" ." chain (\@ISA) at runtime (after $from_file line $from_line) is unsupported"}}my$constructor=$self->generate_method($package,'new',$self->{attribute_specs},{no_install=>1,no_defer=>1 });$self->{inlined}=1;weaken($self->{constructor}=$constructor);$constructor};$self->{inlined}=0;weaken($self->{constructor}=$constructor);$self}sub current_constructor {my ($self,$package)=@_;return *{_getglob("${package}::new")}{CODE}}sub assert_constructor {my ($self)=@_;my$package=$self->{package}or return 1;my$current=$self->current_constructor($package)or return 1;my$constructor=$self->{constructor}or croak "Unknown constructor for $package already exists";croak "Constructor for $package has been replaced with an unknown sub" if$constructor!=$current;croak "Constructor for $package has been inlined and cannot be updated" if$self->{inlined}}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={%{$quote_opts||{}},package=>$into,};for my$no_init (grep!exists($spec->{$_}{init_arg}),keys %$spec){$spec->{$no_init}{init_arg}=$no_init}local$self->{captures}={};my$into_buildargs=$into->can('BUILDARGS');my$body ='    my $invoker = CORE::shift();'."\n" .'    my $class = CORE::ref($invoker) ? CORE::ref($invoker) : $invoker;'."\n" .$self->_handle_subconstructor($into,$name).($into_buildargs && $into_buildargs!=\&Moo::Object::BUILDARGS ? $self->_generate_args_via_buildargs : $self->_generate_args).$self->_check_required($spec).'    my $new = '.$self->construction_string.";\n" .$self->_assign_new($spec).($into->can('BUILD')? $self->buildall_generator->buildall_body_for($into,'$new','$args'): '').'    return $new;'."\n";if ($into->can('DEMOLISH')){require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new->generate_method($into)}quote_sub "${into}::${name}"=>$body,$self->{captures},$quote_opts||{}}sub _handle_subconstructor {my ($self,$into,$name)=@_;if (my$gen=$self->{subconstructor_handler}){'    if ($class ne '.quotify($into).') {'."\n".$gen.'    }'."\n"}else {''}}sub _cap_call {my ($self,$code,$captures)=@_;@{$self->{captures}}{keys %$captures}=values %$captures if$captures;$code}sub _generate_args_via_buildargs {my ($self)=@_;q{    my $args = $class->BUILDARGS(@_);}."\n" .q{    Carp::croak("BUILDARGS did not return a hashref") unless CORE::ref($args) eq 'HASH';} ."\n"}sub _generate_args {my ($self)=@_;return <<'_EOA'}sub _assign_new {my ($self,$spec)=@_;my$ag=$self->accessor_generator;my%test;NAME: foreach my$name (sort keys %$spec){my$attr_spec=$spec->{$name};next NAME unless defined($attr_spec->{init_arg})or $ag->has_eager_default($name,$attr_spec);$test{$name}=$attr_spec->{init_arg}}join '',map {my$arg=$test{$_};my$arg_key=quotify($arg);my$test=defined$arg ? "exists \$args->{$arg_key}" : undef;my$source=defined$arg ? "\$args->{$arg_key}" : undef;my$attr_spec=$spec->{$_};$self->_cap_call($ag->generate_populate_set('$new',$_,$attr_spec,$source,$test,$arg,))}sort keys%test}sub _check_required {my ($self,$spec)=@_;my@required_init=map$spec->{$_}{init_arg},grep {my$s=$spec->{$_};$s->{required}and not($s->{builder}or exists$s->{default})}sort keys %$spec;return '' unless@required_init;'    if (my @missing = grep !exists $args->{$_}, ' .join(', ',map quotify($_),@required_init).') {'."\n" .q{      Carp::croak("Missing required arguments: ".CORE::join(', ', sort @missing));}."\n" ."    }\n"}sub new {my$class=shift;delete _getstash(__PACKAGE__)->{new};bless$class->BUILDARGS(@_),$class}Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(attribute_specs=>{is=>'ro',reader=>'all_attribute_specs',},accessor_generator=>{is=>'ro' },construction_string=>{is=>'lazy' },construction_builder=>{is=>'bare' },subconstructor_handler=>{is=>'ro' },package=>{is=>'bare' },);if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for(__PACKAGE__)}1;
      my $args = scalar @_ == 1
        ? CORE::ref $_[0] eq 'HASH'
          ? { %{ $_[0] } }
          : Carp::croak("Single parameters to new() must be a HASH ref"
              . " data => ". $_[0])
        : @_ % 2
          ? Carp::croak("The new() method for $class expects a hash reference or a"
              . " key/value list. You passed an odd number of arguments")
          : {@_}
      ;
  _EOA
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;sub generate_method {my ($self,$into)=@_;quote_sub "${into}::DEMOLISHALL",join '',$self->_handle_subdemolish($into),qq{    my \$self = shift;\n},$self->demolishall_body_for($into,'$self','@_'),qq{    return \$self\n};quote_sub "${into}::DESTROY",join '',q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Devel::GlobalDestruction;
        eval {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !}sub demolishall_body_for {my ($self,$into,$me,$args)=@_;my@demolishers=grep *{_getglob($_)}{CODE},map "${_}::DEMOLISH",@{mro::get_linear_isa($into)};join '',map qq{    ${me}->${_}(${args});\n},@demolishers}sub _handle_subdemolish {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n".'      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".'    }'."\n"}1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Module/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD';
  package Module::Build;use 5.006;use strict;use warnings;use File::Spec ();use File::Path ();use File::Basename ();use Perl::OSType ();use Module::Build::Base;our@ISA=qw(Module::Build::Base);our$VERSION='0.4229';$VERSION=eval$VERSION;sub _interpose_module {my ($self,$mod)=@_;eval "use $mod";die $@ if $@;no strict 'refs';my$top_class=$mod;while (@{"${top_class}::ISA"}){last if ${"${top_class}::ISA"}[0]eq $ISA[0];$top_class=${"${top_class}::ISA"}[0]}@{"${top_class}::ISA"}=@ISA;@ISA=($mod)}if (grep {-e File::Spec->catfile($_,qw(Module Build Platform),$^O).'.pm'}@INC){__PACKAGE__->_interpose_module("Module::Build::Platform::$^O")}elsif (my$ostype=os_type()){__PACKAGE__->_interpose_module("Module::Build::Platform::$ostype")}else {warn "Unknown OS type '$^O' - using default settings\n"}sub os_type {return Perl::OSType::os_type()}sub is_vmsish {return Perl::OSType::is_os_type('VMS')}sub is_windowsish {return Perl::OSType::is_os_type('Windows')}sub is_unixish {return Perl::OSType::is_os_type('Unix')}1;
MODULE_BUILD

$fatpacked{"Module/Build/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_BASE';
  package Module::Build::Base;use 5.006;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Carp;use Cwd ();use File::Copy ();use File::Find ();use File::Path ();use File::Basename ();use File::Spec 0.82 ();use File::Compare ();use Module::Build::Dumper ();use Text::ParseWords ();use Module::Metadata;use Module::Build::Notes;use Module::Build::Config;use version;sub new {my$self=shift()->_construct(@_);$self->{invoked_action}=$self->{action}||= 'Build_PL';$self->cull_args(@ARGV);die "Too early to specify a build action '$self->{action}'.  Do 'Build $self->{action}' instead.\n" if$self->{action}&& $self->{action}ne 'Build_PL';$self->check_manifest;$self->auto_require;if(grep {!$_}$self->check_prereq,$self->check_autofeatures){$self->log_warn(<<EOF);unless ($self->dist_name eq 'Module-Build' || $ENV{PERL5_CPANPLUS_IS_RUNNING}|| $ENV{PERL5_CPAN_IS_RUNNING}){$self->log_warn("Run 'Build installdeps' to install missing prerequisites.\n\n")}}$self->{properties}{_added_to_INC}=[$self->_added_to_INC ];$self->set_bundle_inc;$self->dist_name;$self->dist_version;$self->release_status;$self->_guess_module_name unless$self->module_name;$self->_find_nested_builds;return$self}sub resume {my$package=shift;my$self=$package->_construct(@_);$self->read_config;my@added_earlier=@{$self->{properties}{_added_to_INC}|| []};@INC=($self->_added_to_INC,@added_earlier,$self->_default_INC);unless ($package->isa($self->build_class)){my$build_class=$self->build_class;my$config_dir=$self->config_dir || '_build';my$build_lib=File::Spec->catdir($config_dir,'lib');unshift(@INC,$build_lib);unless ($build_class->can('new')){eval "require $build_class; 1" or die "Failed to re-load '$build_class': $@"}return$build_class->resume(@_)}unless ($self->_perl_is_same($self->{properties}{perl})){my$perl=$self->find_perl_interpreter;die(<<"DIEFATAL")}$self->cull_args(@ARGV);unless ($self->allow_mb_mismatch){my$mb_version=$Module::Build::VERSION;if ($mb_version ne $self->{properties}{mb_version}){$self->log_warn(<<"MISMATCH")}}$self->{invoked_action}=$self->{action}||= 'build';return$self}sub new_from_context {my ($package,%args)=@_;$package->run_perl_script('Build.PL',[],[$package->unparse_args(\%args)]);return$package->resume}sub current {local@ARGV;return shift()->resume}sub _construct {my ($package,%input)=@_;my$args=delete$input{args}|| {};my$config=delete$input{config}|| {};my$self=bless {args=>{%$args},config=>Module::Build::Config->new(values=>$config),properties=>{base_dir=>$package->cwd,mb_version=>$Module::Build::VERSION,%input,},phash=>{},stash=>{},},$package;$self->_set_defaults;my ($p,$ph)=($self->{properties},$self->{phash});for (qw(notes config_data features runtime_params cleanup auto_features)){my$file=File::Spec->catfile($self->config_dir,$_);$ph->{$_}=Module::Build::Notes->new(file=>$file);$ph->{$_}->restore if -e $file;if (exists$p->{$_}){my$vals=delete$p->{$_};for my$k (sort keys %$vals){$self->$_($k,$vals->{$k})}}}$p->{perl}=$self->find_perl_interpreter or $self->log_warn("Warning: Can't locate your perl binary");my$blibdir=sub {File::Spec->catdir($p->{blib},@_)};$p->{bindoc_dirs}||= [$blibdir->("script")];$p->{libdoc_dirs}||= [$blibdir->("lib"),$blibdir->("arch")];$p->{dist_author}=[$p->{dist_author}]if defined$p->{dist_author}and not ref$p->{dist_author};$p->{requires}=delete$p->{prereq}if defined$p->{prereq};$p->{script_files}=delete$p->{scripts}if defined$p->{scripts};for ('extra_compiler_flags','extra_linker_flags'){$p->{$_}=[$self->split_like_shell($p->{$_})]if exists$p->{$_}}for ('include_dirs'){$p->{$_}=[$p->{$_}]if exists$p->{$_}&&!ref$p->{$_}}$self->add_to_cleanup(@{delete$p->{add_to_cleanup}})if$p->{add_to_cleanup};return$self}sub log_info {my$self=shift;print @_ if ref($self)&& ($self->verbose ||!$self->quiet)}sub log_verbose {my$self=shift;print @_ if ref($self)&& $self->verbose}sub log_debug {my$self=shift;print @_ if ref($self)&& $self->debug}sub log_warn {shift;if (@_ and $_[-1]!~ /\n$/){my (undef,$file,$line)=caller();warn @_," at $file line $line.\n"}else {warn @_}}sub _default_install_paths {my$self=shift;my$c=$self->{config};my$p={};my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');my$bindoc=$c->get('installman1dir')|| undef;my$libdoc=$c->get('installman3dir')|| undef;my$binhtml=$c->get('installhtml1dir')|| $c->get('installhtmldir')|| undef;my$libhtml=$c->get('installhtml3dir')|| $c->get('installhtmldir')|| undef;$p->{install_sets}={core=>{lib=>$c->get('installprivlib'),arch=>$c->get('installarchlib'),bin=>$c->get('installbin'),script=>$c->get('installscript'),bindoc=>$bindoc,libdoc=>$libdoc,binhtml=>$binhtml,libhtml=>$libhtml,},site=>{lib=>$c->get('installsitelib'),arch=>$c->get('installsitearch'),bin=>$c->get('installsitebin')|| $c->get('installbin'),script=>$c->get('installsitescript')|| $c->get('installsitebin')|| $c->get('installscript'),bindoc=>$c->get('installsiteman1dir')|| $bindoc,libdoc=>$c->get('installsiteman3dir')|| $libdoc,binhtml=>$c->get('installsitehtml1dir')|| $binhtml,libhtml=>$c->get('installsitehtml3dir')|| $libhtml,},vendor=>{lib=>$c->get('installvendorlib'),arch=>$c->get('installvendorarch'),bin=>$c->get('installvendorbin')|| $c->get('installbin'),script=>$c->get('installvendorscript')|| $c->get('installvendorbin')|| $c->get('installscript'),bindoc=>$c->get('installvendorman1dir')|| $bindoc,libdoc=>$c->get('installvendorman3dir')|| $libdoc,binhtml=>$c->get('installvendorhtml1dir')|| $binhtml,libhtml=>$c->get('installvendorhtml3dir')|| $libhtml,},};$p->{original_prefix}={core=>$c->get('installprefixexp')|| $c->get('installprefix')|| $c->get('prefixexp')|| $c->get('prefix')|| '',site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',};$p->{original_prefix}{site}||= $p->{original_prefix}{core};$p->{install_base_relpaths}={lib=>['lib','perl5'],arch=>['lib','perl5',$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],};$p->{prefix_relpaths}={core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},};return$p}sub _find_nested_builds {my$self=shift;my$r=$self->recurse_into or return;my ($file,@r);if (!ref($r)&& $r eq 'auto'){local*DH;opendir DH,$self->base_dir or die "Can't scan directory " .$self->base_dir ." for nested builds: $!";while (defined($file=readdir DH)){my$subdir=File::Spec->catdir($self->base_dir,$file);next unless -d $subdir;push@r,$subdir if -e File::Spec->catfile($subdir,'Build.PL')}}$self->recurse_into(\@r)}sub cwd {return Cwd::cwd()}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;\\|'"\[\]\{\}]+$/){push@quoted,$_}else {s/('+)/'"$1"'/g;push@quoted,qq('$_')}}return join " ",@quoted}sub _backticks {my ($self,@cmd)=@_;if ($self->have_forkpipe){local*FH;my$pid=open*FH,"-|";if ($pid){return wantarray ? <FH> : join '',<FH>}else {die "Can't execute @cmd: $!\n" unless defined$pid;exec {$cmd[0]}@cmd}}else {my$cmd=$self->_quote_args(@cmd);return `$cmd`}}sub have_forkpipe {1}sub _perl_is_same {my ($self,$perl)=@_;my@cmd=($perl);if ($ENV{PERL_CORE}){push@cmd,'-I' .File::Spec->catdir(File::Basename::dirname($perl),'lib')}push@cmd,qw(-MConfig=myconfig -e print -e myconfig);return$self->_backticks(@cmd)eq Config->myconfig}{my$known_perl;sub find_perl_interpreter {my$self=shift;return$known_perl if defined($known_perl);return$known_perl=$self->_discover_perl_interpreter}}sub _discover_perl_interpreter {my$proto=shift;my$c=ref($proto)? $proto->{config}: 'Module::Build::Config';my$perl=$^X;my$perl_basename=File::Basename::basename($perl);my@potential_perls;push(@potential_perls,$perl)if File::Spec->file_name_is_absolute($perl);my$abs_perl=File::Spec->rel2abs($perl);push(@potential_perls,$abs_perl);if ($ENV{PERL_CORE}){require ExtUtils::CBuilder;my$perl_src=Cwd::realpath(ExtUtils::CBuilder->perl_src);if (defined($perl_src)&& length($perl_src)){my$uninstperl=File::Spec->rel2abs(File::Spec->catfile($perl_src,$perl_basename));push(@potential_perls,$uninstperl)}}else {push(@potential_perls,$c->get('perlpath'));push(@potential_perls,map File::Spec->catfile($_,$perl_basename),File::Spec->path())}my$exe=$c->get('exe_ext');for my$thisperl (@potential_perls){if (defined$exe){$thisperl .= $exe unless$thisperl =~ m/$exe$/i}if (-f $thisperl && $proto->_perl_is_same($thisperl)){return$thisperl}}my@paths=map File::Basename::dirname($_),@potential_perls;die "Can't locate the perl binary used to run this script " ."in (@paths)\n"}sub find_command {my ($self,$command)=@_;if(File::Spec->file_name_is_absolute($command)){return$self->_maybe_command($command)}else {for my$dir (File::Spec->path){my$abs=File::Spec->catfile($dir,$command);return$abs if$abs=$self->_maybe_command($abs)}}}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d $file;return}sub _is_interactive {return -t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT))}sub _is_unattended {my$self=shift;return$ENV{PERL_MM_USE_DEFAULT}|| (!$self->_is_interactive && eof STDIN)}sub _readline {my$self=shift;return undef if$self->_is_unattended;my$answer=<STDIN>;chomp$answer if defined$answer;return$answer}sub prompt {my$self=shift;my$mess=shift or die "prompt() called without a prompt message";my@def;@def=(shift)if @_;my@dispdef=scalar(@def)? ('[',(defined($def[0])? $def[0].' ' : ''),']'): (' ','');local $|=1;print "$mess ",@dispdef;if ($self->_is_unattended &&!@def){die <<EOF}my$ans=$self->_readline();if (!defined($ans)or!length($ans)){print "$dispdef[1]\n";$ans=scalar(@def)? $def[0]: ''}return$ans}sub y_n {my$self=shift;my ($mess,$def)=@_;die "y_n() called without a prompt message" unless$mess;die "Invalid default value: y_n() default must be 'y' or 'n'" if$def && $def !~ /^[yn]/i;my$answer;while (1){$answer=$self->prompt(@_);return 1 if$answer =~ /^y/i;return 0 if$answer =~ /^n/i;local $|=1;print "Please answer 'y' or 'n'.\n"}}sub current_action {shift->{action}}sub invoked_action {shift->{invoked_action}}sub notes {shift()->{phash}{notes}->access(@_)}sub config_data {shift()->{phash}{config_data}->access(@_)}sub runtime_params {shift->{phash}{runtime_params}->read(@_ ? shift : ())}sub auto_features {shift()->{phash}{auto_features}->access(@_)}sub features {my$self=shift;my$ph=$self->{phash};if (@_){my$key=shift;if ($ph->{features}->exists($key)){return$ph->{features}->access($key,@_)}if (my$info=$ph->{auto_features}->access($key)){my$disabled;for my$type (@{$self->prereq_action_types}){next if$type eq 'description' || $type eq 'recommends' ||!exists$info->{$type};my$prereqs=$info->{$type};for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}return$ph->{features}->access($key,@_)}my%features;my%auto_features=$ph->{auto_features}->access();while (my ($name,$info)=each%auto_features){my$failures=$self->prereq_failures($info);my$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$features{$name}=$disabled ? 0 : 1}%features=(%features,$ph->{features}->access());return wantarray ? %features : \%features}BEGIN {*feature=\&features}sub _mb_feature {my$self=shift;if (($self->module_name || '')eq 'Module::Build'){return$self->feature(@_)}else {require Module::Build::ConfigData;return Module::Build::ConfigData->feature(@_)}}sub _warn_mb_feature_deps {my$self=shift;my$name=shift;$self->log_warn("The '$name' feature is not available.  Please install missing\n" ."feature dependencies and try again.\n".$self->_feature_deps_msg($name)."\n")}sub add_build_element {my ($self,$elem)=@_;my$elems=$self->build_elements;push @$elems,$elem unless grep {$_ eq $elem}@$elems}sub ACTION_config_data {my$self=shift;return unless$self->has_config_data;my$module_name=$self->module_name or die "The config_data feature requires that 'module_name' be set";my$notes_name=$module_name .'::ConfigData';my$notes_pm=File::Spec->catfile($self->blib,'lib',split /::/,"$notes_name.pm");return if$self->up_to_date(['Build.PL',$self->config_file('config_data'),$self->config_file('features')],$notes_pm);$self->log_verbose("Writing config notes to $notes_pm\n");File::Path::mkpath(File::Basename::dirname($notes_pm));Module::Build::Notes->write_config_data (file=>$notes_pm,module=>$module_name,config_module=>$notes_name,config_data=>scalar$self->config_data,feature=>scalar$self->{phash}{features}->access(),auto_features=>scalar$self->auto_features,)}{my%valid_properties=(__PACKAGE__,{});my%additive_properties;sub _mb_classes {my$class=ref($_[0])|| $_[0];return ($class,$class->mb_parents)}sub valid_property {my ($class,$prop)=@_;return grep exists($valid_properties{$_}{$prop}),$class->_mb_classes}sub valid_properties {return keys %{shift->valid_properties_defaults()}}sub valid_properties_defaults {my%out;for my$class (reverse shift->_mb_classes){@out{keys %{$valid_properties{$class}}}=map {$_->()}values %{$valid_properties{$class}}}return \%out}sub array_properties {map {exists$additive_properties{$_}->{ARRAY}? @{$additive_properties{$_}->{ARRAY}}: ()}shift->_mb_classes}sub hash_properties {map {exists$additive_properties{$_}->{HASH}? @{$additive_properties{$_}->{HASH}}: ()}shift->_mb_classes}sub add_property {my ($class,$property)=(shift,shift);die "Property '$property' already exists" if$class->valid_property($property);my%p=@_==1 ? (default=>shift): @_;my$type=ref$p{default};$valid_properties{$class}{$property}=$type eq 'CODE' ? $p{default}: $type eq 'HASH' ? sub {return {%{$p{default}}}}: $type eq 'ARRAY'? sub {return [@{$p{default}}]}: sub {return$p{default}};push @{$additive_properties{$class}->{$type}},$property if$type;unless ($class->can($property)){my$sub=$type eq 'HASH' ? _make_hash_accessor($property,\%p): _make_accessor($property,\%p);no strict 'refs';*{"$class\::$property"}=$sub}return$class}sub property_error {my$self=shift;die 'ERROR: ',@_}sub _set_defaults {my$self=shift;$self->{properties}{build_class}||= ref$self;$self->{properties}{orig_dir}||= $self->{properties}{base_dir};my$defaults=$self->valid_properties_defaults;for my$prop (keys %$defaults){$self->{properties}{$prop}=$defaults->{$prop}unless exists$self->{properties}{$prop}}for my$prop ($self->array_properties){$self->{properties}{$prop}=[@{$defaults->{$prop}}]unless exists$self->{properties}{$prop}}for my$prop ($self->hash_properties){$self->{properties}{$prop}={%{$defaults->{$prop}}}unless exists$self->{properties}{$prop}}}}sub _make_hash_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;my$prop=$x->{$property};if (defined $_[0]&&!ref $_[0]){if (@_==1){return exists$prop->{$_[0]}? $prop->{$_[0]}: undef}elsif (@_ % 2==0){my%new=(%{$prop},@_);local $_=\%new;$x->{$property}=\%new if$check->($self);return$x->{$property}}else {die "Unexpected arguments for property '$property'\n"}}else {die "Unexpected arguments for property '$property'\n" if defined $_[0]&& ref $_[0]ne 'HASH';local $_=$_[0];$x->{$property}=shift if$check->($self)}}}sub _make_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;local $_=$_[0];$x->{$property}=shift if$check->($self);return$x->{$property}}}__PACKAGE__->add_property(auto_configure_requires=>1);__PACKAGE__->add_property(blib=>'blib');__PACKAGE__->add_property(build_class=>'Module::Build');__PACKAGE__->add_property(build_elements=>[qw(PL support pm xs share_dir pod script)]);__PACKAGE__->add_property(build_script=>'Build');__PACKAGE__->add_property(build_bat=>0);__PACKAGE__->add_property(bundle_inc=>[]);__PACKAGE__->add_property(bundle_inc_preload=>[]);__PACKAGE__->add_property(config_dir=>'_build');__PACKAGE__->add_property(dynamic_config=>1);__PACKAGE__->add_property(include_dirs=>[]);__PACKAGE__->add_property(license=>'unknown');__PACKAGE__->add_property(metafile=>'META.yml');__PACKAGE__->add_property(mymetafile=>'MYMETA.yml');__PACKAGE__->add_property(metafile2=>'META.json');__PACKAGE__->add_property(mymetafile2=>'MYMETA.json');__PACKAGE__->add_property(recurse_into=>[]);__PACKAGE__->add_property(use_rcfile=>1);__PACKAGE__->add_property(create_packlist=>1);__PACKAGE__->add_property(allow_mb_mismatch=>0);__PACKAGE__->add_property(config=>undef);__PACKAGE__->add_property(test_file_exts=>['.t']);__PACKAGE__->add_property(use_tap_harness=>0);__PACKAGE__->add_property(cpan_client=>'cpan');__PACKAGE__->add_property(tap_harness_args=>{});__PACKAGE__->add_property(pureperl_only=>0);__PACKAGE__->add_property(allow_pureperl=>0);__PACKAGE__->add_property('installdirs',default=>'site',check=>sub {return 1 if /^(core|site|vendor)$/;return shift->property_error($_ eq 'perl' ? 'Perhaps you meant installdirs to be "core" rather than "perl"?' : 'installdirs must be one of "core", "site", or "vendor"');return shift->property_error("Perhaps you meant 'core'?")if $_ eq 'perl';return 0},);{__PACKAGE__->add_property(html_css=>'')}{my@prereq_action_types=qw(requires build_requires test_requires conflicts recommends);for my$type (@prereq_action_types){__PACKAGE__->add_property($type=>{})}__PACKAGE__->add_property(prereq_action_types=>\@prereq_action_types)}__PACKAGE__->add_property($_=>{})for qw(get_options install_base_relpaths install_path install_sets meta_add meta_merge original_prefix prefix_relpaths configure_requires);__PACKAGE__->add_property($_)for qw(PL_files autosplit base_dir bindoc_dirs c_source cover create_license create_makefile_pl create_readme debugger destdir dist_abstract dist_author dist_name dist_suffix dist_version dist_version_from extra_compiler_flags extra_linker_flags has_config_data install_base libdoc_dirs magic_number mb_version module_name needs_compiler orig_dir perl pm_files pod_files pollute prefix program_name quiet recursive_test_files release_status script_files scripts share_dir sign test_files verbose debug xs_files extra_manify_args);sub config {my$self=shift;my$c=ref($self)? $self->{config}: 'Module::Build::Config';return$c->all_config unless @_;my$key=shift;return$c->get($key)unless @_;my$val=shift;return$c->set($key=>$val)}sub mb_parents {my@in_stack=(shift);my%seen=($in_stack[0]=>1);my ($current,@out);while (@in_stack){next unless defined($current=shift@in_stack)&& $current->isa('Module::Build::Base');push@out,$current;next if$current eq 'Module::Build::Base';no strict 'refs';unshift@in_stack,map {my$c=$_;substr($c,0,2)="main::" if substr($c,0,2)eq '::';$seen{$c}++ ? (): $c}@{"$current\::ISA"}}shift@out;return@out}sub extra_linker_flags {shift->_list_accessor('extra_linker_flags',@_)}sub extra_compiler_flags {shift->_list_accessor('extra_compiler_flags',@_)}sub _list_accessor {(my$self,local $_)=(shift,shift);my$p=$self->{properties};$p->{$_}=[@_]if @_;$p->{$_}=[]unless exists$p->{$_};return ref($p->{$_})? $p->{$_}: [$p->{$_}]}sub subclass {my ($pack,%opts)=@_;my$build_dir='_build';$pack->delete_filetree($build_dir)if -e $build_dir;die "Must provide 'code' or 'class' option to subclass()\n" unless$opts{code}or $opts{class};$opts{code}||= '';$opts{class}||= 'MyModuleBuilder';my$filename=File::Spec->catfile($build_dir,'lib',split '::',$opts{class}).'.pm';my$filedir=File::Basename::dirname($filename);$pack->log_verbose("Creating custom builder $filename in $filedir\n");File::Path::mkpath($filedir);die "Can't create directory $filedir: $!" unless -d $filedir;open(my$fh,'>',$filename)or die "Can't create $filename: $!";print$fh <<EOF;close$fh;unshift@INC,File::Spec->catdir(File::Spec->rel2abs($build_dir),'lib');eval "use $opts{class}";die $@ if $@;return$opts{class}}sub _guess_module_name {my$self=shift;my$p=$self->{properties};return if$p->{module_name};if ($p->{dist_version_from}&& -e $p->{dist_version_from}){my$mi=Module::Metadata->new_from_file($self->dist_version_from);$p->{module_name}=$mi->name}else {my$mod_path=my$mod_name=$p->{dist_name};$mod_name =~ s{-}{::}g;$mod_path =~ s{-}{/}g;$mod_path .= ".pm";if (-e $mod_path || -e "lib/$mod_path"){$p->{module_name}=$mod_name}else {$self->log_warn(<< 'END_WARN')}}}sub dist_name {my$self=shift;my$p=$self->{properties};my$me='dist_name';return$p->{$me}if defined$p->{$me};die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter" unless$self->module_name;($p->{$me}=$self->module_name)=~ s/::/-/g;return$p->{$me}}sub release_status {my ($self)=@_;my$me='release_status';my$p=$self->{properties};if (!defined$p->{$me}){$p->{$me}=$self->_is_dev_version ? 'testing' : 'stable'}unless ($p->{$me}=~ qr/\A(?:stable|testing|unstable)\z/){die "Illegal value '$p->{$me}' for $me\n"}if ($p->{$me}eq 'stable' && $self->_is_dev_version){my$version=$self->dist_version;die "Illegal value '$p->{$me}' with version '$version'\n"}return$p->{$me}}sub dist_suffix {my ($self)=@_;my$p=$self->{properties};my$me='dist_suffix';return$p->{$me}if defined$p->{$me};if ($self->release_status eq 'stable'){$p->{$me}=""}else {$p->{$me}=$self->_is_dev_version ? "" : "TRIAL" }return$p->{$me}}sub dist_version_from {my ($self)=@_;my$p=$self->{properties};my$me='dist_version_from';if ($self->module_name){$p->{$me}||= join('/','lib',split(/::/,$self->module_name)).'.pm'}return$p->{$me}|| undef}sub dist_version {my ($self)=@_;my$p=$self->{properties};my$me='dist_version';return$p->{$me}if defined$p->{$me};if (my$dist_version_from=$self->dist_version_from){my$version_from=File::Spec->catfile(split(qr{/},$dist_version_from));my$pm_info=Module::Metadata->new_from_file($version_from)or die "Can't find file $version_from to determine version";$p->{$me}=$self->normalize_version($pm_info->version());unless (defined$p->{$me}){die "Can't determine distribution version from $version_from"}}die ("Can't determine distribution version, must supply either 'dist_version',\n"."'dist_version_from', or 'module_name' parameter")unless defined$p->{$me};return$p->{$me}}sub _is_dev_version {my ($self)=@_;my$dist_version=$self->dist_version;my$version_obj=eval {version->new($dist_version)};return $@ ? 0 : $version_obj->is_alpha}sub dist_author {shift->_pod_parse('author')}sub dist_abstract {shift->_pod_parse('abstract')}sub _pod_parse {my ($self,$part)=@_;my$p=$self->{properties};my$member="dist_$part";return$p->{$member}if defined$p->{$member};my$docfile=$self->_main_docfile or return;open(my$fh,'<',$docfile)or return;require Module::Build::PodParser;my$parser=Module::Build::PodParser->new(fh=>$fh);my$method="get_$part";return$p->{$member}=$parser->$method()}sub version_from_file {return Module::Metadata->new_from_file($_[1])->version()}sub find_module_by_name {return Module::Metadata->find_module_by_name(@_[1,2])}{my%unlink_list_for_pid;sub _unlink_on_exit {my$self=shift;for my$f (@_){push @{$unlink_list_for_pid{$$}},$f if -f $f}return 1}END {for my$f (map glob($_),@{$unlink_list_for_pid{$$}|| []}){next unless -e $f;File::Path::rmtree($f,0,0)}}}sub add_to_cleanup {my$self=shift;my%files=map {$self->localize_file_path($_),1}@_;$self->{phash}{cleanup}->write(\%files)}sub cleanup {my$self=shift;my$all=$self->{phash}{cleanup}->read;return wantarray ? sort keys %$all : keys %$all}sub config_file {my$self=shift;return unless -d $self->config_dir;return File::Spec->catfile($self->config_dir,@_)}sub read_config {my ($self)=@_;my$file=$self->config_file('build_params')or die "Can't find 'build_params' in " .$self->config_dir;open(my$fh,'<',$file)or die "Can't read '$file': $!";my$ref=eval do {local $/;<$fh>};die if $@;close$fh;my$c;($self->{args},$c,$self->{properties})=@$ref;$self->{config}=Module::Build::Config->new(values=>$c)}sub has_config_data {my$self=shift;return scalar grep$self->{phash}{$_}->has_data(),qw(config_data features auto_features)}sub _write_data {my ($self,$filename,$data)=@_;my$file=$self->config_file($filename);open(my$fh,'>',$file)or die "Can't create '$file': $!";unless (ref($data)){print$fh $data;return}print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}sub write_config {my ($self)=@_;File::Path::mkpath($self->{properties}{config_dir});-d $self->{properties}{config_dir}or die "Can't mkdir $self->{properties}{config_dir}: $!";my@items=@{$self->prereq_action_types};$self->_write_data('prereqs',{map {$_,$self->$_()}@items });$self->_write_data('build_params',[$self->{args},$self->{config}->values_set,$self->{properties}]);$self->_write_data('magicnum',$self->magic_number(int rand 1_000_000));$self->{phash}{$_}->write()foreach qw(notes cleanup features auto_features config_data runtime_params)}{my%packlist_map=('^File::Spec'=>'Cwd','^Devel::AssertOS'=>'Devel::CheckOS',);sub _find_packlist {my ($self,$inst,$mod)=@_;my$lookup=$mod;my$packlist=eval {$inst->packlist($lookup)};if (!$packlist){while (my ($re,$new_mod)=each%packlist_map){if ($mod =~ qr/$re/){$lookup=$new_mod;$packlist=eval {$inst->packlist($lookup)};last}}}return$packlist ? $lookup : undef}sub set_bundle_inc {my$self=shift;my$bundle_inc=$self->{properties}{bundle_inc};my$bundle_inc_preload=$self->{properties}{bundle_inc_preload};return unless inc::latest->can('loaded_modules');require ExtUtils::Installed;my$inst=eval {ExtUtils::Installed->new(extra_libs=>[@INC])};if ($@){$self->log_warn(<< "EUI_ERROR");return}my@bundle_list=map {[$_,0 ]}inc::latest->loaded_modules;while(@bundle_list){my ($mod,$prereq)=@{shift@bundle_list};my$lookup=$self->_find_packlist($inst,$mod);if (!$lookup){die << "NO_PACKLIST"}else {push @{$prereq ? $bundle_inc_preload : $bundle_inc},$lookup}}}}sub check_autofeatures {my ($self)=@_;my$features=$self->auto_features;return 1 unless %$features;my$longest=sub {my@str=@_ or croak("no strings given");my@len=map({length($_)}@str);my$max=0;my$longest;for my$i (0..$#len){($max,$longest)=($len[$i],$str[$i])if($len[$i]> $max)}return($longest)};my$max_name_len=length($longest->(keys %$features));my ($num_disabled,$log_text)=(0,"\nChecking optional features...\n");for my$name (sort keys %$features){$log_text .= $self->_feature_deps_msg($name,$max_name_len)}$num_disabled=()=$log_text =~ /disabled/g;if ($num_disabled){$self->log_warn($log_text);return 0}else {$self->log_verbose($log_text);return 1}}sub _feature_deps_msg {my ($self,$name,$max_name_len)=@_;$max_name_len ||= length$name;my$features=$self->auto_features;my$info=$features->{$name};my$feature_text="$name" .'.' x ($max_name_len - length($name)+ 4);my ($log_text,$disabled)=('','');if (my$failures=$self->prereq_failures($info)){$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$feature_text .= $disabled ? "disabled\n" : "enabled\n";for my$type (@{$self->prereq_action_types}){next unless exists$failures->{$type};$feature_text .= "  $type:\n";my$prereqs=$failures->{$type};for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$required=($type =~ /^(?:\w+_)?(?:requires|conflicts)$/)? 1 : 0;my$prefix=($required)? '!' : '*';$feature_text .= "    $prefix $status->{message}\n"}}}else {$feature_text .= "enabled\n"}$log_text .= $feature_text if$disabled || $self->verbose;return$log_text}sub auto_config_requires {my ($self)=@_;my$p=$self->{properties};if ($self->dist_name ne 'Module-Build' && $self->auto_configure_requires &&!exists$p->{configure_requires}{'Module::Build'}){(my$ver=$VERSION)=~ s/^(\d+\.\d\d).*$/$1/;$self->log_warn(<<EOM);$self->_add_prereq('configure_requires','Module::Build',$ver)}if (inc::latest->can('loaded_module')){for my$mod (inc::latest->loaded_modules){next if exists$p->{configure_requires}{$mod};$self->_add_prereq('configure_requires',$mod,$mod->VERSION)}}return}sub auto_require {my ($self)=@_;my$p=$self->{properties};my$xs_files=$self->find_xs_files;if (!defined$p->{needs_compiler}){if ($self->pureperl_only && $self->allow_pureperl){$self->needs_compiler(0)}else {$self->needs_compiler(keys %$xs_files || defined$self->c_source)}}if ($self->needs_compiler){$self->_add_prereq('build_requires','ExtUtils::CBuilder',0);if (!$self->have_c_compiler){$self->log_warn(<<'EOM')}}if ($self->share_dir){$self->_add_prereq('requires','File::ShareDir','1.00')}return}sub _add_prereq {my ($self,$type,$module,$version)=@_;my$p=$self->{properties};$version=0 unless defined$version;if (exists$p->{$type}{$module}){return if$self->compare_versions($version,'<=',$p->{$type}{$module})}$self->log_verbose("Adding to $type\: $module => $version\n");$p->{$type}{$module}=$version;return 1}sub prereq_failures {my ($self,$info)=@_;my@types=@{$self->prereq_action_types};$info ||= {map {$_,$self->$_()}@types};my$out;for my$type (@types){my$prereqs=$info->{$type};for my$modname (keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ($type =~ /^(?:\w+_)?conflicts$/){next if!$status->{ok};$status->{conflicts}=delete$status->{need};$status->{message}="$modname ($status->{have}) conflicts with this distribution"}elsif ($type =~ /^(?:\w+_)?recommends$/){next if$status->{ok};$status->{message}=(!ref($status->{have})&& $status->{have}eq '<none>' ? "$modname is not installed" : "$modname ($status->{have}) is installed, but we prefer to have $spec")}else {next if$status->{ok}}$out->{$type}{$modname}=$status}}return$out}sub _enum_prereqs {my$self=shift;my%prereqs;for my$type (@{$self->prereq_action_types}){if ($self->can($type)){my$prereq=$self->$type()|| {};$prereqs{$type}=$prereq if %$prereq}}return \%prereqs}sub check_prereq {my$self=shift;my$info=$self->_enum_prereqs;return 1 unless$info;my$log_text="Checking prerequisites...\n";my$failures=$self->prereq_failures($info);if ($failures){$self->log_warn($log_text);for my$type (@{$self->prereq_action_types}){my$prereqs=$failures->{$type};$self->log_warn("  ${type}:\n")if keys %$prereqs;for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$prefix=($type =~ /^(?:\w+_)?recommends$/)? "* " : "! ";$self->log_warn("    $prefix $status->{message}\n")}}return 0}else {$self->log_verbose($log_text ."Looks good\n\n");return 1}}sub perl_version {my ($self)=@_;return $^V ? $self->perl_version_to_float(sprintf "%vd",$^V): $]}sub perl_version_to_float {my ($self,$version)=@_;return$version if grep(/\./,$version)< 2;$version =~ s/\./../;$version =~ s/\.(\d+)/sprintf '%03d', $1/eg;return$version}sub _parse_conditions {my ($self,$spec)=@_;return ">= 0" if not defined$spec;if ($spec =~ /^\s*([\w.]+)\s*$/){return (">= $spec")}else {return split /\s*,\s*/,$spec}}sub try_require {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,defined($spec)? $spec : 0);return unless$status->{ok};my$path=$modname;$path =~ s{::}{/}g;$path .= ".pm";if (defined$INC{$path}){return 1}elsif (exists$INC{$path}){return}else {return eval "require $modname"}}sub check_installed_status {my ($self,$modname,$spec)=@_;my%status=(need=>$spec);if ($modname eq 'perl'){$status{have}=$self->perl_version}elsif (eval {no strict;$status{have}=${"${modname}::VERSION"}}){}else {my$pm_info=Module::Metadata->new_from_module($modname);unless (defined($pm_info)){@status{qw(have message) }=('<none>',"$modname is not installed");return \%status}$status{have}=eval {$pm_info->version()};if ($spec and!defined($status{have})){@status{qw(have message) }=(undef,"Couldn't find a \$VERSION in prerequisite $modname");return \%status}}my@conditions=$self->_parse_conditions($spec);for (@conditions){my ($op,$version)=/^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x or die "Invalid prerequisite condition '$_' for $modname";$version=$self->perl_version_to_float($version)if$modname eq 'perl';next if$op eq '>=' and!$version;unless ($self->compare_versions($status{have},$op,$version)){$status{message}="$modname ($status{have}) is installed, but we need version $op $version";return \%status}}$status{ok}=1;return \%status}sub compare_versions {my$self=shift;my ($v1,$op,$v2)=@_;$v1=version->new($v1)unless eval {$v1->isa('version')};my$eval_str="\$v1 $op \$v2";my$result=eval$eval_str;$self->log_warn("error comparing versions: '$eval_str' $@")if $@;return$result}sub check_installed_version {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,$spec);if ($status->{ok}){return$status->{have}if$status->{have}and "$status->{have}" ne '<none>';return '0 but true'}$@=$status->{message};return 0}sub make_executable {my$self=shift;for (@_){my$current_mode=(stat $_)[2];chmod$current_mode | oct(111),$_}}sub is_executable {my ($self,$file)=@_;return -x $file}sub _startperl {shift()->config('startperl')}sub _added_to_INC {my$self=shift;my%seen;$seen{$_}++ foreach$self->_default_INC;return grep!$seen{$_}++,@INC}{my@default_inc;sub _default_INC {my$self=shift;return@default_inc if@default_inc;local$ENV{PERL5LIB};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;my@inc=$self->_backticks($perl,'-le','print for @INC');chomp@inc;return@default_inc=@inc}}sub print_build_script {my ($self,$fh)=@_;my$build_package=$self->build_class;my$closedata="";my$config_requires;if (-f $self->metafile){my$meta=eval {$self->read_metafile($self->metafile)};$config_requires=$meta && $meta->{prereqs}{configure}{requires}{'Module::Build'}}$config_requires ||= 0;my%q=map {$_,$self->$_()}qw(config_dir base_dir);$q{base_dir}=Win32::GetShortPathName($q{base_dir})if$self->is_windowsish;$q{magic_numfile}=$self->config_file('magicnum');my@myINC=$self->_added_to_INC;for (@myINC,values%q){$_=File::Spec->canonpath($_)unless$self->is_vmsish;s/([\\\'])/\\$1/g}my$quoted_INC=join ",\n",map "     '$_'",@myINC;my$shebang=$self->_startperl;my$magic_number=$self->magic_number;my$dot_in_inc_code=$INC[-1]eq '.' ? <<'END' : '';print$fh <<EOF}sub create_mymeta {my ($self)=@_;my ($meta_obj,$mymeta);my@metafiles=($self->metafile2,$self->metafile,);my@mymetafiles=($self->mymetafile2,$self->mymetafile,);for my$f (@mymetafiles){if ($self->delete_filetree($f)){$self->log_verbose("Removed previous '$f'\n")}}if ($self->try_require("CPAN::Meta","2.142060")){for my$file (@metafiles){next unless -f $file;$meta_obj=eval {CPAN::Meta->load_file($file,{lazy_validation=>0 })};last if$meta_obj}}my$mymeta_obj;if ($meta_obj){my%updated=(%{$meta_obj->as_struct({version=>2.0 })},prereqs=>$self->_normalize_prereqs,dynamic_config=>0,generated_by=>"Module::Build version $Module::Build::VERSION",);$mymeta_obj=CPAN::Meta->new(\%updated,{lazy_validation=>0 })}else {$mymeta_obj=$self->_get_meta_object(quiet=>0,dynamic=>0,fatal=>1,auto=>0)}my@created=$self->_write_meta_files($mymeta_obj,'MYMETA');$self->log_warn("Could not create MYMETA files\n")unless@created;return 1}sub create_build_script {my ($self)=@_;$self->write_config;$self->create_mymeta;my ($build_script,$dist_name,$dist_version)=map$self->$_(),qw(build_script dist_name dist_version);if ($self->delete_filetree($build_script)){$self->log_verbose("Removed previous script '$build_script'\n")}$self->log_info("Creating new '$build_script' script for ","'$dist_name' version '$dist_version'\n");open(my$fh,'>',$build_script)or die "Can't create '$build_script': $!";$self->print_build_script($fh);close$fh;$self->make_executable($build_script);return 1}sub check_manifest {my$self=shift;return unless -e 'MANIFEST';require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);$self->log_verbose("Checking whether your kit is complete...\n");if (my@missed=ExtUtils::Manifest::manicheck()){$self->log_warn("WARNING: the following files are missing in your kit:\n","\t",join("\n\t",@missed),"\n","Please inform the author.\n\n")}else {$self->log_verbose("Looks good\n\n")}}sub dispatch {my$self=shift;local$self->{_completed_actions}={};if (@_){my ($action,%p)=@_;my$args=$p{args}? delete($p{args}): {};local$self->{invoked_action}=$action;local$self->{args}={%{$self->{args}},%$args};local$self->{properties}={%{$self->{properties}},%p};return$self->_call_action($action)}die "No build action specified" unless$self->{action};local$self->{invoked_action}=$self->{action};$self->_call_action($self->{action})}sub _call_action {my ($self,$action)=@_;return if$self->{_completed_actions}{$action}++;local$self->{action}=$action;my$method=$self->can_action($action);die "No action '$action' defined, try running the 'help' action.\n" unless$method;$self->log_debug("Starting ACTION_$action\n");my$rc=$self->$method();$self->log_debug("Finished ACTION_$action\n");return$rc}sub can_action {my ($self,$action)=@_;return$self->can("ACTION_$action")}sub cull_options {my$self=shift;my (@argv)=@_;return({},@argv)unless(ref($self));my$specs=$self->get_options;return({},@argv)unless($specs and %$specs);require Getopt::Long;my@specs;my$args={};for my$k (sort keys %$specs){my$v=$specs->{$k};die "Option specification '$k' conflicts with a " .ref$self ." option of the same name" if$self->valid_property($k);push@specs,$k .(defined$v->{type}? $v->{type}: '');push@specs,$v->{store}if exists$v->{store};$args->{$k}=$v->{default}if exists$v->{default}}local@ARGV=@argv;if (@specs){Getopt::Long::Configure('pass_through');Getopt::Long::GetOptions($args,@specs)}return$args,@ARGV}sub unparse_args {my ($self,$args)=@_;my@out;for my$k (sort keys %$args){my$v=$args->{$k};push@out,(ref$v eq 'HASH' ? map {+"--$k","$_=$v->{$_}"}sort keys %$v : ref$v eq 'ARRAY' ? map {+"--$k",$_}@$v : ("--$k",$v))}return@out}sub args {my$self=shift;return wantarray ? %{$self->{args}}: $self->{args}unless @_;my$key=shift;$self->{args}{$key}=shift if @_;return$self->{args}{$key}}sub _translate_option {my$self=shift;my$opt=shift;(my$tr_opt=$opt)=~ tr/-/_/;return$tr_opt if grep$tr_opt =~ /^(?:no_?)?$_$/,qw(create_license create_makefile_pl create_readme extra_compiler_flags extra_linker_flags install_base install_path meta_add meta_merge test_files use_rcfile use_tap_harness tap_harness_args cpan_client pureperl_only allow_pureperl);return$opt}my%singular_argument=map {($_=>1)}qw/install_base prefix destdir installdirs verbose quiet uninst debug sign/;sub _read_arg {my ($self,$args,$key,$val)=@_;$key=$self->_translate_option($key);if (exists$args->{$key}and not $singular_argument{$key}){$args->{$key}=[$args->{$key}]unless ref$args->{$key};push @{$args->{$key}},$val}else {$args->{$key}=$val}}sub _optional_arg {my$self=shift;my$opt=shift;my$argv=shift;$opt=$self->_translate_option($opt);my@bool_opts=qw(build_bat create_license create_readme pollute quiet uninst use_rcfile verbose debug sign use_tap_harness pureperl_only allow_pureperl);if (grep$opt =~ /^no[-_]?$_$/,@bool_opts){$opt =~ s/^no-?//;return ($opt,0)}return ($opt,shift(@$argv))unless grep $_ eq $opt,@bool_opts;my$arg=1;$arg=shift(@$argv)if @$argv && $argv->[0]=~ /^\d+$/;return ($opt,$arg)}sub read_args {my$self=shift;(my$args,@_)=$self->cull_options(@_);my%args=%$args;my$opt_re=qr/[\w\-]+/;my ($action,@argv);while (@_){local $_=shift;if (/^(?:--)?($opt_re)=(.*)$/){$self->_read_arg(\%args,$1,$2)}elsif (/^--($opt_re)$/){my($opt,$arg)=$self->_optional_arg($1,\@_);$self->_read_arg(\%args,$opt,$arg)}elsif (/^($opt_re)$/ and!defined($action)){$action=$1}else {push@argv,$_}}$args{ARGV}=\@argv;for ('extra_compiler_flags','extra_linker_flags'){$args{$_}=[$self->split_like_shell($args{$_})]if exists$args{$_}}for ('include_dirs'){$args{$_}=[$args{$_}]if exists$args{$_}&&!ref$args{$_}}for ($self->hash_properties,'config'){next unless exists$args{$_};my%hash;$args{$_}||= [];$args{$_}=[$args{$_}]unless ref$args{$_};for my$arg (@{$args{$_}}){$arg =~ /($opt_re)=(.*)/ or die "Malformed '$_' argument: '$arg' should be something like 'foo=bar'";$hash{$1}=$2}$args{$_}=\%hash}for my$key (qw(prefix install_base destdir)){next if!defined$args{$key};$args{$key}=$self->_detildefy($args{$key})}for my$key (qw(install_path)){next if!defined$args{$key};for my$subkey (keys %{$args{$key}}){next if!defined$args{$key}{$subkey};my$subkey_ext=$self->_detildefy($args{$key}{$subkey});if ($subkey eq 'html'){$args{$key}{binhtml}=$subkey_ext;$args{$key}{libhtml}=$subkey_ext}else {$args{$key}{$subkey}=$subkey_ext}}}if ($args{makefile_env_macros}){require Module::Build::Compat;%args=(%args,Module::Build::Compat->makefile_to_build_macros)}return \%args,$action}sub _detildefy {}sub _merge_arglist {my($self,$opts1,$opts2)=@_;$opts1 ||= {};$opts2 ||= {};my%new_opts=%$opts1;while (my ($key,$val)=each %$opts2){if (exists($opts1->{$key})){if (ref($val)eq 'HASH'){while (my ($k,$v)=each %$val){$new_opts{$key}{$k}=$v unless exists($opts1->{$key}{$k})}}}else {$new_opts{$key}=$val}}return%new_opts}sub _home_dir {my@home_dirs;push(@home_dirs,$ENV{HOME})if$ENV{HOME};push(@home_dirs,File::Spec->catpath($ENV{HOMEDRIVE},$ENV{HOMEPATH},''))if$ENV{HOMEDRIVE}&& $ENV{HOMEPATH};my@other_home_envs=qw(USERPROFILE APPDATA WINDIR SYS$LOGIN);push(@home_dirs,map$ENV{$_},grep$ENV{$_},@other_home_envs);my@real_home_dirs=grep -d,@home_dirs;return wantarray ? @real_home_dirs : shift(@real_home_dirs)}sub _find_user_config {my$self=shift;my$file=shift;for my$dir ($self->_home_dir){my$path=File::Spec->catfile($dir,$file);return$path if -e $path}return undef}sub read_modulebuildrc {my($self,$action)=@_;return ()unless$self->use_rcfile;my$modulebuildrc;if (exists($ENV{MODULEBUILDRC})&& $ENV{MODULEBUILDRC}eq 'NONE'){return ()}elsif (exists($ENV{MODULEBUILDRC})&& -e $ENV{MODULEBUILDRC}){$modulebuildrc=$ENV{MODULEBUILDRC}}elsif (exists($ENV{MODULEBUILDRC})){$self->log_warn("WARNING: Can't find resource file " ."'$ENV{MODULEBUILDRC}' defined in environment.\n" ."No options loaded\n");return ()}else {$modulebuildrc=$self->_find_user_config('.modulebuildrc');return ()unless$modulebuildrc}open(my$fh,'<',$modulebuildrc)or die "Can't open $modulebuildrc: $!";my%options;my$buffer='';while (defined(my$line=<$fh>)){chomp($line);$line =~ s/#.*$//;next unless length($line);if ($line =~ /^\S/){if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' ';$buffer=''}$buffer=$line}else {$buffer .= $line}}if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' '}my ($global_opts)=$self->read_args($self->split_like_shell($options{'*'}|| ''));if ($action eq 'fakeinstall' &&!exists$options{fakeinstall}){$action='install'}my ($action_opts)=$self->read_args($self->split_like_shell($options{$action}|| ''));return$self->_merge_arglist($action_opts,$global_opts)}sub merge_modulebuildrc {my($self,$action,%cmdline_opts)=@_;my%rc_opts=$self->read_modulebuildrc($action || $self->{action}|| 'build');my%new_opts=$self->_merge_arglist(\%cmdline_opts,\%rc_opts);$self->merge_args($action,%new_opts)}sub merge_args {my ($self,$action,%args)=@_;$self->{action}=$action if defined$action;my%additive=map {$_=>1}$self->hash_properties;while (my ($key,$val)=each%args){$self->{phash}{runtime_params}->access($key=>$val)if$self->valid_property($key);if ($key eq 'config'){$self->config($_=>$val->{$_})foreach keys %$val}else {my$add_to=$additive{$key}? $self->{properties}{$key}: $self->valid_property($key)? $self->{properties}: $self->{args};if ($additive{$key}){$add_to->{$_}=$val->{$_}foreach keys %$val}else {$add_to->{$key}=$val}}}}sub cull_args {my$self=shift;my@arg_list=@_;unshift@arg_list,$self->split_like_shell($ENV{PERL_MB_OPT})if$ENV{PERL_MB_OPT};my ($args,$action)=$self->read_args(@arg_list);$self->merge_args($action,%$args);$self->merge_modulebuildrc($action,%$args)}sub super_classes {my ($self,$class,$seen)=@_;$class ||= ref($self)|| $self;$seen ||= {};no strict 'refs';my@super=grep {not $seen->{$_}++}$class,@{$class .'::ISA'};return@super,map {$self->super_classes($_,$seen)}@super}sub known_actions {my ($self)=@_;my%actions;no strict 'refs';for my$class ($self->super_classes){for (keys %{$class .'::'}){$actions{$1}++ if /^ACTION_(\w+)/}}return wantarray ? sort keys%actions : \%actions}sub get_action_docs {my ($self,$action)=@_;my$actions=$self->known_actions;die "No known action '$action'" unless$actions->{$action};my ($files_found,@docs)=(0);for my$class ($self->super_classes){(my$file=$class)=~ s{::}{/}g;$file=$INC{$file .'.pm'}or next;open(my$fh,'<',$file)or next;$files_found++;local $_;while (<$fh>){last if /^=head1 ACTIONS\s/}my$style;while (<$fh>){last if /^=head1 /;if(/^=(item|head2)\s+\Q$action\E\b/){$style=$1;push@docs,$_;last}}$style or next;if($style eq 'item'){my ($found,$inlist)=(0,0);while (<$fh>){if (/^=(item|back)/){last unless$inlist}push@docs,$_;++$inlist if /^=over/;--$inlist if /^=back/}}else {while (<$fh>){last if(/^=(?:head[12]|cut)/);push@docs,$_}}}unless ($files_found){$@="Couldn't find any documentation to search";return}unless (@docs){$@="Couldn't find any docs for action '$action'";return}return join '',@docs}sub ACTION_prereq_report {my$self=shift;$self->log_info($self->prereq_report)}sub ACTION_prereq_data {my$self=shift;$self->log_info(Module::Build::Dumper->_data_dump($self->prereq_data))}sub prereq_data {my$self=shift;my@types=('configure_requires',@{$self->prereq_action_types});my$info={map {$_=>$self->$_()}grep {%{$self->$_()}}@types };return$info}sub prereq_report {my$self=shift;my$info=$self->prereq_data;my$output='';for my$type (sort keys %$info){my$prereqs=$info->{$type};$output .= "\n$type:\n";my$mod_len=2;my$ver_len=4;my%mods;for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$len=length$modname;$mod_len=$len if$len > $mod_len;$spec ||= '0';$len=length$spec;$ver_len=$len if$len > $ver_len;my$mod=$self->check_installed_status($modname,$spec);$mod->{name}=$modname;$mod->{ok}||= 0;$mod->{ok}=!$mod->{ok}if$type =~ /^(\w+_)?conflicts$/;$mods{lc$modname}=$mod}my$space=q{ } x ($mod_len - 3);my$vspace=q{ } x ($ver_len - 3);my$sline=q{-} x ($mod_len - 3);my$vline=q{-} x ($ver_len - 3);my$disposition=($type =~ /^(\w+_)?conflicts$/)? 'Clash' : 'Need';$output .= "    Module $space  $disposition $vspace  Have\n"."    ------$sline+------$vline-+----------\n";for my$k (sort keys%mods){my$mod=$mods{$k};my$space=q{ } x ($mod_len - length$k);my$vspace=q{ } x ($ver_len - length$mod->{need});my$f=$mod->{ok}? ' ' : '!';$output .= "  $f $mod->{name} $space     $mod->{need}  $vspace   ".(defined($mod->{have})? $mod->{have}: "")."\n"}}return$output}sub ACTION_help {my ($self)=@_;my$actions=$self->known_actions;if (@{$self->{args}{ARGV}}){my$msg=eval {$self->get_action_docs($self->{args}{ARGV}[0],$actions)};print $@ ? "$@\n" : $msg;return}print <<EOF;print$self->_action_listing($actions);print "\nRun `Build help <action>` for details on an individual action.\n";print "See `perldoc Module::Build` for complete documentation.\n"}sub _action_listing {my ($self,$actions)=@_;my@actions=sort keys %$actions;@actions=map$actions[($_ + ($_ % 2)* @actions)/ 2],0..$#actions;my$out='';while (my ($one,$two)=splice@actions,0,2){$out .= sprintf("  %-12s                   %-12s\n",$one,$two||'')}$out =~ s{\s*$}{}mg;return$out}sub ACTION_retest {my ($self)=@_;local@INC=@INC;@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub ACTION_testall {my ($self)=@_;my@types;for my$action (grep {$_ ne 'all'}$self->get_test_types){push(@types,$action)}$self->generic_test(types=>['default',@types])}sub get_test_types {my ($self)=@_;my$t=$self->{properties}->{test_types};return (defined$t ? (wantarray ? sort keys %$t : keys %$t): ())}sub ACTION_test {my ($self)=@_;$self->generic_test(type=>'default')}sub generic_test {my$self=shift;(@_ % 2)and croak('Odd number of elements in argument hash');my%args=@_;my$p=$self->{properties};my@types=((exists($args{type})? $args{type}: ()),(exists($args{types})? @{$args{types}}: ()),);@types or croak "need some types of tests to check";my%test_types=(default=>$p->{test_file_exts},(defined($p->{test_types})? %{$p->{test_types}}: ()),);for my$type (@types){croak "$type not defined in test_types!" unless defined$test_types{$type }}local$p->{test_file_exts}=[map {ref $_ ? @$_ : $_}@test_types{@types}];$self->depends_on('code');local@INC=@INC;unshift@INC,(File::Spec->catdir($p->{base_dir},$self->blib,'lib'),File::Spec->catdir($p->{base_dir},$self->blib,'arch'));@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub do_tests {my$self=shift;my$tests=$self->find_test_files;local$ENV{PERL_DL_NONLAZY}=1;if(@$tests){my$args=$self->tap_harness_args;if($self->use_tap_harness or ($args and %$args)){my$aggregate=$self->run_tap_harness($tests);if ($aggregate->has_errors){die "Errors in testing.  Cannot continue.\n"}}else {$self->run_test_harness($tests)}}else {$self->log_info("No tests defined.\n")}$self->run_visual_script}sub run_tap_harness {my ($self,$tests)=@_;require TAP::Harness::Env;my$aggregate=TAP::Harness::Env->create({lib=>[@INC],verbosity=>$self->{properties}{verbose},switches=>[$self->harness_switches ],%{$self->tap_harness_args},})->runtests(@$tests);return$aggregate}sub run_test_harness {my ($self,$tests)=@_;require Test::Harness;local$Test::Harness::verbose=$self->verbose || 0;local$Test::Harness::switches=join ' ',$self->harness_switches;Test::Harness::runtests(@$tests)}sub run_visual_script {my$self=shift;$self->run_perl_script('visual.pl','-Mblib='.$self->blib)if -e 'visual.pl'}sub harness_switches {my$self=shift;my@res;push@res,qw(-w -d) if$self->{properties}{debugger};push@res,'-MDevel::Cover' if$self->{properties}{cover};return@res}sub test_files {my$self=shift;my$p=$self->{properties};if (@_){return$p->{test_files}=(@_==1 ? shift : [@_])}return$self->find_test_files}sub expand_test_dir {my ($self,$dir)=@_;my$exts=$self->{properties}{test_file_exts};return sort map {@{$self->rscan_dir($dir,qr{^[^.].*\Q$_\E$})}}@$exts if$self->recursive_test_files;return sort map {glob File::Spec->catfile($dir,"*$_")}@$exts}sub ACTION_testdb {my ($self)=@_;local$self->{properties}{debugger}=1;$self->depends_on('test')}sub ACTION_testcover {my ($self)=@_;unless (Module::Metadata->find_module_by_name('Devel::Cover')){warn("Cannot run testcover action unless Devel::Cover is installed.\n");return}$self->add_to_cleanup('coverage','cover_db');$self->depends_on('code');if (-e 'cover_db'){my$pm_files=$self->rscan_dir (File::Spec->catdir($self->blib,'lib'),$self->file_qr('\.pm$'));my$cover_files=$self->rscan_dir('cover_db',sub {-f $_ and not /\.html$/});$self->do_system(qw(cover -delete))unless$self->up_to_date($pm_files,$cover_files)&& $self->up_to_date($self->test_files,$cover_files)}local$self->{properties}{cover}=1;$self->depends_on('test');$self->do_system('cover')}sub ACTION_code {my ($self)=@_;my$blib=$self->blib;$self->add_to_cleanup($blib);File::Path::mkpath(File::Spec->catdir($blib,'arch'));if (my$split=$self->autosplit){$self->autosplit_file($_,$blib)for ref($split)? @$split : ($split)}for my$element (@{$self->build_elements}){my$method="process_${element}_files";$method="process_files_by_extension" unless$self->can($method);$self->$method($element)}$self->depends_on('config_data')}sub ACTION_build {my$self=shift;$self->log_info("Building " .$self->dist_name ."\n");$self->depends_on('code');$self->depends_on('docs')}sub process_files_by_extension {my ($self,$ext)=@_;my$method="find_${ext}_files";my$files=$self->can($method)? $self->$method(): $self->_find_file_by_type($ext,'lib');for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($self->blib,$files->{$file}))}}sub process_support_files {my$self=shift;my$p=$self->{properties};return unless$p->{c_source};return if$self->pureperl_only && $self->allow_pureperl;my$files;if (ref($p->{c_source})eq "ARRAY"){push @{$p->{include_dirs}},@{$p->{c_source}};for my$path (@{$p->{c_source}}){push @$files,@{$self->rscan_dir($path,$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}}}else {push @{$p->{include_dirs}},$p->{c_source};$files=$self->rscan_dir($p->{c_source},$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}for my$file (@$files){push @{$p->{objects}},$self->compile_c($file)}}sub process_share_dir_files {my$self=shift;my$files=$self->_find_share_dir_files;return unless$files;my$share_prefix=File::Spec->catdir($self->blib,qw/lib auto share/);for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($share_prefix,$files->{$file}))}}sub _find_share_dir_files {my$self=shift;my$share_dir=$self->share_dir;return unless$share_dir;my@file_map;if ($share_dir->{dist}){my$prefix="dist/".$self->dist_name;push@file_map,$self->_share_dir_map($prefix,$share_dir->{dist})}if ($share_dir->{module}){for my$mod (sort keys %{$share_dir->{module}}){(my$altmod=$mod)=~ s{::}{-}g;my$prefix="module/$altmod";push@file_map,$self->_share_dir_map($prefix,$share_dir->{module}{$mod})}}return {@file_map }}sub _share_dir_map {my ($self,$prefix,$list)=@_;my%files;for my$dir (@$list){for my$f (@{$self->rscan_dir($dir,sub {-f})}){$f =~ s{\A.*?\Q$dir\E/}{};$files{"$dir/$f"}="$prefix/$f"}}return%files}sub process_PL_files {my ($self)=@_;my$files=$self->find_PL_files;for my$file (sort keys %$files){my$to=$files->{$file};unless ($self->up_to_date($file,$to)){$self->run_perl_script($file,[],[@$to])or die "$file failed";$self->add_to_cleanup(@$to)}}}sub process_xs_files {my$self=shift;return if$self->pureperl_only && $self->allow_pureperl;my$files=$self->find_xs_files;croak 'Can\'t build xs files under --pureperl-only' if %$files && $self->pureperl_only;for my$from (sort keys %$files){my$to=$files->{$from};unless ($from eq $to){$self->add_to_cleanup($to);$self->copy_if_modified(from=>$from,to=>$to)}$self->process_xs($to)}}sub process_pod_files {shift()->process_files_by_extension(shift())}sub process_pm_files {shift()->process_files_by_extension(shift())}sub process_script_files {my$self=shift;my$files=$self->find_script_files;return unless keys %$files;my$script_dir=File::Spec->catdir($self->blib,'script');File::Path::mkpath($script_dir);for my$file (sort keys %$files){my$result=$self->copy_if_modified($file,$script_dir,'flatten')or next;$self->fix_shebang_line($result)unless$self->is_vmsish;$self->make_executable($result)}}sub find_PL_files {my$self=shift;if (my$files=$self->{properties}{PL_files}){if (ref$files eq 'ARRAY'){return {map {$_,[/^(.*)\.PL$/]}map$self->localize_file_path($_),@$files }}elsif (ref$files eq 'HASH'){my%out;while (my ($file,$to)=each %$files){$out{$self->localize_file_path($file)}=[map$self->localize_file_path($_),ref$to ? @$to : ($to)]}return \%out}else {die "'PL_files' must be a hash reference or array reference"}}return unless -d 'lib';return {map {$_,[/^(.*)\.PL$/i ]}@{$self->rscan_dir('lib',$self->file_qr('\.PL$'))}}}sub find_pm_files {shift->_find_file_by_type('pm','lib')}sub find_pod_files {shift->_find_file_by_type('pod','lib')}sub find_xs_files {shift->_find_file_by_type('xs','lib')}sub find_script_files {my$self=shift;if (my$files=$self->script_files){return {map {$self->localize_file_path($_),$files->{$_}}keys %$files }}return {}}sub find_test_files {my$self=shift;my$p=$self->{properties};if (my$files=$p->{test_files}){$files=[sort keys %$files]if ref$files eq 'HASH';$files=[map {-d $_ ? $self->expand_test_dir($_): $_}map glob,$self->split_like_shell($files)];return [map$self->localize_file_path($_),@$files ]}else {my@tests;push@tests,'test.pl' if -e 'test.pl';push@tests,$self->expand_test_dir('t')if -e 't' and -d _;return \@tests}}sub _find_file_by_type {my ($self,$type,$dir)=@_;if (my$files=$self->{properties}{"${type}_files"}){return {map$self->localize_file_path($_),%$files }}return {}unless -d $dir;return {map {$_,$_}map$self->localize_file_path($_),grep!/\.\#/,@{$self->rscan_dir($dir,$self->file_qr("\\.$type\$"))}}}sub localize_file_path {my ($self,$path)=@_;return File::Spec->catfile(split m{/},$path)}sub localize_dir_path {my ($self,$path)=@_;return File::Spec->catdir(split m{/},$path)}sub fix_shebang_line {my ($self,@files)=@_;my$c=ref($self)? $self->{config}: 'Module::Build::Config';my ($does_shbang)=$c->get('sharpbang')=~ /^\s*\#\!/;for my$file (@files){open(my$FIXIN,'<',$file)or die "Can't process '$file': $!";local $/="\n";chomp(my$line=<$FIXIN>);next unless$line =~ s/^\s*\#!\s*//;my ($cmd,$arg)=(split(' ',$line,2),'');next unless$cmd =~ /perl/i;my$interpreter=$self->{properties}{perl};$self->log_verbose("Changing sharpbang in $file to $interpreter\n");my$shb='';$shb .= $c->get('sharpbang')."$interpreter $arg\n" if$does_shbang;open(my$FIXOUT,'>',"$file.new")or die "Can't create new $file: $!\n";local $\;undef $/;print$FIXOUT $shb,<$FIXIN>;close$FIXIN;close$FIXOUT;rename($file,"$file.bak")or die "Can't rename $file to $file.bak: $!";rename("$file.new",$file)or die "Can't rename $file.new to $file: $!";$self->delete_filetree("$file.bak")or $self->log_warn("Couldn't clean up $file.bak, leaving it there");$self->do_system($c->get('eunicefix'),$file)if$c->get('eunicefix')ne ':'}}sub ACTION_testpod {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod 0.95; 1} or die "The 'testpod' action requires Test::Pod version 0.95";my@files=sort keys %{$self->_find_pods($self->libdoc_dirs)},keys %{$self->_find_pods ($self->bindoc_dirs,exclude=>[$self->file_qr('\.bat$')])}or die "Couldn't find any POD files to test\n";{package Module::Build::PodTester;Test::Pod->import(tests=>scalar@files);pod_file_ok($_)foreach@files}}sub ACTION_testpodcoverage {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod::Coverage 1.00; 1} or die "The 'testpodcoverage' action requires ","Test::Pod::Coverage version 1.00";local@INC=@INC;my$p=$self->{properties};unshift(@INC,File::Spec->catdir($p->{base_dir},$self->blib,'lib'),);all_pod_coverage_ok()}sub ACTION_docs {my$self=shift;$self->depends_on('code');$self->depends_on('manpages','html')}sub _is_default_installable {my$self=shift;my$type=shift;return ($self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs)->{$type}))? 1 : 0}sub _is_ActivePerl {my$self=shift;unless (exists($self->{_is_ActivePerl})){$self->{_is_ActivePerl}=(eval {require ActivePerl::DocTools}|| 0)}return$self->{_is_ActivePerl}}sub _is_ActivePPM {my$self=shift;unless (exists($self->{_is_ActivePPM})){$self->{_is_ActivePPM}=(eval {require ActivePerl::PPM}|| 0)}return$self->{_is_ActivePPM}}sub ACTION_manpages {my$self=shift;return unless$self->_mb_feature('manpage_support');$self->depends_on('code');my%extra_manify_args=$self->{properties}{'extra_manify_args'}? %{$self->{properties}{'extra_manify_args'}}: ();for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));my$files=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.bat$')]);next unless %$files;my$sub=$self->can("manify_${type}_pods");$self->$sub(%extra_manify_args)if defined($sub)}}sub manify_bin_pods {my$self=shift;my%podman_args=(section=>1,@_);my$files=$self->_find_pods($self->{properties}{bindoc_dirs},exclude=>[$self->file_qr('\.bat$')]);return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'bindoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man1page_name($file).'.' .$self->config('man1ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub manify_lib_pods {my$self=shift;my%podman_args=(section=>3,@_);my$files=$self->_find_pods($self->{properties}{libdoc_dirs});return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'libdoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man3page_name($files->{$file}).'.' .$self->config('man3ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub _find_pods {my ($self,$dirs,%args)=@_;my%files;for my$spec (@$dirs){my$dir=$self->localize_dir_path($spec);next unless -e $dir;FILE: foreach my$file (@{$self->rscan_dir($dir)}){for my$regexp (@{$args{exclude}}){next FILE if$file =~ $regexp}$file=$self->localize_file_path($file);$files{$file}=File::Spec->abs2rel($file,$dir)if$self->contains_pod($file)}}return \%files}sub contains_pod {my ($self,$file)=@_;return '' unless -T $file;open(my$fh,'<',$file)or die "Can't open $file: $!";while (my$line=<$fh>){return 1 if$line =~ /^\=(?:head|pod|item)/}return ''}sub ACTION_html {my$self=shift;return unless$self->_mb_feature('HTML_support');$self->depends_on('code');for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));$self->htmlify_pods($type)}}sub htmlify_pods {my$self=shift;my$type=shift;my$htmldir=shift || File::Spec->catdir($self->blib,"${type}html");$self->add_to_cleanup('pod2htm*');my$pods=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.(?:bat|com|html)$')]);return unless %$pods;unless (-d $htmldir){File::Path::mkpath($htmldir,0,oct(755))or die "Couldn't mkdir $htmldir: $!"}my@rootdirs=($type eq 'bin')? qw(bin) : $self->installdirs eq 'core' ? qw(lib) : qw(site lib);my$podroot=$ENV{PERL_CORE}? File::Basename::dirname($ENV{PERL_CORE}): $self->original_prefix('core');my$htmlroot=$self->install_sets('core')->{libhtml};my$podpath;unless (defined$self->args('html_links')and!$self->args('html_links')){my@podpath=((map {File::Spec->abs2rel($_,$podroot)}grep {-d}($self->install_sets('core','lib'),$self->install_sets('core','bin'),$self->install_sets('site','lib'),)),File::Spec->rel2abs($self->blib));$podpath=$ENV{PERL_CORE}? File::Spec->catdir($podroot,'lib'): join(":",map {tr,:\\,|/,;$_}@podpath)}my$blibdir=join('/',File::Spec->splitdir((File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),'');my ($with_ActiveState,$htmltool);if ($with_ActiveState=$self->_is_ActivePerl && eval {require ActivePerl::DocTools::Pod;1}){my$tool_v=ActiveState::DocTools::Pod->VERSION;$htmltool="ActiveState::DocTools::Pod";$htmltool .= " $tool_v" if$tool_v && length$tool_v}else {require Module::Build::PodParser;require Pod::Html;$htmltool="Pod::Html " .Pod::Html->VERSION}$self->log_verbose("Converting Pod to HTML with $htmltool\n");my$errors=0;POD: foreach my$pod (sort keys %$pods){my ($name,$path)=File::Basename::fileparse($pods->{$pod},$self->file_qr('\.(?:pm|plx?|pod)$'));my@dirs=File::Spec->splitdir(File::Spec->canonpath($path));pop(@dirs)if scalar(@dirs)&& $dirs[-1]eq File::Spec->curdir;my$fulldir=File::Spec->catdir($htmldir,@rootdirs,@dirs);my$tmpfile=File::Spec->catfile($fulldir,"${name}.tmp");my$outfile=File::Spec->catfile($fulldir,"${name}.html");my$infile=File::Spec->abs2rel($pod);next if$self->up_to_date($infile,$outfile);unless (-d $fulldir){File::Path::mkpath($fulldir,0,oct(755))or die "Couldn't mkdir $fulldir: $!"}$self->log_verbose("HTMLifying $infile -> $outfile\n");if ($with_ActiveState){my$depth=@rootdirs + @dirs;my%opts=(infile=>$infile,outfile=>$tmpfile,(defined($podpath)? (podpath=>$podpath): ()),podroot=>$podroot,index=>1,depth=>$depth,);eval {ActivePerl::DocTools::Pod::pod2html(map {($_,$opts{$_})}sort keys%opts);1}or $self->log_warn("[$htmltool] pod2html (" .join(", ",map {"q{$_} => q{$opts{$_}}"}(sort keys%opts)).") failed: $@")}else {my$path2root=File::Spec->catdir((File::Spec->updir)x @dirs);open(my$fh,'<',$infile)or die "Can't read $infile: $!";my$abstract=Module::Build::PodParser->new(fh=>$fh)->get_abstract();my$title=join('::',(@dirs,$name));$title .= " - $abstract" if$abstract;my@opts=("--title=$title",(defined($podpath)? "--podpath=$podpath" : ()),"--infile=$infile","--outfile=$tmpfile","--podroot=$podroot",($path2root ? "--htmlroot=$path2root" : ()),);unless (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--flush'))}if (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--header','--backlink'))}elsif (eval{Pod::Html->VERSION(1.03)}){push(@opts,('--header','--backlink=Back to Top'))}$self->log_verbose("P::H::pod2html @opts\n");{my$orig=Cwd::getcwd();eval {Pod::Html::pod2html(@opts);1}or $self->log_warn("[$htmltool] pod2html( " .join(", ",map {"q{$_}"}@opts).") failed: $@");chdir($orig)}}if (!-r $tmpfile){$errors++;next POD}open(my$fh,'<',$tmpfile)or die "Can't read $tmpfile: $!";my$html=join('',<$fh>);close$fh;if (!$self->_is_ActivePerl){$html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;$html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;$html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i}$html =~ s/\Q$blibdir\E//g;open($fh,'>',$outfile)or die "Can't write $outfile: $!";print$fh $html;close$fh;unlink($tmpfile)}return!$errors}sub man1page_name {my$self=shift;return File::Basename::basename(shift)}sub man3page_name {my$self=shift;my ($vol,$dirs,$file)=File::Spec->splitpath(shift);my@dirs=File::Spec->splitdir(File::Spec->canonpath($dirs));$file =~ s/\.p(?:od|m|l)\z//i;return join($self->manpage_separator,@dirs,$file)}sub manpage_separator {return '::'}sub ACTION_diff {my$self=shift;$self->depends_on('build');my$local_lib=File::Spec->rel2abs('lib');my@myINC=grep {$_ ne $local_lib}@INC;push@myINC,map$self->install_destination($_),qw(lib arch);my@flags=@{$self->{args}{ARGV}};@flags=$self->split_like_shell($self->{args}{flags}|| '')unless@flags;my$installmap=$self->install_map;delete$installmap->{read};delete$installmap->{write};my$text_suffix=$self->file_qr('\.(pm|pod)$');for my$localdir (sort keys %$installmap){my@localparts=File::Spec->splitdir($localdir);my$files=$self->rscan_dir($localdir,sub {-f});for my$file (@$files){my@parts=File::Spec->splitdir($file);@parts=@parts[@localparts .. $#parts];my$installed=Module::Metadata->find_module_by_name(join('::',@parts),\@myINC);if (not $installed){print "Only in lib: $file\n";next}my$status=File::Compare::compare($installed,$file);next if$status==0;die "Can't compare $installed and $file: $!" if$status==-1;if ($file =~ $text_suffix){$self->do_system('diff',@flags,$installed,$file)}else {print "Binary files $file and $installed differ\n"}}}}sub ACTION_pure_install {shift()->depends_on('install')}sub ACTION_install {my ($self)=@_;require ExtUtils::Install;$self->depends_on('build');$self->_do_in_dir(".",sub {ExtUtils::Install::install($self->install_map,$self->verbose,0,$self->{args}{uninst}||0)});if ($self->_is_ActivePerl && $self->{_completed_actions}{html}){$self->log_info("Building ActivePerl Table of Contents\n");eval {ActivePerl::DocTools::WriteTOC(verbose=>$self->verbose ? 1 : 0);1}or $self->log_warn("AP::DT:: WriteTOC() failed: $@")}if ($self->_is_ActivePPM){my$F_perllocal=File::Spec->catfile($self->install_sets('core','lib'),'perllocal.pod');my$dt_stamp=time;$self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");open my$perllocal,">>",$F_perllocal;close$perllocal;utime($dt_stamp,$dt_stamp,$F_perllocal)}}sub ACTION_fakeinstall {my ($self)=@_;require ExtUtils::Install;my$eui_version=ExtUtils::Install->VERSION;if ($eui_version < 1.32){$self->log_warn("The 'fakeinstall' action requires Extutils::Install 1.32 or later.\n" ."(You only have version $eui_version).");return}$self->depends_on('build');ExtUtils::Install::install($self->install_map,!$self->quiet,1,$self->{args}{uninst}||0)}sub ACTION_versioninstall {my ($self)=@_;die "You must have only.pm 0.25 or greater installed for this operation: $@\n" unless eval {require only;'only'->VERSION(0.25);1};$self->depends_on('build');my%onlyargs=map {exists($self->{args}{$_})? ($_=>$self->{args}{$_}): ()}qw(version versionlib);only::install::install(%onlyargs)}sub ACTION_installdeps {my ($self)=@_;my$info=$self->_enum_prereqs;if (!$info){$self->log_info("No prerequisites detected\n");return}my$failures=$self->prereq_failures($info);if (!$failures){$self->log_info("All prerequisites satisfied\n");return}my@install;for my$type (sort keys %$failures){my$prereqs=$failures->{$type};if($type =~ m/^(?:\w+_)?requires$/){push(@install,sort keys %$prereqs);next}$self->log_info("Checking optional dependencies:\n");for my$module (sort keys %$prereqs){push(@install,$module)if($self->y_n("Install $module?",'y'))}}return unless@install;my ($command,@opts)=$self->split_like_shell($self->cpan_client);if (!File::Spec->file_name_is_absolute($command)){my@loc=('site','vendor','');my@bindirs=File::Basename::dirname($self->perl);push@bindirs,map {($self->config->{"install${_}bin"},$self->config->{"install${_}script"})}@loc;for my$d (@bindirs){my$abs_cmd=$self->find_command(File::Spec->catfile($d,$command));if (defined$abs_cmd){$command=$abs_cmd;last}}}$self->do_system($command,@opts,@install)}sub ACTION_clean {my ($self)=@_;$self->log_info("Cleaning up build files\n");for my$item (map glob($_),$self->cleanup){$self->delete_filetree($item)}}sub ACTION_realclean {my ($self)=@_;$self->depends_on('clean');$self->log_info("Cleaning up configuration files\n");$self->delete_filetree($self->config_dir,$self->mymetafile,$self->mymetafile2,$self->build_script)}sub ACTION_ppd {my ($self)=@_;require Module::Build::PPMMaker;my$ppd=Module::Build::PPMMaker->new();my$file=$ppd->make_ppd(%{$self->{args}},build=>$self);$self->add_to_cleanup($file)}sub ACTION_ppmdist {my ($self)=@_;$self->depends_on('build');my$ppm=$self->ppm_name;$self->delete_filetree($ppm);$self->log_info("Creating $ppm\n");$self->add_to_cleanup($ppm,"$ppm.tar.gz");my%types=(lib=>'lib',arch=>'arch',bin=>'bin',script=>'script',bindoc=>'man1',libdoc=>'man3',binhtml=>undef,libhtml=>undef,);for my$type ($self->install_types){next if exists($types{$type})&&!defined($types{$type});my$dir=File::Spec->catdir($self->blib,$type);next unless -e $dir;my$files=$self->rscan_dir($dir);for my$file (@$files){next unless -f $file;my$rel_file=File::Spec->abs2rel(File::Spec->rel2abs($file),File::Spec->rel2abs($dir));my$to_file=File::Spec->catfile($ppm,'blib',exists($types{$type})? $types{$type}: $type,$rel_file);$self->copy_if_modified(from=>$file,to=>$to_file)}}for my$type (qw(bin lib)){$self->htmlify_pods($type,File::Spec->catdir($ppm,'blib','html'))}my$target=File::Spec->catfile(File::Spec->updir,$ppm);$self->_do_in_dir($ppm,sub {$self->make_tarball('blib',$target)});$self->depends_on('ppd');$self->delete_filetree($ppm)}sub ACTION_pardist {my ($self)=@_;if (not eval {require PAR::Dist;PAR::Dist->VERSION(0.17)}){$self->log_warn("In order to create .par distributions, you need to\n" ."install PAR::Dist first.");return()}$self->depends_on('build');return PAR::Dist::blib_to_par(name=>$self->dist_name,version=>$self->dist_version,)}sub ACTION_dist {my ($self)=@_;$self->dispatch('distdir');my$dist_dir=$self->dist_dir;$self->make_tarball($dist_dir);$self->delete_filetree($dist_dir)}sub ACTION_distcheck {my ($self)=@_;$self->_check_manifest_skip unless$self->invoked_action eq 'distclean';require ExtUtils::Manifest;local $^W;my ($missing,$extra)=ExtUtils::Manifest::fullcheck();return unless @$missing || @$extra;my$msg="MANIFEST appears to be out of sync with the distribution\n";if ($self->invoked_action eq 'distcheck'){die$msg}else {warn$msg}}sub _check_mymeta_skip {my$self=shift;my$maniskip=shift || 'MANIFEST.SKIP';require ExtUtils::Manifest;local $^W;my$skip_factory=ExtUtils::Manifest->can('maniskip')|| ExtUtils::Manifest->can('_maniskip');my$mymetafile=$self->mymetafile;for my$file ($self->mymetafile,$self->mymetafile2){unless ($skip_factory && $skip_factory->($maniskip)->($file)){$self->log_warn("File '$maniskip' does not include '$file'. Adding it now.\n");my$safe=quotemeta($file);$self->_append_maniskip("^$safe\$",$maniskip)}}}sub _add_to_manifest {my ($self,$manifest,$lines)=@_;$lines=[$lines]unless ref$lines;my$existing_files=$self->_read_manifest($manifest);return unless defined($existing_files);@$lines=grep {!exists$existing_files->{$_}}@$lines or return;my$mode=(stat$manifest)[2];chmod($mode | oct(222),$manifest)or die "Can't make $manifest writable: $!";open(my$fh,'<',$manifest)or die "Can't read $manifest: $!";my$last_line=(<$fh>)[-1]|| "\n";my$has_newline=$last_line =~ /\n$/;close$fh;open($fh,'>>',$manifest)or die "Can't write to $manifest: $!";print$fh "\n" unless$has_newline;print$fh map "$_\n",@$lines;close$fh;chmod($mode,$manifest);$self->log_verbose(map "Added to $manifest: $_\n",@$lines)}sub _sign_dir {my ($self,$dir)=@_;unless (eval {require Module::Signature;1}){$self->log_warn("Couldn't load Module::Signature for 'distsign' action:\n $@\n");return}{my$manifest=File::Spec->catfile($dir,'MANIFEST');die "Signing a distribution requires a MANIFEST file" unless -e $manifest;$self->_add_to_manifest($manifest,"SIGNATURE    Added here by Module::Build")}$self->_do_in_dir($dir,sub {local$Module::Signature::Quiet=1;Module::Signature::sign()})}sub _do_in_dir {my ($self,$dir,$do)=@_;my$start_dir=File::Spec->rel2abs($self->cwd);chdir$dir or die "Can't chdir() to $dir: $!";eval {$do->()};my@err=$@ ? ($@): ();chdir$start_dir or push@err,"Can't chdir() back to $start_dir: $!";die join "\n",@err if@err}sub ACTION_distsign {my ($self)=@_;{local$self->{properties}{sign}=0;$self->depends_on('distdir')unless -d $self->dist_dir}$self->_sign_dir($self->dist_dir)}sub ACTION_skipcheck {my ($self)=@_;require ExtUtils::Manifest;local $^W;ExtUtils::Manifest::skipcheck()}sub ACTION_distclean {my ($self)=@_;$self->depends_on('realclean');$self->depends_on('distcheck')}sub do_create_makefile_pl {my$self=shift;require Module::Build::Compat;$self->log_info("Creating Makefile.PL\n");eval {Module::Build::Compat->create_makefile_pl($self->create_makefile_pl,$self,@_)};if ($@){1 while unlink 'Makefile.PL';die "$@\n"}$self->_add_to_manifest('MANIFEST','Makefile.PL')}sub do_create_license {my$self=shift;$self->log_info("Creating LICENSE file\n");if (!$self->_mb_feature('license_creation')){$self->_warn_mb_feature_deps('license_creation');die "Aborting.\n"}my$l=$self->license or die "Can't create LICENSE file: No license specified\n";my$license=$self->_software_license_object or die << "HERE";$self->delete_filetree('LICENSE');open(my$fh,'>','LICENSE')or die "Can't write LICENSE file: $!";print$fh $license->fulltext;close$fh;$self->_add_to_manifest('MANIFEST','LICENSE')}sub do_create_readme {my$self=shift;$self->delete_filetree('README');my$docfile=$self->_main_docfile;unless ($docfile){$self->log_warn(<<EOF);return}if (eval {require Pod::Readme;Pod::Readme->can('new')}){$self->log_info("Creating README using Pod::Readme\n");my$parser=Pod::Readme->new;$parser->parse_from_file($docfile,'README',@_)}elsif (eval {require Pod::Text;1}){$self->log_info("Creating README using Pod::Text\n");if (open(my$fh,'>','README')){local $^W=0;no strict "refs";my$old_parse_file;$old_parse_file=\&{"Pod::Simple::parse_file"}and local *{"Pod::Simple::parse_file"}=sub {my$self=shift;$self->output_fh($_[1])if $_[1];$self->$old_parse_file($_[0])}if$Pod::Text::VERSION ==3.01;Pod::Text::pod2text($docfile,$fh);close$fh}else {$self->log_warn("Cannot create 'README' file: Can't open file for writing\n");return}}else {$self->log_warn("Can't load Pod::Readme or Pod::Text to create README\n");return}$self->_add_to_manifest('MANIFEST','README')}sub _main_docfile {my$self=shift;if (my$pm_file=$self->dist_version_from){(my$pod_file=$pm_file)=~ s/.pm$/.pod/;return (-e $pod_file ? $pod_file : $pm_file)}else {return undef}}sub do_create_bundle_inc {my$self=shift;my$dist_inc=File::Spec->catdir($self->dist_dir,'inc');require inc::latest;inc::latest->write($dist_inc,@{$self->bundle_inc_preload});inc::latest->bundle_module($_,$dist_inc)for @{$self->bundle_inc};return 1}sub ACTION_distdir {my ($self)=@_;if (@{$self->bundle_inc}&&!$self->_mb_feature('inc_bundling_support')){$self->_warn_mb_feature_deps('inc_bundling_support');die "Aborting.\n"}$self->depends_on('distmeta');my$dist_files=$self->_read_manifest('MANIFEST')or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";delete$dist_files->{SIGNATURE};die "No files found in MANIFEST - try running 'manifest' action?\n" unless ($dist_files and keys %$dist_files);my$metafile=$self->metafile;$self->log_warn("*** Did you forget to add $metafile to the MANIFEST?\n")unless exists$dist_files->{$metafile};my$dist_dir=$self->dist_dir;$self->delete_filetree($dist_dir);$self->log_info("Creating $dist_dir\n");$self->add_to_cleanup($dist_dir);for my$file (sort keys %$dist_files){next if$file =~ m{^MYMETA\.};my$new=$self->copy_if_modified(from=>$file,to_dir=>$dist_dir,verbose=>0)}$self->do_create_bundle_inc if @{$self->bundle_inc};$self->_sign_dir($dist_dir)if$self->{properties}{sign}}sub ACTION_disttest {my ($self)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {local$ENV{AUTHOR_TESTING}=1;local$ENV{RELEASE_TESTING}=1;$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['test'])or die "Error executing 'Build test' in dist directory"})}sub ACTION_distinstall {my ($self,@args)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['install'])or die "Error executing 'Build install' in dist directory"})}sub _eumanifest_has_include {my$self=shift;require ExtUtils::Manifest;return eval {ExtUtils::Manifest->VERSION(1.50);1}}sub _default_maniskip {my$self=shift;my$default_maniskip;for my$dir (@INC){$default_maniskip=File::Spec->catfile($dir,"ExtUtils","MANIFEST.SKIP");last if -r $default_maniskip}return$default_maniskip}sub _slurp {my$self=shift;my$file=shift;my$mode=shift || "";open my$fh,"<$mode",$file or croak "Can't open $file for reading: $!";local $/;return <$fh>}sub _spew {my$self=shift;my$file=shift;my$content=shift || "";my$mode=shift || "";open my$fh,">$mode",$file or croak "Can't open $file for writing: $!";print {$fh}$content;close$fh}sub _case_tolerant {my$self=shift;if (ref$self){$self->{_case_tolerant}=File::Spec->case_tolerant unless defined($self->{_case_tolerant});return$self->{_case_tolerant}}else {return File::Spec->case_tolerant}}sub _append_maniskip {my$self=shift;my$skip=shift;my$file=shift || 'MANIFEST.SKIP';return unless defined$skip && length$skip;open(my$fh,'>>',$file)or die "Can't open $file: $!";print$fh "$skip\n";close$fh}sub _write_default_maniskip {my$self=shift;my$file=shift || 'MANIFEST.SKIP';open(my$fh,'>',$file)or die "Can't open $file: $!";my$content=$self->_eumanifest_has_include ? "#!include_default\n" : $self->_slurp($self->_default_maniskip);$content .= <<'EOF';$content .= '\b'.$self->dist_name.'-[\d\.\_]+'."\n";print$fh $content;close$fh;return}sub _check_manifest_skip {my ($self)=@_;my$maniskip='MANIFEST.SKIP';if (!-e $maniskip){$self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");$self->_write_default_maniskip($maniskip);$self->_unlink_on_exit($maniskip)}else {$self->_check_mymeta_skip($maniskip)}return}sub ACTION_manifest {my ($self)=@_;$self->_check_manifest_skip;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);ExtUtils::Manifest::mkmanifest()}sub ACTION_manifest_skip {my ($self)=@_;if (-e 'MANIFEST.SKIP'){$self->log_warn("MANIFEST.SKIP already exists.\n");return 0}$self->log_info("Creating a new MANIFEST.SKIP file\n");return$self->_write_default_maniskip;return -e 'MANIFEST.SKIP'}sub file_qr {return shift->{_case_tolerant}? qr($_[0])i : qr($_[0])}sub dist_dir {my ($self)=@_;my$dir=join "-",$self->dist_name,$self->dist_version;$dir .= "-" .$self->dist_suffix if$self->dist_suffix;return$dir}sub ppm_name {my$self=shift;return 'PPM-' .$self->dist_dir}sub _files_in {my ($self,$dir)=@_;return unless -d $dir;local*DH;opendir DH,$dir or die "Can't read directory $dir: $!";my@files;while (defined (my$file=readdir DH)){my$full_path=File::Spec->catfile($dir,$file);next if -d $full_path;push@files,$full_path}return@files}sub share_dir {my$self=shift;my$p=$self->{properties};$p->{share_dir}=shift if @_;if (!defined$p->{share_dir}){return}elsif (!ref$p->{share_dir}){$p->{share_dir}={dist=>[$p->{share_dir}]}}elsif (ref$p->{share_dir}eq 'ARRAY'){$p->{share_dir}={dist=>$p->{share_dir}}}elsif (ref$p->{share_dir}eq 'HASH'){my$share_dir=$p->{share_dir};if (defined$share_dir->{dist}){if (!ref$share_dir->{dist}){$share_dir->{dist}=[$share_dir->{dist}]}elsif (ref$share_dir->{dist}ne 'ARRAY'){die "'dist' key in 'share_dir' must be scalar or arrayref"}}if (defined$share_dir->{module}){my$mod_hash=$share_dir->{module};if (ref$mod_hash eq 'HASH'){for my$k (sort keys %$mod_hash){if (!ref$mod_hash->{$k}){$mod_hash->{$k}=[$mod_hash->{$k}]}elsif(ref$mod_hash->{$k}ne 'ARRAY'){die "modules in 'module' key of 'share_dir' must be scalar or arrayref"}}}else {die "'module' key in 'share_dir' must be hashref"}}}else {die "'share_dir' must be hashref, arrayref or string"}return$p->{share_dir}}sub script_files {my$self=shift;for ($self->{properties}{script_files}){$_=shift if @_;next unless $_;return $_ if ref $_ eq 'HASH';return $_={map {$_,1}@$_ }if ref $_ eq 'ARRAY';die "'script_files' must be a hashref, arrayref, or string" if ref();return $_={map {$_,1}$self->_files_in($_)}if -d $_;return $_={$_=>1}}my%pl_files=map {File::Spec->canonpath($_)=>1}keys %{$self->PL_files || {}};my@bin_files=$self->_files_in('bin');my%bin_map=map {$_=>File::Spec->canonpath($_)}@bin_files;return $_={map {$_=>1}grep!$pl_files{$bin_map{$_}},@bin_files }}BEGIN {*scripts=\&script_files}{my%licenses=(perl=>'Perl_5',apache=>'Apache_2_0',apache_1_1=>'Apache_1_1',artistic=>'Artistic_1',artistic_2=>'Artistic_2',lgpl=>'LGPL_2_1',lgpl2=>'LGPL_2_1',lgpl3=>'LGPL_3_0',bsd=>'BSD',gpl=>'GPL_1',gpl2=>'GPL_2',gpl3=>'GPL_3',mit=>'MIT',mozilla=>'Mozilla_1_1',restrictive=>'Restricted',open_source=>undef,unrestricted=>undef,unknown=>undef,);my%license_urls=(perl=>'http://dev.perl.org/licenses/',apache=>'http://apache.org/licenses/LICENSE-2.0',apache_1_1=>'http://apache.org/licenses/LICENSE-1.1',artistic=>'http://opensource.org/licenses/artistic-license.php',artistic_2=>'http://opensource.org/licenses/artistic-license-2.0.php',lgpl=>'http://opensource.org/licenses/lgpl-license.php',lgpl2=>'http://opensource.org/licenses/lgpl-2.1.php',lgpl3=>'http://opensource.org/licenses/lgpl-3.0.html',bsd=>'http://opensource.org/licenses/bsd-license.php',gpl=>'http://opensource.org/licenses/gpl-license.php',gpl2=>'http://opensource.org/licenses/gpl-2.0.php',gpl3=>'http://opensource.org/licenses/gpl-3.0.html',mit=>'http://opensource.org/licenses/mit-license.php',mozilla=>'http://opensource.org/licenses/mozilla1.1.php',restrictive=>undef,open_source=>undef,unrestricted=>undef,unknown=>undef,);sub valid_licenses {return \%licenses}sub _license_url {return$license_urls{$_[1]}}}sub _software_license_class {my ($self,$license)=@_;if ($self->valid_licenses->{$license}&& eval {require Software::LicenseUtils;Software::LicenseUtils->VERSION(0.103009)}){my@classes=Software::LicenseUtils->guess_license_from_meta_key($license,1);if (@classes==1){eval "require $classes[0]";return$classes[0]}}LICENSE: for my$l ($self->valid_licenses->{$license },$license){next unless defined$l;my$trial="Software::License::" .$l;if (eval "require Software::License; Software::License->VERSION(0.014); require $trial; 1"){return$trial}}return}sub _software_license_object {my ($self)=@_;return unless defined(my$license=$self->license);my$class=$self->_software_license_class($license)or return;my$author=join(" & ",@{$self->dist_author})|| 'unknown';my$sl=eval {$class->new({holder=>$author})};if ($@){$self->log_warn("Error getting '$class' object: $@")}return$sl}sub _hash_merge {my ($self,$h,$k,$v)=@_;if (ref$h->{$k}eq 'ARRAY'){push @{$h->{$k}},ref$v ? @$v : $v}elsif (ref$h->{$k}eq 'HASH'){$h->{$k}{$_}=$v->{$_}foreach keys %$v}else {$h->{$k}=$v}}sub ACTION_distmeta {my ($self)=@_;$self->do_create_makefile_pl if$self->create_makefile_pl;$self->do_create_readme if$self->create_readme;$self->do_create_license if$self->create_license;$self->do_create_metafile}sub do_create_metafile {my$self=shift;return if$self->{wrote_metadata};my$p=$self->{properties};unless ($p->{license}){$self->log_warn("No license specified, setting license = 'unknown'\n");$p->{license}='unknown'}my@metafiles=($self->metafile,$self->metafile2);$self->delete_filetree($_)for@metafiles;local@INC=@INC;if (($self->module_name || '')eq 'Module::Build'){$self->depends_on('config_data');push@INC,File::Spec->catdir($self->blib,'lib')}my$meta_obj=$self->_get_meta_object(quiet=>1,fatal=>1,auto=>1);my@created=$self->_write_meta_files($meta_obj,'META');if (@created){$self->{wrote_metadata}=1;$self->_add_to_manifest('MANIFEST',$_)for@created}return 1}sub _write_meta_files {my$self=shift;my ($meta,$file)=@_;$file =~ s{\.(?:yml|json)$}{};my@created;push@created,"$file\.yml" if$meta && $meta->save("$file\.yml",{version=>"1.4"});push@created,"$file\.json" if$meta && $meta->save("$file\.json");if (@created){$self->log_info("Created " .join(" and ",@created)."\n")}return@created}sub _get_meta_object {my$self=shift;my%args=@_;return unless$self->try_require("CPAN::Meta","2.142060");my$meta;eval {my$data=$self->get_metadata(fatal=>$args{fatal},auto=>$args{auto},);$data->{dynamic_config}=$args{dynamic}if defined$args{dynamic};$meta=CPAN::Meta->create($data)};if ($@ &&!$args{quiet}){$self->log_warn("Could not get valid metadata. Error is: $@\n")}return$meta}sub read_metafile {my$self=shift;my ($metafile)=@_;return unless$self->try_require("CPAN::Meta","2.110420");my$meta=CPAN::Meta->load_file($metafile);return$meta->as_struct({version=>"2.0"})}sub normalize_version {my ($self,$version)=@_;$version=0 unless defined$version and length$version;if ($version =~ /[=<>!,]/){}elsif (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version}my%prereq_map=(requires=>[qw/runtime requires/],configure_requires=>[qw/configure requires/],build_requires=>[qw/build requires/ ],test_requires=>[qw/test requires/ ],test_recommends=>[qw/test recommends/ ],recommends=>[qw/runtime recommends/ ],conflicts=>[qw/runtime conflicts/ ],);sub _normalize_prereqs {my ($self)=@_;my$p=$self->{properties};my%prereq_types;for my$type ('configure_requires',@{$self->prereq_action_types}){if (exists$p->{$type}and keys %{$p->{$type}}){my ($phase,$relation)=@{$prereq_map{$type}};for my$mod (keys %{$p->{$type}}){$prereq_types{$phase}{$relation}{$mod}=$self->normalize_version($p->{$type}{$mod})}}}return \%prereq_types}sub _get_license {my$self=shift;my$license=$self->license;my ($meta_license,$meta_license_url);my$valid_licenses=$self->valid_licenses();if (my$sl=$self->_software_license_object){$meta_license=$sl->meta2_name;$meta_license_url=$sl->url}elsif (exists$valid_licenses->{$license}){$meta_license=$valid_licenses->{$license}? lc$valid_licenses->{$license}: $license;$meta_license_url=$self->_license_url($license)}else {$self->log_warn("Can not determine license type for '" .$self->license ."'\nSetting META license field to 'unknown'.\n");$meta_license='unknown'}return ($meta_license,$meta_license_url)}sub get_metadata {my ($self,%args)=@_;my$fatal=$args{fatal}|| 0;my$p=$self->{properties};$self->auto_config_requires if$args{auto};for my$f (qw(dist_name dist_version dist_author dist_abstract license)){my$field=$self->$f();unless (defined$field and length$field){my$err="ERROR: Missing required field '$f' for metafile\n";if ($fatal){die$err}else {$self->log_warn($err)}}}my%metadata=(name=>$self->dist_name,version=>$self->normalize_version($self->dist_version),author=>$self->dist_author,abstract=>$self->dist_abstract,generated_by=>"Module::Build version $Module::Build::VERSION",'meta-spec'=>{version=>'2',url=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec',},dynamic_config=>exists$p->{dynamic_config}? $p->{dynamic_config}: 1,release_status=>$self->release_status,);my ($meta_license,$meta_license_url)=$self->_get_license;$metadata{license}=[$meta_license ];$metadata{resources}{license}=[$meta_license_url ]if defined$meta_license_url;$metadata{prereqs}=$self->_normalize_prereqs;if (exists$p->{no_index}){$metadata{no_index}=$p->{no_index}}elsif (my$pkgs=eval {$self->find_dist_packages}){$metadata{provides}=$pkgs if %$pkgs}else {$self->log_warn("$@\nWARNING: Possible missing or corrupt 'MANIFEST' file.\n" ."Nothing to enter for 'provides' field in metafile.\n")}if (my$add=$self->meta_add){if (not exists$add->{'meta-spec'}or $add->{'meta-spec'}{version}!=2){require CPAN::Meta::Converter;if (CPAN::Meta::Converter->VERSION('2.141170')){$add=CPAN::Meta::Converter->new($add)->upgrade_fragment;delete$add->{prereqs}}else {$self->log_warn("Can't meta_add without CPAN::Meta 2.141170")}}while (my($k,$v)=each %{$add}){$metadata{$k}=$v}}if (my$merge=$self->meta_merge){if (eval {require CPAN::Meta::Merge}){%metadata=%{CPAN::Meta::Merge->new(default_version=>'1.4')->merge(\%metadata,$merge)}}else {$self->log_warn("Can't merge without CPAN::Meta::Merge")}}return \%metadata}sub prepare_metadata {my ($self,$node,$keys,$args)=@_;unless (ref$node eq 'HASH'){croak "prepare_metadata() requires a hashref argument to hold output\n"}croak 'Keys argument to prepare_metadata is no longer supported' if$keys;%{$node}=%{$self->get_meta(%{$args})};return$node}sub _read_manifest {my ($self,$file)=@_;return undef unless -e $file;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);return scalar ExtUtils::Manifest::maniread($file)}sub find_dist_packages {my$self=shift;my$manifest=$self->_read_manifest('MANIFEST')or die "Can't find dist packages without a MANIFEST file\nRun 'Build manifest' to generate one\n";my%dist_files=map {$self->localize_file_path($_)=>$_}keys %$manifest;my@pm_files=sort grep {$_ !~ m{^t}}grep {exists$dist_files{$_}}keys %{$self->find_pm_files};return$self->find_packages_in_files(\@pm_files,\%dist_files)}sub find_packages_in_files {my ($self,$file_list,$filename_map)=@_;my(%prime,%alt);for my$file (@{$file_list}){my$mapped_filename=$filename_map->{$file};my@path=split(/\//,$mapped_filename);(my$prime_package=join('::',@path[1..$#path]))=~ s/\.pm$//;my$pm_info=Module::Metadata->new_from_file($file);for my$package ($pm_info->packages_inside){next if$package eq 'main';next if$package eq 'DB';next if grep /^_/,split(/::/,$package);my$version=$pm_info->version($package);if ($package eq $prime_package){if (exists($prime{$package})){die "Unexpected conflict in '$package'; multiple versions found.\n"}else {$prime{$package}{file}=$mapped_filename;$prime{$package}{version}=$version if defined($version)}}else {push(@{$alt{$package}},{file=>$mapped_filename,version=>$version,})}}}for my$package (sort keys(%alt)){my$result=$self->_resolve_module_versions($alt{$package});if (exists($prime{$package})){if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" .$result->{err})}elsif (defined($result->{version})){if (exists($prime{$package}{version})&& defined($prime{$package}{version})){if ($self->compare_versions($prime{$package}{version},'!=',$result->{version})){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" ."  $result->{file} ($result->{version})\n")}}else {$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}}}else {}}else {if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" .$result->{err})}$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}if defined($result->{version})}}for my$provides (values%prime){if ($provides->{version}){$provides->{version}=$self->normalize_version($provides->{version})}else {delete$provides->{version}}}return \%prime}sub _resolve_module_versions {my$self=shift;my$packages=shift;my($file,$version);my$err='';for my$p (@$packages){if (defined($p->{version})){if (defined($version)){if ($self->compare_versions($version,'!=',$p->{version})){$err .= "  $p->{file} ($p->{version})\n"}else {}}else {$file=$p->{file};$version=$p->{version}}}$file ||= $p->{file}if defined($p->{file})}if ($err){$err="  $file ($version)\n" .$err}my%result=(file=>$file,version=>$version,err=>$err);return \%result}sub make_tarball {my ($self,$dir,$file)=@_;$file ||= $dir;$self->log_info("Creating $file.tar.gz\n");if ($self->{args}{tar}){my$tar_flags=$self->verbose ? 'cvf' : 'cf';$self->do_system($self->split_like_shell($self->{args}{tar}),$tar_flags,"$file.tar",$dir);$self->do_system($self->split_like_shell($self->{args}{gzip}),"$file.tar")if$self->{args}{gzip}}else {eval {require Archive::Tar && Archive::Tar->VERSION(1.09);1}or die "You must install Archive::Tar 1.09+ to make a distribution tarball\n"."or specify a binary tar program with the '--tar' option.\n"."See the documentation for the 'dist' action.\n";my$files=$self->rscan_dir($dir);$Archive::Tar::DO_NOT_USE_PREFIX=(grep {length($_)>= 100}@$files)? 0 : 1;my$tar=Archive::Tar->new;$tar->add_files(@$files);for my$f ($tar->get_files){$f->mode($f->mode & ~022)}$tar->write("$file.tar.gz",1)}}sub install_path {my$self=shift;my($type,$value)=(@_,'<empty>');Carp::croak('Type argument missing')unless defined($type);my$map=$self->{properties}{install_path};return$map unless @_;unless (defined($value)){delete($map->{$type});return undef}if ($value eq '<empty>'){return undef unless exists$map->{$type};return$map->{$type}}return$map->{$type}=$value}sub install_sets {my ($self,$dirs,$key,$value)=@_;$dirs=$self->installdirs unless defined$dirs;if (@_==4 && defined$dirs && defined$key){$self->{properties}{install_sets}{$dirs}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{install_sets},$self->_default_install_paths->{install_sets})};if (defined$dirs && defined$key){return$map->{$dirs}{$key}}elsif (defined$dirs){return$map->{$dirs}}else {croak "Can't determine installdirs for install_sets()"}}sub original_prefix {my ($self,$key,$value)=@_;if (@_==3 && defined$key){$self->{properties}{original_prefix}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{original_prefix},$self->_default_install_paths->{original_prefix})};return$map unless defined$key;return$map->{$key}}sub install_base_relpaths {my$self=shift;if (@_ > 1){$self->_set_relpaths($self->{properties}{install_base_relpaths},@_)}my$map={$self->_merge_arglist($self->{properties}{install_base_relpaths},$self->_default_install_paths->{install_base_relpaths})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub prefix_relpaths {my$self=shift;my$installdirs=shift || $self->installdirs or croak "Can't determine installdirs for prefix_relpaths()";if (@_ > 1){$self->{properties}{prefix_relpaths}{$installdirs}||= {};$self->_set_relpaths($self->{properties}{prefix_relpaths}{$installdirs},@_)}my$map={$self->_merge_arglist($self->{properties}{prefix_relpaths}{$installdirs},$self->_default_install_paths->{prefix_relpaths}{$installdirs})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub _set_relpaths {my$self=shift;my($map,$type,$value)=@_;Carp::croak('Type argument missing')unless defined($type);if (!defined($value)){$map->{$type}=undef;return}else {Carp::croak("Value must be a relative path")if File::Spec::Unix->file_name_is_absolute($value);my@value=split(/\//,$value);$map->{$type}=\@value}}sub prefix_relative {my ($self,$type)=@_;my$installdirs=$self->installdirs;my$relpath=$self->install_sets($installdirs)->{$type};return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type,)}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m|/$|;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined($path)&& length($path);if(!defined($path)|| (length($path)==0)){$self->log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->log_verbose("    now $path in $rprefix\n");return$path}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return$default}}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,$relpath): undef}if ($self->prefix){my$relpath=$self->prefix_relative($type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs)->{$type}}sub install_types {my$self=shift;my%types;if ($self->install_base){%types=%{$self->install_base_relpaths}}elsif ($self->prefix){%types=%{$self->prefix_relpaths}}else {%types=%{$self->install_sets($self->installdirs)}}%types=(%types,%{$self->install_path});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my(%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push(@skipping,$type)}}$self->log_warn("WARNING: Can't figure out install path for types: @skipping\n" ."Files will not be installed.\n")if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}sub depends_on {my$self=shift;for my$action (@_){$self->_call_action($action)}}sub rscan_dir {my ($self,$dir,$pattern)=@_;my@result;local $_;my$subr=!$pattern ? sub {push@result,$File::Find::name}: !ref($pattern)|| (ref$pattern eq 'Regexp')? sub {push@result,$File::Find::name if /$pattern/}: ref($pattern)eq 'CODE' ? sub {push@result,$File::Find::name if$pattern->()}: die "Unknown pattern type";File::Find::find({wanted=>$subr,no_chdir=>1,preprocess=>sub {sort @_}},$dir);return \@result}sub delete_filetree {my$self=shift;my$deleted=0;for (@_){next unless -e $_;$self->log_verbose("Deleting $_\n");File::Path::rmtree($_,0,0);die "Couldn't remove '$_': $!\n" if -e $_;$deleted++}return$deleted}sub autosplit_file {my ($self,$file,$to)=@_;require AutoSplit;my$dir=File::Spec->catdir($to,'lib','auto');AutoSplit::autosplit($file,$dir)}sub cbuilder {my$self=shift;my$s=$self->{stash};return$s->{_cbuilder}if$s->{_cbuilder};require ExtUtils::CBuilder;return$s->{_cbuilder}=ExtUtils::CBuilder->new(config=>$self->config,($self->quiet ? (quiet=>1): ()),)}sub have_c_compiler {my ($self)=@_;my$p=$self->{properties};return$p->{_have_c_compiler}if defined$p->{_have_c_compiler};$self->log_verbose("Checking if compiler tools configured... ");my$b=$self->cbuilder;my$have=$b && eval {$b->have_compiler};$self->log_verbose($have ? "ok.\n" : "failed.\n");return$p->{_have_c_compiler}=$have}sub compile_c {my ($self,$file,%args)=@_;if (!$self->have_c_compiler){die "Error: no compiler detected to compile '$file'.  Aborting\n"}my$b=$self->cbuilder;my$obj_file=$b->object_file($file);$self->add_to_cleanup($obj_file);return$obj_file if$self->up_to_date($file,$obj_file);$b->compile(source=>$file,defines=>$args{defines},object_file=>$obj_file,include_dirs=>$self->include_dirs,extra_compiler_flags=>$self->extra_compiler_flags,);return$obj_file}sub link_c {my ($self,$spec)=@_;my$p=$self->{properties};$self->add_to_cleanup($spec->{lib_file});my$objects=$p->{objects}|| [];return$spec->{lib_file}if$self->up_to_date([$spec->{obj_file},@$objects],$spec->{lib_file});my$module_name=$spec->{module_name}|| $self->module_name;$self->cbuilder->link(module_name=>$module_name,objects=>[$spec->{obj_file},@$objects],lib_file=>$spec->{lib_file},extra_linker_flags=>$self->extra_linker_flags);return$spec->{lib_file}}sub compile_xs {my ($self,$file,%args)=@_;$self->log_verbose("$file -> $args{outfile}\n");if (eval {require ExtUtils::ParseXS;1}){ExtUtils::ParseXS::process_file(filename=>$file,prototypes=>0,output=>$args{outfile},)}else {my$xsubpp=Module::Metadata->find_module_by_name('ExtUtils::xsubpp')or die "Can't find ExtUtils::xsubpp in INC (@INC)";my@typemaps;push@typemaps,Module::Metadata->find_module_by_name('ExtUtils::typemap',\@INC);my$lib_typemap=Module::Metadata->find_module_by_name('typemap',[File::Basename::dirname($file),File::Spec->rel2abs('.')]);push@typemaps,$lib_typemap if$lib_typemap;@typemaps=map {+'-typemap',$_}@typemaps;my$cf=$self->{config};my$perl=$self->{properties}{perl};my@command=($perl,"-I".$cf->get('installarchlib'),"-I".$cf->get('installprivlib'),$xsubpp,'-noprototypes',@typemaps,$file);$self->log_info("@command\n");open(my$fh,'>',$args{outfile})or die "Couldn't write $args{outfile}: $!";print {$fh}$self->_backticks(@command);close$fh}}sub split_like_shell {my ($self,$string)=@_;return ()unless defined($string);return @$string if ref$string eq 'ARRAY';$string =~ s/^\s+|\s+$//g;return ()unless length($string);return Text::ParseWords::shellwords($string)}sub oneliner {my($self,$cmd,$switches,$args)=@_;$switches=[]unless defined$switches;$args=[]unless defined$args;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;return$self->_quote_args($perl,@$switches,'-e',$cmd,@$args)}sub run_perl_script {my ($self,$script,$preargs,$postargs)=@_;for ($preargs,$postargs){$_=[$self->split_like_shell($_)]unless ref()}return$self->run_perl_command([@$preargs,$script,@$postargs])}sub run_perl_command {my ($self,$args)=@_;$args=[$self->split_like_shell($args)]unless ref($args);my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;local$ENV{PERL5LIB}=join$self->config('path_sep'),$self->_added_to_INC;return$self->do_system($perl,@$args)}sub _infer_xs_spec {my$self=shift;my$file=shift;my$cf=$self->{config};my%spec;my($v,$d,$f)=File::Spec->splitpath($file);my@d=File::Spec->splitdir($d);(my$file_base=$f)=~ s/\.[^.]+$//i;$spec{base_name}=$file_base;$spec{src_dir}=File::Spec->catpath($v,$d,'');shift(@d)while@d && ($d[0]eq 'lib' || $d[0]eq '');pop(@d)while@d && $d[-1]eq '';$spec{module_name}=join('::',(@d,$file_base));$spec{archdir}=File::Spec->catdir($self->blib,'arch','auto',@d,$file_base);$spec{c_file}=File::Spec->catfile($spec{src_dir},"${file_base}.c");$spec{obj_file}=File::Spec->catfile($spec{src_dir},"${file_base}".$cf->get('obj_ext'));require DynaLoader;my$modfname=defined&DynaLoader::mod2fname ? DynaLoader::mod2fname([@d,$file_base]): $file_base;$spec{bs_file}=File::Spec->catfile($spec{archdir},"$modfname.bs");$spec{lib_file}=File::Spec->catfile($spec{archdir},"$modfname.".$cf->get('dlext'));return \%spec}sub process_xs {my ($self,$file)=@_;my$spec=$self->_infer_xs_spec($file);(my$file_base=$file)=~ s/\.[^.]+$//;$self->add_to_cleanup($spec->{c_file});unless ($self->up_to_date($file,$spec->{c_file})){$self->compile_xs($file,outfile=>$spec->{c_file})}my$v=$self->dist_version;$self->compile_c($spec->{c_file},defines=>{VERSION=>qq{"$v"},XS_VERSION=>qq{"$v"}});File::Path::mkpath($spec->{archdir},0,oct(777))unless -d $spec->{archdir};$self->add_to_cleanup($spec->{bs_file});unless ($self->up_to_date($file,$spec->{bs_file})){require ExtUtils::Mkbootstrap;$self->log_info("ExtUtils::Mkbootstrap::Mkbootstrap('$spec->{bs_file}')\n");ExtUtils::Mkbootstrap::Mkbootstrap($spec->{bs_file});open(my$fh,'>>',$spec->{bs_file});utime((time)x2,$spec->{bs_file})}$self->link_c($spec)}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my%seen;my$sep=$self->config('path_sep');local$ENV{PERL5LIB}=(!exists($ENV{PERL5LIB})? '' : length($ENV{PERL5LIB})< 500 ? $ENV{PERL5LIB}: join$sep,grep {!$seen{$_}++ and -d $_}split($sep,$ENV{PERL5LIB}));my$status=system(@cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub copy_if_modified {my$self=shift;my%args=(@_ > 3 ? (@_): (from=>shift,to_dir=>shift,flatten=>shift));$args{verbose}=!$self->quiet unless exists$args{verbose};my$file=$args{from};unless (defined$file and length$file){die "No 'from' parameter given to copy_if_modified"}$args{flatten}=1 if File::Spec->file_name_is_absolute($file);my$to_path;if (defined$args{to}and length$args{to}){$to_path=$args{to}}elsif (defined$args{to_dir}and length$args{to_dir}){$to_path=File::Spec->catfile($args{to_dir},$args{flatten}? File::Basename::basename($file): $file)}else {die "No 'to' or 'to_dir' parameter given to copy_if_modified"}return if$self->up_to_date($file,$to_path);{local$self->{properties}{quiet}=1;$self->delete_filetree($to_path)}File::Path::mkpath(File::Basename::dirname($to_path),0,oct(777));$self->log_verbose("Copying $file -> $to_path\n");if ($^O eq 'os2'){chmod 0666,$to_path;File::Copy::syscopy($file,$to_path,0x1)or die "Can't copy('$file', '$to_path'): $!"}else {File::Copy::copy($file,$to_path)or die "Can't copy('$file', '$to_path'): $!"}my$mode=oct(444)| ($self->is_executable($file)? oct(111): 0);chmod($mode,$to_path);return$to_path}sub up_to_date {my ($self,$source,$derived)=@_;$source=[$source]unless ref$source;$derived=[$derived]unless ref$derived;return 0 if @$source &&!@$derived || grep {not -e}@$derived;my$most_recent_source=time / (24*60*60);for my$file (@$source){unless (-e $file){$self->log_warn("Can't find source file $file for up-to-date check");next}$most_recent_source=-M _ if -M _ < $most_recent_source}for my$derived (@$derived){return 0 if -M $derived > $most_recent_source}return 1}sub dir_contains {my ($self,$first,$second)=@_;($first,$second)=map File::Spec->canonpath($_),($first,$second);my@first_dirs=File::Spec->splitdir($first);my@second_dirs=File::Spec->splitdir($second);return 0 if@second_dirs < @first_dirs;my$is_same=($self->_case_tolerant ? sub {lc(shift())eq lc(shift())}: sub {shift()eq shift()});while (@first_dirs){return 0 unless$is_same->(shift@first_dirs,shift@second_dirs)}return 1}1;
  
  ERRORS/WARNINGS FOUND IN PREREQUISITES.  You may wish to install the versions
  of the modules indicated above before proceeding with this installation
  
  EOF
  * FATAL ERROR: Perl interpreter mismatch. Configuration was initially
    created with '$self->{properties}{perl}'
    but we are now using '$perl'.  You must
    run 'Build realclean' or 'make realclean' and re-configure.
  DIEFATAL
  * WARNING: Configuration was initially created with Module::Build
    version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
    If errors occur, you must re-run the Build.PL or Makefile.PL script.
  MISMATCH
  ERROR: This build seems to be unattended, but there is no default value
  for this question.  Aborting.
  EOF
  package $opts{class};
  use $pack;
  \@ISA = qw($pack);
  $opts{code}
  1;
  EOF
  No 'module_name' was provided and it could not be inferred
  from other properties.  This will prevent a packlist from
  being written for this file.  Please set either 'module_name'
  or 'dist_version_from' in Build.PL.
  END_WARN
  Bundling in inc/ is disabled because ExtUtils::Installed could not
  create a list of your installed modules.  Here is the error:
  $@
  EUI_ERROR
  Could not find a packlist for '$mod'.  If it's a core module, try
  force installing it from CPAN.
  NO_PACKLIST
  Module::Build was not found in configure_requires! Adding it now
  automatically as: configure_requires => { 'Module::Build' => $ver }
  EOM
  Warning: ExtUtils::CBuilder not installed or no compiler detected
  Proceeding with configuration, but compilation may fail during Build
  
  EOM
      if ($INC[-1] ne '.') {
          push @INC, '.';
      }
  END
  $shebang
  
  use strict;
  use Cwd;
  use File::Basename;
  use File::Spec;
  
  sub magic_number_matches {
    return 0 unless -e '$q{magic_numfile}';
    my \$FH;
    open \$FH, '<','$q{magic_numfile}' or return 0;
    my \$filenum = <\$FH>;
    close \$FH;
    return \$filenum == $magic_number;
  }
  
  my \$progname;
  my \$orig_dir;
  BEGIN {
    \$^W = 1;  # Use warnings
    \$progname = basename(\$0);
    \$orig_dir = Cwd::cwd();
    my \$base_dir = '$q{base_dir}';
    if (!magic_number_matches()) {
      unless (chdir(\$base_dir)) {
        die ("Couldn't chdir(\$base_dir), aborting\\n");
      }
      unless (magic_number_matches()) {
        die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\\n");
      }
    }
    unshift \@INC,
      (
  $quoted_INC
      );
  $dot_in_inc_code
  }
  
  close(*DATA) unless eof(*DATA); # ensure no open handles to this script
  
  use $build_package;
  Module::Build->VERSION(q{$config_requires});
  
  # Some platforms have problems setting \$^X in shebang contexts, fix it up here
  \$^X = Module::Build->find_perl_interpreter;
  
  if (-e 'Build.PL' and not $build_package->up_to_date('Build.PL', \$progname)) {
     warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\\n";
  }
  
  # This should have just enough arguments to be able to bootstrap the rest.
  my \$build = $build_package->resume (
    properties => {
      config_dir => '$q{config_dir}',
      orig_dir => \$orig_dir,
    },
  );
  
  \$build->dispatch;
  EOF
  
   Usage: $0 <action> --arg1=value --arg2=value ...
   Example: $0 test --verbose=1
  
   Actions defined:
  EOF
  Can't create LICENSE file: '$l' is not a valid license key
  or Software::License subclass;
  HERE
  Cannot create README: can't determine which file contains documentation;
  Must supply either 'dist_version_from', or 'module_name' parameter.
  EOF
  # Avoid configuration metadata file
  ^MYMETA\.
  
  # Avoid Module::Build generated and utility files.
  \bBuild$
  \bBuild.bat$
  \b_build
  \bBuild.COM$
  \bBUILD.COM$
  \bbuild.com$
  ^MANIFEST\.SKIP
  
  # Avoid archives of this distribution
  EOF
MODULE_BUILD_BASE

$fatpacked{"Module/Build/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COMPAT';
  package Module::Build::Compat;use strict;use warnings;our$VERSION='0.4229';use File::Basename ();use File::Spec;use Config;use Module::Build;use Module::Metadata;use version;use Data::Dumper;my%convert_installdirs=(PERL=>'core',SITE=>'site',VENDOR=>'vendor',);my%makefile_to_build=(TEST_VERBOSE=>'verbose',VERBINST=>'verbose',INC=>sub {map {(extra_compiler_flags=>$_)}Module::Build->split_like_shell(shift)},POLLUTE=>sub {(extra_compiler_flags=>'-DPERL_POLLUTE')},INSTALLDIRS=>sub {(installdirs=>$convert_installdirs{uc shift()})},LIB=>sub {my$lib=shift;my%config=(installprivlib=>$lib,installsitelib=>$lib,installarchlib=>"$lib/$Config{archname}",installsitearch=>"$lib/$Config{archname}");return map {(config=>"$_=$config{$_}")}sort keys%config},(map {my$name=$_;$name=>sub {my@ret=(config=>lc($name)."=" .shift);print STDERR "# Converted to @ret\n";return@ret}}qw(INSTALLARCHLIB INSTALLSITEARCH INSTALLVENDORARCH INSTALLPRIVLIB INSTALLSITELIB INSTALLVENDORLIB INSTALLBIN INSTALLSITEBIN INSTALLVENDORBIN INSTALLSCRIPT INSTALLSITESCRIPT INSTALLVENDORSCRIPT INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR)),map {$_,lc($_)}qw(DESTDIR PREFIX INSTALL_BASE UNINST),);my%macro_to_build=%makefile_to_build;delete$macro_to_build{LIB};sub _merge_prereq {my ($req,$breq)=@_;$req ||= {};$breq ||= {};for my$p ($req,$breq){for my$k (sort keys %$p){next if$k eq 'perl';my$v_obj=eval {version->new($p->{$k})};if (!defined$v_obj){die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n"}if ($v_obj->is_qv){my$proper_ver=$v_obj->numify;warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";$p->{$k}=$proper_ver}}}my$merge={%$req };for my$k (keys %$breq){my$v1=$merge->{$k}|| 0;my$v2=$breq->{$k};$merge->{$k}=$v1 > $v2 ? $v1 : $v2}return %$merge}sub create_makefile_pl {my ($package,$type,$build,%args)=@_;die "Don't know how to build Makefile.PL of type '$type'" unless$type =~ /^(small|passthrough|traditional)$/;if ($type eq 'passthrough'){$build->log_warn(<<"HERE")}my$fh;if ($args{fh}){$fh=$args{fh}}else {$args{file}||= 'Makefile.PL';local$build->{properties}{quiet}=1;$build->delete_filetree($args{file});open($fh,'>',"$args{file}")or die "Can't write $args{file}: $!"}print {$fh}"# Note: this file was auto-generated by ",__PACKAGE__," version $VERSION\n";my$requires=$build->requires;if (my$minimum_perl=$requires->{perl}){my$min_ver=version->new($minimum_perl)->numify;print {$fh}"require $min_ver;\n"}my$subclass_load='';if (ref($build)ne "Module::Build"){my$subclass_dir=$package->subclass_dir($build);if (File::Spec->file_name_is_absolute($subclass_dir)){my$base_dir=$build->base_dir;if ($build->dir_contains($base_dir,$subclass_dir)){$subclass_dir=File::Spec->abs2rel($subclass_dir,$base_dir);$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}else {$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}if ($type eq 'small'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'passthrough'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'traditional'){my (%MM_Args,%prereq);if (eval "use Tie::IxHash 1.2; 1"){tie%MM_Args,'Tie::IxHash';tie%prereq,'Tie::IxHash'}my%name=($build->module_name ? (NAME=>$build->module_name): (DISTNAME=>$build->dist_name));my%version=($build->dist_version_from ? (VERSION_FROM=>$build->dist_version_from): (VERSION=>$build->dist_version));%MM_Args=(%name,%version);%prereq=_merge_prereq($build->requires,$build->build_requires);%prereq=map {$_,$prereq{$_}}sort keys%prereq;delete$prereq{perl};$MM_Args{PREREQ_PM}=\%prereq;$MM_Args{INSTALLDIRS}=$build->installdirs eq 'core' ? 'perl' : $build->installdirs;$MM_Args{EXE_FILES}=[sort keys %{$build->script_files}]if$build->script_files;$MM_Args{PL_FILES}=$build->PL_files || {};if ($build->recursive_test_files){$MM_Args{test}={TESTS=>join q{ },$package->_test_globs($build)}}local$Data::Dumper::Terse=1;my$args=Data::Dumper::Dumper(\%MM_Args);$args =~ s/\{(.*)\}/($1)/s;print$fh <<"EOF"}}sub _test_globs {my ($self,$build)=@_;return map {File::Spec->catfile($_,'*.t')}@{$build->rscan_dir('t',sub {-d $File::Find::name})}}sub subclass_dir {my ($self,$build)=@_;return (Module::Metadata->find_module_dir_by_name(ref$build)|| File::Spec->catdir($build->config_dir,'lib'))}sub unixify_dir {my ($self,$path)=@_;return join '/',File::Spec->splitdir($path)}sub makefile_to_build_args {my$class=shift;my@out;for my$arg (@_){next if$arg eq '';my ($key,$val)=($arg =~ /^(\w+)=(.+)/ ? ($1,$2): die "Malformed argument '$arg'");($val)=Module::Build->_detildefy($val)if$val =~ /^~/;if (exists$makefile_to_build{$key}){my$trans=$makefile_to_build{$key};push@out,$class->_argvify(ref($trans)? $trans->($val): ($trans=>$val))}elsif (exists$Config{lc($key)}){push@out,$class->_argvify(config=>lc($key)."=$val")}else {push@out,$class->_argvify("\L$key"=>$val)}}return@out}sub _argvify {my ($self,@pairs)=@_;my@out;while (@pairs){my ($k,$v)=splice@pairs,0,2;push@out,("--$k",$v)}return@out}sub makefile_to_build_macros {my@out;my%config;for my$macro (sort keys%macro_to_build){my$trans=$macro_to_build{$macro};next unless exists$ENV{$macro}&& length$ENV{$macro};my$val=$ENV{$macro};my@args=ref($trans)? $trans->($val): ($trans=>$val);while (@args){my ($k,$v)=splice(@args,0,2);if ($k eq 'config'){if ($v =~ /^([^=]+)=(.*)$/){$config{$1}=$2}else {warn "Couldn't parse config '$v'\n"}}else {push@out,($k=>$v)}}}push@out,(config=>\%config)if%config;return@out}sub run_build_pl {my ($pack,%in)=@_;$in{script}||= 'Build.PL';my@args=$in{args}? $pack->makefile_to_build_args(@{$in{args}}): ();print "# running $in{script} @args\n";Module::Build->run_perl_script($in{script},[],\@args)or die "Couldn't run $in{script}: $!"}sub fake_makefile {my ($self,%args)=@_;unless (exists$args{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$args{build_class}='Module::Build'}my$class=$args{build_class};my$perl=$class->find_perl_interpreter;$perl='MCR ' .$perl if$self->_is_vms_mms;my$noop=($class->is_windowsish ? 'rem>nul' : $self->_is_vms_mms ? 'Continue' : 'true');my$filetype=$class->is_vmsish ? '.COM' : '';my$Build='Build' .$filetype .' --makefile_env_macros 1';my$unlink=$class->oneliner('1 while unlink $ARGV[0]',[],[$args{makefile}]);$unlink =~ s/\$/\$\$/g unless$class->is_vmsish;my$maketext=join '',map {"$_=\n"}sort keys%macro_to_build;$maketext .= ($^O eq 'os2' ? "SHELL = sh\n\n" : $^O eq 'MSWin32' && $Config{make}=~ /gmake/ ? "SHELL = $ENV{COMSPEC}\n\n" : "\n\n");$maketext .= <<"EOF";for my$action ($class->known_actions){next if$action =~ /^(all|distclean|realclean|force_do_it)$/;$maketext .= <<"EOF"}if ($self->_is_vms_mms){$maketext .= "\n.FIRST\n\t\@ $noop\n";for my$macro (sort keys%macro_to_build){$maketext .= ".IFDEF $macro\n\tDEFINE $macro \"\$($macro)\"\n.ENDIF\n"}$maketext .= "\n"}else {$maketext .= "\n.EXPORT : " .join(' ',sort keys%macro_to_build)."\n\n"}return$maketext}sub fake_prereqs {my$file=File::Spec->catfile('_build','prereqs');open(my$fh,'<',"$file")or die "Can't read $file: $!";my$prereqs=eval do {local $/;<$fh>};close$fh;my%merged=_merge_prereq($prereqs->{requires},$prereqs->{build_requires});my@prereq;for (sort keys%merged){next if $_ eq 'perl';push@prereq,"$_=>q[$merged{$_}]"}return unless@prereq;return "#     PREREQ_PM => { " .join(", ",@prereq)." }\n\n"}sub write_makefile {my ($pack,%in)=@_;unless (exists$in{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$in{build_class}='Module::Build'}my$class=$in{build_class};$in{makefile}||= $pack->_is_vms_mms ? 'Descrip.MMS' : 'Makefile';open MAKE,"> $in{makefile}" or die "Cannot write $in{makefile}: $!";print MAKE$pack->fake_prereqs;print MAKE$pack->fake_makefile(%in);close MAKE}sub _is_vms_mms {return Module::Build->is_vmsish && ($Config{make}=~ m/MM[SK]/i)}1;
  
  IMPORTANT NOTE: The '$type' style of Makefile.PL is deprecated and
  may be removed in a future version of Module::Build in favor of the
  'configure_requires' property.  See Module::Build::Compat
  documentation for details.
  
  HERE
      use Module::Build::Compat 0.02;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
      unless (eval "use Module::Build::Compat 0.02; 1" ) {
        print "This module requires Module::Build to install itself.\n";
  
        require ExtUtils::MakeMaker;
        my $yn = ExtUtils::MakeMaker::prompt
  	('  Install Module::Build now from CPAN?', 'y');
  
        unless ($yn =~ /^y/i) {
  	die " *** Cannot install without Module::Build.  Exiting ...\n";
        }
  
        require Cwd;
        require File::Spec;
        require CPAN;
  
        # Save this 'cause CPAN will chdir all over the place.
        my $cwd = Cwd::cwd();
  
        CPAN::Shell->install('Module::Build::Compat');
        CPAN::Shell->expand("Module", "Module::Build::Compat")->uptodate
  	or die "Couldn't install Module::Build, giving up.\n";
  
        chdir $cwd or die "Cannot chdir() back to $cwd: $!";
      }
      eval "use Module::Build::Compat 0.02; 1" or die $@;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      my $build_script = 'Build';
      $build_script .= '.com' if $^O eq 'VMS';
      exit(0) unless(-e $build_script); # cpantesters convention
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  use ExtUtils::MakeMaker;
  WriteMakefile
  $args;
  EOF
  all : force_do_it
  	$perl $Build
  realclean : force_do_it
  	$perl $Build realclean
  	$unlink
  distclean : force_do_it
  	$perl $Build distclean
  	$unlink
  
  
  force_do_it :
  	@ $noop
  EOF
  $action : force_do_it
  	$perl $Build $action
  EOF
MODULE_BUILD_COMPAT

$fatpacked{"Module/Build/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIG';
  package Module::Build::Config;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Config;sub new {my ($pack,%args)=@_;return bless {stack=>{},values=>$args{values}|| {},},$pack}sub get {my ($self,$key)=@_;return$self->{values}{$key}if ref($self)&& exists$self->{values}{$key};return$Config{$key}}sub set {my ($self,$key,$val)=@_;$self->{values}{$key}=$val}sub push {my ($self,$key,$val)=@_;push @{$self->{stack}{$key}},$self->{values}{$key}if exists$self->{values}{$key};$self->{values}{$key}=$val}sub pop {my ($self,$key)=@_;my$val=delete$self->{values}{$key};if (exists$self->{stack}{$key}){$self->{values}{$key}=pop @{$self->{stack}{$key}};delete$self->{stack}{$key}unless @{$self->{stack}{$key}}}return$val}sub values_set {my$self=shift;return undef unless ref($self);return$self->{values}}sub all_config {my$self=shift;my$v=ref($self)? $self->{values}: {};return {%Config,%$v}}1;
MODULE_BUILD_CONFIG

$fatpacked{"Module/Build/ConfigData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIGDATA';
  package Module::Build::ConfigData;use strict;my$arrayref=eval do {local $/;<DATA>}or die "Couldn't load ConfigData data: $@";close DATA;my ($config,$features,$auto_features)=@$arrayref;sub config {$config->{$_[1]}}sub set_config {$config->{$_[1]}=$_[2]}sub set_feature {$features->{$_[1]}=0+!!$_[2]}sub auto_feature_names {sort grep!exists$features->{$_},keys %$auto_features}sub feature_names {my@features=(sort keys %$features,auto_feature_names());@features}sub config_names {sort keys %$config}sub write {my$me=__FILE__;require Data::Dumper;my$mode_orig=(stat$me)[2]& 07777;chmod($mode_orig | 0222,$me);open(my$fh,'+<',$me)or die "Can't rewrite $me: $!";seek($fh,0,0);while (<$fh>){last if /^__DATA__$/}die "Couldn't find __DATA__ token in $me" if eof($fh);seek($fh,tell($fh),0);my$data=[$config,$features,$auto_features];print($fh 'do{ my ' .Data::Dumper->new([$data],['x'])->Purity(1)->Dump().'$x; }');truncate($fh,tell($fh));close$fh;chmod($mode_orig,$me)or warn "Couldn't restore permissions on $me: $!"}sub feature {my ($package,$key)=@_;return$features->{$key}if exists$features->{$key};my$info=$auto_features->{$key}or return 0;require Module::Build;for my$type (sort keys %$info){my$prereqs=$info->{$type};next if$type eq 'description' || $type eq 'recommends';for my$modname (sort keys %$prereqs){my$status=Module::Build->check_installed_status($modname,$prereqs->{$modname});if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}__DATA__ do{ my $x = [
         {},
         {},
         {
           'HTML_support' => {
                               'description' => 'Create HTML documentation',
                               'requires' => {
                                               'Pod::Html' => 0
                                             }
                             },
           'PPM_support' => {
                              'description' => 'Generate PPM files for distributions'
                            },
           'dist_authoring' => {
                                 'description' => 'Create new distributions',
                                 'recommends' => {
                                                   'Module::Signature' => '0.21',
                                                   'Pod::Readme' => '0.04'
                                                 },
                                 'requires' => {
                                                 'Archive::Tar' => '1.09'
                                               }
                               },
           'inc_bundling_support' => {
                                       'description' => 'Bundle Module::Build in inc/',
                                       'requires' => {
                                                       'ExtUtils::Install' => '1.54',
                                                       'ExtUtils::Installed' => '1.999',
                                                       'inc::latest' => '0.5'
                                                     }
                                     },
           'license_creation' => {
                                   'description' => 'Create licenses automatically in distributions',
                                   'requires' => {
                                                   'Software::License' => '0.103009'
                                                 }
                                 },
           'manpage_support' => {
                                  'description' => 'Create Unix man pages',
                                  'requires' => {
                                                  'Pod::Man' => 0
                                                }
                                }
         }
       ];
  $x; }
MODULE_BUILD_CONFIGDATA

$fatpacked{"Module/Build/Cookbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COOKBOOK';
  package Module::Build::Cookbook;use strict;use warnings;our$VERSION='0.4229';
MODULE_BUILD_COOKBOOK

$fatpacked{"Module/Build/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_DUMPER';
  package Module::Build::Dumper;use strict;use warnings;our$VERSION='0.4229';use Data::Dumper;sub _data_dump {my ($self,$data)=@_;return ("do{ my " .Data::Dumper->new([$data],['x'])->Purity(1)->Terse(0)->Sortkeys(1)->Dump().'$x; }')}1;
MODULE_BUILD_DUMPER

$fatpacked{"Module/Build/Notes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_NOTES';
  package Module::Build::Notes;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Data::Dumper;use Module::Build::Dumper;sub new {my ($class,%args)=@_;my$file=delete$args{file}or die "Missing required parameter 'file' to new()";my$self=bless {disk=>{},new=>{},file=>$file,%args,},$class}sub restore {my$self=shift;open(my$fh,'<',$self->{file})or die "Can't read $self->{file}: $!";$self->{disk}=eval do {local $/;<$fh>};die $@ if $@;close$fh;$self->{new}={}}sub access {my$self=shift;return$self->read()unless @_;my$key=shift;return$self->read($key)unless @_;my$value=shift;$self->write({$key=>$value });return$self->read($key)}sub has_data {my$self=shift;return keys %{$self->read()}> 0}sub exists {my ($self,$key)=@_;return exists($self->{new}{$key})|| exists($self->{disk}{$key})}sub read {my$self=shift;if (@_){my$key=shift;return$self->{new}{$key}if exists$self->{new}{$key};return$self->{disk}{$key}}my$out=(keys %{$self->{new}}? {%{$self->{disk}},%{$self->{new}}}: $self->{disk});return wantarray ? %$out : $out}sub _same {my ($self,$x,$y)=@_;return 1 if!defined($x)and!defined($y);return 0 if!defined($x)or!defined($y);return$x eq $y}sub write {my ($self,$href)=@_;$href ||= {};@{$self->{new}}{keys %$href }=values %$href;for my$key (keys %{$self->{new}}){next if ref$self->{new}{$key};next if ref$self->{disk}{$key}or!exists$self->{disk}{$key};delete$self->{new}{$key}if$self->_same($self->{new}{$key},$self->{disk}{$key})}if (my$file=$self->{file}){my ($vol,$dir,$base)=File::Spec->splitpath($file);$dir=File::Spec->catpath($vol,$dir,'');return unless -e $dir && -d $dir;return if -e $file and!keys %{$self->{new}};@{$self->{disk}}{keys %{$self->{new}}}=values %{$self->{new}};$self->_dump($file,$self->{disk});$self->{new}={}}return$self->read}sub _dump {my ($self,$file,$data)=@_;open(my$fh,'>',$file)or die "Can't create '$file': $!";print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}my$orig_template=do {local $/;<DATA>};close DATA;sub write_config_data {my ($self,%args)=@_;my$template=$orig_template;$template =~ s/NOTES_NAME/$args{config_module}/g;$template =~ s/MODULE_NAME/$args{module}/g;$template =~ s/=begin private\n//;$template =~ s/=end private/=cut/;$template =~ s{$_\n}{} for '=begin private','=end private';open(my$fh,'>',$args{file})or die "Can't create '$args{file}': $!";print {$fh}$template;print {$fh}"\n__DATA__\n";print {$fh}Module::Build::Dumper->_data_dump([$args{config_data},$args{feature},$args{auto_features}]);close$fh}1;__DATA__ package NOTES_NAME;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  =begin private
  
  =head1 NAME
  
  NOTES_NAME - Configuration for MODULE_NAME
  
  =head1 SYNOPSIS
  
    use NOTES_NAME;
    $value = NOTES_NAME->config('foo');
    $value = NOTES_NAME->feature('bar');
  
    @names = NOTES_NAME->config_names;
    @names = NOTES_NAME->feature_names;
  
    NOTES_NAME->set_config(foo => $new_value);
    NOTES_NAME->set_feature(bar => $new_value);
    NOTES_NAME->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<MODULE_NAME>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<NOTES_NAME>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<NOTES_NAME>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<NOTES_NAME>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<NOTES_NAME> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<NOTES_NAME> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<NOTES_NAME>.
  
  =end private
  
MODULE_BUILD_NOTES

$fatpacked{"Module/Build/PPMMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PPMMAKER';
  package Module::Build::PPMMaker;use strict;use warnings;use Config;our$VERSION='0.4229';$VERSION=eval$VERSION;sub new {my$package=shift;return bless {@_},$package}sub make_ppd {my ($self,%args)=@_;my$build=delete$args{build};my@codebase;if (exists$args{codebase}){@codebase=ref$args{codebase}? @{$args{codebase}}: ($args{codebase})}else {my$distfile=$build->ppm_name .'.tar.gz';print "Using default codebase '$distfile'\n";@codebase=($distfile)}my%dist;for my$info (qw(name author abstract version)){my$method="dist_$info";$dist{$info}=$build->$method()or die "Can't determine distribution's $info\n"}$self->_simple_xml_escape($_)foreach$dist{abstract},@{$dist{author}};my$ppd=<<"PPD";for my$type (qw(requires)){my$prereq=$build->$type();for my$modname (sort keys %$prereq){next if$modname eq 'perl';my$min_version='0.0';for my$c ($build->_parse_conditions($prereq->{$modname})){my ($op,$version)=$c =~ /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x;if ($op eq '>='){$min_version=$version;last}}$modname .= '::' unless$modname =~ /::/;$ppd .= qq!        <REQUIRE NAME="$modname" VERSION="$min_version" />\n!}}if (keys %{$build->find_xs_files}){my$perl_version=$self->_ppd_version($build->perl_version);$ppd .= sprintf(<<'EOF',$self->_varchname($build->config))}for my$codebase (@codebase){$self->_simple_xml_escape($codebase);$ppd .= sprintf(<<'EOF',$codebase)}$ppd .= <<'EOF';my$ppd_file="$dist{name}.ppd";open(my$fh,'>',$ppd_file)or die "Cannot write to $ppd_file: $!";binmode($fh,":utf8")if $] >= 5.008 && $Config{useperlio};print$fh $ppd;close$fh;return$ppd_file}sub _ppd_version {my ($self,$version)=@_;return join ',',(split(/\./,$version),(0)x4)[0..3]}sub _varchname {my ($self,$config)=@_;my$varchname=$config->{archname};if ($] >= 5.008){my$vstring=sprintf "%vd",$^V;$vstring =~ s/\.\d+$//;$varchname .= "-$vstring"}return$varchname}{my%escapes=("\n"=>"\\n",'"'=>'&quot;','&'=>'&amp;','>'=>'&gt;','<'=>'&lt;',);my$rx=join '|',keys%escapes;sub _simple_xml_escape {$_[1]=~ s/($rx)/$escapes{$1}/go}}1;
  <SOFTPKG NAME=\"$dist{name}\" VERSION=\"$dist{version}\">
      <ABSTRACT>$dist{abstract}</ABSTRACT>
  @{[ join "\n", map "    <AUTHOR>$_</AUTHOR>", @{$dist{author}} ]}
      <IMPLEMENTATION>
  PPD
          <ARCHITECTURE NAME="%s" />
  EOF
          <CODEBASE HREF="%s" />
  EOF
      </IMPLEMENTATION>
  </SOFTPKG>
  EOF
MODULE_BUILD_PPMMAKER

$fatpacked{"Module/Build/Platform/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DEFAULT';
  package Module::Build::Platform::Default;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_DEFAULT

$fatpacked{"Module/Build/Platform/MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_MACOS';
  package Module::Build::Platform::MacOS;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);use ExtUtils::Install;sub have_forkpipe {0}sub new {my$class=shift;my$self=$class->SUPER::new(@_);for ('sitelib','sitearch'){$self->config($_=>$self->config("install$_"))unless$self->config($_)}(my$sp=$self->config('startperl'))=~ s/.*Exit \{Status\}\s//;$self->config(startperl=>$sp);return$self}sub make_executable {my$self=shift;require MacPerl;for (@_){MacPerl::SetFileInfo('McPL','TEXT',$_)}}sub dispatch {my$self=shift;if(!@_ and!@ARGV){require MacPerl;my@action_list=qw(build test install);my%actions=map {+($_,1)}$self->known_actions;delete@actions{@action_list};push@action_list,sort {$a cmp $b}keys%actions;my%toolserver=map {+$_=>1}qw(test disttest diff testdb);for (@action_list){$_ .= ' *' if$toolserver{$_}}my$cmd=MacPerl::Pick("What build command? ('*' requires ToolServer)",@action_list);return unless defined$cmd;$cmd =~ s/ \*$//;$ARGV[0]=($cmd);my$args=MacPerl::Ask('Any extra arguments?  (ie. verbose=1)','');return unless defined$args;push@ARGV,$self->split_like_shell($args)}$self->SUPER::dispatch(@_)}sub ACTION_realclean {my$self=shift;chmod 0666,$self->{properties}{build_script};$self->SUPER::ACTION_realclean}sub ACTION_install {my$self=shift;return$self->SUPER::ACTION_install(@_)if eval {ExtUtils::Install->VERSION('1.30');1};local $^W=0;local*ExtUtils::Install::find=sub {my ($code,@dirs)=@_;@dirs=map {$_ eq '.' ? File::Spec->curdir : $_}@dirs;return File::Find::find($code,@dirs)};return$self->SUPER::ACTION_install(@_)}1;
MODULE_BUILD_PLATFORM_MACOS

$fatpacked{"Module/Build/Platform/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_UNIX';
  package Module::Build::Platform::Unix;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub is_executable {my ($self,$file)=@_;return +(stat$file)[2]& 0100}sub _startperl {"#! " .shift()->perl}sub _construct {my$self=shift()->SUPER::_construct(@_);my$c=$self->{config};for (qw(siteman1 siteman3 vendorman1 vendorman3)){$c->{"install${_}dir"}||= $c->{"install${_}"}}return$self}sub _detildefy {my ($self,$value)=@_;$value =~ s[^~([^/]+)?(?=/|$)]   # tilde with optional username [$1 ? (eval{(getpwnam $1)[7]}|| "~$1"): ($ENV{HOME}|| eval{(getpwuid $>)[7]}|| glob("~"))]ex;return$value}1;
MODULE_BUILD_PLATFORM_UNIX

$fatpacked{"Module/Build/Platform/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VMS';
  package Module::Build::Platform::VMS;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;use Config;our@ISA=qw(Module::Build::Base);sub _set_defaults {my$self=shift;$self->SUPER::_set_defaults(@_);$self->{properties}{build_script}='Build.com'}sub cull_args {my$self=shift;my($action,$args)=$self->SUPER::cull_args(@_);my@possible_actions=grep {lc $_ eq lc$action}$self->known_actions;die "Ambiguous action '$action'.  Could be one of @possible_actions" if@possible_actions > 1;return ($possible_actions[0],$args)}sub manpage_separator {return '__'}sub _catprefix {my($self,$rprefix,$default)=@_;my($rvol,$rdirs)=File::Spec->splitpath($rprefix);if($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->log_verbose("  rprefix translated to $rprefix\n"."  sprefix translated to $sprefix\n");if(length($path)==0){$self->log_verbose("  no path to prefixify.\n")}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($sprefix eq $rprefix){$self->log_verbose("  no new prefix.\n")}else {my($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config('vms_prefix');if($path_vol eq $vms_prefix.':'){$self->log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix($rprefix,$path_dirs)}else {$self->log_verbose("    cannot prefixify.\n");return$self->prefix_relpaths($self->installdirs,$type)}}$self->log_verbose("    now $path\n");return$path}sub _quote_args {my ($self,@args)=@_;my$got_arrayref=(scalar(@args)==1 && ref$args[0]eq 'ARRAY')? 1 : 0;map {if (!/^\//){$_ =~ s/\"/""/g;$_=q(").$_.q(")}}($got_arrayref ? @{$args[0]}: @args);return$got_arrayref ? $args[0]: join(' ',@args)}sub have_forkpipe {0}sub _backticks {my ($self,@cmd)=@_;my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return `$cmd $args`}sub find_command {my ($self,$command)=@_;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}$self->SUPER::find_command($command)}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d _;my(@dirs)=('');my(@exts)=('',$Config{'exe_ext'},'.exe','.com');if ($file !~ m![/:>\]]!){for (my$i=0;defined$ENV{"DCL\$PATH;$i"};$i++){my$dir=$ENV{"DCL\$PATH;$i"};$dir .= ':' unless$dir =~ m%[\]:]$%;push(@dirs,$dir)}push(@dirs,'Sys$System:');for my$dir (@dirs){my$sysfile="$dir$file";for my$ext (@exts){return$file if -x "$sysfile$ext" &&!-d _}}}return}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return!system("$cmd $args")}sub oneliner {my$self=shift;my$oneliner=$self->SUPER::oneliner(@_);$oneliner =~ s/^\"\S+\"//;return "MCR $^X $oneliner"}sub rscan_dir {my ($self,$dir,$pattern)=@_;my$result=$self->SUPER::rscan_dir($dir,$pattern);for my$file (@$result){if (!_efs()&& ($file =~ m#/#)){$file =~ s/\.$//}}return$result}sub dist_dir {my$self=shift;my$dist_dir=$self->SUPER::dist_dir;$dist_dir =~ s/\./_/g unless _efs();return$dist_dir}sub man3page_name {my$self=shift;my$mpname=$self->SUPER::man3page_name(shift);my$sep=$self->manpage_separator;$mpname =~ s/^$sep//;return$mpname}sub expand_test_dir {my ($self,$dir)=@_;my@reldirs=$self->SUPER::expand_test_dir($dir);for my$eachdir (@reldirs){my ($v,$d,$f)=File::Spec->splitpath($eachdir);my$reldir=File::Spec->abs2rel(File::Spec->catpath($v,$d,''));$eachdir=File::Spec->catfile($reldir,$f)}return@reldirs}sub _detildefy {my ($self,$arg)=@_;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}sub find_perl_interpreter {return VMS::Filespec::vmsify($^X)}sub localize_file_path {my ($self,$path)=@_;$path=VMS::Filespec::vmsify($path);$path =~ s/\.\z//;return$path}sub localize_dir_path {my ($self,$path)=@_;return VMS::Filespec::vmspath($path)}sub ACTION_clean {my ($self)=@_;for my$item (map glob(VMS::Filespec::rmsexpand($_,'.;0')),$self->cleanup){$self->delete_filetree($item)}}my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _efs {my$efs;if ($use_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}1;
MODULE_BUILD_PLATFORM_VMS

$fatpacked{"Module/Build/Platform/VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VOS';
  package Module::Build::Platform::VOS;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_VOS

$fatpacked{"Module/Build/Platform/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_WINDOWS';
  package Module::Build::Platform::Windows;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Config;use File::Basename;use File::Spec;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub manpage_separator {return '.'}sub have_forkpipe {0}sub _detildefy {my ($self,$value)=@_;$value =~ s,^~(?= [/\\] | $ ),$ENV{HOME},x if$ENV{HOME};return$value}sub ACTION_realclean {my ($self)=@_;$self->SUPER::ACTION_realclean();my$basename=basename($0);$basename =~ s/(?:\.bat)?$//i;if (lc$basename eq lc$self->build_script){if ($self->build_bat){$self->log_verbose("Deleting $basename.bat\n");my$full_progname=$0;$full_progname =~ s/(?:\.bat)?$/.bat/i;require Win32;my$null_arg=(Win32::IsWinNT())? '""' : '';my$cmd=qq(start $null_arg /min "\%comspec\%" /c del "$full_progname");open(my$fh,'>>',"$basename.bat")or die "Can't create $basename.bat: $!";print$fh $cmd;close$fh }else {$self->delete_filetree($self->build_script .'.bat')}}}sub make_executable {my$self=shift;$self->SUPER::make_executable(@_);for my$script (@_){if ($script =~ /\.(bat|cmd)$/){$self->SUPER::make_executable($script);next}else {my%opts=();if ($script eq $self->build_script){$opts{ntargs}=q(-x -S %0 --build_bat %*);$opts{otherargs}=q(-x -S "%0" --build_bat %1 %2 %3 %4 %5 %6 %7 %8 %9)}my$out=eval {$self->pl2bat(in=>$script,update=>1,%opts)};if ($@){$self->log_warn("WARNING: Unable to convert file '$script' to an executable script:\n$@")}else {$self->SUPER::make_executable($out)}}}}sub pl2bat {my$self=shift;my%opts=@_;$opts{ntargs}='-x -S %0 %*' unless exists$opts{ntargs};$opts{otherargs}='-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9' unless exists$opts{otherargs};$opts{stripsuffix}='/\\.plx?/' unless exists$opts{stripsuffix};$opts{stripsuffix}=($opts{stripsuffix}=~ m{^/([^/]*[^/\$]|)\$?/?$} ? $1 : "\Q$opts{stripsuffix}\E");unless (exists$opts{out}){$opts{out}=$opts{in};$opts{out}=~ s/$opts{stripsuffix}$//oi;$opts{out}.= '.bat' unless$opts{in}=~ /\.bat$/i or $opts{in}=~ /^-$/}my$head=<<EOT;$head =~ s/^\s+//gm;my$headlines=2 + ($head =~ tr/\n/\n/);my$tail="\n__END__\n:endofperl\n";my$linedone=0;my$taildone=0;my$linenum=0;my$skiplines=0;my$start=$Config{startperl};$start="#!perl" unless$start =~ /^#!.*perl/;open(my$in,'<',"$opts{in}")or die "Can't open $opts{in}: $!";my@file=<$in>;close($in);for my$line (@file){$linenum++;if ($line =~ /^:endofperl\b/){if (!exists$opts{update}){warn "$opts{in} has already been converted to a batch file!\n";return}$taildone++}if (not $linedone and $line =~ /^#!.*perl/){if (exists$opts{update}){$skiplines=$linenum - 1;$line .= "#line ".(1+$headlines)."\n"}else {$line .= "#line ".($linenum+$headlines)."\n"}$linedone++}if ($line =~ /^#\s*line\b/ and $linenum==2 + $skiplines){$line=""}}open(my$out,'>',"$opts{out}")or die "Can't open $opts{out}: $!";print$out $head;print$out $start,($opts{usewarnings}? " -w" : ""),"\n#line ",($headlines+1),"\n" unless$linedone;print$out @file[$skiplines..$#file];print$out $tail unless$taildone;close($out);return$opts{out}}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;|'"\[\]\{\}]+$/){push@quoted,$_}else {s/"/\\"/g;push@quoted,qq("$_")}}return join " ",@quoted}sub split_like_shell {(my$self,local $_)=@_;return @$_ if defined()&& ref()eq 'ARRAY';my@argv;return@argv unless defined()&& length();my$length=length;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub do_system {my ($self,@cmd)=@_;my$cmd=$self->_quote_args(@cmd);my$status=system($cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub _maybe_command {my($self,$file)=@_;my@e=exists($ENV{'PATHEXT'})? split(/;/,$ENV{PATHEXT}): qw(.com .exe .bat .cmd);my$e='';for (@e){$e .= "\Q$_\E|"}chop$e;if ($file =~ /($e)$/i){return$file if -e $file}else {for (@e){return "$file$_" if -e "$file$_"}}return}1;
      \@rem = '--*-Perl-*--
      \@echo off
      if "%OS%" == "Windows_NT" goto WinNT
      perl $opts{otherargs}
      goto endofperl
      :WinNT
      perl $opts{ntargs}
      if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
      if %errorlevel% == 9009 echo You do not have Perl in your PATH.
      if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
      goto endofperl
      \@rem ';
  EOT
MODULE_BUILD_PLATFORM_WINDOWS

$fatpacked{"Module/Build/Platform/aix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_AIX';
  package Module::Build::Platform::aix;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_AIX

$fatpacked{"Module/Build/Platform/cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_CYGWIN';
  package Module::Build::Platform::cygwin;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub _maybe_command {my ($self,$file)=@_;if ($file =~ m{^/cygdrive/}i){require Module::Build::Platform::Windows;return Module::Build::Platform::Windows->_maybe_command($file)}return$self->SUPER::_maybe_command($file)}1;
MODULE_BUILD_PLATFORM_CYGWIN

$fatpacked{"Module/Build/Platform/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DARWIN';
  package Module::Build::Platform::darwin;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_DARWIN

$fatpacked{"Module/Build/Platform/os2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_OS2';
  package Module::Build::Platform::os2;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub have_forkpipe {0}sub _maybe_command {my($self,$file)=@_;$file =~ s,[/\\]+,/,g;return$file if -x $file &&!-d _;return "$file.exe" if -x "$file.exe" &&!-d _;return "$file.cmd" if -x "$file.cmd" &&!-d _;return}1;
MODULE_BUILD_PLATFORM_OS2

$fatpacked{"Module/Build/PodParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PODPARSER';
  package Module::Build::PodParser;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;sub new {my$package=shift;my$self;$self=bless {have_pod_parser=>0,@_},$package;unless ($self->{fh}){die "No 'file' or 'fh' parameter given" unless$self->{file};open($self->{fh},'<',$self->{file})or die "Couldn't open $self->{file}: $!"}return$self}sub parse_from_filehandle {my ($self,$fh)=@_;local $_;while (<$fh>){next unless /^=(?!cut)/ .. /^=cut/;last if ($self->{abstract})=/^ (?: [a-z_0-9:]+ | [BCIF] < [a-z_0-9:]+ > ) \s+ - \s+ (.*\S) /ix}my@author;while (<$fh>){next unless /^=head1\s+AUTHORS?/i ... /^=/;next if /^=/;push@author,$_ if /\@/}return unless@author;s/^\s+|\s+$//g foreach@author;$self->{author}=\@author;return}sub get_abstract {my$self=shift;return$self->{abstract}if defined$self->{abstract};$self->parse_from_filehandle($self->{fh});return$self->{abstract}}sub get_author {my$self=shift;return$self->{author}if defined$self->{author};$self->parse_from_filehandle($self->{fh});return$self->{author}|| []}
MODULE_BUILD_PODPARSER

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;use strict;use warnings;use Cwd;use Carp ();use Module::CPANfile::Environment;use Module::CPANfile::Requirement;our$VERSION='1.1004';BEGIN {if (${^TAINT}){*untaint=sub {my$str=shift;($str)=$str =~ /^(.+)$/s;$str}}else {*untaint=sub {$_[0]}}}sub new {my($class,$file)=@_;bless {},$class}sub load {my($proto,$file)=@_;my$self=ref$proto ? $proto : $proto->new;$self->parse($file || _default_cpanfile());$self}sub save {my($self,$path)=@_;open my$out,">",$path or die "$path: $!";print {$out}$self->to_string}sub parse {my($self,$file)=@_;my$code=do {open my$fh,"<",$file or die "$file: $!";join '',<$fh>};$code=untaint$code;my$env=Module::CPANfile::Environment->new($file);$env->parse($code)or die $@;$self->{_mirrors}=$env->mirrors;$self->{_prereqs}=$env->prereqs}sub from_prereqs {my($proto,$prereqs)=@_;my$self=$proto->new;$self->{_prereqs}=Module::CPANfile::Prereqs->from_cpan_meta($prereqs);$self}sub mirrors {my$self=shift;$self->{_mirrors}|| []}sub features {my$self=shift;map$self->feature($_),$self->{_prereqs}->identifiers}sub feature {my($self,$identifier)=@_;$self->{_prereqs}->feature($identifier)}sub prereq {shift->prereqs}sub prereqs {my$self=shift;$self->{_prereqs}->as_cpan_meta}sub merged_requirements {my$self=shift;$self->{_prereqs}->merged_requirements}sub effective_prereqs {my($self,$features)=@_;$self->prereqs_with(@{$features || []})}sub prereqs_with {my($self,@feature_identifiers)=@_;my@others=map {$self->feature($_)->prereqs}@feature_identifiers;$self->prereqs->with_merged_prereqs(\@others)}sub prereq_specs {my$self=shift;$self->prereqs->as_string_hash}sub prereq_for_module {my($self,$module)=@_;$self->{_prereqs}->find($module)}sub options_for_module {my($self,$module)=@_;my$prereq=$self->prereq_for_module($module)or return;$prereq->requirement->options}sub merge_meta {my($self,$file,$version)=@_;require CPAN::Meta;$version ||= $file =~ /\.yml$/ ? '1.4' : '2';my$prereq=$self->prereqs;my$meta=CPAN::Meta->load_file($file);my$prereqs_hash=$prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;my$struct={%{$meta->as_struct},prereqs=>$prereqs_hash };CPAN::Meta->new($struct)->save($file,{version=>$version })}sub _d($) {require Data::Dumper;chomp(my$value=Data::Dumper->new([$_[0]])->Terse(1)->Dump);$value}sub _default_cpanfile {my$file=Cwd::abs_path('cpanfile');untaint$file}sub to_string {my($self,$include_empty)=@_;my$mirrors=$self->mirrors;my$prereqs=$self->prereq_specs;my$code='';$code .= $self->_dump_mirrors($mirrors);$code .= $self->_dump_prereqs($prereqs,$include_empty);for my$feature ($self->features){$code .= "feature @{[ _d $feature->{identifier} ]}, @{[ _d $feature->{description} ]} => sub {\n";$code .= $self->_dump_prereqs($feature->{prereqs}->as_string_hash,$include_empty,4);$code .= "};\n\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_mirrors {my($self,$mirrors)=@_;my$code="";for my$url (@$mirrors){$code .= "mirror @{[ _d $url ]};\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_prereqs {my($self,$prereqs,$include_empty,$base_indent)=@_;my$code='';for my$phase (qw(runtime configure build test develop)){my$indent=$phase eq 'runtime' ? '' : '    ';$indent .= (' ' x ($base_indent || 0));my($phase_code,$requirements);$phase_code .= "on $phase => sub {\n" unless$phase eq 'runtime';for my$type (qw(requires recommends suggests conflicts)){for my$mod (sort keys %{$prereqs->{$phase}{$type}}){my$ver=$prereqs->{$phase}{$type}{$mod};$phase_code .= $ver eq '0' ? "${indent}$type @{[ _d $mod ]}" : "${indent}$type @{[ _d $mod ]}, @{[ _d $ver ]}";my$options=$self->options_for_module($mod)|| {};if (%$options){my@opts;for my$key (keys %$options){my$k=$key =~ /^[a-zA-Z0-9_]+$/ ? $key : _d$key;push@opts,"$k => @{[ _d $options->{$k} ]}"}$phase_code .= ",\n" .join(",\n",map "  $indent$_",@opts)}$phase_code .= ";\n";$requirements++}}$phase_code .= "\n" unless$requirements;$phase_code .= "};\n" unless$phase eq 'runtime';$code .= $phase_code ."\n" if$requirements or $include_empty}$code =~ s/\n+$/\n/s;$code}1;
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;use strict;use warnings;use Module::CPANfile::Prereqs;use Carp ();my@bindings=qw(on requires recommends suggests conflicts feature osname mirror configure_requires build_requires test_requires author_requires);my$file_id=1;sub new {my($class,$file)=@_;bless {file=>$file,phase=>'runtime',feature=>undef,features=>{},prereqs=>Module::CPANfile::Prereqs->new,mirrors=>[],},$class}sub bind {my$self=shift;my$pkg=caller;for my$binding (@bindings){no strict 'refs';*{"$pkg\::$binding"}=sub {$self->$binding(@_)}}}sub parse {my($self,$code)=@_;my$err;{local $@;$file_id++;$self->_evaluate(<<EVAL);$err=$@}if ($err){die "Parsing $self->{file} failed: $err"};return 1}sub _evaluate {my$_environment=$_[0];eval $_[1]}sub prereqs {$_[0]->{prereqs}}sub mirrors {$_[0]->{mirrors}}sub on {my($self,$phase,$code)=@_;local$self->{phase}=$phase;$code->()}sub feature {my($self,$identifier,$description,$code)=@_;if (@_==3 && ref($description)eq 'CODE'){$code=$description;$description=$identifier}unless (ref$description eq '' && ref$code eq 'CODE'){Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }")}local$self->{feature}=$identifier;$self->prereqs->add_feature($identifier,$description);$code->()}sub osname {die "TODO"}sub mirror {my($self,$url)=@_;push @{$self->{mirrors}},$url}sub requirement_for {my($self,$module,@args)=@_;my$requirement=0;$requirement=shift@args if@args % 2;return Module::CPANfile::Requirement->new(name=>$module,version=>$requirement,@args,)}sub requires {my$self=shift;$self->add_prereq(requires=>@_)}sub recommends {my$self=shift;$self->add_prereq(recommends=>@_)}sub suggests {my$self=shift;$self->add_prereq(suggests=>@_)}sub conflicts {my$self=shift;$self->add_prereq(conflicts=>@_)}sub add_prereq {my($self,$type,$module,@args)=@_;$self->prereqs->add(feature=>$self->{feature},phase=>$self->{phase},type=>$type,module=>$module,requirement=>$self->requirement_for($module,@args),)}sub configure_requires {my($self,@args)=@_;$self->on(configure=>sub {$self->requires(@args)})}sub build_requires {my($self,@args)=@_;$self->on(build=>sub {$self->requires(@args)})}sub test_requires {my($self,@args)=@_;$self->on(test=>sub {$self->requires(@args)})}sub author_requires {my($self,@args)=@_;$self->on(develop=>sub {$self->requires(@args)})}1;
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  BEGIN { \$_environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  EVAL
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
  package Module::CPANfile::Prereq;use strict;sub new {my($class,%options)=@_;bless \%options,$class}sub feature {$_[0]->{feature}}sub phase {$_[0]->{phase}}sub type {$_[0]->{type}}sub module {$_[0]->{module}}sub requirement {$_[0]->{requirement}}1;
MODULE_CPANFILE_PREREQ

$fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
  package Module::CPANfile::Prereqs;use strict;use Carp ();use CPAN::Meta::Feature;use Module::CPANfile::Prereq;sub from_cpan_meta {my($class,$prereqs)=@_;my$self=$class->new;for my$phase (keys %$prereqs){for my$type (keys %{$prereqs->{$phase}}){while (my($module,$requirement)=each %{$prereqs->{$phase}{$type}}){$self->add(phase=>$phase,type=>$type,module=>$module,requirement=>Module::CPANfile::Requirement->new(name=>$module,version=>$requirement),)}}}$self}sub new {my$class=shift;bless {prereqs=>{},features=>{},},$class}sub add_feature {my($self,$identifier,$description)=@_;$self->{features}{$identifier}={description=>$description }}sub add {my($self,%args)=@_;my$feature=$args{feature}|| '';push @{$self->{prereqs}{$feature}},Module::CPANfile::Prereq->new(%args)}sub as_cpan_meta {my$self=shift;$self->{cpanmeta}||= $self->build_cpan_meta}sub build_cpan_meta {my($self,$feature)=@_;CPAN::Meta::Prereqs->new($self->specs($feature))}sub specs {my($self,$feature)=@_;$feature='' unless defined$feature;my$prereqs=$self->{prereqs}{$feature}|| [];my$specs={};for my$prereq (@$prereqs){$specs->{$prereq->phase}{$prereq->type}{$prereq->module}=$prereq->requirement->version}return$specs}sub merged_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;for my$prereq (@{$self->{prereqs}}){$reqs->add_string_requirement($prereq->module,$prereq->requirement->version)}$reqs}sub find {my($self,$module)=@_;for my$feature ('',keys %{$self->{features}}){for my$prereq (@{$self->{prereqs}{$feature}}){return$prereq if$prereq->module eq $module}}return}sub identifiers {my$self=shift;keys %{$self->{features}}}sub feature {my($self,$identifier)=@_;my$data=$self->{features}{$identifier}or Carp::croak("Unknown feature '$identifier'");my$prereqs=$self->build_cpan_meta($identifier);CPAN::Meta::Feature->new($identifier,{description=>$data->{description},prereqs=>$prereqs->as_string_hash,})}1;
MODULE_CPANFILE_PREREQS

$fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
  package Module::CPANfile::Requirement;use strict;sub new {my ($class,%args)=@_;$args{version}||= 0;bless +{name=>delete$args{name},version=>delete$args{version},options=>\%args,},$class}sub name {$_[0]->{name}}sub version {$_[0]->{version}}sub options {$_[0]->{options}}sub has_options {keys %{$_[0]->{options}}> 0}1;
MODULE_CPANFILE_REQUIREMENT

$fatpacked{"Module/CPANfile/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_WRITER';
  package Module::CPANfile::Writer;use strict;use warnings;use Carp qw/croak/;use Babble::Match;use PPR;our$VERSION="0.01";sub new {my ($class,$f)=@_;croak('Usage: Module::CPANfile::Writer->new($f)')unless defined$f;my$src;if (ref$f){croak('Not a SCALAR reference')unless ref$f eq 'SCALAR';$src=$$f}else {$src=do {open my$fh,'<',$f or die $!;local $/;<$fh>}}return bless {src=>$src,prereqs=>[],},$class}sub src {my$self=shift;my$top=Babble::Match->new(top_rule=>'Document',text=>$self->{src});$top->each_match_within('Call'=>[[relationship=>'(?:requires|recommends|suggests|conflicts)' ],'(?&PerlOWS) \(? (?&PerlOWS)',[module=>'(?: (?&PerlString) | (?&PerlBareword) )' ],[arg1_before=>'(?&PerlOWS) (?: (?>(?&PerlComma)) (?&PerlOWS) )*' ],[arg1=>'(?&PerlAssignment)?' ],'(?&PerlOWS) (?: (?>(?&PerlComma)) (?&PerlOWS) )*',[args=>'(?&PerlCommaList)?' ],'\)? (?&PerlOWS)',]=>sub {my ($m)=@_;my$relationship=$m->submatches->{relationship}->text;my$module=_perl_string_or_bareword($m->submatches->{module}->text);my$prereq=_find_prereq($self->{add_prereqs},$module,$relationship)or return;my$version=$prereq->{version};if ($m->submatches->{arg1}->text eq '' || _args_num($m->submatches->{args}->text)% 2==1){if ($version){$m->submatches->{module}->transform_text(sub {s/$/, '$version'/})}}else {if ($version){$m->submatches->{arg1}->replace_text(qq{'$version'})}else {$m->submatches->{arg1}->replace_text('');$m->submatches->{arg1_before}->replace_text('')}}});return$top->text}sub save {my ($self,$file)=@_;croak('Usage: $self->save($file)')unless defined$file;open my$fh,'>',$file or die $!;print {$fh}$self->src}sub add_prereq {my ($self,$module,$version,%opts)=@_;croak('Usage: $self->prereq($module, [$version, relationship => $relationship])')unless defined$module;my$relationship=$opts{relationship}|| 'requires';push @{$self->{add_prereqs}},{module=>$module,version=>$version,relationship=>$relationship,}}sub _find_prereq {my ($prereqs,$module,$relationship)=@_;for my$prereq (@$prereqs){if ($prereq->{module}eq $module && $prereq->{relationship}eq $relationship){return$prereq}}return undef}sub _perl_string_or_bareword {my ($s)=@_;if ($s =~ /\A (?&PerlString) \Z $PPR::GRAMMAR/x){return eval$s}return$s}sub _args_num {my ($s)=@_;return scalar grep defined,$s =~ m{
          \G (?: (?>(?&PerlComma)) (?&PerlOWS) )* ((?&PerlAssignment))
              $PPR::GRAMMAR
      }gcx}1;
MODULE_CPANFILE_WRITER

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;use strict;use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);use Module::Pluggable::Object;use if $] > 5.017,'deprecate';$VERSION='5.2';$FORCE_SEARCH_ALL_PATHS=0;sub import {my$class=shift;my%opts=@_;my ($pkg,$file)=caller;my$sub=$opts{'sub_name'}|| 'plugins';my ($package)=$opts{'package'}|| $pkg;$opts{filename}=$file;$opts{package}=$package;$opts{force_search_all_paths}=$FORCE_SEARCH_ALL_PATHS unless exists$opts{force_search_all_paths};my$finder=Module::Pluggable::Object->new(%opts);my$subroutine=sub {my$self=shift;return$finder->plugins(@_)};my$searchsub=sub {my$self=shift;my ($action,@paths)=@_;$finder->{'search_path'}=["${package}::Plugin"]if ($action eq 'add' and not $finder->{'search_path'});push @{$finder->{'search_path'}},@paths if ($action eq 'add');$finder->{'search_path'}=\@paths if ($action eq 'new');return$finder->{'search_path'}};my$onlysub=sub {my ($self,$only)=@_;if (defined$only){$finder->{'only'}=$only};return$finder->{'only'}};my$exceptsub=sub {my ($self,$except)=@_;if (defined$except){$finder->{'except'}=$except};return$finder->{'except'}};no strict 'refs';no warnings qw(redefine prototype);*{"$package\::$sub"}=$subroutine;*{"$package\::search_path"}=$searchsub;*{"$package\::only"}=$onlysub;*{"$package\::except"}=$exceptsub}1;
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;use strict;use File::Find ();use File::Basename;use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);use Carp qw(croak carp confess);use Devel::InnerPackage;use vars qw($VERSION $MR);use if $] > 5.017,'deprecate';$VERSION='5.2';BEGIN {eval {require Module::Runtime};unless ($@){Module::Runtime->import('require_module')}else {*require_module=sub {my$module=shift;my$path=$module .".pm";$path =~ s{::}{/}g;require$path}}}sub new {my$class=shift;my%opts=@_;return bless \%opts,$class}sub plugins {my$self=shift;my@args=@_;$self->{'require'}=1 if$self->{'inner'};my$filename=$self->{'filename'};my$pkg=$self->{'package'};$self->_setup_exceptions;for (qw(search_path search_dirs)){$self->{$_}=[$self->{$_}]if exists$self->{$_}&&!ref($self->{$_})}$self->{'search_path'}||= ["${pkg}::Plugin"];$self->{'on_require_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't require $plugin : $err";return 0};$self->{'on_instantiate_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't instantiate $plugin: $err";return 0};$self->{'follow_symlinks'}=1 unless exists$self->{'follow_symlinks'};my@SEARCHDIR=exists$INC{"blib.pm"}&& defined$filename && $filename =~ m!(^|/)blib/! &&!$self->{'force_search_all_paths'}? grep {/blib/}@INC : @INC;unshift@SEARCHDIR,@{$self->{'search_dirs'}}if defined$self->{'search_dirs'};my@tmp=@INC;unshift@tmp,@{$self->{'search_dirs'}|| []};local@INC=@tmp if defined$self->{'search_dirs'};my@plugins=$self->search_directories(@SEARCHDIR);push(@plugins,$self->handle_inc_hooks($_,@SEARCHDIR))for @{$self->{'search_path'}};push(@plugins,$self->handle_innerpackages($_))for @{$self->{'search_path'}};return ()unless@plugins;my%plugins;for(@plugins){next unless$self->_is_legit($_);$plugins{$_}=1}if (defined$self->{'instantiate'}){my$method=$self->{'instantiate'};my@objs=();for my$package (sort keys%plugins){next unless$package->can($method);my$obj=eval {$package->$method(@_)};$self->{'on_instantiate_error'}->($package,$@)if $@;push@objs,$obj if$obj}return@objs}else {my@objs=sort keys%plugins;return@objs}}sub _setup_exceptions {my$self=shift;my%only;my%except;my$only;my$except;if (defined$self->{'only'}){if (ref($self->{'only'})eq 'ARRAY'){%only=map {$_=>1}@{$self->{'only'}}}elsif (ref($self->{'only'})eq 'Regexp'){$only=$self->{'only'}}elsif (ref($self->{'only'})eq ''){$only{$self->{'only'}}=1}}if (defined$self->{'except'}){if (ref($self->{'except'})eq 'ARRAY'){%except=map {$_=>1}@{$self->{'except'}}}elsif (ref($self->{'except'})eq 'Regexp'){$except=$self->{'except'}}elsif (ref($self->{'except'})eq ''){$except{$self->{'except'}}=1}}$self->{_exceptions}->{only_hash}=\%only;$self->{_exceptions}->{only}=$only;$self->{_exceptions}->{except_hash}=\%except;$self->{_exceptions}->{except}=$except}sub _is_legit {my$self=shift;my$plugin=shift;my%only=%{$self->{_exceptions}->{only_hash}||{}};my%except=%{$self->{_exceptions}->{except_hash}||{}};my$only=$self->{_exceptions}->{only};my$except=$self->{_exceptions}->{except};my$depth=()=split '::',$plugin,-1;return 0 if (keys%only &&!$only{$plugin});return 0 unless (!defined$only || $plugin =~ m!$only!);return 0 if (keys%except && $except{$plugin});return 0 if (defined$except && $plugin =~ m!$except!);return 0 if defined$self->{max_depth}&& $depth>$self->{max_depth};return 0 if defined$self->{min_depth}&& $depth<$self->{min_depth};return 1}sub search_directories {my$self=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){push@plugins,$self->search_paths($dir)}return@plugins}sub search_paths {my$self=shift;my$dir=shift;my@plugins;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;for my$searchpath (@{$self->{'search_path'}}){my$sp=catdir($dir,(split /::/,$searchpath));next unless (-e $sp && -d _);my@files=$self->find_files($sp);for my$file (@files){next unless ($file)=($file =~ /(.*$file_regex)$/);my ($name,$directory,$suffix)=fileparse($file,$file_regex);next if (!$self->{include_editor_junk}&& $self->_is_editor_junk($name));$directory=abs2rel($directory,$sp);my@pkg_dirs=();if ($name eq lc($name)|| $name eq uc($name)){my$pkg_file=catfile($sp,$directory,"$name$suffix");open PKGFILE,"<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";my$in_pod=0;while (my$line=<PKGFILE>){$in_pod=1 if$line =~ m/^=\w/;$in_pod=0 if$line =~ /^=cut/;next if ($in_pod || $line =~ /^=cut/);next if$line =~ /^\s*#/;if ($line =~ m/^\s*package\s+(.*::)?($name)\s*;/i){@pkg_dirs=split /::/,$1 if defined $1;;$name=$2;last}}close PKGFILE}$directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);my@dirs=();if ($directory){($directory)=($directory =~ /(.*)/);@dirs=grep(length($_),splitdir($directory))unless$directory eq curdir();for my$d (reverse@dirs){my$pkg_dir=pop@pkg_dirs;last unless defined$pkg_dir;$d =~ s/\Q$pkg_dir\E/$pkg_dir/i}}else {$directory=""}my$plugin=join '::',$searchpath,@dirs,$name;next unless$plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;$self->handle_finding_plugin($plugin,\@plugins)}push@plugins,$self->handle_innerpackages($searchpath)}return@plugins}sub _is_editor_junk {my$self=shift;my$name=shift;return 1 if$name =~ /~$/;return 1 if$name =~ /^\.#/;return 1 if$name =~ /\.sw[po]$/;return 0}sub handle_finding_plugin {my$self=shift;my$plugin=shift;my$plugins=shift;my$no_req=shift || 0;return unless$self->_is_legit($plugin);unless (defined$self->{'instantiate'}|| $self->{'require'}){push @$plugins,$plugin;return}$self->{before_require}->($plugin)|| return if defined$self->{before_require};unless ($no_req){my$tmp=$@;my$res=eval {require_module($plugin)};my$err=$@;$@=$tmp;if ($err){if (defined$self->{on_require_error}){$self->{on_require_error}->($plugin,$err)|| return}else {return}}}$self->{after_require}->($plugin)|| return if defined$self->{after_require};push @$plugins,$plugin}sub find_files {my$self=shift;my$search_path=shift;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;my@files=();{local $_;File::Find::find({no_chdir=>1,follow=>$self->{'follow_symlinks'},wanted=>sub {return unless$File::Find::name =~ /$file_regex/;(my$path=$File::Find::name)=~ s#^\\./##;push@files,$path}},$search_path)}return@files}sub handle_inc_hooks {my$self=shift;my$path=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){next unless ref$dir && eval {$dir->can('files')};for my$plugin ($dir->files){$plugin =~ s/\.pm$//;$plugin =~ s{/}{::}g;next unless$plugin =~ m!^${path}::!;$self->handle_finding_plugin($plugin,\@plugins)}}return@plugins}sub handle_innerpackages {my$self=shift;return ()if (exists$self->{inner}&&!$self->{inner});my$path=shift;my@plugins;for my$plugin (Devel::InnerPackage::list_packages($path)){$self->handle_finding_plugin($plugin,\@plugins,1)}return@plugins}1;
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  package Module::Runtime;BEGIN {require 5.006}BEGIN {${^WARNING_BITS}=""}our$VERSION="0.016";our@EXPORT_OK=qw($module_name_rx is_module_name is_valid_module_name check_module_name module_notional_filename require_module use_module use_package_optimistically $top_module_spec_rx $sub_module_spec_rx is_module_spec is_valid_module_spec check_module_spec compose_module_name);my%export_ok=map {($_=>undef)}@EXPORT_OK;sub import {my$me=shift;my$callpkg=caller(0);my$errs="";for(@_){if(exists$export_ok{$_}){if(/\A\$(.*)\z/s){*{$callpkg."::".$1}=\$$1}else {*{$callpkg."::".$_}=\&$_}}else {$errs .= "\"$_\" is not exported by the $me module\n"}}if($errs ne ""){die "${errs}Can't continue after import errors "."at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n"}}sub _is_string($) {my($arg)=@_;return defined($arg)&& ref(\$arg)eq "SCALAR"}our$module_name_rx=qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;my$qual_module_spec_rx=qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;my$unqual_top_module_spec_rx=qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$top_module_spec_rx=qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;my$unqual_sub_module_spec_rx=qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$sub_module_spec_rx=qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;sub is_module_name($) {_is_string($_[0])&& $_[0]=~ /\A$module_name_rx\z/o}*is_valid_module_name=\&is_module_name;sub check_module_name($) {unless(&is_module_name){die +(_is_string($_[0])? "`$_[0]'" : "argument")." is not a module name\n"}}sub module_notional_filename($) {&check_module_name;my($name)=@_;$name =~ s!::!/!g;return$name.".pm"}BEGIN {*_WORK_AROUND_HINT_LEAKAGE="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}BEGIN {if(_WORK_AROUND_BROKEN_MODULE_STATE){eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  };die $@ if $@ ne ""}}sub require_module($) {local %^H if _WORK_AROUND_HINT_LEAKAGE;if(_WORK_AROUND_BROKEN_MODULE_STATE){my$notional_filename=&module_notional_filename;my$guard=bless([$notional_filename ],"Module::Runtime::__GUARD__");my$result=CORE::require($notional_filename);pop @$guard;return$result}else {return scalar(CORE::require(&module_notional_filename))}}sub use_module($;$) {my($name,$version)=@_;require_module($name);$name->VERSION($version)if @_ >= 2;return$name}sub use_package_optimistically($;$) {my($name,$version)=@_;my$fn=module_notional_filename($name);eval {local$SIG{__DIE__};require_module($name)};die $@ if $@ ne "" && ($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s || $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);$name->VERSION($version)if @_ >= 2;return$name}sub is_module_spec($$) {my($prefix,$spec)=@_;return _is_string($spec)&& $spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o : qr/\A$top_module_spec_rx\z/o)}*is_valid_module_spec=\&is_module_spec;sub check_module_spec($$) {unless(&is_module_spec){die +(_is_string($_[1])? "`$_[1]'" : "argument")." is not a module specification\n"}}sub compose_module_name($$) {my($prefix,$spec)=@_;check_module_name($prefix)if defined$prefix;&check_module_spec;if($spec =~ s#\A(?:/|::)##){}else {$spec=$prefix."::".$spec if defined$prefix}$spec =~ s#/#::#g;return$spec}1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;use Moo::_strictures;use Moo::_mro;use Moo::_Utils qw(_getglob _getstash _install_coderef _install_modifier _load_module _set_loaded _unimport_coderefs);use Scalar::Util qw(reftype);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Method::Generate::Constructor Method::Generate::Accessor Moo::sification Moo::_Utils Moo::Role)}our$VERSION='2.003004';$VERSION =~ tr/_//d;require Moo::sification;Moo::sification->import;our%MAKERS;sub _install_tracked {my ($target,$name,$code)=@_;$MAKERS{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::${name}"=>$code}sub import {my$target=caller;my$class=shift;_set_loaded(caller);strict->import;warnings->import;if ($INC{'Role/Tiny.pm'}and Role::Tiny->is_role($target)){croak "Cannot import Moo into a role"}$MAKERS{$target}||= {};_install_tracked$target=>extends=>sub {$class->_set_superclasses($target,@_);$class->_maybe_reset_handlemoose($target);return};_install_tracked$target=>with=>sub {require Moo::Role;Moo::Role->apply_roles_to_package($target,@_);$class->_maybe_reset_handlemoose($target)};_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak "Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$class->_constructor_maker_for($target)->register_attribute_specs($name,$spec_ref);$class->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);$class->_maybe_reset_handlemoose($target)}return};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {_install_modifier($target,$type,@_);return}}return if$MAKERS{$target}{is_class};my$stash=_getstash($target);my@not_methods=map +(!ref($_)? *$_{CODE}||(): reftype($_)eq 'CODE' ? $_ : ()),values %$stash;@{$MAKERS{$target}{not_methods}={}}{@not_methods}=@not_methods;$MAKERS{$target}{is_class}=1;{no strict 'refs';@{"${target}::ISA"}=do {require Moo::Object;('Moo::Object')}unless @{"${target}::ISA"}}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub unimport {my$target=caller;_unimport_coderefs($target,$MAKERS{$target})}sub _set_superclasses {my$class=shift;my$target=shift;for my$superclass (@_){_load_module($superclass);if ($INC{'Role/Tiny.pm'}&& Role::Tiny->is_role($superclass)){croak "Can't extend role '$superclass'"}}@{*{_getglob("${target}::ISA")}{ARRAY}}=@_;if (my$old=delete$Moo::MAKERS{$target}{constructor}){$old->assert_constructor;delete _getstash($target)->{new};Moo->_constructor_maker_for($target)->register_attribute_specs(%{$old->all_attribute_specs})}elsif (!$target->isa('Moo::Object')){Moo->_constructor_maker_for($target)}$Moo::HandleMoose::MOUSE{$target}=[grep defined,map Mouse::Util::find_meta($_),@_ ]if Mouse::Util->can('find_meta')}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _accessor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{accessor}||= do {my$maker_class=do {if (my$m=do {require Sub::Defer;if (my$defer_target=(Sub::Defer::defer_info($target->can('new'))||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);$MAKERS{$pkg}&& $MAKERS{$pkg}{accessor}}else {undef}}){ref($m)}else {require Method::Generate::Accessor;'Method::Generate::Accessor'}};$maker_class->new}}sub _constructor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{constructor}||= do {require Method::Generate::Constructor;my%construct_opts=(package=>$target,accessor_generator=>$class->_accessor_maker_for($target),subconstructor_handler=>('      if ($Moo::MAKERS{$class}) {'."\n" .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n" .'          package '.$target.';'."\n" .'          return $invoker->SUPER::new(@_);'."\n" .'        }'."\n" .'        '.$class.'->_constructor_maker_for($class);'."\n" .'        return $invoker->new(@_)'.";\n" .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n" .'        return $meta->new_object('."\n" .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n" .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n" .'        );'."\n" .'      }'."\n"),);my$con;my@isa=@{mro::get_linear_isa($target)};shift@isa;no strict 'refs';if (my ($parent_new)=grep +(defined &{$_.'::new'}),@isa){if ($parent_new eq 'Moo::Object'){}elsif (my$makers=$MAKERS{$parent_new}){$con=$makers->{constructor};$construct_opts{construction_string}=$con->construction_string if$con}elsif ($parent_new->can('BUILDALL')){$construct_opts{construction_builder}=sub {my$inv=$target->can('BUILDARGS')? '' : 'Moo::Object::';'do {' .'  my $args = $class->'.$inv.'BUILDARGS(@_);' .'  $args->{__no_BUILD__} = 1;' .'  $invoker->'.$target.'::SUPER::new($args);' .'}'}}else {$construct_opts{construction_builder}=sub {'$invoker->'.$target.'::SUPER::new(' .($target->can('FOREIGNBUILDARGS')? '$class->FOREIGNBUILDARGS(@_)' : '@_').')'}}}($con ? ref($con): 'Method::Generate::Constructor')->new(%construct_opts)->install_delayed ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})}}sub _concrete_methods_of {my ($me,$class)=@_;my$makers=$MAKERS{$class};my$stash=_getstash($class);my$not_methods={reverse %{$makers->{not_methods}||{}}};+{map {;no strict 'refs';my$code=exists &{"${class}::$_"}? \&{"${class}::$_"}: undef;(!$code or exists$not_methods->{$code})? (): ($_=>$code)}grep +(!ref($stash->{$_})|| reftype($stash->{$_})eq 'CODE'),keys %$stash }}1;
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;use Moo::_strictures;use Moo::_Utils qw(_getstash);use Sub::Quote qw(quotify);use Carp qw(croak);our%TYPE_MAP;our$SETUP_DONE;sub import {return if$SETUP_DONE;inject_all();$SETUP_DONE=1}sub inject_all {croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Class::MOP;inject_fake_metaclass_for($_)for grep $_ ne 'Moo::Object',keys%Moo::MAKERS;inject_fake_metaclass_for($_)for keys%Moo::Role::INFO;require Moose::Meta::Method::Constructor;@Moo::HandleMoose::FakeConstructor::ISA='Moose::Meta::Method::Constructor';@Moo::HandleMoose::FakeMeta::ISA='Moose::Meta::Method::Meta'}sub maybe_reinject_fake_metaclass_for {my ($name)=@_;our%DID_INJECT;if (delete$DID_INJECT{$name}){unless ($Moo::Role::INFO{$name}){Moo->_constructor_maker_for($name)->install_delayed}inject_fake_metaclass_for($name)}}sub inject_fake_metaclass_for {my ($name)=@_;require Class::MOP;require Moo::HandleMoose::FakeMetaClass;Class::MOP::store_metaclass_by_name($name,bless({name=>$name },'Moo::HandleMoose::FakeMetaClass'));require Moose::Util::TypeConstraints;if ($Moo::Role::INFO{$name}){Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name)}else {Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name)}}{package Moo::HandleMoose::FakeConstructor;sub _uninlined_body {\&Moose::Object::new}}sub inject_real_metaclass_for {my ($name)=@_;our%DID_INJECT;return Class::MOP::get_metaclass_by_name($name)if$DID_INJECT{$name};require Moose;require Moo;require Moo::Role;require Scalar::Util;require Sub::Defer;Class::MOP::remove_metaclass_by_name($name);my ($am_role,$am_class,$meta,$attr_specs,$attr_order)=do {if (my$info=$Moo::Role::INFO{$name}){my@attr_info=@{$info->{attributes}||[]};(1,0,Moose::Meta::Role->initialize($name),{@attr_info },[@attr_info[grep!($_ % 2),0..$#attr_info]])}elsif (my$cmaker=Moo->_constructor_maker_for($name)){my$specs=$cmaker->all_attribute_specs;(0,1,Moose::Meta::Class->initialize($name),$specs,[sort {$specs->{$a}{index}<=> $specs->{$b}{index}}keys %$specs ])}else {(0,0,Moose::Meta::Class->initialize($name),{},[])}};{local$DID_INJECT{$name}=1;for my$spec (values %$attr_specs){if (my$inflators=delete$spec->{moosify}){$_->($spec)for @$inflators}}my%methods =%{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};if (my$info=$Moo::Role::INFO{$name}){delete$info->{methods}}$methods{$_}=Sub::Defer::undefer_sub($methods{$_})for grep $_ ne 'new',keys%methods;my@attrs;{local @{_getstash($name)}{keys%methods};my%seen_name;for my$attr_name (@$attr_order){$seen_name{$attr_name}=1;my%spec=%{$attr_specs->{$attr_name}};my%spec_map=(map {$_->name=>$_->init_arg||$_->name}((grep {$_->has_init_arg}$meta->attribute_metaclass->meta->get_all_attributes),grep {exists($_->{init_arg})? defined($_->init_arg): 1}map {my$meta=Moose::Util::resolve_metatrait_alias('Attribute',$_)->meta;map$meta->get_attribute($_),$meta->get_attribute_list}@{$spec{traits}||[]}));$spec_map{traits}||= 'traits';$spec{is}='ro' if$spec{is}eq 'lazy' or $spec{is}eq 'rwp';my$coerce=$spec{coerce};if (my$isa=$spec{isa}){my$tc=$spec{isa}=do {if (my$mapped=$TYPE_MAP{$isa}){my$type=$mapped->();unless (Scalar::Util::blessed($type)&& $type->isa("Moose::Meta::TypeConstraint")){croak "error inflating attribute '$attr_name' for package '$name': " ."\$TYPE_MAP{$isa} did not return a valid type constraint'"}$coerce ? $type->create_child_type(name=>$type->name): $type}else {Moose::Meta::TypeConstraint->new(constraint=>sub {eval {&$isa;1}})}};if ($coerce){$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{coerce}=1}}elsif ($coerce){my$attr=quotify($attr_name);my$tc=Moose::Meta::TypeConstraint->new(constraint=>sub {die "This is not going to work"},inlined=>sub {'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'},);$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{isa}=$tc;$spec{coerce}=1}%spec=map {$spec_map{$_}=>$spec{$_}}grep {exists$spec_map{$_}}keys%spec;push@attrs,$meta->add_attribute($attr_name=>%spec)}for my$mouse (do {our%MOUSE;@{$MOUSE{$name}||[]}}){for my$attr ($mouse->get_all_attributes){my%spec=%{$attr};delete@spec{qw(associated_class associated_methods __METACLASS__ provides curries)};my$attr_name=delete$spec{name};next if$seen_name{$attr_name}++;push@attrs,$meta->add_attribute($attr_name=>%spec)}}}for my$meth_name (keys%methods){my$meth_code=$methods{$meth_name};$meta->add_method($meth_name,$meth_code)}if ($am_role){my$info=$Moo::Role::INFO{$name};$meta->add_required_methods(@{$info->{requires}});for my$modifier (@{$info->{modifiers}}){my ($type,@args)=@$modifier;my$code=pop@args;$meta->${\"add_${type}_method_modifier"}($_,$code)for@args}}elsif ($am_class){for my$attr (@attrs){for my$method (@{$attr->associated_methods}){$method->{body}=$name->can($method->name)}}bless($meta->find_method_by_name('new'),'Moo::HandleMoose::FakeConstructor',);my$meta_meth;if ($meta_meth=$meta->find_method_by_name('meta')and $meta_meth->body==\&Moo::Object::meta){bless($meta_meth,'Moo::HandleMoose::FakeMeta')}require Method::Generate::DemolishAll}$meta->add_role(Class::MOP::class_of($_))for grep!/\|/ && $_ ne $name,keys %{$Moo::Role::APPLIED_TO{$name}}}$DID_INJECT{$name}=1;$meta}1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;use Moo::_strictures;use Carp ();BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub DESTROY {}sub AUTOLOAD {my ($meth)=(our$AUTOLOAD =~ /([^:]+)$/);my$self=shift;Carp::croak "Can't call $meth without object instance" if!ref$self;Carp::croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)}sub can {my$self=shift;return$self->SUPER::can(@_)if!ref$self or $Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)}sub isa {my$self=shift;return$self->SUPER::isa(@_)if!ref$self or $Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)}sub make_immutable {$_[0]}1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;use Moo::_strictures;package Moo::HandleMoose;our%TYPE_MAP;package Moo::HandleMoose::_TypeMap;use Scalar::Util ();use Config;our%WEAK_TYPES;sub _str_to_ref {my$in=shift;return$in if ref$in;if ($in =~ /(?:^|=)([A-Z]+)\(0x([0-9a-zA-Z]+)\)$/){my$type=$1;my$id=do {no warnings 'portable';hex "$2"};require B;my$sv=bless \$id,'B::SV';my$ref=eval {$sv->object_2svref};if (!defined$ref or Scalar::Util::reftype($ref)ne $type){die <<'END_ERROR'}return$ref}return$in}sub TIEHASH {bless {},$_[0]}sub STORE {my ($self,$key,$value)=@_;my$type=_str_to_ref($key);$WEAK_TYPES{$type}=$type;Scalar::Util::weaken($WEAK_TYPES{$type})if ref$type;$self->{$key}=$value}sub FETCH {$_[0]->{$_[1]}}sub FIRSTKEY {my$a=scalar keys %{$_[0]};each %{$_[0]}}sub NEXTKEY {each %{$_[0]}}sub EXISTS {exists $_[0]->{$_[1]}}sub DELETE {delete $_[0]->{$_[1]}}sub CLEAR {%{$_[0]}=()}sub SCALAR {scalar %{$_[0]}}sub CLONE {my@types=map {defined$WEAK_TYPES{$_}? ($WEAK_TYPES{$_}=>$TYPE_MAP{$_}): ()}keys%TYPE_MAP;%WEAK_TYPES=();%TYPE_MAP=@types}sub DESTROY {my%types=%{$_[0]};untie%TYPE_MAP;%TYPE_MAP=%types}if ($Config{useithreads}){my@types=%TYPE_MAP;tie%TYPE_MAP,__PACKAGE__;%TYPE_MAP=@types}1;
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;use Moo::_strictures;use Carp ();our%NO_BUILD;our%NO_DEMOLISH;our$BUILD_MAKER;our$DEMOLISH_MAKER;sub new {my$class=shift;unless (exists$NO_DEMOLISH{$class}){unless ($NO_DEMOLISH{$class}=!$class->can('DEMOLISH')){($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method($class)}}my$proto=$class->BUILDARGS(@_);$NO_BUILD{$class}and return bless({},$class);$NO_BUILD{$class}=!$class->can('BUILD')unless exists$NO_BUILD{$class};$NO_BUILD{$class}? bless({},$class): bless({},$class)->BUILDALL($proto)}sub BUILDARGS {my$class=shift;scalar @_==1 ? ref $_[0]eq 'HASH' ? {%{$_[0]}}: Carp::croak("Single parameters to new() must be a HASH ref" ." data => ".$_[0]): @_ % 2 ? Carp::croak("The new() method for $class expects a hash reference or a" ." key/value list. You passed an odd number of arguments"): {@_}}sub BUILDALL {my$self=shift;$self->${\(($BUILD_MAKER ||= do {require Method::Generate::BuildAll;Method::Generate::BuildAll->new})->generate_method(ref($self)))}(@_)}sub DEMOLISHALL {my$self=shift;$self->${\(($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method(ref($self)))}(@_)}sub does {return!!0 unless ($INC{'Moose/Role.pm'}|| $INC{'Role/Tiny.pm'});require Moo::Role;my$does=Moo::Role->can("does_role");{no warnings 'redefine';*does=$does}goto &$does}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;use Moo::_strictures;use Moo::_Utils qw(_getglob _getstash _install_coderef _install_modifier _load_module _name_coderef _set_loaded _unimport_coderefs);use Carp qw(croak);use Role::Tiny ();BEGIN {our@ISA=qw(Role::Tiny)}BEGIN {our@CARP_NOT=qw(Method::Generate::Accessor Method::Generate::Constructor Moo::sification Moo::_Utils)}our$VERSION='2.003004';$VERSION =~ tr/_//d;require Moo::sification;Moo::sification->import;BEGIN {*INFO=\%Role::Tiny::INFO;*APPLIED_TO=\%Role::Tiny::APPLIED_TO;*COMPOSED=\%Role::Tiny::COMPOSED;*ON_ROLE_CREATE=\@Role::Tiny::ON_ROLE_CREATE}our%INFO;our%APPLIED_TO;our%APPLY_DEFAULTS;our%COMPOSED;our@ON_ROLE_CREATE;sub _install_tracked {my ($target,$name,$code)=@_;$INFO{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::Role::${name}"=>$code}sub import {my$target=caller;if ($Moo::MAKERS{$target}and $Moo::MAKERS{$target}{is_class}){croak "Cannot import Moo::Role into a Moo class"}_set_loaded(caller);goto&Role::Tiny::import}sub _install_subs {my ($me,$target)=@_;_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;($INFO{$target}{accessor_maker}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new})->generate_method($target,$name,$spec_ref);push @{$INFO{$target}{attributes}||=[]},$name,$spec_ref;$me->_maybe_reset_handlemoose($target)}};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];$me->_maybe_reset_handlemoose($target)}}_install_tracked$target=>requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;$me->_maybe_reset_handlemoose($target)};_install_tracked$target=>with=>sub {$me->apply_roles_to_package($target,@_);$me->_maybe_reset_handlemoose($target)};*{_getglob("${target}::meta")}=$me->can('meta')}push@ON_ROLE_CREATE,sub {my$target=shift;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}};sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}sub unimport {my$target=caller;_unimport_coderefs($target,$INFO{$target})}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub methods_provided_by {my ($self,$role)=@_;_load_module($role);$self->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$self->is_role($role);return$self->SUPER::methods_provided_by($role)}sub is_role {my ($self,$role)=@_;$self->_inhale_if_moose($role);$self->SUPER::is_role($role)}sub _inhale_if_moose {my ($self,$role)=@_;my$meta;if (!$self->SUPER::is_role($role)and ($INC{"Moose.pm"}and $meta=Class::MOP::class_of($role)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->isa('Moose::Meta::Role'))or (Mouse::Util->can('find_meta')and $meta=Mouse::Util::find_meta($role)and $meta->isa('Mouse::Meta::Role'))){my$is_mouse=$meta->isa('Mouse::Meta::Role');$INFO{$role}{methods}={map +($_=>$role->can($_)),grep$role->can($_),grep!($is_mouse && $_ eq 'meta'),grep!$meta->get_method($_)->isa('Class::MOP::Method::Meta'),$meta->get_method_list };$APPLIED_TO{$role}={map +($_->name=>1),$meta->calculate_all_roles };$INFO{$role}{requires}=[$meta->get_required_method_list ];$INFO{$role}{attributes}=[map +($_=>do {my$attr=$meta->get_attribute($_);my$spec={%{$is_mouse ? $attr : $attr->original_options}};if ($spec->{isa}){require Sub::Quote;my$get_constraint=do {my$pkg=$is_mouse ? 'Mouse::Util::TypeConstraints' : 'Moose::Util::TypeConstraints';_load_module($pkg);$pkg->can('find_or_create_isa_type_constraint')};my$tc=$get_constraint->($spec->{isa});my$check=$tc->_compiled_type_constraint;my$tc_var='$_check_for_'.Sub::Quote::sanitize_identifier($tc->name);$spec->{isa}=Sub::Quote::quote_sub(qq{
                &${tc_var} or Carp::croak "Type constraint failed for \$_[0]"
              },{$tc_var=>\$check },{package=>$role,},);if ($spec->{coerce}){$spec->{coerce}=$tc->${\($tc->can('coercion')||sub {$_[0]})}->_compiled_type_coercion}}$spec}),$meta->get_attribute_list ];my$mods=$INFO{$role}{modifiers}=[];for my$type (qw(before after around)){my$map=$meta->${\($meta->can("get_${type}_method_modifiers_map")or sub {shift->{"${type}_method_modifiers"}})};for my$method (keys %$map){for my$mod (@{$map->{$method}}){push @$mods,[$type=>$method=>$mod ]}}}$INFO{$role}{inhaled_from_moose}=1;$INFO{$role}{is_role}=1}}sub _maybe_make_accessors {my ($self,$target,$role)=@_;my$m;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}or $INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($target)and ref($m)ne 'Method::Generate::Accessor'){$self->_make_accessors($target,$role)}}sub _make_accessors_if_moose {my ($self,$target,$role)=@_;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}){$self->_make_accessors($target,$role)}}sub _make_accessors {my ($self,$target,$role)=@_;my$acc_gen=($Moo::MAKERS{$target}{accessor}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new});my$con_gen=$Moo::MAKERS{$target}{constructor};my@attrs=@{$INFO{$role}{attributes}||[]};while (my ($name,$spec)=splice@attrs,0,2){if ($con_gen){$spec=$con_gen->all_attribute_specs->{$name}}$acc_gen->generate_method($target,$name,$spec)}}sub _undefer_subs {my ($self,$target,$role)=@_;if ($INC{'Sub/Defer.pm'}){Sub::Defer::undefer_package($role)}}sub role_application_steps {qw(_handle_constructor _undefer_subs _maybe_make_accessors),$_[0]->SUPER::role_application_steps}sub apply_roles_to_package {my ($me,$to,@roles)=@_;for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}$me->SUPER::apply_roles_to_package($to,@roles)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role);$me->SUPER::apply_single_role_to_package($to,$role)}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}my$m;if ($INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($superclass)and ref($m)ne 'Method::Generate::Accessor'){@{*{_getglob("${new_name}::ISA")}{ARRAY}}=($superclass);$Moo::MAKERS{$new_name}={is_class=>1};$me->apply_roles_to_package($new_name,@roles)}else {$me->SUPER::create_class_with_roles($superclass,@roles);$Moo::MAKERS{$new_name}={is_class=>1};$me->_handle_constructor($new_name,$_)for@roles}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($new_name)}$COMPOSED{class}{$new_name}=1;_set_loaded($new_name,(caller)[1]);return$new_name}sub apply_roles_to_object {my ($me,$object,@roles)=@_;my$new=$me->SUPER::apply_roles_to_object($object,@roles);my$class=ref$new;_set_loaded($class,(caller)[1]);my$apply_defaults=exists$APPLY_DEFAULTS{$class}? $APPLY_DEFAULTS{$class}: $APPLY_DEFAULTS{$class}=do {my%attrs=map {@{$INFO{$_}{attributes}||[]}}@roles;if ($INC{'Moo.pm'}and keys%attrs and my$con_gen=Moo->_constructor_maker_for($class)and my$m=Moo->_accessor_maker_for($class)){my$specs=$con_gen->all_attribute_specs;my%captures;my$code=join('',(map {my$name=$_;my$spec=$specs->{$name};if ($m->has_eager_default($name,$spec)){my ($has,$has_cap)=$m->generate_simple_has('$_[0]',$name,$spec);my ($set,$pop_cap)=$m->generate_use_default('$_[0]',$name,$spec,$has);@captures{keys %$has_cap,keys %$pop_cap}=(values %$has_cap,values %$pop_cap);"($set),"}else {()}}sort keys%attrs),);if ($code){require Sub::Quote;Sub::Quote::quote_sub("${class}::_apply_defaults","no warnings 'void';\n$code",\%captures,{package=>$class,no_install=>1,})}else {0}}else {0}};if ($apply_defaults){local$Carp::Internal{+__PACKAGE__}=1;local$Carp::Internal{$class}=1;$new->$apply_defaults}return$new}sub _composable_package_for {my ($self,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$COMPOSED{role}{$composed_name};$self->_make_accessors_if_moose($composed_name,$role);$self->SUPER::_composable_package_for($role)}sub _install_single_modifier {my ($me,@args)=@_;_install_modifier(@args)}sub _install_does {my ($me,$to)=@_;my$new=$me->SUPER::_install_does($to)or return;return _name_coderef("${to}::DOES",$new)}sub does_role {my ($proto,$role)=@_;return 1 if Role::Tiny::does_role($proto,$role);my$meta;if ($INC{'Moose.pm'}and $meta=Class::MOP::class_of($proto)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->can('does_role')){return$meta->does_role($role)}return 0}sub _handle_constructor {my ($me,$to,$role)=@_;my$attr_info=$INFO{$role}&& $INFO{$role}{attributes};return unless$attr_info && @$attr_info;my$info=$INFO{$to};my$con=$INC{"Moo.pm"}&& Moo->_constructor_maker_for($to);my%existing =$info ? @{$info->{attributes}|| []}: $con ? %{$con->all_attribute_specs || {}}: ();my@attr_info=map {@{$attr_info}[$_,$_+1]}grep {!$existing{$attr_info->[$_]}}map {2 * $_}0..@$attr_info/2-1;if ($info){push @{$info->{attributes}||=[]},@attr_info}elsif ($con){$con->register_attribute_specs(map ref()? {%$_ }: $_,@attr_info)}}1;
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;use Moo::_strictures;{no strict 'refs';sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}}BEGIN {my ($su,$sn);$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname or $sn=$INC{'Sub/Name.pm'}or $su=eval {require Sub::Util}&& defined&Sub::Util::set_subname or $sn=eval {require Sub::Name};*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_CAN_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}use Module::Runtime qw(use_package_optimistically module_notional_filename);use Devel::GlobalDestruction ();use Exporter qw(import);use Config;use Carp qw(croak);our@EXPORT=qw(_getglob _install_modifier _load_module _maybe_load_module _getstash _install_coderef _name_coderef _unimport_coderefs _set_loaded);sub _install_modifier {my ($into,$type,$name,$code)=@_;if ($INC{'Sub/Defer.pm'}and my$to_modify=$into->can($name)){Sub::Defer::undefer_sub($to_modify)}require Class::Method::Modifiers;Class::Method::Modifiers::install_modifier(@_)}sub _load_module {my$module=$_[0];my$file=eval {module_notional_filename($module)}or croak $@;use_package_optimistically($module);return 1 if$INC{$file};my$error=$@ || "Can't locate $file";my$stash=_getstash($module)||{};return 1 if grep +(ref($_)|| *$_{CODE}),values %$stash;return 1 if$INC{"Moose.pm"}&& Class::MOP::class_of($module)or Mouse::Util->can('find_meta')&& Mouse::Util::find_meta($module);croak$error}our%MAYBE_LOADED;sub _maybe_load_module {my$module=$_[0];return$MAYBE_LOADED{$module}if exists$MAYBE_LOADED{$module};if(!eval {use_package_optimistically($module)}){warn "$module exists but failed to load with error: $@"}elsif ($INC{module_notional_filename($module)}){return$MAYBE_LOADED{$module}=1}return$MAYBE_LOADED{$module}=0}sub _set_loaded {$INC{Module::Runtime::module_notional_filename($_[0])}||= $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _unimport_coderefs {my ($target,$info)=@_;return unless$info and my$exports=$info->{exports};my%rev=reverse %$exports;my$stash=_getstash($target);for my$name (keys %$exports){if ($stash->{$name}and defined(&{$stash->{$name}})){if ($rev{$target->can($name)}){my$old=delete$stash->{$name};my$full_name=join('::',$target,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});no strict 'refs';*$full_name=*{$old}{$type}}}}}}if ($Config{useithreads}){require Moo::HandleMoose::_TypeMap}1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;use Moo::_strictures;if ("$]" >= 5.010_000){require mro}else {require MRO::Compat}1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;use strict;use warnings;sub import {if ($ENV{MOO_FATAL_WARNINGS}){require strictures;strictures->VERSION(2);@_=('strictures');goto&strictures::import}else {strict->import;warnings->import;warnings->unimport('once')}}1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;use Moo::_strictures;no warnings 'once';use Devel::GlobalDestruction qw(in_global_destruction);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub unimport {croak "Can't disable Moo::sification after inflation has been done" if$Moo::HandleMoose::SETUP_DONE;our$disabled=1}sub Moo::HandleMoose::AuthorityHack::DESTROY {unless (our$disabled or in_global_destruction){require Moo::HandleMoose;Moo::HandleMoose->import}}sub import {return if our$setup_done;if ($INC{"Moose.pm"}){require Moo::HandleMoose;Moo::HandleMoose->import}else {$Moose::AUTHORITY=bless({},'Moo::HandleMoose::AuthorityHack')}$setup_done=1}1;
MOO_SIFICATION

$fatpacked{"MooX/ShortHas.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOOX_SHORTHAS';
  package MooX::ShortHas;use strictures 2;our$VERSION='1.190320';use Moo::_Utils;sub _modified_has {my ($has,$mod,$name,@args)=@_;$has->($name,@{$mod},@args)}sub import {my$caller=caller;my$has=$caller->can("has")or die "Moo not loaded in caller: $caller";my%mods=(lazy=>[qw(is lazy builder)],map {$_=>[is=>$_=>required=>1 ]}qw(ro rwp rw));for my$mod (keys%mods){_install_coderef$caller."::$mod"=>sub {_modified_has$has,$mods{$mod},@_}}}1;
MOOX_SHORTHAS

$fatpacked{"Mu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MU';
  package Mu;use strictures 2;use Import::Into;use Moo ();use MooX::ShortHas ();our$VERSION='1.191300';sub import {my$caller=caller;$_->import::into($caller)for qw(Moo MooX::ShortHas)}1;
MU

$fatpacked{"Mu/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MU_ROLE';
  package Mu::Role;use strictures 2;use Import::Into;use Moo::Role ();use MooX::ShortHas ();our$VERSION='1.191300';sub import {my$caller=caller;$_->import::into($caller)for qw(Moo::Role MooX::ShortHas)}1;
MU_ROLE

$fatpacked{"PPR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPR';
  package PPR;use 5.010;use if $] < 5.018004,re=>'eval';BEGIN {if ($] >= 5.020 && $] <= 5.021){say {STDERR}<<"        END_WARNING"}}use warnings;our$VERSION='0.000023';use utf8;{package PPR::ERROR;use overload q{""}=>'source',q{0+}=>'line',fallback=>1;sub new {my ($class,%obj)=@_;return bless \%obj,$class}sub prefix {return shift->{prefix}}sub source {return shift->{source}}sub line {my$self=shift;my$offset=$self->{line}// shift // 1;return$offset + $self->{prefix}=~ tr/\n//}sub origin {my$self=shift;my$line=shift // 0;my$file=shift // "";return bless {%{$self},line=>$line,file=>$file },ref($self)}sub diagnostic {my$self=shift;my$line=defined$self->{line}? $self->{line}+ $self->{prefix}=~ tr/\n// : 0;my$file=$self->{file}// q{};return q{} if eval "no strict;\n" ."#line $line $file\n" ."sub{ $self->{source} }";my$diagnostic=$@;$diagnostic =~ s{ \s*+ \bat \s++ \( eval \s++ \d++ \) \s++ line \s++ 0,
          Warning: This program is running under Perl $^V and uses the PPR module.
                   Due to an unresolved issue with compilation of large regexes
                   in this version of Perl, your code is likely to compile
                   extremely slowly (i.e. it may take more than a minute).
                   PPR is being loaded at ${\join ' line ', (caller 2)[1,2]}.
          END_WARNING
                                     | \s*+ \( eval \s++ \d++ \)
                                     | \s++ \Z
                                     }{}gx;return$diagnostic}}our$GRAMMAR=qr{
  (?(DEFINE)
  
      (?<PerlDocument>
          \x{FEFF}?+                      # Optional BOM marker
          (?&PerlStatementSequence)
      ) # End of rule
  
      (?<PerlStatementSequence>
          (?>(?&PerlPodSequence))
          (?:
              (?&PerlStatement)
              (?&PerlPodSequence)
          )*+
      ) # End of rule
  
      (?<PerlStatement>
          (?>
              (?>(?&PerlPodSequence))
              (?: (?>(?&PerlLabel)) (?&PerlOWS) )?+
              (?>(?&PerlPodSequence))
              (?>
                  (?&PerlKeyword)
              |
                  # Inlined (?&PerlSubroutineDeclaration)
                  (?>
                      sub \b                             (?>(?&PerlOWS))
                      (?>(?&PerlOldQualifiedIdentifier))    (?&PerlOWS)
                  |
                      AUTOLOAD                              (?&PerlOWS)
                  |
                      DESTROY                               (?&PerlOWS)
                  )
                  (?:
                      # Perl pre 5.028
                      (?:
                          (?>
                              (?&PerlParenthesesList)    # Parameter list
                          |
                              \( [^)]*+ \)               # Prototype (
                          )
                          (?&PerlOWS)
                      )?+
                      (?: (?>(?&PerlAttributes))  (?&PerlOWS) )?+
                  |
                      # Perl post 5.028
                      (?: (?>(?&PerlAttributes))       (?&PerlOWS) )?+
                      (?: (?>(?&PerlParenthesesList))  (?&PerlOWS) )?+    # Parameter list
                  )
                  (?> ; | (?&PerlBlock) )
                  # End of inlining
              |
                  # Inlined (?&PerlUseStatement)
                  (?: use | no ) (?>(?&PerlNWS))
                  (?>
                      (?&PerlVersionNumber)
                  |
                      (?>(?&PerlQualifiedIdentifier))
                      (?: (?>(?&PerlNWS)) (?&PerlVersionNumber)
                          (?! (?>(?&PerlOWS)) (?> (?&PerlInfixBinaryOperator) | (?&PerlComma) | \? ) )
                      )?+
                      (?: (?>(?&PerlNWS)) (?&PerlPodSequence) )?+
                      (?: (?>(?&PerlOWS)) (?&PerlExpression) )?+
                  )
                  (?>(?&PerlOWS)) (?> ; | (?= \} | \z ))
                  # End of inlining
              |
                  # Inlined (?&PerlPackageDeclaration)
                  package
                      (?>(?&PerlNWS)) (?>(?&PerlQualifiedIdentifier))
                  (?: (?>(?&PerlNWS)) (?&PerlVersionNumber) )?+
                      (?>(?&PerlOWS)) (?> ; | (?&PerlBlock) | (?= \} | \z ))
                  # End of inlining
              |
                  (?&PerlControlBlock)
              |
                  (?&PerlFormat)
              |
                  (?>(?&PerlExpression))          (?>(?&PerlOWS))
                  (?&PerlStatementModifier)?+     (?>(?&PerlOWS))
                  (?> ; | (?= \} | \z ))
              |
                  (?&PerlBlock)
              |
                  ;
              )
  
          | # A yada-yada...
              \.\.\. (?>(?&PerlOWS))
              (?> ; | (?= \} | \z ))
  
          | # Just a label...
              (?>(?&PerlLabel)) (?>(?&PerlOWS))
              (?> ; | (?= \} | \z ))
  
          | # Just an empty statement...
              (?>(?&PerlOWS)) ;
  
          | # An error (report it, if it's the first)...
              (?(?{ !defined $PPR::ERROR })
                  (?> (?&PerlOWS) )
                  (?! (?: \} | \z ) )
                  (?{ pos() })
                  ( (?&PerlExpression) (?&PerlOWS) [^\n]++ | [^;\}]++ )
                  (?{ $PPR::ERROR //= PPR::ERROR->new(source => $^N, prefix => substr($_, 0, $^R) ) })
                  (?!)
              )
          )
      ) # End of rule
  
      (?<PerlSubroutineDeclaration>
         (?>
             sub \b                             (?>(?&PerlOWS))
             (?>(?&PerlOldQualifiedIdentifier))    (?&PerlOWS)
         |
             AUTOLOAD                              (?&PerlOWS)
         |
             DESTROY                               (?&PerlOWS)
         )
         (?:
             # Perl pre 5.028
             (?:
                 (?>
                     (?&PerlParenthesesList)    # Parameter list
                 |
                     \( [^)]*+ \)               # Prototype (
                 )
                 (?&PerlOWS)
             )?+
             (?: (?>(?&PerlAttributes))  (?&PerlOWS) )?+
         |
             # Perl post 5.028
             (?: (?>(?&PerlAttributes))       (?&PerlOWS) )?+
             (?: (?>(?&PerlParenthesesList))  (?&PerlOWS) )?+    # Parameter list
         )
         (?> ; | (?&PerlBlock) )
      ) # End of rule
  
      (?<PerlUseStatement>
         (?: use | no ) (?>(?&PerlNWS))
         (?>
             (?&PerlVersionNumber)
         |
             (?>(?&PerlQualifiedIdentifier))
             (?: (?>(?&PerlNWS)) (?&PerlVersionNumber)
                 (?! (?>(?&PerlOWS)) (?> (?&PerlInfixBinaryOperator) | (?&PerlComma) | \? ) )
             )?+
             (?: (?>(?&PerlNWS)) (?&PerlPodSequence) )?+
             (?: (?>(?&PerlOWS)) (?&PerlExpression) )?+
         )
         (?>(?&PerlOWS)) (?> ; | (?= \} | \z ))
      ) # End of rule
  
      (?<PerlReturnExpression>
         return \b (?>(?&PerlOWS)) (?&PerlExpression)
      ) # End of rule
  
      (?<PerlReturnStatement>
         return \b (?: (?>(?&PerlOWS)) (?&PerlExpression) )?+
         (?>(?&PerlOWS)) (?> ; | (?= \} | \z ))
      ) # End of rule
  
      (?<PerlPackageDeclaration>
         package
             (?>(?&PerlNWS)) (?>(?&PerlQualifiedIdentifier))
         (?: (?>(?&PerlNWS)) (?&PerlVersionNumber) )?+
             (?>(?&PerlOWS)) (?> ; | (?&PerlBlock) | (?= \} | \z ))
      ) # End of rule
  
      (?<PerlExpression>
                              (?>(?&PerlLowPrecedenceNotExpression))
          (?: (?>(?&PerlOWS)) (?>(?&PerlLowPrecedenceInfixOperator))
              (?>(?&PerlOWS))    (?&PerlLowPrecedenceNotExpression)  )*+
      ) # End of rule
  
      (?<PerlLowPrecedenceNotExpression>
          (?: not \b (?&PerlOWS) )*+  (?&PerlCommaList)
      ) # End of rule
  
      (?<PerlCommaList>
                  (?>(?&PerlAssignment))  (?>(?&PerlOWS))
          (?:
              (?: (?>(?&PerlComma))          (?&PerlOWS)   )++
                  (?>(?&PerlAssignment))  (?>(?&PerlOWS))
          )*+
              (?: (?>(?&PerlComma))          (?&PerlOWS)   )*+
      ) # End of rule
  
      (?<PerlAssignment>
                              (?>(?&PerlConditionalExpression))
          (?:
              (?>(?&PerlOWS)) (?>(?&PerlAssignmentOperator))
              (?>(?&PerlOWS))    (?&PerlConditionalExpression)
          )*+
      ) # End of rule
  
      (?<PerlScalarExpression>
      (?<PerlConditionalExpression>
          (?>(?&PerlBinaryExpression))
          (?:
              (?>(?&PerlOWS)) \? (?>(?&PerlOWS)) (?>(?&PerlAssignment))
              (?>(?&PerlOWS))  : (?>(?&PerlOWS))    (?&PerlConditionalExpression)
          )?+
      ) # End of rule
      ) # End of rule
  
      (?<PerlBinaryExpression>
                              (?>(?&PerlPrefixPostfixTerm))
          (?: (?>(?&PerlOWS)) (?>(?&PerlInfixBinaryOperator))
              (?>(?&PerlOWS))    (?&PerlPrefixPostfixTerm) )*+
      ) # End of rule
  
      (?<PerlPrefixPostfixTerm>
          (?: (?>(?&PerlPrefixUnaryOperator))  (?&PerlOWS) )*+
          (?>(?&PerlTerm))
          (?:
              # Inlined (?&PerlTermPostfixDereference)
              (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
              (?>
                  (?> (?&PerlQualifiedIdentifier) | (?&PerlVariableScalar) )
                  (?: (?>(?&PerlOWS)) (?&PerlParenthesesList) )?+
  
              |   (?&PerlParenthesesList)
              |   (?&PerlArrayIndexer)
              |   (?&PerlHashIndexer)
              |   \$\*
              )
  
              (?:
                  (?>(?&PerlOWS))
                  (?>
                      ->  (?>(?&PerlOWS))
                      (?> (?&PerlQualifiedIdentifier) | (?&PerlVariableScalar) )
                      (?: (?>(?&PerlOWS)) (?&PerlParenthesesList) )?+
                  |
                      (?: -> (?&PerlOWS) )?+
                      (?> (?&PerlParenthesesList)
                      |   (?&PerlArrayIndexer)
                      |   (?&PerlHashIndexer)
                      |   \$\*
                      )
                  )
              )*+
  
              (?:
                  (?>(?&PerlOWS)) -> (?>(?&PerlOWS)) [\@%]
                  (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
              )?+
              # End of inlining
          )?+
          (?: (?>(?&PerlOWS)) (?&PerlPostfixUnaryOperator) )?+
      ) # End of rule
  
      (?<PerlLvalue>
          (?>
              \\?+ [\$\@%] (?>(?&PerlOWS)) (?&PerlIdentifier)
          |
              \(                                                                     (?>(?&PerlOWS))
                  (?> \\?+ [\$\@%] (?>(?&PerlOWS)) (?&PerlIdentifier) | undef )      (?>(?&PerlOWS))
                  (?:
                      (?>(?&PerlComma))                                              (?>(?&PerlOWS))
                      (?> \\?+ [\$\@%] (?>(?&PerlOWS)) (?&PerlIdentifier) | undef )  (?>(?&PerlOWS))
                  )*+
                  (?: (?>(?&PerlComma)) (?&PerlOWS) )?+
              \)
          )
      ) # End of rule
  
      (?<PerlTerm>
          (?>
              # Inlined (?&PerlReturnExpression)
              return \b (?>(?&PerlOWS)) (?&PerlExpression)
              # End of inlining
          |
              # Inlined (?&PerlVariableDeclaration)
              (?> my | state | our ) \b           (?>(?&PerlOWS))
              (?: (?&PerlQualifiedIdentifier)        (?&PerlOWS)  )?+
              (?>(?&PerlLvalue))                  (?>(?&PerlOWS))
              (?&PerlAttributes)?+
              # End of inlining
          |
              (?&PerlAnonymousSubroutine)
          |
              (?&PerlVariable)
          |
              (?>(?&PerlNullaryBuiltinFunction))  (?! (?>(?&PerlOWS)) \( )
          |
              # Inlined (?&PerlDoBlock) | (?&PerlEvalBlock)
              (?> do | eval ) (?>(?&PerlOWS)) (?&PerlBlock)
              # End of inlining
          |
              (?&PerlCall)
          |
              (?&PerlTypeglob)
          |
              (?>(?&PerlParenthesesList))
              (?: (?>(?&PerlOWS)) (?&PerlArrayIndexer) )?+
              (?:
                  (?>(?&PerlOWS))
                  (?>
                      (?&PerlArrayIndexer)
                  |   (?&PerlHashIndexer)
                  )
              )*+
          |
              (?&PerlAnonymousArray)
          |
              (?&PerlAnonymousHash)
          |
              (?&PerlDiamondOperator)
          |
              (?&PerlContextualMatch)
          |
              (?&PerlQuotelikeS)
          |
              (?&PerlQuotelikeTR)
          |
              (?&PerlQuotelikeQX)
          |
              (?&PerlLiteral)
          )
      ) # End of rule
  
      (?<PerlTermPostfixDereference>
         (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
         (?>
             (?> (?&PerlQualifiedIdentifier) | (?&PerlVariableScalar) )
             (?: (?>(?&PerlOWS)) (?&PerlParenthesesList) )?+
  
         |   (?&PerlParenthesesList)
         |   (?&PerlArrayIndexer)
         |   (?&PerlHashIndexer)
         |   \$\*
         )
  
         (?:
             (?>(?&PerlOWS))
             (?>
                 ->  (?>(?&PerlOWS))
                 (?> (?&PerlQualifiedIdentifier) | (?&PerlVariableScalar) )
                 (?: (?>(?&PerlOWS)) (?&PerlParenthesesList) )?+
             |
                 (?: -> (?&PerlOWS) )?+
                 (?> (?&PerlParenthesesList)
                 |   (?&PerlArrayIndexer)
                 |   (?&PerlHashIndexer)
                 |   \$\*
                 )
             )
         )*+
         (?:
             (?>(?&PerlOWS)) -> (?>(?&PerlOWS)) [\@%]
             (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
         )?+
      ) # End of rule
  
      (?<PerlControlBlock>
          (?> # Conditionals...
              (?> if | unless ) \b                 (?>(?&PerlOWS))
              (?>(?&PerlParenthesesList))          (?>(?&PerlOWS))
              (?>(?&PerlBlock))
  
              (?:
                                                   (?>(?&PerlOWS))
                  (?>(?&PerlPodSequence))
                  elsif \b                         (?>(?&PerlOWS))
                  (?>(?&PerlParenthesesList))      (?>(?&PerlOWS))
                  (?&PerlBlock)
              )*+
  
              (?:
                                                   (?>(?&PerlOWS))
                  (?>(?&PerlPodSequence))
                  else \b                          (?>(?&PerlOWS))
                  (?&PerlBlock)
              )?+
  
          |   # Loops...
              (?>
                  for(?:each)?+ \b
                  (?>(?&PerlOWS))
                  (?:
                      (?> # Explicitly aliased iterator variable...
                          (?> \\ (?>(?&PerlOWS))  (?> my | our | state )
                          |                       (?> my | our | state )  (?>(?&PerlOWS)) \\
                          )
                          (?>(?&PerlOWS))
                          (?> (?&PerlVariableScalar)
                          |   (?&PerlVariableArray)
                          |   (?&PerlVariableHash)
                          )
                      |
                          # Implicitly aliased iterator variable...
                          (?> (?: my | our | state ) (?>(?&PerlOWS)) )?+
                          (?&PerlVariableScalar)
                      )?+
                      (?>(?&PerlOWS))
                      (?> (?&PerlParenthesesList) | (?&PerlQuotelikeQW) )
                  |
                      (?&PPR_three_part_list)
                  )
              |
                  (?> while | until) \b (?>(?&PerlOWS))
                  (?&PerlParenthesesList)
              )
  
              (?>(?&PerlOWS))
              (?>(?&PerlBlock))
  
              (?:
                  (?>(?&PerlOWS))   continue
                  (?>(?&PerlOWS))   (?&PerlBlock)
              )?+
  
          | # Phasers...
              (?> BEGIN | END | CHECK | INIT | UNITCHECK ) \b   (?>(?&PerlOWS))
              (?&PerlBlock)
  
          | # Switches...
              (?> given | when ) \b                             (?>(?&PerlOWS))
              (?>(?&PerlParenthesesList))                            (?>(?&PerlOWS))
              (?&PerlBlock)
          |
              default                                           (?>(?&PerlOWS))
              (?&PerlBlock)
          )
      ) # End of rule
  
      (?<PerlFormat>
          format
          (?: (?>(?&PerlNWS))  (?&PerlQualifiedIdentifier)  )?+
              (?>(?&PerlOWS))  = [^\n]*+
              (?&PPR_newline_and_heredoc)
          (?:
              (?! \. \n )
              [^\n\$\@]*+
              (?:
                  (?>
                      (?= \$ (?! \s ) )  (?&PerlScalarAccessNoSpace)
                  |
                      (?= \@ (?! \s ) )  (?&PerlArrayAccessNoSpace)
                  )
                  [^\n\$\@]*+
              )*+
              (?&PPR_newline_and_heredoc)
          )*+
          \. (?&PerlEndOfLine)
      ) # End of rule
  
      (?<PerlStatementModifier>
          (?> if | for(?:each)?+ | while | unless | until | when )
          \b
          (?>(?&PerlOWS))
          (?&PerlExpression)
      ) # End of rule
  
      (?<PerlBlock>
          \{  (?>(?&PerlStatementSequence))  \}
      ) # End of rule
  
      (?<PerlCall>
          (?>
              [&]                                    (?>(?&PerlOWS))
              (?> (?&PerlBlock)
              |   (?&PerlVariableScalar)
              |   (?&PerlQualifiedIdentifier)
              )                                      (?>(?&PerlOWS))
              (?:
                  \(                                 (?>(?&PerlOWS))
                      (?: (?>(?&PerlExpression))        (?&PerlOWS)   )?+
                  \)
              )?+
          |
              - (?>(?&PPR_filetest_name))            (?>(?&PerlOWS))
              (?&PerlPrefixPostfixTerm)?+
          |
              (?>(?&PerlBuiltinFunction))            (?>(?&PerlOWS))
              (?>
                  \(                                 (?>(?&PerlOWS))
                      (?>
                          (?= (?>(?&PPR_non_reserved_identifier))
                              (?>(?&PerlOWS))
                              (?! \( | (?&PerlComma) )
                          )
                          (?&PerlCall)
                      |
                          (?>(?&PerlBlock))          (?>(?&PerlOWS))
                          (?&PerlExpression)?+
                      |
                          (?>(?&PPR_indirect_obj))   (?>(?&PerlNWS))
                          (?&PerlExpression)
                      |
                          (?&PerlExpression)?+
                      )                              (?>(?&PerlOWS))
                  \)
              |
                      (?>
                          (?=
                              (?>(?&PPR_non_reserved_identifier))
                              (?>(?&PerlOWS))
                              (?! \( | (?&PerlComma) )
                          )
                          (?&PerlCall)
                      |
                          (?>(?&PerlBlock))          (?>(?&PerlOWS))
                          (?&PerlCommaList)?+
                      |
                          (?>(?&PPR_indirect_obj))   (?>(?&PerlNWS))
                          (?&PerlCommaList)
                      |
                          (?&PerlCommaList)?+
                      )
              )
          |
              (?>(?&PPR_non_reserved_identifier)) (?>(?&PerlOWS))
              (?>
                  \(                              (?>(?&PerlOWS))
                      (?: (?>(?&PerlExpression))     (?&PerlOWS)  )?+
                  \)
              |
                      (?>
                          (?=
                              (?>(?&PPR_non_reserved_identifier))
                              (?>(?&PerlOWS))
                              (?! \( | (?&PerlComma) )
                          )
                          (?&PerlCall)
                      |
                          (?>(?&PerlBlock))           (?>(?&PerlOWS))
                          (?&PerlCommaList)?+
                      |
                          (?>(?&PPR_indirect_obj))        (?&PerlNWS)
                          (?&PerlCommaList)
                      |
                          (?&PerlCommaList)?+
                      )
              )
          )
      ) # End of rule
  
      (?<PerlVariableDeclaration>
          (?> my | state | our ) \b           (?>(?&PerlOWS))
          (?: (?&PerlQualifiedIdentifier)        (?&PerlOWS)  )?+
          (?>(?&PerlLvalue))                  (?>(?&PerlOWS))
          (?&PerlAttributes)?+
      ) # End of rule
  
      (?<PerlDoBlock>
          do (?>(?&PerlOWS)) (?&PerlBlock)
      ) # End of rule
  
      (?<PerlEvalBlock>
          eval (?>(?&PerlOWS)) (?&PerlBlock)
      ) # End of rule
  
      (?<PerlAttributes>
          :
          (?>(?&PerlOWS))
          (?>(?&PerlIdentifier))
          (?:
              (?= \( ) (?&PPR_quotelike_body)
          )?+
  
          (?:
              (?> (?>(?&PerlOWS)) : (?&PerlOWS) | (?&PerlNWS) )
              (?>(?&PerlIdentifier))
              (?:
                  (?= \( ) (?&PPR_quotelike_body)
              )?+
          )*+
      ) # End of rule
  
      (?<PerlList>
          (?> (?&PerlParenthesesList) | (?&PerlCommaList) )
      ) # End of rule
  
      (?<PerlParenthesesList>
          \(  (?>(?&PerlOWS))  (?: (?>(?&PerlExpression)) (?&PerlOWS) )?+  \)
      ) # End of rule
  
      (?<PerlAnonymousArray>
          \[  (?>(?&PerlOWS))  (?: (?>(?&PerlExpression)) (?&PerlOWS) )?+  \]
      ) # End of rule
  
      (?<PerlAnonymousHash>
          \{  (?>(?&PerlOWS))  (?: (?>(?&PerlExpression)) (?&PerlOWS) )?+ \}
      ) # End of rule
  
      (?<PerlArrayIndexer>
          \[                          (?>(?&PerlOWS))
              (?>(?&PerlExpression))  (?>(?&PerlOWS))
          \]
      ) # End of rule
  
      (?<PerlHashIndexer>
          \{  (?>(?&PerlOWS))
              (?: -?+ (?&PerlIdentifier) | (?&PerlExpression) )  # (Note: MUST allow backtracking here)
              (?>(?&PerlOWS))
          \}
      ) # End of rule
  
      (?<PerlDiamondOperator>
          <<>>    # Perl 5.22 "double diamond"
        |
          < (?! < )
              (?>(?&PPR_balanced_angles))
          >
          (?=
              (?>(?&PerlOWS))
              (?> \z | [,;\}\])?] | => | : (?! :)        # (
              |   (?&PerlInfixBinaryOperator) | (?&PerlLowPrecedenceInfixOperator)
              |   (?= \w) (?> for(?:each)?+ | while | if | unless | until | when )
              )
          )
      ) # End of rule
  
      (?<PerlComma>
          (?> , | => )
      ) # End of rule
  
      (?<PerlPrefixUnaryOperator>
          (?> [!\\+~] | \+\+  |  --  | - (?! (?&PPR_filetest_name) \b ) )
      ) # End of rule
  
      (?<PerlPostfixUnaryOperator>
          (?> \+\+  |  -- )
      ) # End of rule
  
      (?<PerlInfixBinaryOperator>
          (?>  [=!][~=]
          |    cmp
          |    <= >?+
          |    >=
          |    [lg][te]
          |    eq
          |    ne
          |    [+]             (?! [+=] )
          |     -              (?! [-=] )
          |    [.]{2,3}+
          |    [.%x]           (?! [=]  )
          |    [&|^][.]        (?! [=]  )
          |    [<>*&|/]{1,2}+  (?! [=]  )
          |    \^              (?! [=]  )
          |    ~~
          )
      ) # End of rule
  
      (?<PerlAssignmentOperator>
          (?:  [<>*&|/]{2}
            |  [-+.*/%x]
            |  [&|^][.]?+
          )?+
          =
          (?! > )
      ) # End of rule
  
      (?<PerlLowPrecedenceInfixOperator>
          (?> or | and | xor )
      ) # End of rule
  
      (?<PerlAnonymousSubroutine>
          sub \b
          (?>(?&PerlOWS))
          (?:
              # Perl pre 5.028
              (?:
                  (?>
                      (?&PerlParenthesesList)    # Parameter list
                  |
                      \( [^)]*+ \)               # Prototype (
                  )
                  (?&PerlOWS)
              )?+
              (?: (?>(?&PerlAttributes))  (?&PerlOWS) )?+
          |
              # Perl post 5.028
              (?: (?>(?&PerlAttributes))       (?&PerlOWS) )?+
              (?: (?>(?&PerlParenthesesList))  (?&PerlOWS) )?+    # Parameter list
          )
          (?&PerlBlock)
      ) # End of rule
  
      (?<PerlVariable>
          (?= [\$\@%] )
          (?>
              (?&PerlScalarAccess)
          |   (?&PerlHashAccess)
          |   (?&PerlArrayAccess)
          )
      ) # End of rule
  
      (?<PerlTypeglob>
          \*
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier))  (?: :: )?+
          |
              (?&PerlVariableScalar)
          |
              [][!"#\$%&'()*+,./:;<=>?\@\^`|~-]
          |
              (?&PerlBlock)
          )
          (?:
              (?>(?&PerlOWS)) (?: -> (?&PerlOWS) )?+
              (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
          )*+
          (?:
              (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
              [\@%]
              (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
          )?+
      ) # End of rule
  
      (?<PerlArrayAccess>
          (?>(?&PerlVariableArray))
          (?:
              (?>(?&PerlOWS)) (?: -> (?&PerlOWS) )?+
              (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList)  )
          )*+
          (?:
              (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
              [\@%]
              (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
          )?+
      ) # End of rule
  
      (?<PerlArrayAccessNoSpace>
          (?>(?&PerlVariableArrayNoSpace))
          (?:
              (?: -> )?+
              (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList)  )
          )*+
          (?:
              ->
              [\@%]
              (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
          )?+
      ) # End of rule
  
      (?<PerlArrayAccessNoSpaceNoArrow>
          (?>(?&PerlVariableArray))
          (?:
              (?> (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList)  )
          )*+
      ) # End of rule
  
      (?<PerlHashAccess>
          (?>(?&PerlVariableHash))
          (?:
              (?>(?&PerlOWS)) (?: -> (?&PerlOWS) )?+
              (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
          )*+
          (?:
              (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
              [\@%]
              (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
          )?+
      ) # End of rule
  
      (?<PerlScalarAccess>
          (?>(?&PerlVariableScalar))
          (?:
              (?>(?&PerlOWS))
              (?:
                  (?:
                      (?>(?&PerlOWS))      -> (?>(?&PerlOWS))
                      (?&PerlParenthesesList)
                  |
                      (?>(?&PerlOWS))  (?: ->    (?&PerlOWS)  )?+
                      (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
                  )
                  (?:
                      (?>(?&PerlOWS))  (?: ->    (?&PerlOWS)  )?+
                      (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
                  )*+
              )?+
              (?:
                  (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
                  [\@%]
                  (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
              )?+
          )?+
      ) # End of rule
  
      (?<PerlScalarAccessNoSpace>
          (?>(?&PerlVariableScalarNoSpace))
          (?:
              (?:
                  (?:
                      ->
                      (?&PerlParenthesesList)
                  |
                      (?: -> )?+
                      (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
                  )
                  (?:
                      (?: -> )?+
                      (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
                  )*+
              )?+
              (?:
                  ->
                  [\@%]
                  (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
              )?+
          )?+
      ) # End of rule
  
      (?<PerlScalarAccessNoSpaceNoArrow>
          (?>(?&PerlVariableScalarNoSpace))
          (?:
              (?> (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
          )*+
      ) # End of rule
  
      (?<PerlVariableScalar>
          \$\$
          (?! [\$\{\w] )
      |
          (?:
              \$
              (?:
                  [#]
                  (?=  (?> [\$^\w\{:+] | - (?! > ) )  )
              )?+
              (?&PerlOWS)
          )++
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              \{ [!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-] \}
          |
              \{ \w++ \}
          |
              (?&PerlBlock)
          )
      |
          \$\#
      ) # End of rule
  
      (?<PerlVariableScalarNoSpace>
          \$\$
          (?! [\$\{\w] )
      |
          (?:
              \$
              (?:
                  [#]
                  (?=  (?> [\$^\w\{:+] | - (?! > ) )  )
              )?+
          )++
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              \{ \w++ \}
          |
              (?&PerlBlock)
          )
      |
          \$\#
      ) # End of rule
  
      (?<PerlVariableArray>
          \@     (?>(?&PerlOWS))
          (?: \$    (?&PerlOWS)  )*+
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              (?&PerlBlock)
          )
      ) # End of rule
  
      (?<PerlVariableArrayNoSpace>
          \@
          (?: \$ )*+
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              (?&PerlBlock)
          )
      ) # End of rule
  
      (?<PerlVariableHash>
          %      (?>(?&PerlOWS))
          (?: \$    (?&PerlOWS)  )*+
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)?+
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              (?&PerlBlock)
          )
      ) # End of rule
  
      (?<PerlLabel>
          (?! (?> [msy] | q[wrxq]?+ | tr ) \b )
          (?>(?&PerlIdentifier))
          : (?! : )
      ) # End of rule
  
      (?<PerlLiteral>
          (?> (?&PerlString)
          |   (?&PerlQuotelikeQR)
          |   (?&PerlQuotelikeQW)
          |   (?&PerlNumber)
          |   (?&PerlBareword)
          )
      ) # End of rule
  
      (?<PerlString>
          (?>
              "  [^"\\]*+  (?: \\. [^"\\]*+ )*+ "
          |
              '  [^'\\]*+  (?: \\. [^'\\]*+ )*+ '
          |
              qq \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_quotelike_body_interpolated)
          |
              q \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_quotelike_body)
          |
              (?&PerlHeredoc)
          |
              (?&PerlVString)
          )
      ) # End of rule
  
      (?<PerlQuotelike>
          (?> (?&PerlString)
          |   (?&PerlQuotelikeQR)
          |   (?&PerlQuotelikeQW)
          |   (?&PerlQuotelikeQX)
          |   (?&PerlContextualMatch)
          |   (?&PerlQuotelikeS)
          |   (?&PerlQuotelikeTR)
      )
      ) # End of rule
  
      (?<PerlHeredoc>
          # Match the introducer...
          <<
          (?<_heredoc_indented> [~]?+ )
  
          # Match the terminator specification...
          (?>
              \\?+   (?<_heredoc_terminator>  (?&PerlIdentifier)              )
          |
              (?>(?&PerlOWS))
              (?>
                  "  (?<_heredoc_terminator>  [^"\\]*+  (?: \\. [^"\\]*+ )*+  )  "  #"
              |
                  (?<PPR_HD_nointerp> ' )
                     (?<_heredoc_terminator>  [^'\\]*+  (?: \\. [^'\\]*+ )*+  )  '  #'
              |
                  `  (?<_heredoc_terminator>  [^`\\]*+  (?: \\. [^`\\]*+ )*+  )  `  #`
              )
          |
                     (?<_heredoc_terminator>                                  )
          )
  
          # Do we need to reset the heredoc cache???
          (?{
              if ( ($PPR::_heredoc_origin // q{}) ne $_ ) {
                  %PPR::_heredoc_skip      = ();
                  %PPR::_heredoc_parsed_to = ();
                  $PPR::_heredoc_origin    = $_;
              }
          })
  
          # Do we need to cache content lookahead for this heredoc???
          (?(?{ my $need_to_lookahead = !$PPR::_heredoc_parsed_to{+pos()};
                $PPR::_heredoc_parsed_to{+pos()} = 1;
                $need_to_lookahead;
              })
  
              # Lookahead to detect and remember trailing contents of heredoc
              (?=
                  [^\n]*+ \n                                   # Go to the end of the current line
                  (?{ +pos() })                                # Remember the start of the contents
                  (??{ $PPR::_heredoc_skip{+pos()} // q{} })   # Skip earlier heredoc contents
                  (?>                                          # The heredoc contents consist of...
                      (?:
                          (?!
                              (?(?{ $+{_heredoc_indented} }) \h*+ )   # An indent (if it was a <<~)
                              \g{_heredoc_terminator}                 # The terminator
                              (?: \n | \z )                           # At an end-of-line
                          )
                          (?(<PPR_HD_nointerp>)
                              [^\n]*+ \n
                          |
                              [^\n\$\@]*+
                              (?:
                                  (?>
                                      (?{ local $PPR::_heredoc_EOL_start = $^R })
                                      (?= \$ (?! \s ) )  (?&PerlScalarAccessNoSpace)
                                      (?{ $PPR::_heredoc_EOL_start })
                                  |
                                      (?{ local $PPR::_heredoc_EOL_start = $^R })
                                      (?= \@ (?! \s ) )  (?&PerlArrayAccessNoSpace)
                                      (?{ $PPR::_heredoc_EOL_start })
                                  )
                                  [^\n\$\@]*+
                              )*+
                              \n (??{ $PPR::_heredoc_skip{+pos()} // q{} })
                          )
                      )*+
  
                      (?(?{ $+{_heredoc_indented} }) \h*+ )            # An indent (if it was a <<~)
                      \g{_heredoc_terminator}                          # The specified terminator
                      (?: \n | \z )                                    # Followed by EOL
                  )
  
                  # Then memoize the skip for when it's subsequently needed by PerlOWS or PerlNWS...
                  (?{
                      $PPR::_heredoc_skip{$^R} = "(?s:.\{" . (pos() - $^R) . "\})";
                  })
              )
          )
  
      ) # End of rule
  
      (?<PerlQuotelikeQ>
          (?>
              '  [^'\\]*+  (?: \\. [^'\\]*+ )*+ '
          |
              \b q \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_quotelike_body)
          )
      ) # End of rule
  
      (?<PerlQuotelikeQQ>
          (?>
              "  [^"\\]*+  (?: \\. [^"\\]*+ )*+ "
          |
              \b qq \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_quotelike_body_interpolated)
          )
      ) # End of rule
  
      (?<PerlQuotelikeQW>
          (?>
              qw \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_quotelike_body)
          )
      ) # End of rule
  
      (?<PerlQuotelikeQX>
          (?>
              `  [^`]*+  (?: \\. [^`]*+ )*+  `
          |
              qx
                  (?:
                      (?&PerlOWS) ' (?&PPR_quotelike_body)
                  |
                      \b (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
                      (?&PPR_quotelike_body_interpolated)
                  )
          )
      ) # End of rule
  
      (?<PerlQuotelikeS>
      (?<PerlSubstitution>
          s \b
          (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
          (?>
              # Hashed syntax...
              (?= [#] )
              (?>(?&PPR_quotelike_body_interpolated_unclosed))
                 (?&PPR_quotelike_s_e_check)
              (?>(?&PPR_quotelike_body_interpolated))
          |
              # Bracketed syntax...
              (?= (?>(?&PerlOWS)) [\[(<\{] )      # )
              (?>(?&PPR_quotelike_body_interpolated))
              (?>(?&PerlOWS))
                 (?&PPR_quotelike_s_e_check)
              (?>(?&PPR_quotelike_body_interpolated))
          |
              # Delimited syntax...
              (?>(?&PPR_quotelike_body_interpolated_unclosed))
                 (?&PPR_quotelike_s_e_check)
              (?>(?&PPR_quotelike_body_interpolated))
          )
          [msixpodualgcern]*+
      ) # End of rule
      ) # End of rule
  
      (?<PerlQuotelikeTR>
      (?<PerlTransliteration>
          (?> tr | y ) \b
          (?! (?>(?&PerlOWS)) => )
          (?>
              # Hashed syntax...
              (?= [#] )
              (?>(?&PPR_quotelike_body_interpolated_unclosed))
                 (?&PPR_quotelike_body_interpolated)
          |
              # Bracketed syntax...
              (?= (?>(?&PerlOWS)) [\[(<\{] )      # )
              (?>(?&PPR_quotelike_body_interpolated))
              (?>(?&PerlOWS))
                 (?&PPR_quotelike_body_interpolated)
          |
              # Delimited syntax...
              (?>(?&PPR_quotelike_body_interpolated_unclosed))
                 (?&PPR_quotelike_body_interpolated)
          )
          [cdsr]*+
      ) # End of rule
      ) # End of rule
  
      (?<PerlContextualQuotelikeM>
      (?<PerlContextualMatch>
          (?<PerlQuotelikeM>
          (?<PerlMatch>
              (?>
                  \/\/
              |
                  (?>
                      m (?= [#] )
                  |
                      m \b
                      (?! (?>(?&PerlOWS)) => )
                  |
                      (?= \/ [^/] )
                  )
                  (?&PPR_quotelike_body_interpolated)
              )
              [msixpodualgcn]*+
          ) # End of rule
          ) # End of rule
          (?=
              (?>(?&PerlOWS))
              (?> \z | [,;\}\])?] | => | : (?! :)
              |   (?&PerlInfixBinaryOperator) | (?&PerlLowPrecedenceInfixOperator)
              |   (?= \w) (?> for(?:each)?+ | while | if | unless | until | when )
              )
          )
      ) # End of rule
      ) # End of rule
  
      (?<PerlQuotelikeQR>
          qr \b
          (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
          (?>(?&PPR_quotelike_body_interpolated))
          [msixpodualn]*+
      ) # End of rule
  
      (?<PerlRegex>
          (?>
              (?&PerlMatch)
          |
              (?&PerlQuotelikeQR)
          )
      ) # End of rule
  
      (?<PerlContextualRegex>
          (?>
              (?&PerlContextualMatch)
          |
              (?&PerlQuotelikeQR)
          )
      ) # End of rule
  
  
      (?<PerlBuiltinFunction>
          # Optimized to match any Perl builtin name, without backtracking...
          (?=[^\W\d]) # Skip if possible
          (?>
               s(?>e(?>t(?>(?>(?>(?>hos|ne)t|gr)en|s(?>erven|ockop))t|p(?>r(?>iority|otoent)|went|grp))|m(?>ctl|get|op)|ek(?>dir)?|lect|nd)|y(?>s(?>write|call|open|read|seek|tem)|mlink)|h(?>m(?>write|read|ctl|get)|utdown|ift)|o(?>cket(?>pair)?|rt)|p(?>li(?>ce|t)|rintf)|(?>cala|ubst)r|t(?>ate?|udy)|leep|rand|qrt|ay|in)
              | g(?>et(?>p(?>r(?>oto(?>byn(?>umber|ame)|ent)|iority)|w(?>ent|nam|uid)|eername|grp|pid)|s(?>erv(?>by(?>name|port)|ent)|ock(?>name|opt))|host(?>by(?>addr|name)|ent)|net(?>by(?>addr|name)|ent)|gr(?>ent|gid|nam)|login|c)|mtime|lob|oto|rep)
              | r(?>e(?>ad(?>lin[ek]|pipe|dir)?|(?>quir|vers|nam)e|winddir|turn|set|cv|do|f)|index|mdir|and)
              | c(?>h(?>o(?>m?p|wn)|r(?>oot)?|dir|mod)|o(?>n(?>tinue|nect)|s)|lose(?>dir)?|aller|rypt)
              | e(?>nd(?>(?>hos|ne)t|p(?>roto|w)|serv|gr)ent|x(?>i(?>sts|t)|ec|p)|ach|val(?>bytes)?+|of)
              | l(?>o(?>c(?>al(?>time)?|k)|g)|i(?>sten|nk)|(?>sta|as)t|c(?>first)?|ength)
              | u(?>n(?>(?>lin|pac)k|shift|def|tie)|c(?>first)?|mask|time)
              | p(?>r(?>ototype|intf?)|ack(?>age)?|o[ps]|ipe|ush)
              | d(?>bm(?>close|open)|e(?>fined|lete)|ump|ie|o)
              | f(?>or(?>m(?>line|at)|k)|ileno|cntl|c|lock)
              | t(?>i(?>mes?|ed?)|ell(?>dir)?|runcate)
              | w(?>a(?>it(?>pid)?|ntarray|rn)|rite)
              | m(?>sg(?>ctl|get|rcv|snd)|kdir|ap)
              | b(?>in(?>mode|d)|less|reak)
              | i(?>n(?>dex|t)|mport|octl)
              | a(?>ccept|larm|tan2|bs)
              | o(?>pen(?>dir)?|ct|rd)
              | v(?>alues|ec)
              | k(?>eys|ill)
              | quotemeta
              | join
              | next
              | hex
              | _
          )
          \b
      ) # End of rule
  
      (?<PerlNullaryBuiltinFunction>
          # Optimized to match any Perl builtin name, without backtracking...
          (?= [^\W\d] )  # Skip if possible
          (?>
                get(?:(?:(?:hos|ne)t|serv|gr)ent|p(?:(?:roto|w)ent|pid)|login)
              | end(?:(?:hos|ne)t|p(?:roto|w)|serv|gr)ent
              | wa(?:ntarray|it)
              | times?
              | fork
              | _
          )
          \b
      ) # End of rule
  
      (?<PerlVersionNumber>
          (?>
              (?&PerlVString)
          |
              (?>(?&PPR_digit_seq))
              (?: \. (?&PPR_digit_seq)?+ )*+
          )
      ) # End of rule
  
      (?<PerlVString>
          v  (?>(?&PPR_digit_seq))  (?: \. (?&PPR_digit_seq) )*+
      ) # End of rule
  
      (?<PerlNumber>
          [+-]?+
          (?>
              0  (?>  x (?&PPR_x_digit_seq)
                 |    b (?&PPR_b_digit_seq)
                 |      (?&PPR_o_digit_seq)
                 )
          |
              (?>
                      (?>(?&PPR_digit_seq))
                  (?: \. (?&PPR_digit_seq)?+ )?+
              |
                      \. (?&PPR_digit_seq)
              )
              (?: [eE] [+-]?+ (?&PPR_digit_seq) )?+
          )
      ) # End of rule
  
      (?<PerlOldQualifiedIdentifier>
          (?> (?> :: | ' ) \w++  |  [^\W\d]\w*+ )  (?: (?> :: | ' )  \w++ )*+
      ) # End of rule
  
      (?<PerlQualifiedIdentifier>
          (?>     ::       \w++  |  [^\W\d]\w*+ )  (?: (?> :: | ' )  \w++ )*+
      ) # End of rule
  
      (?<PerlIdentifier>
                                    [^\W\d]\w*+
      ) # End of rule
  
      (?<PerlBareword>
          (?! (?> (?= \w )
                  (?> for(?:each)?+ | while | if | unless | until | use | no | given | when | sub | return )
              |   (?&PPR_named_op)
              |   __ (?> END | DATA ) __ (?&PerlEndOfLine)
              ) \b
              (?! (?>(?&PerlOWS)) => )
          )
          (?! (?> q[qwrx]?+ | [mys] | tr ) \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
          )
          (?: :: )?+
          [^\W\d]\w*+
          (?: (?: :: | ' )  [^\W\d]\w*+  )*+
          (?: :: )?+
          (?! \( )    # )
      |
          :: (?! \w | \{ )
      ) # End of rule
  
      (?<PerlKeyword>
          (?!)    # None, by default, but can be overridden in a composing regex
      ) # End of rule
  
      (?<PerlPodSequence>
          (?>(?&PerlOWS))  (?: (?>(?&PerlPod))  (?&PerlOWS) )*+
      ) # End of rule
  
      (?<PerlPod>
          ^ = [^\W\d]\w*+             # A line starting with =<identifier>
          .*?                         # Up to the first...
          (?>
              ^ = cut \b [^\n]*+ $    # ...line starting with =cut
          |                           # or
              \z                      # ...EOF
          )
      ) # End of rule
  
  
      ##### Whitespace matching (part of API) #################################
  
      (?<PerlOWS>
          (?:
              \h++
          |
              (?&PPR_newline_and_heredoc)
          |
              [#] [^\n]*+
          |
              __ (?> END | DATA ) __ \b .*+ \z
          )*+
      ) # End of rule
  
      (?<PerlNWS>
          (?:
              \h++
          |
              (?&PPR_newline_and_heredoc)
          |
              [#] [^\n]*+
          |
              __ (?> END | DATA ) __ \b .*+ \z
          )++
      ) # End of rule
  
      (?<PerlEndOfLine>
          \n
      ) # End of rule
  
  
      ###### Internal components (not part of API) ##########################
  
      (?<PPR_named_op>
          (?> cmp
          |   [lg][te]
          |   eq
          |   ne
          |   and
          |   or
          |   xor
          )
      )
  
      (?<PPR_non_reserved_identifier>
          (?! (?>
                 for(?:each)?+ | while | if | unless | until | given | when | default
              |  sub | format | use | no
              |  (?&PPR_named_op)
              |  [msy] | q[wrxq]?+ | tr
              |   __ (?> END | DATA ) __ \n
              )
              \b
          )
          (?>(?&PerlQualifiedIdentifier))
          (?! :: )
      )
  
      (?<PPR_three_part_list>
          \(  (?>(?&PerlOWS)) (?: (?>(?&PerlExpression)) (?&PerlOWS) )??
           ;  (?>(?&PerlOWS)) (?: (?>(?&PerlExpression)) (?&PerlOWS) )??
           ;  (?>(?&PerlOWS)) (?: (?>(?&PerlExpression)) (?&PerlOWS) )??
          \)
      )
  
      (?<PPR_indirect_obj>
          (?&PerlBareword)
      |
          (?>(?&PerlVariableScalar))
          (?! (?>(?&PerlOWS)) (?> [<\[\{] | -> ) )
      )
  
      (?<PPR_quotelike_body>
          (?>(?&PPR_quotelike_body_unclosed))
          \S   # (Note: Don't have to test that this matches; the preceding subrule already did that)
      )
  
      (?<PPR_balanced_parens>
          [^)(\\\n]*+
          (?:
              (?>
                  \\.
              |
                  \(  (?>(?&PPR_balanced_parens))  \)
              |
                  (?&PPR_newline_and_heredoc)
              )
              [^)(\\\n]*+
          )*+
      )
  
      (?<PPR_balanced_curlies>
          [^\}\{\\\n]*+
          (?:
              (?>
                  \\.
              |
                  \{  (?>(?&PPR_balanced_curlies))  \}
              |
                  (?&PPR_newline_and_heredoc)
              )
              [^\}\{\\\n]*+
          )*+
      )
  
      (?<PPR_balanced_squares>
          [^][\\\n]*+
          (?:
              (?>
                  \\.
              |
                  \[  (?>(?&PPR_balanced_squares))  \]
              |
                  (?&PPR_newline_and_heredoc)
              )
              [^][\\\n]*+
          )*+
      )
  
      (?<PPR_balanced_angles>
          [^><\\\n]*+
          (?:
              (?>
                  \\.
              |
                  <  (?>(?&PPR_balanced_angles))  >
              |
                  (?&PPR_newline_and_heredoc)
              )
              [^><\\\n]*+
          )*+
      )
  
      (?<PPR_quotelike_body_unclosed>
          (?>
                 [#]
                 [^#\\\n]*+
                 (?:
                     (?: \\. | (?&PPR_newline_and_heredoc) )
                     [^#\\\n]*+
                 )*+
                 (?= [#] )
          |
              (?>(?&PerlOWS))
              (?>
                  \{  (?>(?&PPR_balanced_curlies))    (?= \} )
              |
                  \[  (?>(?&PPR_balanced_squares))    (?= \] )
              |
                  \(  (?>(?&PPR_balanced_parens))     (?= \) )
              |
                   <  (?>(?&PPR_balanced_angles))     (?=  > )
              |
                  \\
                      [^\\\n]*+
                      (
                          (?&PPR_newline_and_heredoc)
                          [^\\\n]*+
                      )*+
                  (?= \\ )
              |
                   /
                       [^\\/\n]*+
                   (?:
                       (?: \\. | (?&PPR_newline_and_heredoc) )
                       [^\\/\n]*+
                   )*+
                   (?=  / )
              |
                  (?<PPR_qldel> \S )
                      (?:
                          \\.
                      |
                          (?&PPR_newline_and_heredoc)
                      |
                          (?! \g{PPR_qldel} ) .
                      )*+
                  (?= \g{PPR_qldel} )
              )
          )
      )
  
      (?<PPR_quotelike_body_interpolated>
          (?>(?&PPR_quotelike_body_interpolated_unclosed))
          \S   # (Note: Don't have to test that this matches; the preceding subrule already did that)
      )
  
      (?<PPR_balanced_parens_interpolated>
          [^)(\\\n\$\@]*+
          (?:
              (?>
                  \\.
              |
                  \(  (?>(?&PPR_balanced_parens_interpolated))  \)
              |
                  (?&PPR_newline_and_heredoc)
              |
                  (?= \$ (?! [\s\)] ) )  (?&PerlScalarAccessNoSpace)
              |
                  (?= \@ (?! [\s\)] ) )  (?&PerlArrayAccessNoSpace)
              |
                  [\$\@]
              )
              [^)(\\\n\$\@]*+
          )*+
      )
  
      (?<PPR_balanced_curlies_interpolated>
          [^\}\{\\\n\$\@]*+
          (?:
              (?>
                  \\.
              |
                  \{  (?>(?&PPR_balanced_curlies_interpolated))  \}
              |
                  (?&PPR_newline_and_heredoc)
              |
                  (?= \$ (?! [\s\}] ) )  (?&PerlScalarAccessNoSpace)
              |
                  (?= \@ (?! [\s\}] ) )  (?&PerlArrayAccessNoSpace)
              |
                  [\$\@]
              )
              [^\}\{\\\n\$\@]*+
          )*+
      )
  
      (?<PPR_balanced_squares_interpolated>
          [^][\\\n\$\@]*+
          (?:
              (?>
                  \\.
              |
                  \[  (?>(?&PPR_balanced_squares_interpolated))  \]
              |
                  (?&PPR_newline_and_heredoc)
              |
                  (?= \$ (?! [\s\]] ) )  (?&PerlScalarAccessNoSpace)
              |
                  (?= \@ (?! [\s\]] ) )  (?&PerlArrayAccessNoSpace)
              |
                  [\$\@]
              )
              [^][\\\n\$\@]*+
          )*+
      )
  
      (?<PPR_balanced_angles_interpolated>
          [^><\\\n\$\@]*+
          (?:
              (?>
                  \\.
              |
                  <  (?>(?&PPR_balanced_angles_interpolated))  >
              |
                  (?&PPR_newline_and_heredoc)
              |
                  (?= \$ (?! [\s>] ) )  (?&PerlScalarAccessNoSpace)
              |
                  (?= \@ (?! [\s>] ) )  (?&PerlArrayAccessNoSpace)
              |
                  [\$\@]
              )
              [^><\\\n\$\@]*+
          )*+
      )
  
      (?<PPR_quotelike_body_interpolated_unclosed>
          # Start by working out where it actually ends (ignoring interpolations)...
          (?=
              (?>
                  [#]
                  [^#\\\n\$\@]*+
                  (?:
                      (?>
                          \\.
                      |
                          (?&PPR_newline_and_heredoc)
                      |
                          (?= \$ (?! [\s#] ) )  (?&PerlScalarAccessNoSpace)
                      |
                          (?= \@ (?! [\s#] ) )  (?&PerlArrayAccessNoSpace)
                      |
                          [\$\@]
                      )
                      [^#\\\n\$\@]*+
                  )*+
                  (?= [#] )
              |
                  (?>(?&PerlOWS))
                  (?>
                      \{  (?>(?&PPR_balanced_curlies_interpolated))    (?= \} )
                  |
                      \[  (?>(?&PPR_balanced_squares_interpolated))    (?= \] )
                  |
                      \(  (?>(?&PPR_balanced_parens_interpolated))     (?= \) )
                  |
                      <  (?>(?&PPR_balanced_angles_interpolated))     (?=  > )
                  |
                      \\
                          [^\\\n\$\@]*+
                          (?:
                              (?>
                                  (?&PPR_newline_and_heredoc)
                              |
                                  (?= \$ (?! [\s\\] ) )  (?&PerlScalarAccessNoSpace)
                              |
                                  (?= \@ (?! [\s\\] ) )  (?&PerlArrayAccessNoSpace)
                              |
                                  [\$\@]
                              )
                              [^\\\n\$\@]*+
                          )*+
                      (?= \\ )
                  |
                      /
                          [^\\/\n\$\@]*+
                          (?:
                              (?>
                                  \\.
                              |
                                  (?&PPR_newline_and_heredoc)
                              |
                                  (?= \$ (?! [\s/] ) )  (?&PerlScalarAccessNoSpace)
                              |
                                  (?= \@ (?! [\s/] ) )  (?&PerlArrayAccessNoSpace)
                              |
                                  [\$\@]
                              )
                              [^\\/\n\$\@]*+
                          )*+
                      (?= / )
                  |
                      -
                          (?:
                              \\.
                          |
                              (?&PPR_newline_and_heredoc)
                          |
                              (?:
                                  (?= \$ (?! [\s-] ) )  (?&PerlScalarAccessNoSpaceNoArrow)
                              |
                                  (?= \@ (?! [\s-] ) )  (?&PerlArrayAccessNoSpaceNoArrow)
                              |
                                  [^-]
                              )
                          )*+
                      (?= - )
                  |
                      (?<PPR_qldel> \S )
                          (?:
                              \\.
                          |
                              (?&PPR_newline_and_heredoc)
                          |
                              (?! \g{PPR_qldel} )
                              (?:
                                  (?= \$ (?! \g{PPR_qldel} | \s ) )  (?&PerlScalarAccessNoSpace)
                              |
                                  (?= \@ (?! \g{PPR_qldel} | \s ) )  (?&PerlArrayAccessNoSpace)
                              |
                                  .
                              )
                          )*+
                      (?= \g{PPR_qldel} )
                  )
              )
          )
  
          (?&PPR_quotelike_body_unclosed)
      )
  
      (?<PPR_quotelike_s_e_check>
          (??{ local $PPR::_quotelike_s_end = -1; '' })
          (?:
              (?=
                  (?&PPR_quotelike_body_interpolated)
                  (??{ $PPR::_quotelike_s_end = +pos(); '' })
                  [msixpodualgcrn]*+ e [msixpodualgcern]*+
              )
              (?=
                  (?(?{ $PPR::_quotelike_s_end >= 0 })
                      (?>
                          (??{ +pos() && +pos() < $PPR::_quotelike_s_end ? '' : '(?!)' })
                          (?>
                              (?&PerlVariable)
                          |
                              (?&PerlQuotelike)
                          |
                              \\?+ .
                          )
                      )*+
                  )
              )
          )?+
      )
  
      (?<PPR_filetest_name>   [ABCMORSTWXbcdefgkloprstuwxz]          )
  
      (?<PPR_digit_seq>               \d++ (?: _?+         \d++ )*+  )
      (?<PPR_x_digit_seq>     [\da-fA-F]++ (?: _?+ [\da-fA-F]++ )*+  )
      (?<PPR_o_digit_seq>          [0-7]++ (?: _?+      [0-7]++ )*+  )
      (?<PPR_b_digit_seq>          [0-1]++ (?: _?+      [0-1]++ )*+  )
  
      (?<PPR_newline_and_heredoc>
          \n (??{ ($PPR::_heredoc_origin // q{}) eq ($_//q{}) ? ($PPR::_heredoc_skip{+pos()} // q{}) : q{} })
      )
  )
  }xms;sub decomment {if ($] >= 5.014 && $] < 5.016){_croak("PPR::decomment() does not work under Perl 5.14")}my ($str)=@_;local%PPR::comment_len;$str =~ m{ \A (?&PerlDocument) \Z
  
                  (?(DEFINE)
                      (?<decomment>
                         ( (?<! [\$@%] ) [#] [^\n]*+ )
                         (?{
                              my $len = length($^N);
                              my $pos = pos() - $len;
                              $PPR::comment_len{$pos} = $len;
                         })
                      )
  
                      (?<PerlOWS>
                          (?:
                              \h++
                          |
                              (?&PPR_newline_and_heredoc)
                          |
                              (?&decomment)
                          |
                              __ (?> END | DATA ) __ \b .*+ \z
                          )*+
                      ) # End of rule
  
                      (?<PerlNWS>
                          (?:
                              \h++
                          |
                              (?&PPR_newline_and_heredoc)
                          |
                              (?&decomment)
                          |
                              __ (?> END | DATA ) __ \b .*+ \z
                          )++
  
                      ) # End of rule
  
                      (?<PerlPod>
                          (
                              ^ = [^\W\d]\w*+
                              .*?
                              (?>
                                  ^ = cut \b [^\n]*+ $
                              |
                                  \z
                              )
                          )
                          (?{
                              my $len = length($^N);
                              my $pos = pos() - $len;
                              $PPR::comment_len{$pos} = $len;
                          })
                      ) # End of rule
  
                      $PPR::GRAMMAR
                  )
              }xms or return;for my$from_pos (_uniq(sort {$b <=> $a}keys%PPR::comment_len)){substr($str,$from_pos,$PPR::comment_len{$from_pos})=q{}}return$str}sub _uniq {my%seen;return grep {!$seen{$_}++}@_}sub _croak {require Carp;Carp::croak(@_)}1;
PPR

$fatpacked{"PPR/X.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPR_X';
  package PPR::X;use 5.010;use if $] < 5.018004,re=>'eval';BEGIN {if ($] >= 5.020 && $] <= 5.021){say {STDERR}<<"        END_WARNING"}}use warnings;our$VERSION='0.000022';use utf8;{package PPR::X::ERROR;use overload q{""}=>'source',q{0+}=>'line',fallback=>1;sub new {my ($class,%obj)=@_;return bless \%obj,$class}sub prefix {return shift->{prefix}}sub source {return shift->{source}}sub line {my$self=shift;my$offset=$self->{line}// shift // 1;return$offset + $self->{prefix}=~ tr/\n//}sub origin {my$self=shift;my$line=shift // 0;my$file=shift // "";return bless {%{$self},line=>$line,file=>$file },ref($self)}sub diagnostic {my$self=shift;my$line=defined$self->{line}? $self->{line}+ $self->{prefix}=~ tr/\n// : 0;my$file=$self->{file}// q{};return q{} if eval "no strict;\n" ."#line $line $file\n" ."sub{ $self->{source} }";my$diagnostic=$@;$diagnostic =~ s{ \s*+ \bat \s++ \( eval \s++ \d++ \) \s++ line \s++ 0,
          Warning: This program is running under Perl $^V and uses the PPR::X module.
                   Due to an unresolved issue with compilation of large regexes
                   in this version of Perl, your code is likely to compile
                   extremely slowly (i.e. it may take more than a minute).
                   PPR::X is being loaded at ${\join ' line ', (caller 2)[1,2]}.
          END_WARNING
                                     | \s*+ \( eval \s++ \d++ \)
                                     | \s++ \Z
                                     }{}gx;return$diagnostic}}our$GRAMMAR=qr{
  (?(DEFINE)
  
      (?<PerlDocument>   (?<PerlStdDocument>
          \x{FEFF}?+                      # Optional BOM marker
          (?&PerlStatementSequence)
      )) # End of rule
  
      (?<PerlStatementSequence>   (?<PerlStdStatementSequence>
          (?>(?&PerlPodSequence))
          (?:
              (?&PerlStatement)
              (?&PerlPodSequence)
          )*+
      )) # End of rule
  
      (?<PerlStatement>   (?<PerlStdStatement>
          (?>
              (?>(?&PerlPodSequence))
              (?: (?>(?&PerlLabel)) (?&PerlOWS) )?+
              (?>(?&PerlPodSequence))
              (?>
                  (?&PerlKeyword)
              |
                  (?&PerlSubroutineDeclaration)
              |
                  (?&PerlUseStatement)
              |
                  (?&PerlPackageDeclaration)
              |
                  (?&PerlControlBlock)
              |
                  (?&PerlFormat)
              |
                  (?>(?&PerlExpression))          (?>(?&PerlOWS))
                  (?&PerlStatementModifier)?+     (?>(?&PerlOWS))
                  (?> ; | (?= \} | \z ))
              |
                  (?&PerlBlock)
              |
                  ;
              )
  
          | # A yada-yada...
              \.\.\. (?>(?&PerlOWS))
              (?> ; | (?= \} | \z ))
  
          | # Just a label...
              (?>(?&PerlLabel)) (?>(?&PerlOWS))
              (?> ; | (?= \} | \z ))
  
          | # Just an empty statement...
              (?>(?&PerlOWS)) ;
  
          | # An error (report it, if it's the first)...
              (?(?{ !defined $PPR::X::ERROR })
                  (?> (?&PerlOWS) )
                  (?! (?: \} | \z ) )
                  (?{ pos() })
                  ( (?&PerlExpression) (?&PerlOWS) [^\n]++ | [^;\}]++ )
                  (?{ $PPR::X::ERROR //= PPR::X::ERROR->new(source => $^N, prefix => substr($_, 0, $^R) ) })
                  (?!)
              )
          )
      )) # End of rule
  
      (?<PerlSubroutineDeclaration>   (?<PerlStdSubroutineDeclaration>
         (?>
             sub \b                             (?>(?&PerlOWS))
             (?>(?&PerlOldQualifiedIdentifier))    (?&PerlOWS)
         |
             AUTOLOAD                              (?&PerlOWS)
         |
             DESTROY                               (?&PerlOWS)
         )
         (?:
             # Perl pre 5.028
             (?:
                 (?>
                     (?&PerlParenthesesList)    # Parameter list
                 |
                     \( [^)]*+ \)               # Prototype (
                 )
                 (?&PerlOWS)
             )?+
             (?: (?>(?&PerlAttributes))  (?&PerlOWS) )?+
         |
             # Perl post 5.028
             (?: (?>(?&PerlAttributes))       (?&PerlOWS) )?+
             (?: (?>(?&PerlParenthesesList))  (?&PerlOWS) )?+    # Parameter list
         )
         (?> ; | (?&PerlBlock) )
      )) # End of rule
  
      (?<PerlUseStatement>   (?<PerlStdUseStatement>
         (?: use | no ) (?>(?&PerlNWS))
         (?>
             (?&PerlVersionNumber)
         |
             (?>(?&PerlQualifiedIdentifier))
             (?: (?>(?&PerlNWS)) (?&PerlVersionNumber)
                 (?! (?>(?&PerlOWS)) (?> (?&PerlInfixBinaryOperator) | (?&PerlComma) | \? ) )
             )?+
             (?: (?>(?&PerlNWS)) (?&PerlPodSequence) )?+
             (?: (?>(?&PerlOWS)) (?&PerlExpression) )?+
         )
         (?>(?&PerlOWS)) (?> ; | (?= \} | \z ))
      )) # End of rule
  
      (?<PerlReturnExpression>   (?<PerlStdReturnExpression>
         return \b (?>(?&PerlOWS)) (?&PerlExpression)
      )) # End of rule
  
      (?<PerlReturnStatement>   (?<PerlStdReturnStatement>
         return \b (?: (?>(?&PerlOWS)) (?&PerlExpression) )?+
         (?>(?&PerlOWS)) (?> ; | (?= \} | \z ))
      )) # End of rule
  
      (?<PerlPackageDeclaration>   (?<PerlStdPackageDeclaration>
         package
             (?>(?&PerlNWS)) (?>(?&PerlQualifiedIdentifier))
         (?: (?>(?&PerlNWS)) (?&PerlVersionNumber) )?+
             (?>(?&PerlOWS)) (?> ; | (?&PerlBlock) | (?= \} | \z ))
      )) # End of rule
  
      (?<PerlExpression>   (?<PerlStdExpression>
                              (?>(?&PerlLowPrecedenceNotExpression))
          (?: (?>(?&PerlOWS)) (?>(?&PerlLowPrecedenceInfixOperator))
              (?>(?&PerlOWS))    (?&PerlLowPrecedenceNotExpression)  )*+
      )) # End of rule
  
      (?<PerlLowPrecedenceNotExpression>   (?<PerlStdLowPrecedenceNotExpression>
          (?: not \b (?&PerlOWS) )*+  (?&PerlCommaList)
      )) # End of rule
  
      (?<PerlCommaList>   (?<PerlStdCommaList>
                  (?>(?&PerlAssignment))  (?>(?&PerlOWS))
          (?:
              (?: (?>(?&PerlComma))          (?&PerlOWS)   )++
                  (?>(?&PerlAssignment))  (?>(?&PerlOWS))
          )*+
              (?: (?>(?&PerlComma))          (?&PerlOWS)   )*+
      )) # End of rule
  
      (?<PerlAssignment>   (?<PerlStdAssignment>
                              (?>(?&PerlConditionalExpression))
          (?:
              (?>(?&PerlOWS)) (?>(?&PerlAssignmentOperator))
              (?>(?&PerlOWS))    (?&PerlConditionalExpression)
          )*+
      )) # End of rule
  
      (?<PerlScalarExpression>   (?<PerlStdScalarExpression>
      (?<PerlConditionalExpression>   (?<PerlStdConditionalExpression>
          (?>(?&PerlBinaryExpression))
          (?:
              (?>(?&PerlOWS)) \? (?>(?&PerlOWS)) (?>(?&PerlAssignment))
              (?>(?&PerlOWS))  : (?>(?&PerlOWS))    (?&PerlConditionalExpression)
          )?+
      )) # End of rule
      )) # End of rule
  
      (?<PerlBinaryExpression>   (?<PerlStdBinaryExpression>
                              (?>(?&PerlPrefixPostfixTerm))
          (?: (?>(?&PerlOWS)) (?>(?&PerlInfixBinaryOperator))
              (?>(?&PerlOWS))    (?&PerlPrefixPostfixTerm) )*+
      )) # End of rule
  
      (?<PerlPrefixPostfixTerm>   (?<PerlStdPrefixPostfixTerm>
          (?: (?>(?&PerlPrefixUnaryOperator))  (?&PerlOWS) )*+
          (?>(?&PerlTerm))
          (?:
              (?&PerlTermPostfixDereference)
          )?+
          (?: (?>(?&PerlOWS)) (?&PerlPostfixUnaryOperator) )?+
      )) # End of rule
  
      (?<PerlLvalue>   (?<PerlStdLvalue>
          (?>
              \\?+ [\$\@%] (?>(?&PerlOWS)) (?&PerlIdentifier)
          |
              \(                                                                     (?>(?&PerlOWS))
                  (?> \\?+ [\$\@%] (?>(?&PerlOWS)) (?&PerlIdentifier) | undef )      (?>(?&PerlOWS))
                  (?:
                      (?>(?&PerlComma))                                              (?>(?&PerlOWS))
                      (?> \\?+ [\$\@%] (?>(?&PerlOWS)) (?&PerlIdentifier) | undef )  (?>(?&PerlOWS))
                  )*+
                  (?: (?>(?&PerlComma)) (?&PerlOWS) )?+
              \)
          )
      )) # End of rule
  
      (?<PerlTerm>   (?<PerlStdTerm>
          (?>
              (?&PerlReturnExpression)
          |
              (?&PerlVariableDeclaration)
          |
              (?&PerlAnonymousSubroutine)
          |
              (?&PerlVariable)
          |
              (?>(?&PerlNullaryBuiltinFunction))  (?! (?>(?&PerlOWS)) \( )
          |
              (?&PerlDoBlock) | (?&PerlEvalBlock)
          |
              (?&PerlCall)
          |
              (?&PerlTypeglob)
          |
              (?>(?&PerlParenthesesList))
              (?: (?>(?&PerlOWS)) (?&PerlArrayIndexer) )?+
              (?:
                  (?>(?&PerlOWS))
                  (?>
                      (?&PerlArrayIndexer)
                  |   (?&PerlHashIndexer)
                  )
              )*+
          |
              (?&PerlAnonymousArray)
          |
              (?&PerlAnonymousHash)
          |
              (?&PerlDiamondOperator)
          |
              (?&PerlContextualMatch)
          |
              (?&PerlQuotelikeS)
          |
              (?&PerlQuotelikeTR)
          |
              (?&PerlQuotelikeQX)
          |
              (?&PerlLiteral)
          )
      )) # End of rule
  
      (?<PerlTermPostfixDereference>   (?<PerlStdTermPostfixDereference>
         (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
         (?>
             (?> (?&PerlQualifiedIdentifier) | (?&PerlVariableScalar) )
             (?: (?>(?&PerlOWS)) (?&PerlParenthesesList) )?+
  
         |   (?&PerlParenthesesList)
         |   (?&PerlArrayIndexer)
         |   (?&PerlHashIndexer)
         |   \$\*
         )
  
         (?:
             (?>(?&PerlOWS))
             (?>
                 ->  (?>(?&PerlOWS))
                 (?> (?&PerlQualifiedIdentifier) | (?&PerlVariableScalar) )
                 (?: (?>(?&PerlOWS)) (?&PerlParenthesesList) )?+
             |
                 (?: -> (?&PerlOWS) )?+
                 (?> (?&PerlParenthesesList)
                 |   (?&PerlArrayIndexer)
                 |   (?&PerlHashIndexer)
                 |   \$\*
                 )
             )
         )*+
         (?:
             (?>(?&PerlOWS)) -> (?>(?&PerlOWS)) [\@%]
             (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
         )?+
      )) # End of rule
  
      (?<PerlControlBlock>   (?<PerlStdControlBlock>
          (?> # Conditionals...
              (?> if | unless ) \b                 (?>(?&PerlOWS))
              (?>(?&PerlParenthesesList))          (?>(?&PerlOWS))
              (?>(?&PerlBlock))
  
              (?:
                                                   (?>(?&PerlOWS))
                  (?>(?&PerlPodSequence))
                  elsif \b                         (?>(?&PerlOWS))
                  (?>(?&PerlParenthesesList))      (?>(?&PerlOWS))
                  (?&PerlBlock)
              )*+
  
              (?:
                                                   (?>(?&PerlOWS))
                  (?>(?&PerlPodSequence))
                  else \b                          (?>(?&PerlOWS))
                  (?&PerlBlock)
              )?+
  
          |   # Loops...
              (?>
                  for(?:each)?+ \b
                  (?>(?&PerlOWS))
                  (?:
                      (?> # Explicitly aliased iterator variable...
                          (?> \\ (?>(?&PerlOWS))  (?> my | our | state )
                          |                       (?> my | our | state )  (?>(?&PerlOWS)) \\
                          )
                          (?>(?&PerlOWS))
                          (?> (?&PerlVariableScalar)
                          |   (?&PerlVariableArray)
                          |   (?&PerlVariableHash)
                          )
                      |
                          # Implicitly aliased iterator variable...
                          (?> (?: my | our | state ) (?>(?&PerlOWS)) )?+
                          (?&PerlVariableScalar)
                      )?+
                      (?>(?&PerlOWS))
                      (?> (?&PerlParenthesesList) | (?&PerlQuotelikeQW) )
                  |
                      (?&PPR_X_three_part_list)
                  )
              |
                  (?> while | until) \b (?>(?&PerlOWS))
                  (?&PerlParenthesesList)
              )
  
              (?>(?&PerlOWS))
              (?>(?&PerlBlock))
  
              (?:
                  (?>(?&PerlOWS))   continue
                  (?>(?&PerlOWS))   (?&PerlBlock)
              )?+
  
          | # Phasers...
              (?> BEGIN | END | CHECK | INIT | UNITCHECK ) \b   (?>(?&PerlOWS))
              (?&PerlBlock)
  
          | # Switches...
              (?> given | when ) \b                             (?>(?&PerlOWS))
              (?>(?&PerlParenthesesList))                            (?>(?&PerlOWS))
              (?&PerlBlock)
          |
              default                                           (?>(?&PerlOWS))
              (?&PerlBlock)
          )
      )) # End of rule
  
      (?<PerlFormat>   (?<PerlStdFormat>
          format
          (?: (?>(?&PerlNWS))  (?&PerlQualifiedIdentifier)  )?+
              (?>(?&PerlOWS))  = [^\n]*+
              (?&PPR_X_newline_and_heredoc)
          (?:
              (?! \. \n )
              [^\n\$\@]*+
              (?:
                  (?>
                      (?= \$ (?! \s ) )  (?&PerlScalarAccessNoSpace)
                  |
                      (?= \@ (?! \s ) )  (?&PerlArrayAccessNoSpace)
                  )
                  [^\n\$\@]*+
              )*+
              (?&PPR_X_newline_and_heredoc)
          )*+
          \. (?&PerlEndOfLine)
      )) # End of rule
  
      (?<PerlStatementModifier>   (?<PerlStdStatementModifier>
          (?> if | for(?:each)?+ | while | unless | until | when )
          \b
          (?>(?&PerlOWS))
          (?&PerlExpression)
      )) # End of rule
  
      (?<PerlBlock>   (?<PerlStdBlock>
          \{  (?>(?&PerlStatementSequence))  \}
      )) # End of rule
  
      (?<PerlCall>   (?<PerlStdCall>
          (?>
              [&]                                    (?>(?&PerlOWS))
              (?> (?&PerlBlock)
              |   (?&PerlVariableScalar)
              |   (?&PerlQualifiedIdentifier)
              )                                      (?>(?&PerlOWS))
              (?:
                  \(                                 (?>(?&PerlOWS))
                      (?: (?>(?&PerlExpression))        (?&PerlOWS)   )?+
                  \)
              )?+
          |
              - (?>(?&PPR_X_filetest_name))            (?>(?&PerlOWS))
              (?&PerlPrefixPostfixTerm)?+
          |
              (?>(?&PerlBuiltinFunction))            (?>(?&PerlOWS))
              (?>
                  \(                                 (?>(?&PerlOWS))
                      (?>
                          (?= (?>(?&PPR_X_non_reserved_identifier))
                              (?>(?&PerlOWS))
                              (?! \( | (?&PerlComma) )
                          )
                          (?&PerlCall)
                      |
                          (?>(?&PerlBlock))          (?>(?&PerlOWS))
                          (?&PerlExpression)?+
                      |
                          (?>(?&PPR_X_indirect_obj))   (?>(?&PerlNWS))
                          (?&PerlExpression)
                      |
                          (?&PerlExpression)?+
                      )                              (?>(?&PerlOWS))
                  \)
              |
                      (?>
                          (?=
                              (?>(?&PPR_X_non_reserved_identifier))
                              (?>(?&PerlOWS))
                              (?! \( | (?&PerlComma) )
                          )
                          (?&PerlCall)
                      |
                          (?>(?&PerlBlock))          (?>(?&PerlOWS))
                          (?&PerlCommaList)?+
                      |
                          (?>(?&PPR_X_indirect_obj))   (?>(?&PerlNWS))
                          (?&PerlCommaList)
                      |
                          (?&PerlCommaList)?+
                      )
              )
          |
              (?>(?&PPR_X_non_reserved_identifier)) (?>(?&PerlOWS))
              (?>
                  \(                              (?>(?&PerlOWS))
                      (?: (?>(?&PerlExpression))     (?&PerlOWS)  )?+
                  \)
              |
                      (?>
                          (?=
                              (?>(?&PPR_X_non_reserved_identifier))
                              (?>(?&PerlOWS))
                              (?! \( | (?&PerlComma) )
                          )
                          (?&PerlCall)
                      |
                          (?>(?&PerlBlock))           (?>(?&PerlOWS))
                          (?&PerlCommaList)?+
                      |
                          (?>(?&PPR_X_indirect_obj))        (?&PerlNWS)
                          (?&PerlCommaList)
                      |
                          (?&PerlCommaList)?+
                      )
              )
          )
      )) # End of rule
  
      (?<PerlVariableDeclaration>   (?<PerlStdVariableDeclaration>
          (?> my | state | our ) \b           (?>(?&PerlOWS))
          (?: (?&PerlQualifiedIdentifier)        (?&PerlOWS)  )?+
          (?>(?&PerlLvalue))                  (?>(?&PerlOWS))
          (?&PerlAttributes)?+
      )) # End of rule
  
      (?<PerlDoBlock>   (?<PerlStdDoBlock>
          do (?>(?&PerlOWS)) (?&PerlBlock)
      )) # End of rule
  
      (?<PerlEvalBlock>   (?<PerlStdEvalBlock>
          eval (?>(?&PerlOWS)) (?&PerlBlock)
      )) # End of rule
  
      (?<PerlAttributes>   (?<PerlStdAttributes>
          :
          (?>(?&PerlOWS))
          (?>(?&PerlIdentifier))
          (?:
              (?= \( ) (?&PPR_X_quotelike_body)
          )?+
  
          (?:
              (?> (?>(?&PerlOWS)) : (?&PerlOWS) | (?&PerlNWS) )
              (?>(?&PerlIdentifier))
              (?:
                  (?= \( ) (?&PPR_X_quotelike_body)
              )?+
          )*+
      )) # End of rule
  
      (?<PerlList>   (?<PerlStdList>
          (?> (?&PerlParenthesesList) | (?&PerlCommaList) )
      )) # End of rule
  
      (?<PerlParenthesesList>   (?<PerlStdParenthesesList>
          \(  (?>(?&PerlOWS))  (?: (?>(?&PerlExpression)) (?&PerlOWS) )?+  \)
      )) # End of rule
  
      (?<PerlAnonymousArray>   (?<PerlStdAnonymousArray>
          \[  (?>(?&PerlOWS))  (?: (?>(?&PerlExpression)) (?&PerlOWS) )?+  \]
      )) # End of rule
  
      (?<PerlAnonymousHash>   (?<PerlStdAnonymousHash>
          \{  (?>(?&PerlOWS))  (?: (?>(?&PerlExpression)) (?&PerlOWS) )?+ \}
      )) # End of rule
  
      (?<PerlArrayIndexer>   (?<PerlStdArrayIndexer>
          \[                          (?>(?&PerlOWS))
              (?>(?&PerlExpression))  (?>(?&PerlOWS))
          \]
      )) # End of rule
  
      (?<PerlHashIndexer>   (?<PerlStdHashIndexer>
          \{  (?>(?&PerlOWS))
              (?: -?+ (?&PerlIdentifier) | (?&PerlExpression) )  # (Note: MUST allow backtracking here)
              (?>(?&PerlOWS))
          \}
      )) # End of rule
  
      (?<PerlDiamondOperator>   (?<PerlStdDiamondOperator>
          <<>>    # Perl 5.22 "double diamond"
        |
          < (?! < )
              (?>(?&PPR_X_balanced_angles))
          >
          (?=
              (?>(?&PerlOWS))
              (?> \z | [,;\}\])?] | => | : (?! :)        # (
              |   (?&PerlInfixBinaryOperator) | (?&PerlLowPrecedenceInfixOperator)
              |   (?= \w) (?> for(?:each)?+ | while | if | unless | until | when )
              )
          )
      )) # End of rule
  
      (?<PerlComma>   (?<PerlStdComma>
          (?> , | => )
      )) # End of rule
  
      (?<PerlPrefixUnaryOperator>   (?<PerlStdPrefixUnaryOperator>
          (?> [!\\+~] | \+\+  |  --  | - (?! (?&PPR_X_filetest_name) \b ) )
      )) # End of rule
  
      (?<PerlPostfixUnaryOperator>   (?<PerlStdPostfixUnaryOperator>
          (?> \+\+  |  -- )
      )) # End of rule
  
      (?<PerlInfixBinaryOperator>   (?<PerlStdInfixBinaryOperator>
          (?>  [=!][~=]
          |    cmp
          |    <= >?+
          |    >=
          |    [lg][te]
          |    eq
          |    ne
          |    [+]             (?! [+=] )
          |     -              (?! [-=] )
          |    [.]{2,3}+
          |    [.%x]           (?! [=]  )
          |    [&|^][.]        (?! [=]  )
          |    [<>*&|/]{1,2}+  (?! [=]  )
          |    \^              (?! [=]  )
          |    ~~
          )
      )) # End of rule
  
      (?<PerlAssignmentOperator>   (?<PerlStdAssignmentOperator>
          (?:  [<>*&|/]{2}
            |  [-+.*/%x]
            |  [&|^][.]?+
          )?+
          =
          (?! > )
      )) # End of rule
  
      (?<PerlLowPrecedenceInfixOperator>   (?<PerlStdLowPrecedenceInfixOperator>
          (?> or | and | xor )
      )) # End of rule
  
      (?<PerlAnonymousSubroutine>   (?<PerlStdAnonymousSubroutine>
          sub \b
          (?>(?&PerlOWS))
          (?:
              # Perl pre 5.028
              (?:
                  (?>
                      (?&PerlParenthesesList)    # Parameter list
                  |
                      \( [^)]*+ \)               # Prototype (
                  )
                  (?&PerlOWS)
              )?+
              (?: (?>(?&PerlAttributes))  (?&PerlOWS) )?+
          |
              # Perl post 5.028
              (?: (?>(?&PerlAttributes))       (?&PerlOWS) )?+
              (?: (?>(?&PerlParenthesesList))  (?&PerlOWS) )?+    # Parameter list
          )
          (?&PerlBlock)
      )) # End of rule
  
      (?<PerlVariable>   (?<PerlStdVariable>
          (?= [\$\@%] )
          (?>
              (?&PerlScalarAccess)
          |   (?&PerlHashAccess)
          |   (?&PerlArrayAccess)
          )
      )) # End of rule
  
      (?<PerlTypeglob>   (?<PerlStdTypeglob>
          \*
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier))  (?: :: )?+
          |
              (?&PerlVariableScalar)
          |
              [][!"#\$%&'()*+,./:;<=>?\@\^`|~-]
          |
              (?&PerlBlock)
          )
          (?:
              (?>(?&PerlOWS)) (?: -> (?&PerlOWS) )?+
              (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
          )*+
          (?:
              (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
              [\@%]
              (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
          )?+
      )) # End of rule
  
      (?<PerlArrayAccess>   (?<PerlStdArrayAccess>
          (?>(?&PerlVariableArray))
          (?:
              (?>(?&PerlOWS)) (?: -> (?&PerlOWS) )?+
              (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList)  )
          )*+
          (?:
              (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
              [\@%]
              (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
          )?+
      )) # End of rule
  
      (?<PerlArrayAccessNoSpace>   (?<PerlStdArrayAccessNoSpace>
          (?>(?&PerlVariableArrayNoSpace))
          (?:
              (?: -> )?+
              (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList)  )
          )*+
          (?:
              ->
              [\@%]
              (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
          )?+
      )) # End of rule
  
      (?<PerlArrayAccessNoSpaceNoArrow>   (?<PerlStdArrayAccessNoSpaceNoArrow>
          (?>(?&PerlVariableArray))
          (?:
              (?> (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList)  )
          )*+
      )) # End of rule
  
      (?<PerlHashAccess>   (?<PerlStdHashAccess>
          (?>(?&PerlVariableHash))
          (?:
              (?>(?&PerlOWS)) (?: -> (?&PerlOWS) )?+
              (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
          )*+
          (?:
              (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
              [\@%]
              (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
          )?+
      )) # End of rule
  
      (?<PerlScalarAccess>   (?<PerlStdScalarAccess>
          (?>(?&PerlVariableScalar))
          (?:
              (?>(?&PerlOWS))
              (?:
                  (?:
                      (?>(?&PerlOWS))      -> (?>(?&PerlOWS))
                      (?&PerlParenthesesList)
                  |
                      (?>(?&PerlOWS))  (?: ->    (?&PerlOWS)  )?+
                      (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
                  )
                  (?:
                      (?>(?&PerlOWS))  (?: ->    (?&PerlOWS)  )?+
                      (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
                  )*+
              )?+
              (?:
                  (?>(?&PerlOWS)) -> (?>(?&PerlOWS))
                  [\@%]
                  (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
              )?+
          )?+
      )) # End of rule
  
      (?<PerlScalarAccessNoSpace>   (?<PerlStdScalarAccessNoSpace>
          (?>(?&PerlVariableScalarNoSpace))
          (?:
              (?:
                  (?:
                      ->
                      (?&PerlParenthesesList)
                  |
                      (?: -> )?+
                      (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
                  )
                  (?:
                      (?: -> )?+
                      (?> \$\* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
                  )*+
              )?+
              (?:
                  ->
                  [\@%]
                  (?> \* | (?&PerlArrayIndexer) | (?&PerlHashIndexer) )
              )?+
          )?+
      )) # End of rule
  
      (?<PerlScalarAccessNoSpaceNoArrow>   (?<PerlStdScalarAccessNoSpaceNoArrow>
          (?>(?&PerlVariableScalarNoSpace))
          (?:
              (?> (?&PerlArrayIndexer) | (?&PerlHashIndexer) | (?&PerlParenthesesList) )
          )*+
      )) # End of rule
  
      (?<PerlVariableScalar>   (?<PerlStdVariableScalar>
          \$\$
          (?! [\$\{\w] )
      |
          (?:
              \$
              (?:
                  [#]
                  (?=  (?> [\$^\w\{:+] | - (?! > ) )  )
              )?+
              (?&PerlOWS)
          )++
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              \{ [!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-] \}
          |
              \{ \w++ \}
          |
              (?&PerlBlock)
          )
      |
          \$\#
      )) # End of rule
  
      (?<PerlVariableScalarNoSpace>   (?<PerlStdVariableScalarNoSpace>
          \$\$
          (?! [\$\{\w] )
      |
          (?:
              \$
              (?:
                  [#]
                  (?=  (?> [\$^\w\{:+] | - (?! > ) )  )
              )?+
          )++
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              \{ \w++ \}
          |
              (?&PerlBlock)
          )
      |
          \$\#
      )) # End of rule
  
      (?<PerlVariableArray>   (?<PerlStdVariableArray>
          \@     (?>(?&PerlOWS))
          (?: \$    (?&PerlOWS)  )*+
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              (?&PerlBlock)
          )
      )) # End of rule
  
      (?<PerlVariableArrayNoSpace>   (?<PerlStdVariableArrayNoSpace>
          \@
          (?: \$ )*+
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              (?&PerlBlock)
          )
      )) # End of rule
  
      (?<PerlVariableHash>   (?<PerlStdVariableHash>
          %      (?>(?&PerlOWS))
          (?: \$    (?&PerlOWS)  )*+
          (?>
              \d++
          |
              \^ [][A-Z^_?\\]
          |
              \{ \^ [A-Z_] \w*+ \}
          |
              (?>(?&PerlOldQualifiedIdentifier)) (?: :: )?+
          |
              :: (?&PerlBlock)?+
          |
              [][!"#\$%&'()*+,.\\/:;<=>?\@\^`|~-]
          |
              (?&PerlBlock)
          )
      )) # End of rule
  
      (?<PerlLabel>   (?<PerlStdLabel>
          (?! (?> [msy] | q[wrxq]?+ | tr ) \b )
          (?>(?&PerlIdentifier))
          : (?! : )
      )) # End of rule
  
      (?<PerlLiteral>   (?<PerlStdLiteral>
          (?> (?&PerlString)
          |   (?&PerlQuotelikeQR)
          |   (?&PerlQuotelikeQW)
          |   (?&PerlNumber)
          |   (?&PerlBareword)
          )
      )) # End of rule
  
      (?<PerlString>   (?<PerlStdString>
          (?>
              "  [^"\\]*+  (?: \\. [^"\\]*+ )*+ "
          |
              '  [^'\\]*+  (?: \\. [^'\\]*+ )*+ '
          |
              qq \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_X_quotelike_body_interpolated)
          |
              q \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_X_quotelike_body)
          |
              (?&PerlHeredoc)
          |
              (?&PerlVString)
          )
      )) # End of rule
  
      (?<PerlQuotelike>   (?<PerlStdQuotelike>
          (?> (?&PerlString)
          |   (?&PerlQuotelikeQR)
          |   (?&PerlQuotelikeQW)
          |   (?&PerlQuotelikeQX)
          |   (?&PerlContextualMatch)
          |   (?&PerlQuotelikeS)
          |   (?&PerlQuotelikeTR)
      )
      )) # End of rule
  
      (?<PerlHeredoc>   (?<PerlStdHeredoc>
          # Match the introducer...
          <<
          (?<_heredoc_indented> [~]?+ )
  
          # Match the terminator specification...
          (?>
              \\?+   (?<_heredoc_terminator>  (?&PerlIdentifier)              )
          |
              (?>(?&PerlOWS))
              (?>
                  "  (?<_heredoc_terminator>  [^"\\]*+  (?: \\. [^"\\]*+ )*+  )  "  #"
              |
                  (?<PPR_X_HD_nointerp> ' )
                     (?<_heredoc_terminator>  [^'\\]*+  (?: \\. [^'\\]*+ )*+  )  '  #'
              |
                  `  (?<_heredoc_terminator>  [^`\\]*+  (?: \\. [^`\\]*+ )*+  )  `  #`
              )
          |
                     (?<_heredoc_terminator>                                  )
          )
  
          # Do we need to reset the heredoc cache???
          (?{
              if ( ($PPR::X::_heredoc_origin // q{}) ne $_ ) {
                  %PPR::X::_heredoc_skip      = ();
                  %PPR::X::_heredoc_parsed_to = ();
                  $PPR::X::_heredoc_origin    = $_;
              }
          })
  
          # Do we need to cache content lookahead for this heredoc???
          (?(?{ my $need_to_lookahead = !$PPR::X::_heredoc_parsed_to{+pos()};
                $PPR::X::_heredoc_parsed_to{+pos()} = 1;
                $need_to_lookahead;
              })
  
              # Lookahead to detect and remember trailing contents of heredoc
              (?=
                  [^\n]*+ \n                                   # Go to the end of the current line
                  (?{ +pos() })                                # Remember the start of the contents
                  (??{ $PPR::X::_heredoc_skip{+pos()} // q{} })   # Skip earlier heredoc contents
                  (?>                                          # The heredoc contents consist of...
                      (?:
                          (?!
                              (?(?{ $+{_heredoc_indented} }) \h*+ )   # An indent (if it was a <<~)
                              \g{_heredoc_terminator}                 # The terminator
                              (?: \n | \z )                           # At an end-of-line
                          )
                          (?(<PPR_X_HD_nointerp>)
                              [^\n]*+ \n
                          |
                              [^\n\$\@]*+
                              (?:
                                  (?>
                                      (?{ local $PPR::X::_heredoc_EOL_start = $^R })
                                      (?= \$ (?! \s ) )  (?&PerlScalarAccessNoSpace)
                                      (?{ $PPR::X::_heredoc_EOL_start })
                                  |
                                      (?{ local $PPR::X::_heredoc_EOL_start = $^R })
                                      (?= \@ (?! \s ) )  (?&PerlArrayAccessNoSpace)
                                      (?{ $PPR::X::_heredoc_EOL_start })
                                  )
                                  [^\n\$\@]*+
                              )*+
                              \n (??{ $PPR::X::_heredoc_skip{+pos()} // q{} })
                          )
                      )*+
  
                      (?(?{ $+{_heredoc_indented} }) \h*+ )            # An indent (if it was a <<~)
                      \g{_heredoc_terminator}                          # The specified terminator
                      (?: \n | \z )                                    # Followed by EOL
                  )
  
                  # Then memoize the skip for when it's subsequently needed by PerlOWS or PerlNWS...
                  (?{
                      $PPR::X::_heredoc_skip{$^R} = "(?s:.\{" . (pos() - $^R) . "\})";
                  })
              )
          )
  
      )) # End of rule
  
      (?<PerlQuotelikeQ>   (?<PerlStdQuotelikeQ>
          (?>
              '  [^'\\]*+  (?: \\. [^'\\]*+ )*+ '
          |
              \b q \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_X_quotelike_body)
          )
      )) # End of rule
  
      (?<PerlQuotelikeQQ>   (?<PerlStdQuotelikeQQ>
          (?>
              "  [^"\\]*+  (?: \\. [^"\\]*+ )*+ "
          |
              \b qq \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_X_quotelike_body_interpolated)
          )
      )) # End of rule
  
      (?<PerlQuotelikeQW>   (?<PerlStdQuotelikeQW>
          (?>
              qw \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
              (?&PPR_X_quotelike_body)
          )
      )) # End of rule
  
      (?<PerlQuotelikeQX>   (?<PerlStdQuotelikeQX>
          (?>
              `  [^`]*+  (?: \\. [^`]*+ )*+  `
          |
              qx
                  (?:
                      (?&PerlOWS) ' (?&PPR_X_quotelike_body)
                  |
                      \b (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
                      (?&PPR_X_quotelike_body_interpolated)
                  )
          )
      )) # End of rule
  
      (?<PerlQuotelikeS>   (?<PerlStdQuotelikeS>
      (?<PerlSubstitution>   (?<PerlStdSubstitution>
          s \b
          (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
          (?>
              # Hashed syntax...
              (?= [#] )
              (?>(?&PPR_X_quotelike_body_interpolated_unclosed))
                 (?&PPR_X_quotelike_s_e_check)
              (?>(?&PPR_X_quotelike_body_interpolated))
          |
              # Bracketed syntax...
              (?= (?>(?&PerlOWS)) [\[(<\{] )      # )
              (?>(?&PPR_X_quotelike_body_interpolated))
              (?>(?&PerlOWS))
                 (?&PPR_X_quotelike_s_e_check)
              (?>(?&PPR_X_quotelike_body_interpolated))
          |
              # Delimited syntax...
              (?>(?&PPR_X_quotelike_body_interpolated_unclosed))
                 (?&PPR_X_quotelike_s_e_check)
              (?>(?&PPR_X_quotelike_body_interpolated))
          )
          [msixpodualgcern]*+
      )) # End of rule
      )) # End of rule
  
      (?<PerlQuotelikeTR>   (?<PerlStdQuotelikeTR>
      (?<PerlTransliteration>   (?<PerlStdTransliteration>
          (?> tr | y ) \b
          (?! (?>(?&PerlOWS)) => )
          (?>
              # Hashed syntax...
              (?= [#] )
              (?>(?&PPR_X_quotelike_body_interpolated_unclosed))
                 (?&PPR_X_quotelike_body_interpolated)
          |
              # Bracketed syntax...
              (?= (?>(?&PerlOWS)) [\[(<\{] )      # )
              (?>(?&PPR_X_quotelike_body_interpolated))
              (?>(?&PerlOWS))
                 (?&PPR_X_quotelike_body_interpolated)
          |
              # Delimited syntax...
              (?>(?&PPR_X_quotelike_body_interpolated_unclosed))
                 (?&PPR_X_quotelike_body_interpolated)
          )
          [cdsr]*+
      )) # End of rule
      )) # End of rule
  
      (?<PerlContextualQuotelikeM>   (?<PerlStdContextualQuotelikeM>
      (?<PerlContextualMatch>   (?<PerlStdContextualMatch>
          (?<PerlQuotelikeM>
          (?<PerlMatch>
              (?>
                  \/\/
              |
                  (?>
                      m (?= [#] )
                  |
                      m \b
                      (?! (?>(?&PerlOWS)) => )
                  |
                      (?= \/ [^/] )
                  )
                  (?&PPR_X_quotelike_body_interpolated)
              )
              [msixpodualgcn]*+
          ) # End of rule
          ) # End of rule
          (?=
              (?>(?&PerlOWS))
              (?> \z | [,;\}\])?] | => | : (?! :)
              |   (?&PerlInfixBinaryOperator) | (?&PerlLowPrecedenceInfixOperator)
              |   (?= \w) (?> for(?:each)?+ | while | if | unless | until | when )
              )
          )
      )) # End of rule
      )) # End of rule
  
      (?<PerlQuotelikeQR>   (?<PerlStdQuotelikeQR>
          qr \b
          (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
          (?>(?&PPR_X_quotelike_body_interpolated))
          [msixpodualn]*+
      )) # End of rule
  
      (?<PerlRegex>   (?<PerlStdRegex>
          (?>
              (?&PerlMatch)
          |
              (?&PerlQuotelikeQR)
          )
      )) # End of rule
  
      (?<PerlContextualRegex>   (?<PerlStdContextualRegex>
          (?>
              (?&PerlContextualMatch)
          |
              (?&PerlQuotelikeQR)
          )
      )) # End of rule
  
  
      (?<PerlBuiltinFunction>   (?<PerlStdBuiltinFunction>
          # Optimized to match any Perl builtin name, without backtracking...
          (?=[^\W\d]) # Skip if possible
          (?>
               s(?>e(?>t(?>(?>(?>(?>hos|ne)t|gr)en|s(?>erven|ockop))t|p(?>r(?>iority|otoent)|went|grp))|m(?>ctl|get|op)|ek(?>dir)?|lect|nd)|y(?>s(?>write|call|open|read|seek|tem)|mlink)|h(?>m(?>write|read|ctl|get)|utdown|ift)|o(?>cket(?>pair)?|rt)|p(?>li(?>ce|t)|rintf)|(?>cala|ubst)r|t(?>ate?|udy)|leep|rand|qrt|ay|in)
              | g(?>et(?>p(?>r(?>oto(?>byn(?>umber|ame)|ent)|iority)|w(?>ent|nam|uid)|eername|grp|pid)|s(?>erv(?>by(?>name|port)|ent)|ock(?>name|opt))|host(?>by(?>addr|name)|ent)|net(?>by(?>addr|name)|ent)|gr(?>ent|gid|nam)|login|c)|mtime|lob|oto|rep)
              | r(?>e(?>ad(?>lin[ek]|pipe|dir)?|(?>quir|vers|nam)e|winddir|turn|set|cv|do|f)|index|mdir|and)
              | c(?>h(?>o(?>m?p|wn)|r(?>oot)?|dir|mod)|o(?>n(?>tinue|nect)|s)|lose(?>dir)?|aller|rypt)
              | e(?>nd(?>(?>hos|ne)t|p(?>roto|w)|serv|gr)ent|x(?>i(?>sts|t)|ec|p)|ach|val(?>bytes)?+|of)
              | l(?>o(?>c(?>al(?>time)?|k)|g)|i(?>sten|nk)|(?>sta|as)t|c(?>first)?|ength)
              | u(?>n(?>(?>lin|pac)k|shift|def|tie)|c(?>first)?|mask|time)
              | p(?>r(?>ototype|intf?)|ack(?>age)?|o[ps]|ipe|ush)
              | d(?>bm(?>close|open)|e(?>fined|lete)|ump|ie|o)
              | f(?>or(?>m(?>line|at)|k)|ileno|cntl|c|lock)
              | t(?>i(?>mes?|ed?)|ell(?>dir)?|runcate)
              | w(?>a(?>it(?>pid)?|ntarray|rn)|rite)
              | m(?>sg(?>ctl|get|rcv|snd)|kdir|ap)
              | b(?>in(?>mode|d)|less|reak)
              | i(?>n(?>dex|t)|mport|octl)
              | a(?>ccept|larm|tan2|bs)
              | o(?>pen(?>dir)?|ct|rd)
              | v(?>alues|ec)
              | k(?>eys|ill)
              | quotemeta
              | join
              | next
              | hex
              | _
          )
          \b
      )) # End of rule
  
      (?<PerlNullaryBuiltinFunction>   (?<PerlStdNullaryBuiltinFunction>
          # Optimized to match any Perl builtin name, without backtracking...
          (?= [^\W\d] )  # Skip if possible
          (?>
                get(?:(?:(?:hos|ne)t|serv|gr)ent|p(?:(?:roto|w)ent|pid)|login)
              | end(?:(?:hos|ne)t|p(?:roto|w)|serv|gr)ent
              | wa(?:ntarray|it)
              | times?
              | fork
              | _
          )
          \b
      )) # End of rule
  
      (?<PerlVersionNumber>   (?<PerlStdVersionNumber>
          (?>
              (?&PerlVString)
          |
              (?>(?&PPR_X_digit_seq))
              (?: \. (?&PPR_X_digit_seq)?+ )*+
          )
      )) # End of rule
  
      (?<PerlVString>   (?<PerlStdVString>
          v  (?>(?&PPR_X_digit_seq))  (?: \. (?&PPR_X_digit_seq) )*+
      )) # End of rule
  
      (?<PerlNumber>   (?<PerlStdNumber>
          [+-]?+
          (?>
              0  (?>  x (?&PPR_X_x_digit_seq)
                 |    b (?&PPR_X_b_digit_seq)
                 |      (?&PPR_X_o_digit_seq)
                 )
          |
              (?>
                      (?>(?&PPR_X_digit_seq))
                  (?: \. (?&PPR_X_digit_seq)?+ )?+
              |
                      \. (?&PPR_X_digit_seq)
              )
              (?: [eE] [+-]?+ (?&PPR_X_digit_seq) )?+
          )
      )) # End of rule
  
      (?<PerlOldQualifiedIdentifier>   (?<PerlStdOldQualifiedIdentifier>
          (?> (?> :: | ' ) \w++  |  [^\W\d]\w*+ )  (?: (?> :: | ' )  \w++ )*+
      )) # End of rule
  
      (?<PerlQualifiedIdentifier>   (?<PerlStdQualifiedIdentifier>
          (?>     ::       \w++  |  [^\W\d]\w*+ )  (?: (?> :: | ' )  \w++ )*+
      )) # End of rule
  
      (?<PerlIdentifier>   (?<PerlStdIdentifier>
                                    [^\W\d]\w*+
      )) # End of rule
  
      (?<PerlBareword>   (?<PerlStdBareword>
          (?! (?> (?= \w )
                  (?> for(?:each)?+ | while | if | unless | until | use | no | given | when | sub | return )
              |   (?&PPR_X_named_op)
              |   __ (?> END | DATA ) __ (?&PerlEndOfLine)
              ) \b
              (?! (?>(?&PerlOWS)) => )
          )
          (?! (?> q[qwrx]?+ | [mys] | tr ) \b
              (?> (?= [#] ) | (?! (?>(?&PerlOWS)) => ) )
          )
          (?: :: )?+
          [^\W\d]\w*+
          (?: (?: :: | ' )  [^\W\d]\w*+  )*+
          (?: :: )?+
          (?! \( )    # )
      |
          :: (?! \w | \{ )
      )) # End of rule
  
      (?<PerlKeyword>   (?<PerlStdKeyword>
          (?!)    # None, by default, but can be overridden in a composing regex
      )) # End of rule
  
      (?<PerlPodSequence>   (?<PerlStdPodSequence>
          (?>(?&PerlOWS))  (?: (?>(?&PerlPod))  (?&PerlOWS) )*+
      )) # End of rule
  
      (?<PerlPod>   (?<PerlStdPod>
          ^ = [^\W\d]\w*+             # A line starting with =<identifier>
          .*?                         # Up to the first...
          (?>
              ^ = cut \b [^\n]*+ $    # ...line starting with =cut
          |                           # or
              \z                      # ...EOF
          )
      )) # End of rule
  
  
      ##### Whitespace matching (part of API) #################################
  
      (?<PerlOWS>   (?<PerlStdOWS>
          (?:
              \h++
          |
              (?&PPR_X_newline_and_heredoc)
          |
              [#] [^\n]*+
          |
              __ (?> END | DATA ) __ \b .*+ \z
          )*+
      )) # End of rule
  
      (?<PerlNWS>   (?<PerlStdNWS>
          (?:
              \h++
          |
              (?&PPR_X_newline_and_heredoc)
          |
              [#] [^\n]*+
          |
              __ (?> END | DATA ) __ \b .*+ \z
          )++
      )) # End of rule
  
      (?<PerlEndOfLine>   (?<PerlStdEndOfLine>
          \n
      )) # End of rule
  
  
      ###### Internal components (not part of API) ##########################
  
      (?<PPR_X_named_op>
          (?> cmp
          |   [lg][te]
          |   eq
          |   ne
          |   and
          |   or
          |   xor
          )
      )
  
      (?<PPR_X_non_reserved_identifier>
          (?! (?>
                 for(?:each)?+ | while | if | unless | until | given | when | default
              |  sub | format | use | no
              |  (?&PPR_X_named_op)
              |  [msy] | q[wrxq]?+ | tr
              |   __ (?> END | DATA ) __ \n
              )
              \b
          )
          (?>(?&PerlQualifiedIdentifier))
          (?! :: )
      )
  
      (?<PPR_X_three_part_list>
          \(  (?>(?&PerlOWS)) (?: (?>(?&PerlExpression)) (?&PerlOWS) )??
           ;  (?>(?&PerlOWS)) (?: (?>(?&PerlExpression)) (?&PerlOWS) )??
           ;  (?>(?&PerlOWS)) (?: (?>(?&PerlExpression)) (?&PerlOWS) )??
          \)
      )
  
      (?<PPR_X_indirect_obj>
          (?&PerlBareword)
      |
          (?>(?&PerlVariableScalar))
          (?! (?>(?&PerlOWS)) (?> [<\[\{] | -> ) )
      )
  
      (?<PPR_X_quotelike_body>
          (?>(?&PPR_X_quotelike_body_unclosed))
          \S   # (Note: Don't have to test that this matches; the preceding subrule already did that)
      )
  
      (?<PPR_X_balanced_parens>
          [^)(\\\n]*+
          (?:
              (?>
                  \\.
              |
                  \(  (?>(?&PPR_X_balanced_parens))  \)
              |
                  (?&PPR_X_newline_and_heredoc)
              )
              [^)(\\\n]*+
          )*+
      )
  
      (?<PPR_X_balanced_curlies>
          [^\}\{\\\n]*+
          (?:
              (?>
                  \\.
              |
                  \{  (?>(?&PPR_X_balanced_curlies))  \}
              |
                  (?&PPR_X_newline_and_heredoc)
              )
              [^\}\{\\\n]*+
          )*+
      )
  
      (?<PPR_X_balanced_squares>
          [^][\\\n]*+
          (?:
              (?>
                  \\.
              |
                  \[  (?>(?&PPR_X_balanced_squares))  \]
              |
                  (?&PPR_X_newline_and_heredoc)
              )
              [^][\\\n]*+
          )*+
      )
  
      (?<PPR_X_balanced_angles>
          [^><\\\n]*+
          (?:
              (?>
                  \\.
              |
                  <  (?>(?&PPR_X_balanced_angles))  >
              |
                  (?&PPR_X_newline_and_heredoc)
              )
              [^><\\\n]*+
          )*+
      )
  
      (?<PPR_X_quotelike_body_unclosed>
          (?>
                 [#]
                 [^#\\\n]*+
                 (?:
                     (?: \\. | (?&PPR_X_newline_and_heredoc) )
                     [^#\\\n]*+
                 )*+
                 (?= [#] )
          |
              (?>(?&PerlOWS))
              (?>
                  \{  (?>(?&PPR_X_balanced_curlies))    (?= \} )
              |
                  \[  (?>(?&PPR_X_balanced_squares))    (?= \] )
              |
                  \(  (?>(?&PPR_X_balanced_parens))     (?= \) )
              |
                   <  (?>(?&PPR_X_balanced_angles))     (?=  > )
              |
                  \\
                      [^\\\n]*+
                      (
                          (?&PPR_X_newline_and_heredoc)
                          [^\\\n]*+
                      )*+
                  (?= \\ )
              |
                   /
                       [^\\/\n]*+
                   (?:
                       (?: \\. | (?&PPR_X_newline_and_heredoc) )
                       [^\\/\n]*+
                   )*+
                   (?=  / )
              |
                  (?<PPR_X_qldel> \S )
                      (?:
                          \\.
                      |
                          (?&PPR_X_newline_and_heredoc)
                      |
                          (?! \g{PPR_X_qldel} ) .
                      )*+
                  (?= \g{PPR_X_qldel} )
              )
          )
      )
  
      (?<PPR_X_quotelike_body_interpolated>
          (?>(?&PPR_X_quotelike_body_interpolated_unclosed))
          \S   # (Note: Don't have to test that this matches; the preceding subrule already did that)
      )
  
      (?<PPR_X_balanced_parens_interpolated>
          [^)(\\\n\$\@]*+
          (?:
              (?>
                  \\.
              |
                  \(  (?>(?&PPR_X_balanced_parens_interpolated))  \)
              |
                  (?&PPR_X_newline_and_heredoc)
              |
                  (?= \$ (?! [\s\)] ) )  (?&PerlScalarAccessNoSpace)
              |
                  (?= \@ (?! [\s\)] ) )  (?&PerlArrayAccessNoSpace)
              |
                  [\$\@]
              )
              [^)(\\\n\$\@]*+
          )*+
      )
  
      (?<PPR_X_balanced_curlies_interpolated>
          [^\}\{\\\n\$\@]*+
          (?:
              (?>
                  \\.
              |
                  \{  (?>(?&PPR_X_balanced_curlies_interpolated))  \}
              |
                  (?&PPR_X_newline_and_heredoc)
              |
                  (?= \$ (?! [\s\}] ) )  (?&PerlScalarAccessNoSpace)
              |
                  (?= \@ (?! [\s\}] ) )  (?&PerlArrayAccessNoSpace)
              |
                  [\$\@]
              )
              [^\}\{\\\n\$\@]*+
          )*+
      )
  
      (?<PPR_X_balanced_squares_interpolated>
          [^][\\\n\$\@]*+
          (?:
              (?>
                  \\.
              |
                  \[  (?>(?&PPR_X_balanced_squares_interpolated))  \]
              |
                  (?&PPR_X_newline_and_heredoc)
              |
                  (?= \$ (?! [\s\]] ) )  (?&PerlScalarAccessNoSpace)
              |
                  (?= \@ (?! [\s\]] ) )  (?&PerlArrayAccessNoSpace)
              |
                  [\$\@]
              )
              [^][\\\n\$\@]*+
          )*+
      )
  
      (?<PPR_X_balanced_angles_interpolated>
          [^><\\\n\$\@]*+
          (?:
              (?>
                  \\.
              |
                  <  (?>(?&PPR_X_balanced_angles_interpolated))  >
              |
                  (?&PPR_X_newline_and_heredoc)
              |
                  (?= \$ (?! [\s>] ) )  (?&PerlScalarAccessNoSpace)
              |
                  (?= \@ (?! [\s>] ) )  (?&PerlArrayAccessNoSpace)
              |
                  [\$\@]
              )
              [^><\\\n\$\@]*+
          )*+
      )
  
      (?<PPR_X_quotelike_body_interpolated_unclosed>
          # Start by working out where it actually ends (ignoring interpolations)...
          (?=
              (?>
                  [#]
                  [^#\\\n\$\@]*+
                  (?:
                      (?>
                          \\.
                      |
                          (?&PPR_X_newline_and_heredoc)
                      |
                          (?= \$ (?! [\s#] ) )  (?&PerlScalarAccessNoSpace)
                      |
                          (?= \@ (?! [\s#] ) )  (?&PerlArrayAccessNoSpace)
                      |
                          [\$\@]
                      )
                      [^#\\\n\$\@]*+
                  )*+
                  (?= [#] )
              |
                  (?>(?&PerlOWS))
                  (?>
                      \{  (?>(?&PPR_X_balanced_curlies_interpolated))    (?= \} )
                  |
                      \[  (?>(?&PPR_X_balanced_squares_interpolated))    (?= \] )
                  |
                      \(  (?>(?&PPR_X_balanced_parens_interpolated))     (?= \) )
                  |
                      <  (?>(?&PPR_X_balanced_angles_interpolated))     (?=  > )
                  |
                      \\
                          [^\\\n\$\@]*+
                          (?:
                              (?>
                                  (?&PPR_X_newline_and_heredoc)
                              |
                                  (?= \$ (?! [\s\\] ) )  (?&PerlScalarAccessNoSpace)
                              |
                                  (?= \@ (?! [\s\\] ) )  (?&PerlArrayAccessNoSpace)
                              |
                                  [\$\@]
                              )
                              [^\\\n\$\@]*+
                          )*+
                      (?= \\ )
                  |
                      /
                          [^\\/\n\$\@]*+
                          (?:
                              (?>
                                  \\.
                              |
                                  (?&PPR_X_newline_and_heredoc)
                              |
                                  (?= \$ (?! [\s/] ) )  (?&PerlScalarAccessNoSpace)
                              |
                                  (?= \@ (?! [\s/] ) )  (?&PerlArrayAccessNoSpace)
                              |
                                  [\$\@]
                              )
                              [^\\/\n\$\@]*+
                          )*+
                      (?= / )
                  |
                      -
                          (?:
                              \\.
                          |
                              (?&PPR_X_newline_and_heredoc)
                          |
                              (?:
                                  (?= \$ (?! [\s-] ) )  (?&PerlScalarAccessNoSpaceNoArrow)
                              |
                                  (?= \@ (?! [\s-] ) )  (?&PerlArrayAccessNoSpaceNoArrow)
                              |
                                  [^-]
                              )
                          )*+
                      (?= - )
                  |
                      (?<PPR_X_qldel> \S )
                          (?:
                              \\.
                          |
                              (?&PPR_X_newline_and_heredoc)
                          |
                              (?! \g{PPR_X_qldel} )
                              (?:
                                  (?= \$ (?! \g{PPR_X_qldel} | \s ) )  (?&PerlScalarAccessNoSpace)
                              |
                                  (?= \@ (?! \g{PPR_X_qldel} | \s ) )  (?&PerlArrayAccessNoSpace)
                              |
                                  .
                              )
                          )*+
                      (?= \g{PPR_X_qldel} )
                  )
              )
          )
  
          (?&PPR_X_quotelike_body_unclosed)
      )
  
      (?<PPR_X_quotelike_s_e_check>
          (??{ local $PPR::X::_quotelike_s_end = -1; '' })
          (?:
              (?=
                  (?&PPR_X_quotelike_body_interpolated)
                  (??{ $PPR::X::_quotelike_s_end = +pos(); '' })
                  [msixpodualgcrn]*+ e [msixpodualgcern]*+
              )
              (?=
                  (?(?{ $PPR::X::_quotelike_s_end >= 0 })
                      (?>
                          (??{ +pos() && +pos() < $PPR::X::_quotelike_s_end ? '' : '(?!)' })
                          (?>
                              (?&PerlVariable)
                          |
                              (?&PerlQuotelike)
                          |
                              \\?+ .
                          )
                      )*+
                  )
              )
          )?+
      )
  
      (?<PPR_X_filetest_name>   [ABCMORSTWXbcdefgkloprstuwxz]          )
  
      (?<PPR_X_digit_seq>               \d++ (?: _?+         \d++ )*+  )
      (?<PPR_X_x_digit_seq>     [\da-fA-F]++ (?: _?+ [\da-fA-F]++ )*+  )
      (?<PPR_X_o_digit_seq>          [0-7]++ (?: _?+      [0-7]++ )*+  )
      (?<PPR_X_b_digit_seq>          [0-1]++ (?: _?+      [0-1]++ )*+  )
  
      (?<PPR_X_newline_and_heredoc>
          \n (??{ ($PPR::X::_heredoc_origin // q{}) eq ($_//q{}) ? ($PPR::X::_heredoc_skip{+pos()} // q{}) : q{} })
      )
  )
  }xms;sub decomment {if ($] >= 5.014 && $] < 5.016){_croak("PPR::X::decomment() does not work under Perl 5.14")}my ($str)=@_;local%PPR::X::comment_len;$str =~ m{ \A (?&PerlDocument) \Z
  
                  (?(DEFINE)
                      (?<decomment>
                         ( (?<! [\$@%] ) [#] [^\n]*+ )
                         (?{
                              my $len = length($^N);
                              my $pos = pos() - $len;
                              $PPR::X::comment_len{$pos} = $len;
                         })
                      )
  
                      (?<PerlOWS>
                          (?:
                              \h++
                          |
                              (?&PPR_X_newline_and_heredoc)
                          |
                              (?&decomment)
                          |
                              __ (?> END | DATA ) __ \b .*+ \z
                          )*+
                      ) # End of rule
  
                      (?<PerlNWS>
                          (?:
                              \h++
                          |
                              (?&PPR_X_newline_and_heredoc)
                          |
                              (?&decomment)
                          |
                              __ (?> END | DATA ) __ \b .*+ \z
                          )++
  
                      ) # End of rule
  
                      (?<PerlPod>
                          (
                              ^ = [^\W\d]\w*+
                              .*?
                              (?>
                                  ^ = cut \b [^\n]*+ $
                              |
                                  \z
                              )
                          )
                          (?{
                              my $len = length($^N);
                              my $pos = pos() - $len;
                              $PPR::X::comment_len{$pos} = $len;
                          })
                      ) # End of rule
  
                      $PPR::X::GRAMMAR
                  )
              }xms or return;for my$from_pos (_uniq(sort {$b <=> $a}keys%PPR::X::comment_len)){substr($str,$from_pos,$PPR::X::comment_len{$from_pos})=q{}}return$str}sub _uniq {my%seen;return grep {!$seen{$_}++}@_}sub _croak {require Carp;Carp::croak(@_)}1;
PPR_X

$fatpacked{"Parse/PMFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_PMFILE';
  package Parse::PMFile;sub __clean_eval {eval $_[0]}use strict;use warnings;use Safe;use JSON::PP ();use Dumpvalue;use version ();use File::Spec ();our$VERSION='0.41';our$VERBOSE=0;our$ALLOW_DEV_VERSION=0;our$FORK=0;our$UNSAFE=$] < 5.010000 ? 1 : 0;sub new {my ($class,$meta,$opts)=@_;bless {%{$opts || {}},META_CONTENT=>$meta},$class}sub parse {my ($self,$pmfile)=@_;$pmfile =~ s|\\|/|g;my($filemtime)=(stat$pmfile)[9];$self->{MTIME}=$filemtime;$self->{PMFILE}=$pmfile;unless ($self->_version_from_meta_ok){my$version;unless (eval {$version=$self->_parse_version;1}){$self->_verbose(1,"error with version in $pmfile: $@");return}$self->{VERSION}=$version;if ($self->{VERSION}=~ /^\{.*\}$/){}elsif ($self->{VERSION}=~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){return}}my($ppp)=$self->_packages_per_pmfile;my@keys_ppp=$self->_filter_ppps(sort keys %$ppp);$self->_verbose(1,"Will check keys_ppp[@keys_ppp]\n");my ($package,%errors);my%checked_in;DBPACK: foreach$package (@keys_ppp){if ($package !~ /^\w[\w\:\']*\w?\z/ || $package !~ /\w\z/ || $package =~ /:/ && $package !~ /::/ || $package =~ /\w:\w/ || $package =~ /:::/){$self->_verbose(1,"Package[$package] did not pass the ultimate sanity check");delete$ppp->{$package};next}if ($self->{USERID}&& $self->{PERMISSIONS}&&!$self->_perm_check($package)){delete$ppp->{$package};next}{my (undef,$module)=split m{/lib/},$self->{PMFILE},2;if ($module){$module =~ s{\.pm\z}{};$module =~ s{/}{::}g;if (lc$module eq lc$package && $module ne $package){$errors{$package}={indexing_warning=>"Capitalization of package ($package) does not match filename!",infile=>$self->{PMFILE},}}}}my$pp=$ppp->{$package};if ($pp->{version}&& $pp->{version}=~ /^\{.*\}$/){my$err=JSON::PP::decode_json($pp->{version});if ($err->{x_normalize}){$errors{$package}={normalize=>$err->{version},infile=>$pp->{infile},};$pp->{version}="undef"}elsif ($err->{openerr}){$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          read the file. It issued the following error: C< $err->{r} >},);$errors{$package}={open=>$err->{r},infile=>$pp->{infile},}}else {$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          parse the following line in that file: C< $err->{line} >
  
          Note: the indexer is running in a Safe compartement and cannot
          provide the full functionality of perl in the VERSION line. It
          is trying hard, but sometime it fails. As a workaround, please
          consider writing a META.yml that contains a 'provides'
          attribute or contact the CPAN admins to investigate (yet
          another) workaround against "Safe" limitations.)},);$errors{$package}={parse_version=>$err->{line},infile=>$err->{file},}}}for ($package,$pp->{version},){if (!defined || /^\s*$/ || /\s/){delete$ppp->{$package};next}}unless ($self->_version_ok($pp)){$errors{$package}={long_version=>qq{Version string exceeds maximum allowed length of 16b: "$pp->{version}"},infile=>$pp->{infile},};next}$checked_in{$package}=$ppp->{$package}}return (wantarray && %errors)? (\%checked_in,\%errors): \%checked_in}sub _version_ok {my ($self,$pp)=@_;return if length($pp->{version}|| 0)> 16;return 1}sub _perm_check {my ($self,$package)=@_;my$userid=$self->{USERID};my$module=$self->{PERMISSIONS}->module_permissions($package);return 1 if!$module;return 1 if defined$module->m && $module->m eq $userid;return 1 if defined$module->f && $module->f eq $userid;return 1 if defined$module->c && grep {$_ eq $userid}@{$module->c};return}sub _parse_version {my$self=shift;use strict;my$pmfile=$self->{PMFILE};my$tmpfile=File::Spec->catfile(File::Spec->tmpdir,"ParsePMFile$$" .rand(1000));my$pmcp=$pmfile;for ($pmcp){s/([^\\](\\\\)*)@/$1\\@/g}my($v);{package main;my$pid;if ($self->{FORK}|| $FORK){$pid=fork();die "Can't fork: $!" unless defined$pid}if ($pid){waitpid($pid,0);if (open my$fh,'<',$tmpfile){$v=<$fh>}}else {my($comp)=Safe->new;my$eval=qq{
                  local(\$^W) = 0;
                  Parse::PMFile::_parse_version_safely("$pmcp");
              };$comp->permit("entereval");$comp->share("*Parse::PMFile::_parse_version_safely");$comp->share("*version::new");$comp->share("*version::numify");$comp->share_from('main',['*version::','*charstar::','*Exporter::','*DynaLoader::']);$comp->share_from('version',['&qv']);$comp->permit(":base_math");$comp->deny(qw/enteriter iter unstack goto/);version->import('qv')if$self->{UNSAFE}|| $UNSAFE;{no strict;$v=($self->{UNSAFE}|| $UNSAFE)? eval$eval : $comp->reval($eval)}if ($@){my$err=$@;if (ref$err){if ($err->{line}=~ /([\$*])([\w\:\']*)\bVERSION\b.*?\=(.*)/){local($^W)=0;my ($sigil,$vstr)=($1,$3);$self->_restore_overloaded_stuff(1)if$err->{line}=~ /use\s+version\b|version\->|qv\(/;$v=($self->{UNSAFE}|| $UNSAFE)? eval$vstr : $comp->reval($vstr);$v=$$v if$sigil eq '*' && ref$v}if ($@ or!$v){$self->_verbose(1,sprintf("reval failed: err[%s] for eval[%s]",JSON::PP::encode_json($err),$eval,));$v=JSON::PP::encode_json($err)}}else {$v=JSON::PP::encode_json({openerr=>$err })}}if (defined$v){no warnings;$v=$v->numify if ref($v)=~ /^version(::vpp)?$/}else {$v=""}if ($self->{FORK}|| $FORK){open my$fh,'>:utf8',$tmpfile;print$fh $v;exit 0}else {utf8::encode($v);$v=undef if defined$v &&!length$v;$comp->erase;$self->_restore_overloaded_stuff}}}unlink$tmpfile if ($self->{FORK}|| $FORK)&& -e $tmpfile;return$self->_normalize_version($v)}sub _restore_overloaded_stuff {my ($self,$used_version_in_safe)=@_;return if$self->{UNSAFE}|| $UNSAFE;no strict 'refs';no warnings 'redefine';my$restored;if ($INC{'version/vxs.pm'}){*{'version::(""'}=\&version::vxs::stringify;*{'version::(0+'}=\&version::vxs::numify;*{'version::(cmp'}=\&version::vxs::VCMP;*{'version::(<=>'}=\&version::vxs::VCMP;*{'version::(bool'}=\&version::vxs::boolean;$restored=1}if ($INC{'version/vpp.pm'}){{package charstar;overload->import}if (!$used_version_in_safe){package version::vpp;overload->import}unless ($restored){*{'version::(""'}=\&version::vpp::stringify;*{'version::(0+'}=\&version::vpp::numify;*{'version::(cmp'}=\&version::vpp::vcmp;*{'version::(<=>'}=\&version::vpp::vcmp;*{'version::(bool'}=\&version::vpp::vbool}*{'version::vpp::(""'}=\&version::vpp::stringify;*{'version::vpp::(0+'}=\&version::vpp::numify;*{'version::vpp::(cmp'}=\&version::vpp::vcmp;*{'version::vpp::(<=>'}=\&version::vpp::vcmp;*{'version::vpp::(bool'}=\&version::vpp::vbool;*{'charstar::(""'}=\&charstar::thischar;*{'charstar::(0+'}=\&charstar::thischar;*{'charstar::(++'}=\&charstar::increment;*{'charstar::(--'}=\&charstar::decrement;*{'charstar::(+'}=\&charstar::plus;*{'charstar::(-'}=\&charstar::minus;*{'charstar::(*'}=\&charstar::multiply;*{'charstar::(cmp'}=\&charstar::cmp;*{'charstar::(<=>'}=\&charstar::spaceship;*{'charstar::(bool'}=\&charstar::thischar;*{'charstar::(='}=\&charstar::clone;$restored=1}if (!$restored){*{'version::(""'}=\&version::stringify;*{'version::(0+'}=\&version::numify;*{'version::(cmp'}=\&version::vcmp;*{'version::(<=>'}=\&version::vcmp;*{'version::(bool'}=\&version::boolean}}sub _packages_per_pmfile {my$self=shift;my$ppp={};my$pmfile=$self->{PMFILE};my$filemtime=$self->{MTIME};my$version=$self->{VERSION};open my$fh,"<","$pmfile" or return$ppp;local $/="\n";my$inpod=0;PLINE: while (<$fh>){chomp;my($pline)=$_;$inpod=$pline =~ /^=(?!cut)/ ? 1 : $pline =~ /^=cut/ ? 0 : $inpod;next if$inpod;next if substr($pline,0,4)eq "=cut";$pline =~ s/\#.*//;next if$pline =~ /^\s*$/;if ($pline =~ /^__(?:END|DATA)__\b/ and $pmfile !~ /\.PL$/){last PLINE}my$pkg;my$strict_version;if ($pline =~ m{
                        # (.*) # takes too much time if $pline is long
                        #(?<![*\$\\@%&]) # no sigils
                        ^[\s\{;]*
                        \bpackage\s+
                        ([\w\:\']+)
                        \s*
                        (?: $ | [\}\;] | \{ | \s+($version::STRICT) )
                      }x){$pkg=$1;$strict_version=$2;if ($pkg eq "DB"){next PLINE}}if ($pkg){$pkg =~ s/\'/::/g;next PLINE unless$pkg =~ /^[A-Za-z]/;next PLINE unless$pkg =~ /\w$/;next PLINE if$pkg eq "main";next PLINE if length($pkg)> 128;$ppp->{$pkg}{parsed}++;$ppp->{$pkg}{infile}=$pmfile;if ($self->_simile($pmfile,$pkg)){$ppp->{$pkg}{simile}=$pmfile;if ($self->_version_from_meta_ok){my$provides=$self->{META_CONTENT}{provides};if (exists$provides->{$pkg}){if (defined$provides->{$pkg}{version}){my$v=$provides->{$pkg}{version};if ($v =~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){next PLINE}unless (eval {$version=$self->_normalize_version($v);1}){$self->_verbose(1,"error with version in $pmfile: $@");next}$ppp->{$pkg}{version}=$version}else {$ppp->{$pkg}{version}="undef"}}}else {if (defined$strict_version){$ppp->{$pkg}{version}=$strict_version }else {$ppp->{$pkg}{version}=defined$version ? $version : ""}no warnings;if ($version eq 'undef'){$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}}else {$ppp->{$pkg}{version}=$version if$version > $ppp->{$pkg}{version}|| $version gt $ppp->{$pkg}{version}}}}else {$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}&& length($ppp->{$pkg}{version})}$ppp->{$pkg}{filemtime}=$filemtime}else {}}close$fh;$ppp}{no strict;sub _parse_version_safely {my($parsefile)=@_;my$result;local*FH;local $/="\n";open(FH,$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;while (<FH>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;last if /^__(?:END|DATA)__\b/;chop;if (my ($ver)=/package \s+ \S+ \s+ (\S+) \s* [;{]/x){return$ver if version::is_lax($ver)}next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*(?<![!><=])\=(?![=>])/;my$current_parsed_line=$_;my$eval=qq{
                  package #
                      ExtUtils::MakeMaker::_version;
  
                  local $1$2;
                  \$$2=undef; do {
                      $_
                  }; \$$2
              };local $^W=0;local$SIG{__WARN__}=sub {};$result=__clean_eval($eval);if ($@ or!defined$result){die +{eval=>$eval,line=>$current_parsed_line,file=>$parsefile,err=>$@,}}last}close FH;$result="undef" unless defined$result;if ((ref$result)=~ /^version(?:::vpp)?\b/){no warnings;$result=$result->numify}return$result}}sub _filter_ppps {my($self,@ppps)=@_;my@res;MANI: for my$ppp (@ppps){if ($self->{META_CONTENT}){my$no_index=$self->{META_CONTENT}{no_index}|| $self->{META_CONTENT}{private};if (ref($no_index)eq 'HASH'){my%map=(package=>qr{\z},namespace=>qr{::},);for my$k (qw(package namespace)){next unless my$v=$no_index->{$k};my$rest=$map{$k};if (ref$v eq "ARRAY"){for my$ve (@$v){$ve =~ s|::$||;if ($ppp =~ /^$ve$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to ve[$ve]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to ve[$ve]")}}}else {$v =~ s|::$||;if ($ppp =~ /^$v$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to v[$v]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to v[$v]")}}}}else {$self->_verbose(1,"No keyword 'no_index' or 'private' in META_CONTENT")}}else {}push@res,$ppp}$self->_verbose(1,"Result of filter_ppps: res[@res]");@res}sub _simile {my($self,$file,$package)=@_;$file =~ s|.*/||;$file =~ s|\.pm(?:\.PL)?||;my$ret=$package =~ m/\b\Q$file\E$/;$ret ||= 0;unless ($ret){$ret=1 if lc$file eq 'version'}$self->_verbose(1,"Result of simile(): file[$file] package[$package] ret[$ret]\n");$ret}sub _normalize_version {my($self,$v)=@_;$v="undef" unless defined$v;my$dv=Dumpvalue->new;my$sdv=$dv->stringify($v,1);$self->_verbose(1,"Result of normalize_version: sdv[$sdv]\n");return$v if$v eq "undef";return$v if$v =~ /^\{.*\}$/;$v =~ s/^\s+//;$v =~ s/\s+\z//;if ($v =~ /_/){return$v }if (!version::is_lax($v)){return JSON::PP::encode_json({x_normalize=>'version::is_lax failed',version=>$v })}my$vv=eval {no warnings;version->new($v)->numify};if ($@){return JSON::PP::encode_json({x_normalize=>$@,version=>$v })}if ($vv eq $v){}else {my$forced=$self->_force_numeric($v);if ($forced eq $vv){}elsif ($forced =~ /^v(.+)/){no warnings;$vv=version->new($1)->numify}else {if ($forced==$vv){$vv=$forced}}}return$vv}sub _force_numeric {my($self,$v)=@_;$v=$self->_readable($v);if ($v =~ /^(\+?)(\d*)(\.(\d*))?/ && (defined $2 && length $2 || defined $4 && length $4)){my$two=defined $2 ? $2 : "";my$three=defined $3 ? $3 : "";$v="$two$three"}$v}sub _version_from_meta_ok {my($self)=@_;return$self->{VERSION_FROM_META_OK}if exists$self->{VERSION_FROM_META_OK};my$c=$self->{META_CONTENT};return($self->{VERSION_FROM_META_OK}=0)unless$c->{provides};my ($mb_v)=(defined$c->{generated_by}? $c->{generated_by}: '')=~ /Module::Build version ([\d\.]+)/;return($self->{VERSION_FROM_META_OK}=1)unless$mb_v;return($self->{VERSION_FROM_META_OK}=1)if$mb_v eq '0.250.0';if ($mb_v >= 0.19 && $mb_v < 0.26 &&!keys %{$c->{provides}}){return($self->{VERSION_FROM_META_OK}=0)}return($self->{VERSION_FROM_META_OK}=1)}sub _verbose {my($self,$level,@what)=@_;warn@what if$level <= ((ref$self && $self->{VERBOSE})|| $VERBOSE)}sub _vcmp {my($self,$l,$r)=@_;local($^W)=0;$self->_verbose(9,"l[$l] r[$r]");return 0 if$l eq $r;for ($l,$r){s/_//g}$self->_verbose(9,"l[$l] r[$r]");for ($l,$r){next unless tr/.// > 1 || /^v/;s/^v?/v/;1 while s/\.0+(\d)/.$1/}$self->_verbose(9,"l[$l] r[$r]");if ($l=~/^v/ <=> $r=~/^v/){for ($l,$r){next if /^v/;$_=$self->_float2vv($_)}}$self->_verbose(9,"l[$l] r[$r]");my$lvstring="v0";my$rvstring="v0";if ($] >= 5.006 && $l =~ /^v/ && $r =~ /^v/){$lvstring=$self->_vstring($l);$rvstring=$self->_vstring($r);$self->_verbose(9,sprintf "lv[%vd] rv[%vd]",$lvstring,$rvstring)}return (($l ne "undef")<=> ($r ne "undef")|| $lvstring cmp $rvstring || $l <=> $r || $l cmp $r)}sub _vgt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)> 0}sub _vlt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)< 0}sub _vge {my($self,$l,$r)=@_;$self->_vcmp($l,$r)>= 0}sub _vle {my($self,$l,$r)=@_;$self->_vcmp($l,$r)<= 0}sub _vstring {my($self,$n)=@_;$n =~ s/^v// or die "Parse::PMFile::_vstring() called with invalid arg [$n]";pack "U*",split /\./,$n}sub _float2vv {my($self,$n)=@_;my($rev)=int($n);$rev ||= 0;my($mantissa)=$n =~ /\.(\d{1,12})/;$mantissa ||= 0;$mantissa .= "0" while length($mantissa)%3;my$ret="v" .$rev;while ($mantissa){$mantissa =~ s/(\d{1,3})// or die "Panic: length>0 but not a digit? mantissa[$mantissa]";$ret .= ".".int($1)}$ret =~ s/(\.0)+/.0/;$ret}sub _readable {my($self,$n)=@_;$n =~ /^([\w\-\+\.]+)/;return $1 if defined $1 && length($1)>0;if ($] < 5.006){$self->_verbose(9,"Suspicious version string seen [$n]\n");return$n}my$better=sprintf "v%vd",$n;$self->_verbose(9,"n[$n] better[$better]");return$better}1;
PARSE_PMFILE

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;use strict;use warnings;package Path::Tiny;our$VERSION='0.108';use Config;use Exporter 5.57 (qw/import/);use File::Spec 0.86 ();use Carp ();our@EXPORT=qw/path/;our@EXPORT_OK=qw/cwd rootdir tempfile tempdir/;use constant {PATH=>0,CANON=>1,VOL=>2,DIR=>3,FILE=>4,TEMP=>5,IS_WIN32=>($^O eq 'MSWin32'),};use overload (q{""}=>sub {$_[0]->[PATH]},bool=>sub () {1},fallback=>1,);sub FREEZE {return $_[0]->[PATH]}sub THAW {return path($_[2])}{no warnings 'once';*TO_JSON=*FREEZE};my$HAS_UU;sub _check_UU {local$SIG{__DIE__};!!eval {require Unicode::UTF8;Unicode::UTF8->VERSION(0.58);1}}my$HAS_PU;sub _check_PU {local$SIG{__DIE__};!!eval {require Encode;require PerlIO::utf8_strict;PerlIO::utf8_strict->VERSION(0.003);1}}my$HAS_FLOCK=$Config{d_flock}|| $Config{d_fcntl_can_lock}|| $Config{d_lockf};my$SLASH=qr{[\\/]};my$NOTSLASH=qr{[^\\/]};my$DRV_VOL=qr{[a-z]:}i;my$UNC_VOL=qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;my$WIN32_ROOT=qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;sub _win32_vol {my ($path,$drv)=@_;require Cwd;my$dcwd=eval {Cwd::getdcwd($drv)};$dcwd="$drv" unless defined$dcwd && length$dcwd;$dcwd =~ s{$SLASH?$}{/};$path =~ s{^$DRV_VOL}{$dcwd};return$path}sub _is_root {return IS_WIN32()? ($_[0]=~ /^$WIN32_ROOT$/): ($_[0]eq '/')}BEGIN {*_same=IS_WIN32()? sub {lc($_[0])eq lc($_[1])}: sub {$_[0]eq $_[1]}}my%MODEBITS=(om=>0007,gm=>0070,um=>0700);{my$m=0;$MODEBITS{$_}=(1 << $m++)for qw/ox ow or gx gw gr ux uw ur/};sub _symbolic_chmod {my ($mode,$symbolic)=@_;for my$clause (split /,\s*/,$symbolic){if ($clause =~ m{\A([augo]+)([=+-])([rwx]+)\z}){my ($who,$action,$perms)=($1,$2,$3);$who =~ s/a/ugo/g;for my$w (split //,$who){my$p=0;$p |= $MODEBITS{"$w$_"}for split //,$perms;if ($action eq '='){$mode=($mode & ~$MODEBITS{"${w}m"})| $p}else {$mode=$action eq "+" ? ($mode | $p): ($mode & ~$p)}}}else {Carp::croak("Invalid mode clause '$clause' for chmod()")}}return$mode}{package flock;use warnings::register}my$WARNED_NO_FLOCK=0;sub _throw {my ($self,$function,$file,$msg)=@_;if ($function =~ /^flock/ && $! =~ /operation not supported|function not implemented/i &&!warnings::fatal_enabled('flock')){if (!$WARNED_NO_FLOCK){warnings::warn(flock=>"Flock not available: '$!': continuing in unsafe mode");$WARNED_NO_FLOCK++}}else {$msg=$! unless defined$msg;Path::Tiny::Error->throw($function,(defined$file ? $file : $self->[PATH]),$msg)}return}sub _get_args {my ($raw,@valid)=@_;if (defined($raw)&& ref($raw)ne 'HASH'){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Options for $called_as must be a hash reference")}my$cooked={};for my$k (@valid){$cooked->{$k}=delete$raw->{$k}if exists$raw->{$k}}if (keys %$raw){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Invalid option(s) for $called_as: " .join(", ",keys %$raw))}return$cooked}sub path {my$path=shift;Carp::croak("Path::Tiny paths require defined, positive-length parts")unless 1 + @_==grep {defined && length}$path,@_;if (!@_ && ref($path)eq __PACKAGE__ &&!$path->[TEMP]){return$path}$path="$path";if (IS_WIN32()){$path=_win32_vol($path,$1)if$path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};$path .= "/" if$path =~ m{^$UNC_VOL$}}if (@_){$path .= (_is_root($path)? "" : "/").join("/",@_)}my$cpath=$path=File::Spec->canonpath($path);$path =~ tr[\\][/] if IS_WIN32();$path="/" if$path eq '/..';$path .= "/" if IS_WIN32()&& $path =~ m{^$UNC_VOL$};if (_is_root($path)){$path =~ s{/?$}{/}}else {$path =~ s{/$}{}}if ($path =~ m{^(~[^/]*).*}){require File::Glob;my ($homedir)=File::Glob::bsd_glob($1);$homedir =~ tr[\\][/] if IS_WIN32();$path =~ s{^(~[^/]*)}{$homedir}}bless [$path,$cpath ],__PACKAGE__}sub new {shift;path(@_)}sub cwd {require Cwd;return path(Cwd::getcwd())}sub rootdir {path(File::Spec->rootdir)}sub tempfile {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);$args->{TEMPLATE}=$maybe_template->[0]if @$maybe_template;require File::Temp;my$temp=File::Temp->new(TMPDIR=>1,%$args);close$temp;my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;return$self}sub tempdir {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);require File::Temp;my$temp=File::Temp->newdir(@$maybe_template,TMPDIR=>1,%$args);my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;$temp->{REALNAME}=$self->[CANON]if IS_WIN32;return$self}sub _parse_file_temp_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? delete$args{TEMPLATE}: $leading_template ? $leading_template : ());return (\@template,\%args)}sub _splitpath {my ($self)=@_;@{$self}[VOL,DIR,FILE ]=File::Spec->splitpath($self->[PATH])}sub _resolve_symlinks {my ($self)=@_;my$new=$self;my ($count,%seen)=0;while (-l $new->[PATH]){if ($seen{$new->[PATH]}++){$self->_throw('readlink',$self->[PATH],"symlink loop detected")}if (++$count > 100){$self->_throw('readlink',$self->[PATH],"maximum symlink depth exceeded")}my$resolved=readlink$new->[PATH]or $new->_throw('readlink',$new->[PATH]);$resolved=path($resolved);$new=$resolved->is_absolute ? $resolved : $new->sibling($resolved)}return$new}sub absolute {my ($self,$base)=@_;if (IS_WIN32){return$self if length$self->volume;if ($self->is_absolute){require Cwd;my ($drv)=Win32::GetCwd()=~ /^($DRV_VOL | $UNC_VOL)/x;return path($drv .$self->[PATH])}}else {return$self if$self->is_absolute}require Cwd;return path(Cwd::getcwd(),$_[0]->[PATH])unless defined$base;$base=path($base);return path(($base->is_absolute ? $base : $base->absolute),$_[0]->[PATH])}sub append {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$mode=$args->{truncate}? ">" : ">>";my$fh=$self->filehandle({locked=>1 },$mode,$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close')}sub append_raw {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);$args->{binmode}=':unix';append($self,$args,@data)}sub append_utf8 {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){$args->{binmode}=":unix";append($self,$args,map {Unicode::UTF8::encode_utf8($_)}@data)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";append($self,$args,@data)}else {$args->{binmode}=":unix:encoding(UTF-8)";append($self,$args,@data)}}sub assert {my ($self,$assertion)=@_;return$self unless$assertion;if (ref$assertion eq 'CODE'){local $_=$self;$assertion->()or Path::Tiny::Error->throw("assert",$self->[PATH],"failed assertion")}else {Carp::croak("argument to assert must be a code reference argument")}return$self}sub basename {my ($self,@suffixes)=@_;$self->_splitpath unless defined$self->[FILE];my$file=$self->[FILE];for my$s (@suffixes){my$re=ref($s)eq 'Regexp' ? qr/$s$/ : qr/\Q$s\E$/;last if$file =~ s/$re//}return$file}sub canonpath {$_[0]->[CANON]}sub cached_temp {my$self=shift;$self->_throw("cached_temp",$self,"has no cached File::Temp object")unless defined$self->[TEMP];return$self->[TEMP]}sub child {my ($self,@parts)=@_;return path($self->[PATH],@parts)}sub children {my ($self,$filter)=@_;my$dh;opendir$dh,$self->[PATH]or $self->_throw('opendir');my@children=readdir$dh;closedir$dh or $self->_throw('closedir');if (not defined$filter){@children=grep {$_ ne '.' && $_ ne '..'}@children}elsif ($filter && ref($filter)eq 'Regexp'){@children=grep {$_ ne '.' && $_ ne '..' && $_ =~ $filter}@children}else {Carp::croak("Invalid argument '$filter' for children()")}return map {path($self->[PATH],$_)}@children}sub chmod {my ($self,$new_mode)=@_;my$mode;if ($new_mode =~ /\d/){$mode=($new_mode =~ /^0/ ? oct($new_mode): $new_mode)}elsif ($new_mode =~ /[=+-]/){$mode=_symbolic_chmod($self->stat->mode & 07777,$new_mode)}else {Carp::croak("Invalid mode argument '$new_mode' for chmod()")}CORE::chmod($mode,$self->[PATH])or $self->_throw("chmod");return 1}sub copy {my ($self,$dest)=@_;require File::Copy;File::Copy::copy($self->[PATH],$dest)or Carp::croak("copy failed for $self to $dest: $!");return -d $dest ? path($dest,$self->basename): path($dest)}sub digest {my ($self,@opts)=@_;my$args=(@opts && ref$opts[0]eq 'HASH')? shift@opts : {};$args=_get_args($args,qw/chunk_size/);unshift@opts,'SHA-256' unless@opts;require Digest;my$digest=Digest->new(@opts);if ($args->{chunk_size}){my$fh=$self->filehandle({locked=>1 },"<",":unix");my$buf;$digest->add($buf)while read$fh,$buf,$args->{chunk_size}}else {$digest->add($self->slurp_raw)}return$digest->hexdigest}sub dirname {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return length$self->[DIR]? $self->[DIR]: "."}sub edit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp(exists($args->{binmode})? {binmode=>$args->{binmode}}: ());$cb->();$self->spew($args,$_);return}sub edit_utf8 {my ($self,$cb)=@_;Carp::croak("Callback for edit_utf8() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp_utf8;$cb->();$self->spew_utf8($_);return}sub edit_raw {$_[2]={binmode=>":unix" };goto&edit}sub edit_lines {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit_lines() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$temp_fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);my$in_fh=$self->filehandle({locked=>1 },'<',$binmode);local $_;while (<$in_fh>){$cb->();$temp_fh->print($_)}close$temp_fh or $self->_throw('close',$temp);close$in_fh or $self->_throw('close');return$temp->move($resolved_path)}sub edit_lines_raw {$_[2]={binmode=>":unix" };goto&edit_lines}sub edit_lines_utf8 {$_[2]={binmode=>":raw:encoding(UTF-8)" };goto&edit_lines}sub exists {-e $_[0]->[PATH]}sub is_file {-e $_[0]->[PATH]&&!-d _}sub is_dir {-d $_[0]->[PATH]}sub filehandle {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked exclusive/);$args->{locked}=1 if$args->{exclusive};my ($opentype,$binmode)=@args;$opentype="<" unless defined$opentype;Carp::croak("Invalid file mode '$opentype'")unless grep {$opentype eq $_}qw/< +< > +> >> +>>/;$binmode=((caller(0))[10]|| {})->{'open' .substr($opentype,-1,1)}unless defined$binmode;$binmode="" unless defined$binmode;my ($fh,$lock,$trunc);if ($HAS_FLOCK && $args->{locked}&&!$ENV{PERL_PATH_TINY_NO_FLOCK}){require Fcntl;if (grep {$opentype eq $_}qw(> +>)){my$flags=$opentype eq ">" ? Fcntl::O_WRONLY(): Fcntl::O_RDWR();$flags |= Fcntl::O_CREAT();$flags |= Fcntl::O_EXCL()if$args->{exclusive};sysopen($fh,$self->[PATH],$flags)or $self->_throw("sysopen");if ($binmode =~ s/^:unix//){binmode($fh,":raw")or $self->_throw("binmode (:raw)");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")or $self->_throw("binmode (:pop)")}}if (length$binmode){binmode($fh,$binmode)or $self->_throw("binmode ($binmode)")}$lock=Fcntl::LOCK_EX();$trunc=1}elsif ($^O eq 'aix' && $opentype eq "<"){if (-w $self->[PATH]){$opentype="+<";$lock=Fcntl::LOCK_EX()}}else {$lock=$opentype eq "<" ? Fcntl::LOCK_SH(): Fcntl::LOCK_EX()}}unless ($fh){my$mode=$opentype .$binmode;open$fh,$mode,$self->[PATH]or $self->_throw("open ($mode)")}do {flock($fh,$lock)or $self->_throw("flock ($lock)")}if$lock;do {truncate($fh,0)or $self->_throw("truncate")}if$trunc;return$fh}sub is_absolute {substr($_[0]->dirname,0,1)eq '/'}sub is_relative {substr($_[0]->dirname,0,1)ne '/'}sub is_rootdir {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return$self->[DIR]eq '/' && $self->[FILE]eq ''}sub iterator {my$self=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);my@dirs=$self;my$current;return sub {my$next;while (@dirs){if (ref$dirs[0]eq 'Path::Tiny'){if (!-r $dirs[0]){shift@dirs and next}$current=$dirs[0];my$dh;opendir($dh,$current->[PATH])or $self->_throw('opendir',$current->[PATH]);$dirs[0]=$dh;if (-l $current->[PATH]&&!$args->{follow_symlinks}){shift@dirs and next}}while (defined($next=readdir$dirs[0])){next if$next eq '.' || $next eq '..';my$path=$current->child($next);push@dirs,$path if$args->{recurse}&& -d $path &&!(!$args->{follow_symlinks}&& -l $path);return$path}shift@dirs}return}}sub lines {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);my$chomp=$args->{chomp};if ($args->{count}){my ($counter,$mod,@result)=(0,abs($args->{count}));while (my$line=<$fh>){$line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if$chomp;$result[$counter++ ]=$line;last if$counter==$args->{count};$counter %= $mod}splice(@result,0,0,splice(@result,$counter))if@result==$mod && $counter % $mod;return@result}elsif ($chomp){return map {s/(?:\x{0d}?\x{0a}|\x{0d})$//;$_}<$fh>}else {return wantarray ? <$fh> : (my$count=()=<$fh>)}}sub lines_raw {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ($args->{chomp}&&!$args->{count}){return split /\n/,slurp_raw($self)}else {$args->{binmode}=":raw";return lines($self,$args)}}my$CRLF=qr/(?:\x{0d}?\x{0a}|\x{0d})/;sub lines_utf8 {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ((defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU()))&& $args->{chomp}&&!$args->{count}){my$slurp=slurp_utf8($self);$slurp =~ s/$CRLF$//;return split$CRLF,$slurp,-1}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";return lines($self,$args)}else {$args->{binmode}=":raw:encoding(UTF-8)";return lines($self,$args)}}sub mkpath {my ($self,$args)=@_;$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};require File::Path;my@dirs=File::Path::make_path($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("mkpath failed for $file: $message")}return@dirs}sub move {my ($self,$dst)=@_;return rename($self->[PATH],$dst)|| $self->_throw('rename',$self->[PATH]."' -> '$dst")}my%opens=(opena=>">>",openr=>"<",openw=>">",openrw=>"+<");while (my ($k,$v)=each%opens){no strict 'refs';*{$k}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);my ($binmode)=@args;$binmode=((caller(0))[10]|| {})->{'open' .substr($v,-1,1)}unless defined$binmode;$self->filehandle($args,$v,$binmode)};*{$k ."_raw"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw")};*{$k ."_utf8"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw:encoding(UTF-8)")}}sub parent {my ($self,$level)=@_;$level=1 unless defined$level && $level > 0;$self->_splitpath unless defined$self->[FILE];my$parent;if (length$self->[FILE]){if ($self->[FILE]eq '.' || $self->[FILE]eq ".."){$parent=path($self->[PATH]."/..")}else {$parent=path(_non_empty($self->[VOL].$self->[DIR]))}}elsif (length$self->[DIR]){if ($self->[DIR]=~ m{(?:^\.\./|/\.\./|/\.\.$)}){$parent=path($self->[VOL].$self->[DIR]."/..")}else {(my$dir=$self->[DIR])=~ s{/[^\/]+/$}{/};$parent=path($self->[VOL].$dir)}}else {$parent=path(_non_empty($self->[VOL]))}return$level==1 ? $parent : $parent->parent($level - 1)}sub _non_empty {my ($string)=shift;return ((defined($string)&& length($string))? $string : ".")}sub realpath {my$self=shift;$self=$self->_resolve_symlinks;require Cwd;$self->_splitpath if!defined$self->[FILE];my$check_parent=length$self->[FILE]&& $self->[FILE]ne '.' && $self->[FILE]ne '..';my$realpath=eval {local$SIG{__WARN__}=sub {};Cwd::realpath($check_parent ? $self->parent->[PATH]: $self->[PATH])};$self->_throw("resolving realpath")unless defined$realpath && length$realpath && -e $realpath;return ($check_parent ? path($realpath,$self->[FILE]): path($realpath))}sub relative {my ($self,$base)=@_;$base=path(defined$base && length$base ? $base : '.');$self=$self->absolute if$self->is_relative;$base=$base->absolute if$base->is_relative;$self=$self->absolute if!length$self->volume && length$base->volume;$base=$base->absolute if length$self->volume &&!length$base->volume;if (!_same($self->volume,$base->volume)){Carp::croak("relative() can't cross volumes: '$self' vs '$base'")}return path(".")if _same($self->[PATH],$base->[PATH]);if ($base->subsumes($self)){$base="" if$base->is_rootdir;my$relative="$self";$relative =~ s{\A\Q$base/}{};return path($relative)}my (@common,@self_parts,@base_parts);@base_parts=split /\//,$base->_just_filepath;if ($self->is_rootdir){@common=("");shift@base_parts}else {@self_parts=split /\//,$self->_just_filepath;while (@self_parts && @base_parts && _same($self_parts[0],$base_parts[0])){push@common,shift@base_parts;shift@self_parts}}if (my$new_base=$self->_resolve_between(\@common,\@base_parts)){return$self->relative($new_base)}my@new_path=(("..")x (0+ @base_parts),@self_parts);return path(@new_path)}sub _just_filepath {my$self=shift;my$self_vol=$self->volume;return "$self" if!length$self_vol;(my$self_path="$self")=~ s{\A\Q$self_vol}{};return$self_path}sub _resolve_between {my ($self,$common,$base)=@_;my$path=$self->volume .join("/",@$common);my$changed=0;for my$p (@$base){$path .= "/$p";if ($p eq '..'){$changed=1;if (-e $path){$path=path($path)->realpath->[PATH]}else {$path =~ s{/[^/]+/..$}{/}}}if (-l $path){$changed=1;$path=path($path)->realpath->[PATH]}}return$changed ? path($path): undef}sub remove {my$self=shift;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];return unlink($self->[PATH])|| $self->_throw('unlink')}sub remove_tree {my ($self,$args)=@_;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};$args->{safe}=1 unless defined$args->{safe};require File::Path;my$count=File::Path::remove_tree($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("remove_tree failed for $file: $message")}return$count}sub sibling {my$self=shift;return path($self->parent->[PATH],@_)}sub slurp {my$self=shift;my$args=_get_args(shift,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);if ((defined($binmode)? $binmode : "")eq ":unix" and my$size=-s $fh){my$buf;read$fh,$buf,$size;return$buf}else {local $/;return scalar <$fh>}}sub slurp_raw {$_[1]={binmode=>":unix" };goto&slurp}sub slurp_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){return Unicode::UTF8::decode_utf8(slurp($_[0],{binmode=>":unix" }))}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$_[1]={binmode=>":unix:utf8_strict" };goto&slurp}else {$_[1]={binmode=>":raw:encoding(UTF-8)" };goto&slurp}}sub spew {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close',$temp->[PATH]);return$temp->move($resolved_path)}sub spew_raw {splice @_,1,0,{binmode=>":unix" };goto&spew}sub spew_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){my$self=shift;spew($self,{binmode=>":unix" },map {Unicode::UTF8::encode_utf8($_)}map {ref eq 'ARRAY' ? @$_ : $_}@_)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){splice @_,1,0,{binmode=>":unix:utf8_strict" };goto&spew}else {splice @_,1,0,{binmode=>":unix:encoding(UTF-8)" };goto&spew}}sub stat {my$self=shift;require File::stat;return File::stat::stat($self->[PATH])|| $self->_throw('stat')}sub lstat {my$self=shift;require File::stat;return File::stat::lstat($self->[PATH])|| $self->_throw('lstat')}sub stringify {$_[0]->[PATH]}sub subsumes {my$self=shift;Carp::croak("subsumes() requires a defined, positive-length argument")unless defined $_[0];my$other=path(shift);if ($self->is_absolute &&!$other->is_absolute){$other=$other->absolute}elsif ($other->is_absolute &&!$self->is_absolute){$self=$self->absolute}if (length$self->volume &&!length$other->volume){$other=$other->absolute}elsif (length$other->volume &&!length$self->volume){$self=$self->absolute}if ($self->[PATH]eq '.'){return!!1}elsif ($self->is_rootdir){return$other->[PATH]=~ m{^\Q$self->[PATH]\E}}else {return$other->[PATH]=~ m{^\Q$self->[PATH]\E(?:/|$)}}}sub touch {my ($self,$epoch)=@_;if (!-e $self->[PATH]){my$fh=$self->openw;close$fh or $self->_throw('close')}if (defined$epoch){utime$epoch,$epoch,$self->[PATH]or $self->_throw("utime ($epoch)")}else {utime undef,undef,$self->[PATH]or $self->_throw("utime ()")}return$self}sub touchpath {my ($self)=@_;my$parent=$self->parent;$parent->mkpath unless$parent->exists;$self->touch}sub visit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);Carp::croak("Callback for visit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$next=$self->iterator($args);my$state={};while (my$file=$next->()){local $_=$file;my$r=$cb->($file,$state);last if ref($r)eq 'SCALAR' &&!$$r}return$state}sub volume {my ($self)=@_;$self->_splitpath unless defined$self->[VOL];return$self->[VOL]}package Path::Tiny::Error;our@CARP_NOT=qw/Path::Tiny/;use overload (q{""}=>sub {(shift)->{msg}},fallback=>1);sub throw {my ($class,$op,$file,$err)=@_;chomp(my$trace=Carp::shortmess);my$msg="Error $op on '$file': $err$trace\n";die bless {op=>$op,file=>$file,err=>$err,msg=>$msg },$class}1;
PATH_TINY

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}use strict;use warnings;our$VERSION='2.000006';$VERSION =~ tr/_//d;our%INFO;our%APPLIED_TO;our%COMPOSED;our%COMPOSITE_INFO;our@ON_ROLE_CREATE;BEGIN {*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0};*_WORK_AROUND_HINT_LEAKAGE ="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_MRO_MODULE="$]" < 5.010 ? sub(){"MRO/Compat.pm"}: sub(){"mro.pm"}}sub croak {require Carp;no warnings 'redefine';*croak=\&Carp::croak;goto&Carp::croak}sub Role::Tiny::__GUARD__::DESTROY {delete$INC{$_[0]->[0]}if @{$_[0]}}sub _load_module {my ($module)=@_;(my$file="$module.pm")=~ s{::}{/}g;return 1 if$INC{$file};return 1 if grep!/::\z/,keys %{_getstash($module)};my$guard=_WORK_AROUND_BROKEN_MODULE_STATE && bless([$file ],'Role::Tiny::__GUARD__');local %^H if _WORK_AROUND_HINT_LEAKAGE;require$file;pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;return 1}sub import {my$target=caller;my$me=shift;strict->import;warnings->import;$me->_install_subs($target);return if$me->is_role($target);$INFO{$target}{is_role}=1;my$stash=_getstash($target);my@not_methods=map +(ref $_ eq 'CODE' ? $_ : ref $_ ? (): *$_{CODE}||()),values %$stash;@{$INFO{$target}{not_methods}={}}{@not_methods}=@not_methods;$APPLIED_TO{$target}={$target=>undef };for my$hook (@ON_ROLE_CREATE){$hook->($target)}}sub _install_subs {my ($me,$target)=@_;return if$me->is_role($target);for my$type (qw(before after around)){*{_getglob "${target}::${type}"}=sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];return}}*{_getglob "${target}::requires"}=sub {push @{$INFO{$target}{requires}||=[]},@_;return};*{_getglob "${target}::with"}=sub {$me->apply_roles_to_package($target,@_);return}}sub role_application_steps {qw(_install_methods _check_requires _install_modifiers _copy_applied_list)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);croak "This is apply_role_to_package" if ref($to);croak "${role} is not a Role::Tiny" unless$me->is_role($role);for my$step ($me->role_application_steps){$me->$step($to,$role)}}sub _copy_applied_list {my ($me,$to,$role)=@_;@{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}}=()}sub apply_roles_to_object {my ($me,$object,@roles)=@_;croak "No roles supplied!" unless@roles;my$class=ref($object);bless($_[1],$me->create_class_with_roles($class,@roles))}my$role_suffix='A000';sub _composite_name {my ($me,$superclass,@roles)=@_;my$new_name=join('__WITH__',$superclass,my$compose_name=join '__AND__',@roles);if (length($new_name)> 252){$new_name=$COMPOSED{abbrev}{$new_name}||= do {my$abbrev=substr$new_name,0,250 - length$role_suffix;$abbrev =~ s/(?<!:):$//;$abbrev.'__'.$role_suffix++}}return wantarray ? ($new_name,$compose_name): $new_name}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;croak "No roles supplied!" unless@roles;_load_module($superclass);{my%seen;if (my@dupes=grep 1==$seen{$_}++,@roles){croak "Duplicated roles: ".join(', ',@dupes)}}my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);croak "${role} is not a Role::Tiny" unless$me->is_role($role)}require(_MRO_MODULE);my$composite_info=$me->_composite_info_for(@roles);my%conflicts=%{$composite_info->{conflicts}};if (keys%conflicts){my$fail=join "\n",map {"Method name conflict for '$_' between roles " ."'".join("' and '",sort values %{$conflicts{$_}})."'" .", cannot apply these simultaneously to an object."}keys%conflicts;croak$fail}my@composable=map$me->_composable_package_for($_),reverse@roles;my@requires=grep {my$method=$_;!grep $_->can($method)&&!$COMPOSED{role}{$_}{modifiers_only}{$method},@composable}@{$composite_info->{requires}};$me->_check_requires($superclass,$compose_name,\@requires);*{_getglob("${new_name}::ISA")}=[@composable,$superclass ];@{$APPLIED_TO{$new_name}||={}}{map keys %{$APPLIED_TO{$_}},@roles }=();$COMPOSED{class}{$new_name}=1;return$new_name}sub apply_role_to_package {shift->apply_single_role_to_package(@_)}sub apply_roles_to_package {my ($me,$to,@roles)=@_;return$me->apply_role_to_package($to,$roles[0])if@roles==1;my%conflicts=%{$me->_composite_info_for(@roles)->{conflicts}};my@have=grep$to->can($_),keys%conflicts;delete@conflicts{@have};if (keys%conflicts){my$fail=join "\n",map {"Due to a method name conflict between roles " ."'".join(' and ',sort values %{$conflicts{$_}})."'" .", the method '$_' must be implemented by '${to}'"}keys%conflicts;croak$fail}my@role_methods=map$me->_concrete_methods_of($_),@roles;local @{$_}{@have}for@role_methods;delete @{$_}{@have}for@role_methods;if ($INFO{$to}){delete$INFO{$to}{methods}}our%BACKCOMPAT_HACK;if($me ne __PACKAGE__ and exists$BACKCOMPAT_HACK{$me}? $BACKCOMPAT_HACK{$me}: $BACKCOMPAT_HACK{$me}=$me->can('role_application_steps')==\&role_application_steps && $me->can('apply_single_role_to_package')!=\&apply_single_role_to_package){for my$role (@roles){$me->apply_single_role_to_package($to,$role)}}else {for my$step ($me->role_application_steps){for my$role (@roles){$me->$step($to,$role)}}}$APPLIED_TO{$to}{join('|',@roles)}=1}sub _composite_info_for {my ($me,@roles)=@_;$COMPOSITE_INFO{join('|',sort@roles)}||= do {for my$role (@roles){_load_module($role)}my%methods;for my$role (@roles){my$this_methods=$me->_concrete_methods_of($role);$methods{$_}{$this_methods->{$_}}=$role for keys %$this_methods}my%requires;@requires{map @{$INFO{$_}{requires}||[]},@roles}=();delete$requires{$_}for keys%methods;delete$methods{$_}for grep keys(%{$methods{$_}})==1,keys%methods;+{conflicts=>\%methods,requires=>[keys%requires]}}}sub _composable_package_for {my ($me,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$COMPOSED{role}{$composed_name};$me->_install_methods($composed_name,$role);my$base_name=$composed_name.'::_BASE';_getstash($base_name);{no strict 'refs';@{"${composed_name}::ISA"}=($base_name)}my$modifiers=$INFO{$role}{modifiers}||[];my@mod_base;my@modifiers=grep!$composed_name->can($_),do {my%h;@h{map @{$_}[1..$#$_-1],@$modifiers}=();keys%h};for my$modified (@modifiers){push@mod_base,"sub ${modified} { shift->next::method(\@_) }"}my$e;{local $@;eval(my$code=join "\n","package ${base_name};",@mod_base);$e="Evaling failed: $@\nTrying to eval:\n${code}" if $@}die$e if$e;$me->_install_modifiers($composed_name,$role);$COMPOSED{role}{$composed_name}={modifiers_only=>{map {$_=>1}@modifiers },};return$composed_name}sub _check_requires {my ($me,$to,$name,$requires)=@_;return unless my@requires=@{$requires||$INFO{$name}{requires}||[]};if (my@requires_fail=grep!$to->can($_),@requires){if (my$to_info=$INFO{$to}){push @{$to_info->{requires}||=[]},@requires_fail}else {croak "Can't apply ${name} to ${to} - missing ".join(', ',@requires_fail)}}}sub _concrete_methods_of {my ($me,$role)=@_;my$info=$INFO{$role};my$stash=_getstash($role);my$not_methods={reverse %{$info->{not_methods}||{}}};$info->{methods}||= +{map {;no strict 'refs';my$code=exists &{"${role}::$_"}? \&{"${role}::$_"}: undef;(!$code or exists$not_methods->{$code})? (): ($_=>$code)}grep +(!ref($stash->{$_})|| ref($stash->{$_})eq 'CODE'),keys %$stash }}sub methods_provided_by {my ($me,$role)=@_;croak "${role} is not a Role::Tiny" unless$me->is_role($role);(keys %{$me->_concrete_methods_of($role)},@{$INFO{$role}->{requires}||[]})}sub _install_methods {my ($me,$to,$role)=@_;my$info=$INFO{$role};my$methods=$me->_concrete_methods_of($role);my$stash=_getstash($to);my%has_methods;@has_methods{grep +(ref($stash->{$_})|| *{$stash->{$_}}{CODE}),keys %$stash }=();for my$i (grep!exists$has_methods{$_},keys %$methods){no warnings 'once';my$glob=_getglob "${to}::${i}";*$glob=$methods->{$i};next unless$i =~ /^\(/ && ((defined&overload::nil && $methods->{$i}==\&overload::nil)|| (defined&overload::_nil && $methods->{$i}==\&overload::_nil));my$overload=${*{_getglob "${role}::${i}"}{SCALAR}};next unless defined$overload;*$glob=\$overload}$me->_install_does($to)}sub _install_modifiers {my ($me,$to,$name)=@_;return unless my$modifiers=$INFO{$name}{modifiers};my$info=$INFO{$to};my$existing=($info ? $info->{modifiers}: $COMPOSED{modifiers}{$to})||= [];my@modifiers=grep {my$modifier=$_;!grep $_==$modifier,@$existing}@{$modifiers||[]};push @$existing,@modifiers;if (!$info){for my$modifier (@modifiers){$me->_install_single_modifier($to,@$modifier)}}}my$vcheck_error;sub _install_single_modifier {my ($me,@args)=@_;defined($vcheck_error)or $vcheck_error=do {local $@;eval {require Class::Method::Modifiers;Class::Method::Modifiers->VERSION(1.05);1}? 0 : $@};$vcheck_error and die$vcheck_error;Class::Method::Modifiers::install_modifier(@args)}my$FALLBACK=sub {0};sub _install_does {my ($me,$to)=@_;return if$me->is_role($to);my$does=$me->can('does_role');*{_getglob "${to}::does"}=$does unless$to->can('does');return if$to->can('DOES')and $to->can('DOES')!=(UNIVERSAL->can('DOES')|| 0);my$existing=$to->can('DOES')|| $to->can('isa')|| $FALLBACK;my$new_sub=sub {my ($proto,$role)=@_;$proto->$does($role)or $proto->$existing($role)};no warnings 'redefine';return *{_getglob "${to}::DOES"}=$new_sub}sub does_role {my ($proto,$role)=@_;require(_MRO_MODULE);for my$class (@{mro::get_linear_isa(ref($proto)||$proto)}){return 1 if exists$APPLIED_TO{$class}{$role}}return 0}sub is_role {my ($me,$role)=@_;return!!($INFO{$role}&& ($INFO{$role}{is_role}|| $INFO{$role}{not_methods}))}1;
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;use strict;use warnings;our$VERSION='2.000006';$VERSION=eval$VERSION;use Role::Tiny ();use Exporter 'import';our@EXPORT=qw(with);sub with {my$target=caller;Role::Tiny->apply_roles_to_package($target,@_)}1;
ROLE_TINY_WITH

$fatpacked{"Scope/Guard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SCOPE_GUARD';
  package Scope::Guard;use strict;use warnings;use Carp qw(confess);use Exporter ();our@ISA=qw(Exporter);our@EXPORT_OK=qw(guard scope_guard);our$VERSION='0.21';sub new {confess "Can't create a Scope::Guard in void context" unless (defined wantarray);my$class=shift;my$handler=shift()|| die 'Scope::Guard::new: no handler supplied';my$ref=ref$handler || '';die "Scope::Guard::new: invalid handler - expected CODE ref, got: '$ref'" unless ref($handler)eq 'CODE';bless [0,$handler ],ref$class || $class}sub dismiss {my$self=shift;my$dismiss=@_ ? shift : 1;$self->[0]=$dismiss}sub guard(&) {__PACKAGE__->new(shift)}sub scope_guard($) {__PACKAGE__->new(shift)}sub DESTROY {my$self=shift;my ($dismiss,$handler)=@$self;$handler->()unless ($dismiss)}1;
SCOPE_GUARD

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  package String::ShellQuote;use strict;use vars qw($VERSION @ISA @EXPORT);require Exporter;$VERSION='1.04';@ISA=qw(Exporter);@EXPORT=qw(shell_quote shell_quote_best_effort shell_comment_quote);sub croak {require Carp;goto&Carp::croak}sub _shell_quote_backend {my@in=@_;my@err=();if (0){require RS::Handy;print RS::Handy::data_dump(\@in)}return \@err,'' unless@in;my$ret='';my$saw_non_equal=0;for (@in){if (!defined $_ or $_ eq ''){$_="''";next}if (s/\x00//g){push@err,"No way to quote string containing null (\\000) bytes"}my$escape=0;if (/=/){if (!$saw_non_equal){$escape=1}}else {$saw_non_equal=1}if (m|[^\w!%+,\-./:=@^]|){$escape=1}if ($escape || (!$saw_non_equal && /=/)){s/'/'\\''/g;s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;$_="'$_'";s/^''//;s/''$//}}continue {$ret .= "$_ "}chop$ret;return \@err,$ret}sub shell_quote {my ($rerr,$s)=_shell_quote_backend @_;if (@$rerr){my%seen;@$rerr=grep {!$seen{$_}++}@$rerr;my$s=join '',map {"shell_quote(): $_\n"}@$rerr;chomp$s;croak$s}return$s}sub shell_quote_best_effort {my ($rerr,$s)=_shell_quote_backend @_;return$s}sub shell_comment_quote {return '' unless @_;unless (@_==1){croak "Too many arguments to shell_comment_quote " ."(got " .@_ ." expected 1)"}local $_=shift;s/\n/\n#/g;return $_}1;
STRING_SHELLQUOTE

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;use strict;use warnings;use Exporter qw(import);use Scalar::Util qw(weaken);use Carp qw(croak);our$VERSION='2.006003';$VERSION=eval$VERSION;our@EXPORT=qw(defer_sub undefer_sub undefer_all);our@EXPORT_OK=qw(undefer_package defer_info);sub _getglob {no strict 'refs';\*{$_[0]}}BEGIN {my$no_subname;*_subname =defined&Sub::Util::set_subname ? \&Sub::Util::set_subname : defined&Sub::Name::subname ? \&Sub::Name::subname : (eval {require Sub::Util}&& defined&Sub::Util::set_subname)? \&Sub::Util::set_subname : (eval {require Sub::Name}&& defined&Sub::Name::subname)? \&Sub::Name::subname : ($no_subname=1,sub {$_[1]});*_CAN_SUBNAME=$no_subname ? sub(){0}: sub(){1}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}our%DEFERRED;sub undefer_sub {my ($deferred)=@_;my$info=$DEFERRED{$deferred}or return$deferred;my ($target,$maker,$options,$undeferred_ref,$deferred_sub)=@$info;if (!($deferred_sub && $deferred eq $deferred_sub || ${$undeferred_ref}&& $deferred eq ${$undeferred_ref})){return$deferred}return ${$undeferred_ref}if ${$undeferred_ref};${$undeferred_ref}=my$made=$maker->();if (defined($target)&& $deferred eq *{_getglob($target)}{CODE}||''){no warnings 'redefine';*{_getglob($target)}=$made}my$undefer_info=[$target,$maker,$options,$undeferred_ref ];$info->[5]=$DEFERRED{$made}=$undefer_info;weaken ${$undefer_info->[3]};return$made}sub undefer_all {undefer_sub($_)for keys%DEFERRED;return}sub undefer_package {my$package=shift;undefer_sub($_)for grep {my$name=$DEFERRED{$_}&& $DEFERRED{$_}[0];$name && $name =~ /^${package}::[^:]+$/}keys%DEFERRED;return}sub defer_info {my ($deferred)=@_;my$info=$DEFERRED{$deferred||''}or return undef;my ($target,$maker,$options,$undeferred_ref,$deferred_sub)=@$info;if (!($deferred_sub && $deferred eq $deferred_sub || ${$undeferred_ref}&& $deferred eq ${$undeferred_ref})){delete$DEFERRED{$deferred};return undef}[$target,$maker,$options,($undeferred_ref && $$undeferred_ref ? $$undeferred_ref : ()),]}sub defer_sub {my ($target,$maker,$options)=@_;my$package;my$subname;($package,$subname)=$target =~ /^(.*)::([^:]+)$/ or croak "$target is not a fully qualified sub name!" if$target;$package ||= $options && $options->{package}|| caller;my@attributes=@{$options && $options->{attributes}|| []};if (@attributes){/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_" for@attributes}my$deferred;my$undeferred;my$deferred_info=[$target,$maker,$options,\$undeferred ];if (@attributes || $target &&!_CAN_SUBNAME){my$code =q[#line ].(__LINE__+2).q[ "].__FILE__.qq["\n] .qq[package $package;\n] .($target ? "sub $subname" : '+sub').join('',map " :$_",@attributes).q[ {
          package Sub::Defer;
          # uncoverable subroutine
          # uncoverable statement
          $undeferred ||= undefer_sub($deferred_info->[4]);
          goto &$undeferred; # uncoverable statement
          $undeferred; # fake lvalue return
        }]."\n" .($target ? "\\&$subname" : '');my$e;$deferred=do {no warnings qw(redefine closure);local $@;eval$code or $e=$@};die$e if defined$e}else {$deferred=sub {$undeferred ||= undefer_sub($deferred_info->[4]);goto &$undeferred};_install_coderef($target,$deferred)if$target}weaken($deferred_info->[4]=$deferred);weaken($DEFERRED{$deferred}=$deferred_info);return$deferred}sub CLONE {%DEFERRED=map {defined $_ ? ($_->[4]? ($_->[4]=>$_): ($_->[3]&& ${$_->[3]})? (${$_->[3]}=>$_): ()): ()}values%DEFERRED}1;
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;$Sub::Exporter::Progressive::VERSION='0.001013';use strict;use warnings;sub _croak {require Carp;&Carp::croak}sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';no warnings 'once';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (grep {length ref $_ or $_ !~ / \A [:-]? \w+ \z /xm}@args){_croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined((my ($num)=grep {m/^\d/}@args)[0])){_croak "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if (($setup||'')eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){_croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};_croak$too_complicated if grep {length ref $_}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){_croak$too_complicated if grep {length ref $_ or $_ =~ / \A - (?! all \b ) /x}@{$tagset}}@defaults=@{$tags{default}|| []}}else {_croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||= [@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;_croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Info.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INFO';
  package Sub::Info;use strict;use warnings;our$VERSION='0.002';use Carp qw/croak/;use B();use Importer Importer=>'import';our@EXPORT_OK=qw{sub_info};sub sub_info {my ($sub,@all_lines)=@_;my%in=map {$_=>1}@all_lines;croak "sub_info requires a coderef as its first argument" unless ref($sub)eq 'CODE';my$cobj=B::svref_2object($sub);my$name=$cobj->GV->NAME;my$file=$cobj->FILE;my$package=$cobj->GV->STASH->NAME;my$op=$cobj->START;while ($op){push@all_lines=>$op->line if$op->can('line');last unless$op->can('next');$op=$op->next}my ($start,$end,@lines);if (@all_lines){@all_lines=sort {$a <=> $b}@all_lines;($start,$end)=($all_lines[0],$all_lines[-1]);if ($start < $end){$start-- unless$start <= 1 || $in{$start};$end++ unless$in{$end}}@lines=($start,$end)}return {ref=>$sub,cobj=>$cobj,name=>$name,file=>$file,package=>$package,start_line=>$start,end_line=>$end,all_lines=>\@all_lines,lines=>\@lines,}}1;
SUB_INFO

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;sub _clean_eval {eval $_[0]}use strict;use warnings;use Sub::Defer qw(defer_sub);use Scalar::Util qw(weaken);use Exporter qw(import);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Sub::Defer)}use B ();BEGIN {*_HAVE_IS_UTF8=defined&utf8::is_utf8 ? sub(){1}: sub(){0};*_HAVE_PERLSTRING=defined&B::perlstring ? sub(){1}: sub(){0};*_BAD_BACKSLASH_ESCAPE=_HAVE_PERLSTRING()&& "$]"==5.010_000 ? sub(){1}: sub(){0}}our$VERSION='2.006003';$VERSION=eval$VERSION;our@EXPORT=qw(quote_sub unquote_sub quoted_from_sub qsub);our@EXPORT_OK=qw(quotify capture_unroll inlinify sanitize_identifier);our%QUOTED;my%escape;if (_BAD_BACKSLASH_ESCAPE){%escape=((map +(chr($_)=>sprintf '\x%02x',$_),0 .. 0x31,0x7f),"\t"=>"\\t","\n"=>"\\n","\r"=>"\\r","\f"=>"\\f","\b"=>"\\b","\a"=>"\\a","\e"=>"\\e",(map +($_=>"\\$_"),qw(" \ $ @)),)}sub quotify {my$value=$_[0];no warnings 'numeric';!defined$value ? 'undef()' : (!(_HAVE_IS_UTF8 && utf8::is_utf8($value))&& length((my$dummy='')& $value)&& 0 + $value eq $value)? ($value!=$value ? ($value eq -CORE::sin(9**9**9)? '(-CORE::sin(9**9**9))' : 'CORE::sin(9**9**9)'): $value==9**9**9 ? '(9**9**9)' : $value==-9**9**9 ? '(-9**9**9)' : int($value)==$value ? $value : do {my$float=sprintf('%.20f',$value);$float =~ s/(\.[0-9]+?)0+\z/$1/;$float}):!length($value)&& eval {use warnings 'FATAL'=>'numeric';$value==0}? '(!1)' : _BAD_BACKSLASH_ESCAPE && _HAVE_IS_UTF8 && utf8::is_utf8($value)? do {$value =~ s/(["\$\@\\[:cntrl:]]|[^\x00-\x7f])/
        $escape{$1} || sprintf('\x{%x}', ord($1))
      /ge;qq["$value"]}: _HAVE_PERLSTRING ? B::perlstring($value): qq["\Q$value\E"]}sub sanitize_identifier {my$name=shift;$name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;$name}sub capture_unroll {my ($from,$captures,$indent)=@_;join('',map {/^([\@\%\$])/ or croak "capture key should start with \@, \% or \$: $_";(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n}}keys %$captures)}sub inlinify {my ($code,$args,$extra,$local)=@_;$args='()' if!defined$args;my$do='do { '.($extra||'');if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//){$do .= $1}if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms){my ($pre,$indent,$code_args)=($1,$2,$3);$do .= $pre;if ($code_args ne $args){$do .= $indent .'my ('.$code_args.') = ('.$args.'); '}}elsif ($local || $args ne '@_'){$do .= ($local ? 'local ' : '').'@_ = ('.$args.'); '}$do.$code.' }'}sub quote_sub {my$options=(ref($_[-1])eq 'HASH' and ref($_[-2])eq 'HASH')? pop : {};my$captures=ref($_[-1])eq 'HASH' ? pop : undef;undef($captures)if$captures &&!keys %$captures;my$code=pop;my$name=$_[0];if ($name){my$subname=$name;my$package=$subname =~ s/(.*)::// ? $1 : caller;$name=join '::',$package,$subname;croak qq{package name "$package" too long!} if length$package > 252;croak qq{package name "$package" is not valid!} unless$package =~ /^[^\d\W]\w*(?:::\w+)*$/;croak qq{sub name "$subname" too long!} if length$subname > 252;croak qq{sub name "$subname" is not valid!} unless$subname =~ /^[^\d\W]\w*$/}my@caller=caller(0);my ($attributes,$file,$line)=@{$options}{qw(attributes file line)};if ($attributes){/\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_" for @$attributes}my$quoted_info={name=>$name,code=>$code,captures=>$captures,package=>(exists$options->{package}? $options->{package}: $caller[0]),hints=>(exists$options->{hints}? $options->{hints}: $caller[8]),warning_bits=>(exists$options->{warning_bits}? $options->{warning_bits}: $caller[9]),hintshash=>(exists$options->{hintshash}? $options->{hintshash}: $caller[10]),($attributes ? (attributes=>$attributes): ()),($file ? (file=>$file): ()),($line ? (line=>$line): ()),};my$unquoted;weaken($quoted_info->{unquoted}=\$unquoted);if ($options->{no_defer}){my$fake=\my$var;local$QUOTED{$fake}=$quoted_info;my$sub=unquote_sub($fake);Sub::Defer::_install_coderef($name,$sub)if$name &&!$options->{no_install};return$sub}else {my$deferred=defer_sub(($options->{no_install}? undef : $name),sub {$unquoted if 0;unquote_sub($quoted_info->{deferred})},{($attributes ? (attributes=>$attributes): ()),($name ? (): (package=>$quoted_info->{package})),},);weaken($quoted_info->{deferred}=$deferred);weaken($QUOTED{$deferred}=$quoted_info);return$deferred}}sub _context {my$info=shift;$info->{context}||= do {my ($package,$hints,$warning_bits,$hintshash,$file,$line)=@{$info}{qw(package hints warning_bits hintshash file line)};$line ||= 1 if$file;my$line_mark='';if ($line){$line_mark="#line ".($line-1);if ($file){$line_mark .= qq{ "$file"}}$line_mark .= "\n"}$info->{context}="# BEGIN quote_sub PRELUDE\n" ."package $package;\n" ."BEGIN {\n" ."  \$^H = ".quotify($hints).";\n" ."  \${^WARNING_BITS} = ".quotify($warning_bits).";\n" ."  \%^H = (\n" .join('',map "    ".quotify($_)." => ".quotify($hintshash->{$_}).",\n",keys %$hintshash)."  );\n" ."}\n" .$line_mark ."# END quote_sub PRELUDE\n"}}sub quoted_from_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub||''}or return undef;my ($name,$code,$captures,$unquoted,$deferred)=@{$quoted_info}{qw(name code captures unquoted deferred)};$code=_context($quoted_info).$code;$unquoted &&= $$unquoted;if (($deferred && $deferred eq $sub)|| ($unquoted && $unquoted eq $sub)){return [$name,$code,$captures,$unquoted,$deferred ]}return undef}sub unquote_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub}or return undef;my$unquoted=$quoted_info->{unquoted};unless ($unquoted && $$unquoted){my ($name,$code,$captures,$package,$attributes)=@{$quoted_info}{qw(name code captures package attributes)};($package,$name)=$name =~ /(.*)::(.*)/ if$name;my%captures=$captures ? %$captures : ();$captures{'$_UNQUOTED'}=\$unquoted;$captures{'$_QUOTED'}=\$quoted_info;my$make_sub ="{\n" .capture_unroll("\$_[1]",\%captures,2)."  package ${package};\n" .($name ? "  no warnings 'closure';\n  sub ${name} " : "  \$\$_UNQUOTED = sub ").($attributes ? join('',map ":$_ ",@$attributes): '')."{\n" ."  (\$_QUOTED,\$_UNQUOTED) if 0;\n" ._context($quoted_info).$code ."  }".($name ? "\n  \$\$_UNQUOTED = \\&${name}" : '').";\n" ."}\n" ."1;\n";if (my$debug=$ENV{SUB_QUOTE_DEBUG}){if ($debug =~ m{^([^\W\d]\w*(?:::\w+)*(?:::)?)$}){my$filter=$1;my$match =$filter =~ /::$/ ? $package.'::' : $filter =~ /::/ ? $package.'::'.($name||'__ANON__'): ($name||'__ANON__');warn$make_sub if$match eq $filter}elsif ($debug =~ m{\A/(.*)/\z}s){my$filter=$1;warn$make_sub if$code =~ $filter}else {warn$make_sub}}{no strict 'refs';local *{"${package}::${name}"}if$name;my ($success,$e);{local $@;$success=_clean_eval($make_sub,\%captures);$e=$@}unless ($success){my$space=length($make_sub =~ tr/\n//);my$line=0;$make_sub =~ s/^/sprintf "%${space}d: ", ++$line/emg;croak "Eval went very, very wrong:\n\n${make_sub}\n\n$e"}weaken($QUOTED{$$unquoted}=$quoted_info)}}$$unquoted}sub qsub ($) {goto&quote_sub}sub CLONE {my@quoted=map {defined $_ ? ($_->{unquoted}&& ${$_->{unquoted}}? (${$_->{unquoted}}=>$_): (),$_->{deferred}? ($_->{deferred}=>$_): (),): ()}values%QUOTED;%QUOTED=@quoted;weaken($_)for values%QUOTED}1;
SUB_QUOTE

$fatpacked{"Term/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE';
  package Term::Table;use strict;use warnings;our$VERSION='0.013';use Term::Table::Cell();use Term::Table::Util qw/term_size uni_length USE_GCS/;use Scalar::Util qw/blessed/;use List::Util qw/max sum/;use Carp qw/croak carp/;use Term::Table::HashBase qw/rows _columns collapse max_width mark_tail sanitize show_header auto_columns no_collapse header allow_overflow pad/;sub BORDER_SIZE() {4}sub DIV_SIZE() {3}sub CELL_PAD_SIZE() {2}sub init {my$self=shift;croak "You cannot have a table with no rows" unless$self->{+ROWS}&& @{$self->{+ROWS}};$self->{+MAX_WIDTH}||= term_size();$self->{+NO_COLLAPSE}||= {};if (ref($self->{+NO_COLLAPSE})eq 'ARRAY'){$self->{+NO_COLLAPSE}={map {($_=>1)}@{$self->{+NO_COLLAPSE}}}}if ($self->{+NO_COLLAPSE}&& $self->{+HEADER}){my$header=$self->{+HEADER};for(my$idx=0;$idx < @$header;$idx++){$self->{+NO_COLLAPSE}->{$idx}||= $self->{+NO_COLLAPSE}->{$header->[$idx]}}}$self->{+PAD}=4 unless defined$self->{+PAD};$self->{+COLLAPSE}=1 unless defined$self->{+COLLAPSE};$self->{+SANITIZE}=1 unless defined$self->{+SANITIZE};$self->{+MARK_TAIL}=1 unless defined$self->{+MARK_TAIL};if($self->{+HEADER}){$self->{+SHOW_HEADER}=1 unless defined$self->{+SHOW_HEADER}}else {$self->{+HEADER}=[];$self->{+AUTO_COLUMNS}=1;$self->{+SHOW_HEADER}=0}}sub columns {my$self=shift;$self->regen_columns unless$self->{+_COLUMNS};return$self->{+_COLUMNS}}sub regen_columns {my$self=shift;my$has_header=$self->{+SHOW_HEADER}&& @{$self->{+HEADER}};my%new_col=(width=>0,count=>$has_header ? -1 : 0);my$cols=[map {{%new_col}}@{$self->{+HEADER}}];my@rows=@{$self->{+ROWS}};for my$row ($has_header ? ($self->{+HEADER},@rows): (@rows)){for my$ci (0 .. max(@$cols - 1,@$row - 1)){$cols->[$ci]||= {%new_col}if$self->{+AUTO_COLUMNS};my$c=$cols->[$ci]or next;$c->{idx}||= $ci;$c->{rows}||= [];my$r=$row->[$ci];$r=Term::Table::Cell->new(value=>$r)unless blessed($r)&& ($r->isa('Term::Table::Cell')|| $r->isa('Term::Table::CellStack')|| $r->isa('Term::Table::Spacer'));$r->sanitize if$self->{+SANITIZE};$r->mark_tail if$self->{+MARK_TAIL};my$rs=$r->width;$c->{width}=$rs if$rs > $c->{width};$c->{count}++ if$rs;push @{$c->{rows}}=>$r}}@$cols=grep {$_->{count}> 0 || $self->{+NO_COLLAPSE}->{$_->{idx}}}@$cols if$self->{+COLLAPSE};my$current=sum(map {$_->{width}}@$cols);my$border=sum(BORDER_SIZE,$self->{+PAD},DIV_SIZE * (@$cols - 1));my$total=$current + $border;if ($total > $self->{+MAX_WIDTH}){my$fair=($self->{+MAX_WIDTH}- $border)/ @$cols;if ($fair < 1){return$self->{+_COLUMNS}=$cols if$self->{+ALLOW_OVERFLOW};croak "Table is too large ($total including $self->{+PAD} padding) to fit into max-width ($self->{+MAX_WIDTH})"}my$under=0;my@fix;for my$c (@$cols){if ($c->{width}> $fair){push@fix=>$c}else {$under += $c->{width}}}$fair=int(($self->{+MAX_WIDTH}- $border - $under)/ @fix);if ($fair < 1){return$self->{+_COLUMNS}=$cols if$self->{+ALLOW_OVERFLOW};croak "Table is too large ($total including $self->{+PAD} padding) to fit into max-width ($self->{+MAX_WIDTH})"}$_->{width}=$fair for@fix}$self->{+_COLUMNS}=$cols}sub render {my$self=shift;my$cols=$self->columns;for my$col (@$cols){for my$cell (@{$col->{rows}}){$cell->reset}}my$width=sum(BORDER_SIZE,$self->{+PAD},DIV_SIZE * @$cols,map {$_->{width}}@$cols);my$border='+' .join('+',map {'-' x ($_->{width}+ CELL_PAD_SIZE)}@$cols).'+';my$template='|' .join('|',map {my$w=$_->{width}+ CELL_PAD_SIZE;'%s'}@$cols).'|';my$spacer='|' .join('|',map {' ' x ($_->{width}+ CELL_PAD_SIZE)}@$cols).'|';my@out=($border);my ($row,$split,$found)=(0,0,0);while(1){my@row;my$is_spacer=0;for my$col (@$cols){my$r=$col->{rows}->[$row];unless($r){push@row=>'';next}my ($v,$vw);if ($r->isa('Term::Table::Cell')){my$lw=$r->border_left_width;my$rw=$r->border_right_width;$vw=$col->{width}- $lw - $rw;$v=$r->break->next($vw)}elsif ($r->isa('Term::Table::CellStack')){($v,$vw)=$r->break->next($col->{width})}elsif ($r->isa('Term::Table::Spacer')){$is_spacer=1}if ($is_spacer){last}elsif (defined$v){$found++;my$bcolor=$r->border_color || '';my$vcolor=$r->value_color || '';my$reset=$r->reset_color || '';if (my$need=$vw - uni_length($v)){$v .= ' ' x $need}my$rt="${reset}${bcolor}\%s${reset} ${vcolor}\%s${reset} ${bcolor}\%s${reset}";push@row=>sprintf($rt,$r->border_left || '',$v,$r->border_right || '')}else {push@row=>' ' x ($col->{width}+ 2)}}if (!grep {$_ && m/\S/}@row){last unless$found || $is_spacer;push@out=>$border if$row==0 && $self->{+SHOW_HEADER}&& @{$self->{+HEADER}};push@out=>$spacer if$split > 1 || $is_spacer;$row++;$split=0;$found=0;next}if ($split==1 && @out > 1 && $out[-2]ne $border && $out[-2]ne $spacer){my$last=pop@out;push@out=>($spacer,$last)}push@out=>sprintf($template,@row);$split++}pop@out while@out && $out[-1]eq $spacer;unless (USE_GCS){for my$row (@out){next unless$row =~ m/[^\x00-\x7F]/;unshift@out=>"Unicode::GCString is not installed, table may not display all unicode characters properly";last}}return (@out,$border)}sub display {my$self=shift;my ($fh)=@_;my@parts=map "$_\n",$self->render;print$fh @parts if$fh;print@parts}1;
TERM_TABLE

$fatpacked{"Term/Table/Cell.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_CELL';
  package Term::Table::Cell;use strict;use warnings;our$VERSION='0.013';use Term::Table::LineBreak();use Term::Table::Util qw/uni_length/;use List::Util qw/sum/;use Term::Table::HashBase qw/value border_left border_right _break _widths border_color value_color reset_color/;my%CHAR_MAP=("\n"=>"\\n\n","\a"=>'\\a',"\b"=>'\\b',"\e"=>'\\e',"\f"=>'\\f',"\r"=>'\\r',"\t"=>'\\t'," "=>' ',);sub init {my$self=shift;$self->{+VALUE}=defined$self->{+VALUE}? "$self->{+VALUE}" : ''}sub char_id {my$class=shift;my ($char)=@_;return "\\N{U+" .sprintf("\%X",ord($char))."}"}sub show_char {my$class=shift;my ($char,%props)=@_;return$char if$props{no_newline}&& $char eq "\n";return$CHAR_MAP{$char}|| $class->char_id($char)}sub sanitize {my$self=shift;$self->{+VALUE}=~ s/([\s\t\p{Zl}\p{C}\p{Zp}])/$self->show_char($1)/ge}sub mark_tail {my$self=shift;$self->{+VALUE}=~ s/([\s\t\p{Zl}\p{C}\p{Zp}])$/$1 eq ' ' ? $self->char_id($1) : $self->show_char($1, no_newline => 1)/se}sub value_width {my$self=shift;my$w=$self->{+_WIDTHS}||= {};return$w->{value}if defined$w->{value};my@parts=split /(\n)/,$self->{+VALUE};my$max=0;while (@parts){my$text=shift@parts;my$sep=shift@parts || '';my$len=uni_length("$text");$max=$len if$len > $max}return$w->{value}=$max}sub border_left_width {my$self=shift;$self->{+_WIDTHS}->{left}||= uni_length($self->{+BORDER_LEFT}|| '')}sub border_right_width {my$self=shift;$self->{+_WIDTHS}->{right}||= uni_length($self->{+BORDER_RIGHT}|| '')}sub width {my$self=shift;$self->{+_WIDTHS}->{all}||= sum(map {$self->$_}qw/value_width border_left_width border_right_width/)}sub break {my$self=shift;$self->{+_BREAK}||= Term::Table::LineBreak->new(string=>$self->{+VALUE})}sub reset {my$self=shift;delete$self->{+_BREAK}}1;
TERM_TABLE_CELL

$fatpacked{"Term/Table/CellStack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_CELLSTACK';
  package Term::Table::CellStack;use strict;use warnings;our$VERSION='0.013';use Term::Table::HashBase qw/-cells -idx/;use List::Util qw/max/;sub init {my$self=shift;$self->{+CELLS}||= []}sub add_cell {my$self=shift;push @{$self->{+CELLS}}=>@_}sub add_cells {my$self=shift;push @{$self->{+CELLS}}=>@_}sub sanitize {my$self=shift;$_->sanitize(@_)for @{$self->{+CELLS}}}sub mark_tail {my$self=shift;$_->mark_tail(@_)for @{$self->{+CELLS}}}my@proxy=qw{border_left border_right border_color value_color reset_color border_left_width border_right_width};for my$meth (@proxy){no strict 'refs';*$meth=sub {my$self=shift;$self->{+CELLS}->[$self->{+IDX}]->$meth}}for my$meth (qw{value_width width}){no strict 'refs';*$meth=sub {my$self=shift;return max(map {$_->$meth}@{$self->{+CELLS}})}}sub next {my$self=shift;my ($cw)=@_;while ($self->{+IDX}< @{$self->{+CELLS}}){my$cell=$self->{+CELLS}->[$self->{+IDX}];my$lw=$cell->border_left_width;my$rw=$cell->border_right_width;my$vw=$cw - $lw - $rw;my$it=$cell->break->next($vw);return ($it,$vw)if$it;$self->{+IDX}++}return}sub break {$_[0]}sub reset {my$self=shift;$self->{+IDX}=0;$_->reset for @{$self->{+CELLS}}}1;
TERM_TABLE_CELLSTACK

$fatpacked{"Term/Table/HashBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_HASHBASE';
  package Term::Table::HashBase;use strict;use warnings;{no warnings 'once';$Term::Table::HashBase::VERSION='0.003';*Term::Table::HashBase::ATTR_SUBS=\%Object::HashBase::ATTR_SUBS}require Carp;{no warnings 'once';$Carp::Internal{+__PACKAGE__}=1}BEGIN {*_isa=($] >= 5.010 && require mro)? \&mro::get_linear_isa : sub {no strict 'refs';my@packages=($_[0]);my%seen;for my$package (@packages){push@packages,grep!$seen{$_}++,@{"$package\::ISA"}}return \@packages}}my%STRIP=('^'=>1,'-'=>1,);sub import {my$class=shift;my$into=caller;my$isa=_isa($into);my$attr_subs=$Term::Table::HashBase::ATTR_SUBS{$into}||= {};my%subs=(($into->can('new')? (): (new=>\&_new)),(map %{$Term::Table::HashBase::ATTR_SUBS{$_}|| {}},@{$isa}[1 .. $#$isa]),(map {my$p=substr($_,0,1);my$x=$_;substr($x,0,1)='' if$STRIP{$p};my ($sub,$attr)=(uc$x,$x);$sub=>($attr_subs->{$sub}=sub() {$attr}),$attr=>sub {$_[0]->{$attr}},$p eq '-' ? ("set_$attr"=>sub {Carp::croak("'$attr' is read-only")}): $p eq '^' ? ("set_$attr"=>sub {Carp::carp("set_$attr() is deprecated");$_[0]->{$attr}=$_[1]}): ("set_$attr"=>sub {$_[0]->{$attr}=$_[1]}),}@_),);no strict 'refs';*{"$into\::$_"}=$subs{$_}for keys%subs}sub _new {my ($class,%params)=@_;my$self=bless \%params,$class;$self->init if$self->can('init');$self}1;
TERM_TABLE_HASHBASE

$fatpacked{"Term/Table/LineBreak.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_LINEBREAK';
  package Term::Table::LineBreak;use strict;use warnings;our$VERSION='0.013';use Carp qw/croak/;use Scalar::Util qw/blessed/;use Term::Table::Util qw/uni_length/;use Term::Table::HashBase qw/string gcstring _len _parts idx/;sub init {my$self=shift;croak "string is a required attribute" unless defined$self->{+STRING}}sub columns {uni_length($_[0]->{+STRING})}sub break {my$self=shift;my ($len)=@_;$self->{+_LEN}=$len;$self->{+IDX}=0;my$str=$self->{+STRING}."";my@parts;my@chars=split //,$str;while (@chars){my$size=0;my$part='';until ($size==$len){my$char=shift@chars;$char='' unless defined$char;my$l=uni_length("$char");last unless$l;last if$char eq "\n";if ($size + $l > $len){unshift@chars=>$char;last}$size += $l;$part .= $char}shift@chars if$size==$len && @chars && $chars[0]eq "\n";until ($size==$len){$part .= ' ';$size += 1}push@parts=>$part}$self->{+_PARTS}=\@parts}sub next {my$self=shift;if (@_){my ($len)=@_;$self->break($len)if!$self->{+_LEN}|| $self->{+_LEN}!=$len}else {croak "String has not yet been broken" unless$self->{+_PARTS}}my$idx=$self->{+IDX}++;my$parts=$self->{+_PARTS};return undef if$idx >= @$parts;return$parts->[$idx]}1;
TERM_TABLE_LINEBREAK

$fatpacked{"Term/Table/Spacer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_SPACER';
  package Term::Table::Spacer;use strict;use warnings;our$VERSION='0.013';sub new {bless {},$_[0]}sub width {1}sub sanitize {}sub mark_tail {}sub reset {}1;
TERM_TABLE_SPACER

$fatpacked{"Term/Table/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_UTIL';
  package Term::Table::Util;use strict;use warnings;use Config qw/%Config/;our$VERSION='0.013';use Importer Importer=>'import';our@EXPORT_OK=qw/term_size USE_GCS USE_TERM_READKEY USE_TERM_SIZE_ANY uni_length/;sub DEFAULT_SIZE() {80}sub try(&) {my$code=shift;local ($@,$?,$!);my$ok=eval {$code->();1};my$err=$@;return ($ok,$err)}my ($tsa)=try {require Term::Size::Any;Term::Size::Any->import('chars')};my ($trk)=try {require Term::ReadKey};$trk &&= Term::ReadKey->can('GetTerminalSize');if (!-t *STDOUT){*USE_TERM_READKEY=sub() {0};*USE_TERM_SIZE_ANY=sub() {0};*term_size=sub {return$ENV{TABLE_TERM_SIZE}if$ENV{TABLE_TERM_SIZE};return DEFAULT_SIZE}}elsif ($tsa){*USE_TERM_READKEY=sub() {0};*USE_TERM_SIZE_ANY=sub() {1};*_term_size=sub {my$size=chars(\*STDOUT);return DEFAULT_SIZE if!$size;return DEFAULT_SIZE if$size < DEFAULT_SIZE;return$size}}elsif ($trk){*USE_TERM_READKEY=sub() {1};*USE_TERM_SIZE_ANY=sub() {0};*_term_size=sub {my$total;try {my@warnings;{local$SIG{__WARN__}=sub {push@warnings=>@_};($total)=Term::ReadKey::GetTerminalSize(*STDOUT)}@warnings=grep {$_ !~ m/Unable to get Terminal Size/}@warnings;warn@warnings if@warnings};return DEFAULT_SIZE if!$total;return DEFAULT_SIZE if$total < DEFAULT_SIZE;return$total}}else {*USE_TERM_READKEY=sub() {0};*USE_TERM_SIZE_ANY=sub() {0};*term_size=sub {return$ENV{TABLE_TERM_SIZE}if$ENV{TABLE_TERM_SIZE};return DEFAULT_SIZE}}if (USE_TERM_READKEY()|| USE_TERM_SIZE_ANY()){if (index($Config{sig_name},'WINCH')>= 0){my$changed=0;my$polled=-1;$SIG{WINCH}=sub {$changed++};my$size;*term_size=sub {return$ENV{TABLE_TERM_SIZE}if$ENV{TABLE_TERM_SIZE};unless ($changed==$polled){$polled=$changed;$size=_term_size()}return$size}}else {*term_size=sub {return$ENV{TABLE_TERM_SIZE}if$ENV{TABLE_TERM_SIZE};_term_size()}}}my ($gcs,$err)=try {require Unicode::GCString};if ($gcs){*USE_GCS=sub() {1};*uni_length=sub {Unicode::GCString->new($_[0])->columns}}else {*USE_GCS=sub() {0};*uni_length=sub {length($_[0])}}1;
TERM_TABLE_UTIL

$fatpacked{"Test/CPAN/Changes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_CPAN_CHANGES';
  package Test::CPAN::Changes;use strict;use warnings;use CPAN::Changes;use Test::Builder;use version ();our$VERSION='0.400002';my$Test=Test::Builder->new;sub import {my$self=shift;my$caller=caller;no strict 'refs';*{$caller .'::changes_ok'}=\&changes_ok;*{$caller .'::changes_file_ok'}=\&changes_file_ok;$Test->exported_to($caller);$Test->plan(@_)}sub changes_ok {$Test->plan(tests=>4);return changes_file_ok(undef,@_)}sub changes_file_ok {my ($file,$arg)=@_;$file ||= 'Changes';$arg ||= {};my$changes=eval {CPAN::Changes->load($file)};if ($@){$Test->ok(0,"Unable to parse $file");$Test->diag("  ERR: $@");return}$Test->ok(1,"$file is loadable");my@releases=$changes->releases;if (!@releases){$Test->ok(0,"$file does not contain any releases");return}$Test->ok(1,"$file contains at least one release");for (@releases){if (!defined $_->date || $_->date eq ''){$Test->ok(0,"$file contains an invalid release date");$Test->diag('  ERR: No date at version ' .$_->version);return}my$d=$_->{_parsed_date };if ($d !~ m[^${CPAN::Changes::W3CDTF_REGEX}$] && $d !~ m[^(${CPAN::Changes::UNKNOWN_VALS})$]){$Test->carp('Date "' .$d .'" is not in the recommended format')}(my$version=$_->version)=~ s/-TRIAL$//;if (not version::is_lax($version)){$Test->ok(0,"$file contains an invalid version number");$Test->diag('  ERR: ' .$_->version);return}}$Test->ok(1,"$file contains valid release dates");$Test->ok(1,"$file contains valid version numbers");if (defined$arg->{version}){my$v=$arg->{version};if (my$release=$changes->release($v)){$Test->ok(1,"$file has an entry for the current version, $v");my$changes=$release->changes;if ($changes and grep {@$_ > 0}values %$changes){$Test->ok(1,"entry for the current version, $v, has content")}else {$Test->ok(0,"entry for the current version, $v, no content")}}else {$Test->ok(0,"$file has no entry for the current version, $v");$Test->ok(0,"$file has no entry for the current version, $v")}}return$changes}1;
TEST_CPAN_CHANGES

$fatpacked{"Test2/AsyncSubtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST';
  package Test2::AsyncSubtest;use strict;use warnings;use Test2::IPC;our$VERSION='0.000122';our@CARP_NOT=qw/Test2::Util::HashBase/;use Carp qw/croak cluck confess/;use Test2::Util qw/get_tid CAN_THREAD CAN_FORK/;use Scalar::Util qw/blessed weaken/;use List::Util qw/first/;use Scope::Guard();use Test2::API();use Test2::API::Context();use Test2::Util::Trace();use Time::HiRes();use Test2::AsyncSubtest::Hub();use Test2::AsyncSubtest::Event::Attach();use Test2::AsyncSubtest::Event::Detach();use Test2::Util::HashBase qw{name hub trace frame send_to events finished active stack id cid uuid children _in_use _attached pid tid};sub CAN_REALLY_THREAD {return 0 unless CAN_THREAD;return 0 unless eval {require threads;threads->VERSION('1.34');1};return 1}my$UUID_VIA=Test2::API::_add_uuid_via_ref();my$CID=1;my@STACK;sub TOP {@STACK ? $STACK[-1]: undef}sub init {my$self=shift;croak "'name' is a required attribute" unless$self->{+NAME};my$to=$self->{+SEND_TO}||= Test2::API::test2_stack()->top;$self->{+STACK}=[@STACK];$_->{+_IN_USE}++ for reverse@STACK;$self->{+TID}=get_tid;$self->{+PID}=$$;$self->{+CID}='AsyncSubtest-' .$CID++;$self->{+ID}=1;$self->{+FINISHED}=0;$self->{+ACTIVE}=0;$self->{+_IN_USE}=0;$self->{+CHILDREN}=[];$self->{+UUID}=${$UUID_VIA}->()if defined $$UUID_VIA;unless($self->{+HUB}){my$ipc=Test2::API::test2_ipc();my$formatter=Test2::API::test2_stack->top->format;my$args=delete$self->{hub_init_args}|| {};my$hub=Test2::AsyncSubtest::Hub->new(%$args,ipc=>$ipc,nested=>$to->nested + 1,buffered=>1,formatter=>$formatter,);weaken($hub->{ast}=$self);$self->{+HUB}=$hub}$self->{+TRACE}||= Test2::Util::Trace->new(frame=>$self->{+FRAME}|| [caller(1)],buffered=>$to->buffered,nested=>$to->nested,cid=>$self->{+CID},uuid=>$self->{+UUID},hid=>$to->hid,huuid=>$to->uuid,);my$hub=$self->{+HUB};$hub->set_ast_ids({})unless$hub->ast_ids;$hub->listen($self->_listener)}sub _listener {my$self=shift;my$events=$self->{+EVENTS}||= [];sub {push @$events=>$_[1]}}sub context {my$self=shift;my$send_to=$self->{+SEND_TO};confess "Attempt to close AsyncSubtest when original parent hub (a non async-subtest?) has ended" if$send_to->ended;return Test2::API::Context->new(trace=>$self->{+TRACE},hub=>$send_to,)}sub _gen_event {my$self=shift;my ($type,$id,$hub)=@_;my$class="Test2::AsyncSubtest::Event::$type";return$class->new(id=>$id,trace=>Test2::Util::Trace->new(frame=>[caller(1)],buffered=>$hub->buffered,nested=>$hub->nested,cid=>$self->{+CID},uuid=>$self->{+UUID},hid=>$hub->hid,huuid=>$hub->uuid,),)}sub cleave {my$self=shift;my$id=$self->{+ID}++;$self->{+HUB}->ast_ids->{$id}=0;return$id}sub attach {my$self=shift;my ($id)=@_;croak "An ID is required" unless$id;croak "ID $id is not valid" unless defined$self->{+HUB}->ast_ids->{$id};croak "ID $id is already attached" if$self->{+HUB}->ast_ids->{$id};croak "You must attach INSIDE the child process/thread" if$self->{+HUB}->is_local;$self->{+_ATTACHED}=[$$,get_tid,$id ];$self->{+HUB}->send($self->_gen_event('Attach',$id,$self->{+HUB}))}sub detach {my$self=shift;if ($self->{+PID}==$$ && $self->{+TID}==get_tid){cluck "You must detach INSIDE the child process/thread ($$, " .get_tid ." instead of $self->{+PID}, $self->{+TID})";return}my$att=$self->{+_ATTACHED}or croak "Not attached";croak "Attempt to detach from wrong child" unless$att->[0]==$$ && $att->[1]==get_tid;my$id=$att->[2];$self->{+HUB}->send($self->_gen_event('Detach',$id,$self->{+HUB}));delete$self->{+_ATTACHED}}sub ready {return!shift->pending}sub pending {my$self=shift;my$hub=$self->{+HUB};return -1 unless$hub->is_local;$hub->cull;return$self->{+_IN_USE}+ keys %{$self->{+HUB}->ast_ids}}sub run {my$self=shift;my ($code,@args)=@_;croak "AsyncSubtest->run() takes a codeblock as the first argument" unless$code && ref($code)eq 'CODE';$self->start;my ($ok,$err,$finished);T2_SUBTEST_WRAPPER: {$ok=eval {$code->(@args);1};$err=$@;if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/){$ok=undef;$err=undef}else {$finished=1}}$self->stop;my$hub=$self->{+HUB};if (!$finished){if(my$bailed=$hub->bailed_out){my$ctx=$self->context;$ctx->bail($bailed->reason);return}my$code=$hub->exit_code;$ok=!$code;$err="Subtest ended with exit code $code" if$code}unless ($ok){my$e=Test2::Event::Exception->new(error=>$err,trace=>Test2::Util::Trace->new(frame=>[caller(0)],buffered=>$hub->buffered,nested=>$hub->nested,cid=>$self->{+CID},uuid=>$self->{+UUID},hid=>$hub->hid,huuid=>$hub->uuid,),);$hub->send($e)}return$hub->is_passing}sub start {my$self=shift;croak "Subtest is already complete" if$self->{+FINISHED};$self->{+ACTIVE}++;push@STACK=>$self;my$hub=$self->{+HUB};my$stack=Test2::API::test2_stack();$stack->push($hub);return$hub->is_passing}sub stop {my$self=shift;croak "Subtest is not active" unless$self->{+ACTIVE}--;croak "AsyncSubtest stack mismatch" unless@STACK && $self==$STACK[-1];pop@STACK;my$hub=$self->{+HUB};my$stack=Test2::API::test2_stack();$stack->pop($hub);return$hub->is_passing}sub finish {my$self=shift;my%params=@_;my$hub=$self->hub;croak "Subtest is already finished" if$self->{+FINISHED}++;croak "Subtest can only be finished in the process/thread that created it" unless$hub->is_local;croak "Subtest is still active" if$self->{+ACTIVE};$self->wait;my$todo=$params{todo};my$skip=$params{skip};my$empty=!@{$self->{+EVENTS}};my$no_asserts=!$hub->count;my$collapse=$params{collapse};my$no_plan=$params{no_plan}|| ($collapse && $no_asserts)|| $skip;my$trace=Test2::Util::Trace->new(frame=>$self->{+TRACE}->{frame},buffered=>$hub->buffered,nested=>$hub->nested,cid=>$self->{+CID},uuid=>$self->{+UUID},hid=>$hub->hid,huuid=>$hub->uuid,);$hub->finalize($trace,!$no_plan)unless$hub->no_ending || $hub->ended;if ($hub->ipc){$hub->ipc->drop_hub($hub->hid);$hub->set_ipc(undef)}return$hub->is_passing if$params{silent};my$ctx=$self->context;my$pass=1;if ($skip){$ctx->skip($self->{+NAME},$skip)}else {if ($collapse && $empty){$ctx->ok($hub->is_passing,$self->{+NAME});return$hub->is_passing}if ($collapse && $no_asserts){push @{$self->{+EVENTS}}=>Test2::Event::Plan->new(trace=>$trace,max=>0,directive=>'SKIP',reason=>"No assertions")}my$e=$ctx->build_event('Subtest',pass=>$hub->is_passing,subtest_id=>$hub->id,subtest_uuid=>$hub->uuid,name=>$self->{+NAME},buffered=>1,subevents=>$self->{+EVENTS},$todo ? (todo=>$todo,effective_pass=>1,): (),);$ctx->hub->send($e);unless ($e->effective_pass){$ctx->failure_diag($e);$ctx->diag("Bad subtest plan, expected " .$hub->plan ." but ran " .$hub->count)if$hub->plan &&!$hub->check_plan &&!grep {$_->causes_fail}@{$self->{+EVENTS}}}$pass=$e->pass}$_->{+_IN_USE}-- for reverse @{$self->{+STACK}};return$pass}sub wait {my$self=shift;my$hub=$self->{+HUB};my$children=$self->{+CHILDREN};while (@$children){$hub->cull;if (my$child=pop @$children){if (blessed($child)){$child->join}else {waitpid($child,0)}}else {Time::HiRes::sleep('0.01')}}$hub->cull;cluck "Subtest '$self->{+NAME}': All children have completed, but we still appear to be pending" if$hub->is_local && keys %{$self->{+HUB}->ast_ids}}sub fork {croak "Forking is not supported" unless CAN_FORK;my$self=shift;my$id=$self->cleave;my$pid=CORE::fork();unless (defined$pid){delete$self->{+HUB}->ast_ids->{$id};croak "Failed to fork"}if($pid){push @{$self->{+CHILDREN}}=>$pid;return$pid}$self->attach($id);return$self->_guard}sub run_fork {my$self=shift;my ($code,@args)=@_;my$f=$self->fork;return$f unless blessed($f);$self->run($code,@args);$self->detach();$f->dismiss();exit 0}sub run_thread {croak "Threading is not supported" unless CAN_REALLY_THREAD;my$self=shift;my ($code,@args)=@_;my$id=$self->cleave;my$thr=threads->create(sub {$self->attach($id);$self->run($code,@args);$self->detach(get_tid);return 0});push @{$self->{+CHILDREN}}=>$thr;return$thr}sub _guard {my$self=shift;my ($pid,$tid)=($$,get_tid);return Scope::Guard->new(sub {return unless $$==$pid && get_tid==$tid;my$error="Scope Leak";if (my$ex=$@){chomp($ex);$error .= " ($ex)"}cluck$error;my$e=$self->context->build_event('Exception',error=>"$error\n",);$self->{+HUB}->send($e);$self->detach();exit 255})}sub DESTROY {my$self=shift;return unless$self->{+NAME};if (my$att=$self->{+_ATTACHED}){return unless$self->{+HUB};eval {$self->detach()}}return if$self->{+FINISHED};return unless$self->{+PID}==$$;return unless$self->{+TID}==get_tid;local $@;eval {$_->{+_IN_USE}-- for reverse @{$self->{+STACK}}};warn "Subtest $self->{+NAME} did not finish!";exit 255}1;
TEST2_ASYNCSUBTEST

$fatpacked{"Test2/AsyncSubtest/Event/Attach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST_EVENT_ATTACH';
  package Test2::AsyncSubtest::Event::Attach;use strict;use warnings;our$VERSION='0.000122';use base 'Test2::Event';use Test2::Util::HashBase qw/id/;sub no_display {1}sub callback {my$self=shift;my ($hub)=@_;my$id=$self->{+ID};my$ids=$hub->ast_ids;unless (defined$ids->{$id}){require Test2::Event::Exception;my$trace=$self->trace;$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>"Invalid AsyncSubtest attach ID: $id at " .$trace->debug ."\n",));return}if ($ids->{$id}++){require Test2::Event::Exception;my$trace=$self->trace;$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>"AsyncSubtest ID $id already attached at " .$trace->debug ."\n",));return}}1;
TEST2_ASYNCSUBTEST_EVENT_ATTACH

$fatpacked{"Test2/AsyncSubtest/Event/Detach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST_EVENT_DETACH';
  package Test2::AsyncSubtest::Event::Detach;use strict;use warnings;our$VERSION='0.000122';use base 'Test2::Event';use Test2::Util::HashBase qw/id/;sub no_display {1}sub callback {my$self=shift;my ($hub)=@_;my$id=$self->{+ID};my$ids=$hub->ast_ids;unless (defined$ids->{$id}){require Test2::Event::Exception;my$trace=$self->trace;$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>"Invalid AsyncSubtest detach ID: $id at " .$trace->debug ."\n",));return}unless (delete$ids->{$id}){require Test2::Event::Exception;my$trace=$self->trace;$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>"AsyncSubtest ID $id is not attached at " .$trace->debug ."\n",));return}}1;
TEST2_ASYNCSUBTEST_EVENT_DETACH

$fatpacked{"Test2/AsyncSubtest/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST_FORMATTER';
  package Test2::AsyncSubtest::Formatter;use strict;use warnings;our$VERSION='0.000122';die "Should not load this anymore";1;
TEST2_ASYNCSUBTEST_FORMATTER

$fatpacked{"Test2/AsyncSubtest/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST_HUB';
  package Test2::AsyncSubtest::Hub;use strict;use warnings;our$VERSION='0.000122';use base 'Test2::Hub::Subtest';use Test2::Util::HashBase qw/ast_ids ast/;sub init {my$self=shift;$self->SUPER::init();if (my$format=$self->format){my$hide=$format->can('hide_buffered')? $format->hide_buffered : 1;$self->format(undef)if$hide}}sub inherit {my$self=shift;my ($from,%params)=@_;if (my$ls=$from->{+_LISTENERS}){push @{$self->{+_LISTENERS}}=>grep {$_->{inherit}}@$ls}if (my$pfs=$from->{+_PRE_FILTERS}){push @{$self->{+_PRE_FILTERS}}=>grep {$_->{inherit}}@$pfs}if (my$fs=$from->{+_FILTERS}){push @{$self->{+_FILTERS}}=>grep {$_->{inherit}}@$fs}}1;
TEST2_ASYNCSUBTEST_HUB

$fatpacked{"Test2/Bundle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_BUNDLE';
  package Test2::Bundle;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_BUNDLE

$fatpacked{"Test2/Bundle/Extended.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_BUNDLE_EXTENDED';
  package Test2::Bundle::Extended;use strict;use warnings;use Test2::V0;our$VERSION='0.000122';BEGIN {push@Test2::Bundle::Extended::ISA=>'Test2::V0';no warnings 'once';*EXPORT=\@Test2::V0::EXPORT}our%EXPORT_TAGS=('v1'=>\@Test2::Bundle::Extended::EXPORT,);1;
TEST2_BUNDLE_EXTENDED

$fatpacked{"Test2/Bundle/More.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_BUNDLE_MORE';
  package Test2::Bundle::More;use strict;use warnings;our$VERSION='0.000122';use Test2::Plugin::ExitSummary;use Test2::Tools::Basic qw{ok pass fail skip todo diag note plan skip_all done_testing bail_out};use Test2::Tools::ClassicCompare qw{is is_deeply isnt like unlike cmp_ok};use Test2::Tools::Class qw/can_ok isa_ok/;use Test2::Tools::Subtest qw/subtest_streamed/;BEGIN {*BAIL_OUT=\&bail_out;*subtest=\&subtest_streamed}our@EXPORT=qw{ok pass fail skip todo diag note plan skip_all done_testing BAIL_OUT is isnt like unlike is_deeply cmp_ok isa_ok can_ok subtest};use base 'Exporter';1;
TEST2_BUNDLE_MORE

$fatpacked{"Test2/Bundle/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_BUNDLE_SIMPLE';
  package Test2::Bundle::Simple;use strict;use warnings;our$VERSION='0.000122';use Test2::Plugin::ExitSummary;use Test2::Tools::Basic qw/ok plan done_testing skip_all/;our@EXPORT=qw/ok plan done_testing skip_all/;use base 'Exporter';1;
TEST2_BUNDLE_SIMPLE

$fatpacked{"Test2/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE';
  package Test2::Compare;use strict;use warnings;our$VERSION='0.000122';use Scalar::Util qw/blessed/;use Test2::Util qw/try/;use Test2::Util::Ref qw/rtype/;use Carp qw/croak/;our@EXPORT_OK=qw{compare get_build push_build pop_build build strict_convert relaxed_convert convert};use base 'Exporter';sub compare {my ($got,$check,$convert)=@_;$check=$convert->($check);return$check->run(id=>undef,got=>$got,exists=>1,convert=>$convert,seen=>{},)}my@BUILD;sub get_build {@BUILD ? $BUILD[-1]: undef}sub push_build {push@BUILD=>$_[0]}sub pop_build {return pop@BUILD if@BUILD && $_[0]&& $BUILD[-1]==$_[0];my$have=@BUILD ? "$BUILD[-1]" : 'undef';my$want=$_[0]? "$_[0]" : 'undef';croak "INTERNAL ERROR: Attempted to pop incorrect build, have $have, tried to pop $want"}sub build {my ($class,$code)=@_;my@caller=caller(1);die "'$caller[3]\()' should not be called in void context in $caller[1] line $caller[2]\n" unless defined(wantarray);my$build=$class->new(builder=>$code,called=>\@caller);push@BUILD=>$build;my ($ok,$err)=try {$code->($build);1};pop@BUILD;die$err unless$ok;return$build}sub strict_convert {convert($_[0],{implicit_end=>1,use_regex=>0,use_code=>0 })}sub relaxed_convert {convert($_[0],{implicit_end=>0,use_regex=>1,use_code=>1 })}my$CONVERT_LOADED=0;my%ALLOWED_KEYS=(implicit_end=>1,use_regex=>1,use_code=>1);sub convert {my ($thing,$config)=@_;unless($CONVERT_LOADED){require Test2::Compare::Array;require Test2::Compare::Base;require Test2::Compare::Custom;require Test2::Compare::DeepRef;require Test2::Compare::Hash;require Test2::Compare::Pattern;require Test2::Compare::Ref;require Test2::Compare::Regex;require Test2::Compare::Scalar;require Test2::Compare::String;require Test2::Compare::Undef;require Test2::Compare::Wildcard;$CONVERT_LOADED=1}if (ref($config)){my$bad=join ', '=>grep {!$ALLOWED_KEYS{$_}}keys %$config;croak "The following config options are not understood by convert(): $bad" if$bad;$config->{implicit_end}=1 unless defined$config->{implicit_end};$config->{use_regex}=1 unless defined$config->{use_regex};$config->{use_code}=0 unless defined$config->{use_code}}else {if ($config){$config={implicit_end=>1,use_regex=>0,use_code=>0,}}else {$config={implicit_end=>0,use_regex=>1,use_code=>1,}}}return _convert($thing,$config)}sub _convert {my ($thing,$config)=@_;return Test2::Compare::Undef->new()unless defined$thing;if (blessed($thing)&& $thing->isa('Test2::Compare::Base')){if ($config->{implicit_end}&& $thing->can('set_ending')&&!defined$thing->ending){my$clone=$thing->clone;$clone->set_ending('implicit');return$clone}return$thing unless$thing->isa('Test2::Compare::Wildcard');my$newthing=_convert($thing->expect,$config);$newthing->set_builder($thing->builder)unless$newthing->builder;$newthing->set_file($thing->_file)unless$newthing->_file;$newthing->set_lines($thing->_lines)unless$newthing->_lines;return$newthing}my$type=rtype($thing);return Test2::Compare::Array->new(inref=>$thing,$config->{implicit_end}? (ending=>1): ())if$type eq 'ARRAY';return Test2::Compare::Hash->new(inref=>$thing,$config->{implicit_end}? (ending=>1): ())if$type eq 'HASH';return Test2::Compare::Pattern->new(pattern=>$thing,stringify_got=>1,)if$config->{use_regex}&& $type eq 'REGEXP';return Test2::Compare::Custom->new(code=>$thing)if$config->{use_code}&& $type eq 'CODE';return Test2::Compare::Regex->new(input=>$thing)if$type eq 'REGEXP';if ($type eq 'SCALAR' || $type eq 'VSTRING'){my$nested=_convert($$thing,$config);return Test2::Compare::Scalar->new(item=>$nested)}return Test2::Compare::DeepRef->new(input=>$thing)if$type eq 'REF';return Test2::Compare::Ref->new(input=>$thing)if$type;return Test2::Compare::String->new(input=>$thing)}1;
TEST2_COMPARE

$fatpacked{"Test2/Compare/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_ARRAY';
  package Test2::Compare::Array;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/inref meta ending items order for_each/;use Carp qw/croak confess/;use Scalar::Util qw/reftype looks_like_number/;sub init {my$self=shift;if(defined(my$ref=$self->{+INREF})){croak "Cannot specify both 'inref' and 'items'" if$self->{+ITEMS};croak "Cannot specify both 'inref' and 'order'" if$self->{+ORDER};croak "'inref' must be an array reference, got '$ref'" unless reftype($ref)eq 'ARRAY';my$order=$self->{+ORDER}=[];my$items=$self->{+ITEMS}={};for (my$i=0;$i < @$ref;$i++){push @$order=>$i;$items->{$i}=$ref->[$i]}}else {$self->{+ITEMS}||= {};croak "All indexes listed in the 'items' hashref must be numeric" if grep {!looks_like_number($_)}keys %{$self->{+ITEMS}};$self->{+ORDER}||= [sort {$a <=> $b}keys %{$self->{+ITEMS}}];croak "All indexes listed in the 'order' arrayref must be numeric" if grep {!(looks_like_number($_)|| (ref($_)&& reftype($_)eq 'CODE'))}@{$self->{+ORDER}}}$self->{+FOR_EACH}||= [];$self->SUPER::init()}sub name {'<ARRAY>'}sub meta_class {'Test2::Compare::Meta'}sub verify {my$self=shift;my%params=@_;return 0 unless$params{exists};my$got=$params{got};return 0 unless defined$got;return 0 unless ref($got);return 0 unless reftype($got)eq 'ARRAY';return 1}sub add_prop {my$self=shift;$self->{+META}=$self->meta_class->new unless defined$self->{+META};$self->{+META}->add_prop(@_)}sub top_index {my$self=shift;my@order=@{$self->{+ORDER}};while(@order){my$idx=pop@order;next if ref$idx;return$idx}return undef}sub add_item {my$self=shift;my$check=pop;my ($idx)=@_;my$top=$self->top_index;croak "elements must be added in order!" if$top && $idx && $idx <= $top;$idx=defined($top)? $top + 1 : 0 unless defined($idx);push @{$self->{+ORDER}}=>$idx;$self->{+ITEMS}->{$idx}=$check}sub add_filter {my$self=shift;my ($code)=@_;croak "A single coderef is required" unless @_==1 && $code && ref$code && reftype($code)eq 'CODE';push @{$self->{+ORDER}}=>$code}sub add_for_each {my$self=shift;push @{$self->{+FOR_EACH}}=>@_}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$state=0;my@order=@{$self->{+ORDER}};my$items=$self->{+ITEMS};my$for_each=$self->{+FOR_EACH};my$meta=$self->{+META};push@deltas=>$meta->deltas(%params)if defined$meta;my@list=@$got;while (@order){my$idx=shift@order;my$overflow=0;my$val;if (ref($idx)){@list=$idx->(@list);next}confess "Internal Error: Stacks are out of sync (state > idx)" if$state > $idx + 1;while ($state <= $idx){$overflow=!@list;$val=shift@list;for my$check (@$for_each){$check=$convert->($check);push@deltas=>$check->run(id=>[ARRAY=>$state],convert=>$convert,seen=>$seen,exists=>!$overflow,$overflow ? (): (got=>$val),)}$state++}confess "Internal Error: Stacks are out of sync (state != idx + 1)" unless$state==$idx + 1;my$check=$convert->($items->{$idx});push@deltas=>$check->run(id=>[ARRAY=>$idx],convert=>$convert,seen=>$seen,exists=>!$overflow,$overflow ? (): (got=>$val),)}while (@list && (@$for_each || $self->{+ENDING})){my$item=shift@list;for my$check (@$for_each){$check=$convert->($check);push@deltas=>$check->run(id=>[ARRAY=>$state],convert=>$convert,seen=>$seen,got=>$item,exists=>1,)}if ($self->{+ENDING}){push@deltas=>$self->delta_class->new(dne=>'check',verified=>undef,id=>[ARRAY=>$state],got=>$item,check=>undef,$self->{+ENDING}eq 'implicit' ? (note=>'implicit end'): (),)}$state++}return@deltas}1;
TEST2_COMPARE_ARRAY

$fatpacked{"Test2/Compare/Bag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_BAG';
  package Test2::Compare::Bag;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/ending meta items for_each/;use Carp qw/croak confess/;use Scalar::Util qw/reftype looks_like_number/;sub init {my$self=shift;$self->{+ITEMS}||= [];$self->{+FOR_EACH}||= [];$self->SUPER::init()}sub name {'<BAG>'}sub meta_class {'Test2::Compare::Meta'}sub verify {my$self=shift;my%params=@_;return 0 unless$params{exists};my$got=$params{got}|| return 0;return 0 unless ref($got);return 0 unless reftype($got)eq 'ARRAY';return 1}sub add_prop {my$self=shift;$self->{+META}=$self->meta_class->new unless defined$self->{+META};$self->{+META}->add_prop(@_)}sub add_item {my$self=shift;my$check=pop;my ($idx)=@_;push @{$self->{+ITEMS}},$check}sub add_for_each {my$self=shift;push @{$self->{+FOR_EACH}}=>@_}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$state=0;my@items=@{$self->{+ITEMS}};my@for_each=@{$self->{+FOR_EACH}};my@list=@$got;my%unmatched=map {$_=>$list[$_]}0..$#list;my$meta=$self->{+META};push@deltas=>$meta->deltas(%params)if defined$meta;while (@items){my$item=shift@items;my$check=$convert->($item);my$match=0;for my$idx (0..$#list){next unless exists$unmatched{$idx};my$val=$list[$idx];my$deltas=$check->run(id=>[ARRAY=>$idx],convert=>$convert,seen=>$seen,exists=>1,got=>$val,);unless ($deltas){$match++;delete$unmatched{$idx};last}}unless ($match){push@deltas=>$self->delta_class->new(dne=>'got',verified=>undef,id=>[ARRAY=>'*'],got=>undef,check=>$check,)}}if (@for_each){my@checks=map {$convert->($_)}@for_each;for my$idx (0..$#list){delete$unmatched{$idx};my$val=$list[$idx];for my$check (@checks){push@deltas=>$check->run(id=>[ARRAY=>$idx],convert=>$convert,seen=>$seen,exists=>1,got=>$val,)}}}if($self->{+ENDING}&& keys%unmatched){for my$idx (sort keys%unmatched){my$elem=$list[$idx];push@deltas=>$self->delta_class->new(dne=>'check',verified=>undef,id=>[ARRAY=>$idx],got=>$elem,check=>undef,$self->{+ENDING}eq 'implicit' ? (note=>'implicit end'): (),)}}return@deltas}1;
TEST2_COMPARE_BAG

$fatpacked{"Test2/Compare/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_BASE';
  package Test2::Compare::Base;use strict;use warnings;our$VERSION='0.000122';use Carp qw/confess croak/;use Scalar::Util qw/blessed/;use Sub::Info qw/sub_info/;use Test2::Compare::Delta();sub MAX_CYCLES() {75}use Test2::Util::HashBase qw{builder _file _lines _info called};use Test2::Util::Ref qw/render_ref/;{no warnings 'once';*set_lines=\&set__lines;*set_file=\&set__file}sub clone {my$self=shift;my$class=blessed($self);return bless({%$self},$class)}sub init {my$self=shift;$self->{+_LINES}=delete$self->{lines}if exists$self->{lines};$self->{+_FILE}=delete$self->{file}if exists$self->{file}}sub file {my$self=shift;return$self->{+_FILE}if$self->{+_FILE};if ($self->{+BUILDER}){$self->{+_INFO}||= sub_info($self->{+BUILDER});return$self->{+_INFO}->{file}}elsif ($self->{+CALLED}){return$self->{+CALLED}->[1]}return undef}sub lines {my$self=shift;return$self->{+_LINES}if$self->{+_LINES};if ($self->{+BUILDER}){$self->{+_INFO}||= sub_info($self->{+BUILDER});return$self->{+_INFO}->{lines}if @{$self->{+_INFO}->{lines}}}if ($self->{+CALLED}){return [$self->{+CALLED}->[2]]}return []}sub delta_class {'Test2::Compare::Delta'}sub deltas {()}sub got_lines {()}sub stringify_got {0}sub operator {''}sub verify {confess "unimplemented"}sub name {confess "unimplemented"}sub render {my$self=shift;return$self->name}sub run {my$self=shift;my%params=@_;my$id=$params{id};my$convert=$params{convert}or confess "no convert sub provided";my$seen=$params{seen}||= {};$params{exists}=exists$params{got}? 1 : 0 unless exists$params{exists};my$exists=$params{exists};my$got=$exists ? $params{got}: undef;my$gotname=render_ref($got);if (defined($got)&& ref$got){die "Cycle detected in comparison, aborting" if$seen->{$gotname}&& $seen->{$gotname}>= MAX_CYCLES;$seen->{$gotname}++}my$ok=$self->verify(%params);my@deltas=$ok ? $self->deltas(%params): ();$seen->{$gotname}-- if defined$got && ref$got;return if$ok &&!@deltas;return$self->delta_class->new(verified=>$ok,id=>$id,got=>$got,check=>$self,children=>\@deltas,$exists ? (): (dne=>'got'),)}1;
TEST2_COMPARE_BASE

$fatpacked{"Test2/Compare/Bool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_BOOL';
  package Test2::Compare::Bool;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/input/;use Test2::Compare::Negatable;sub name {my$self=shift;my$in=$self->{+INPUT};return _render_bool($in)}sub operator {my$self=shift;return '!=' if$self->{+NEGATE};return '=='}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;my$want=$self->{+INPUT};my$match=($want xor $got)? 0 : 1;$match=$match ? 0 : 1 if$self->{+NEGATE};return$match}sub run {my$self=shift;my$delta=$self->SUPER::run(@_)or return;my$dne=$delta->dne || "";unless ($dne eq 'got'){my$got=$delta->got;$delta->set_got(_render_bool($got))}return$delta}sub _render_bool {my$bool=shift;my$name=$bool ? 'TRUE' : 'FALSE';my$val=defined$bool ? $bool : 'undef';$val="''" unless length($val);return "<$name ($val)>"}1;
TEST2_COMPARE_BOOL

$fatpacked{"Test2/Compare/Custom.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_CUSTOM';
  package Test2::Compare::Custom;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/code name operator/;use Carp qw/croak/;sub init {my$self=shift;croak "'code' is required" unless$self->{+CODE};$self->{+OPERATOR}||= 'CODE(...)';$self->{+NAME}||= '<Custom Code>';$self->SUPER::init()}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};my$code=$self->{+CODE};local $_=$got;my$ok=$code->(got=>$got,exists=>$exists,operator=>$self->{+OPERATOR},name=>$self->{+NAME},);return$ok}1;
TEST2_COMPARE_CUSTOM

$fatpacked{"Test2/Compare/DeepRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_DEEPREF';
  package Test2::Compare::DeepRef;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/input/;use Test2::Util::Ref qw/render_ref rtype/;use Scalar::Util qw/refaddr/;use Carp qw/croak/;sub init {my$self=shift;croak "'input' is a required attribute" unless$self->{+INPUT};croak "'input' must be a reference, got '" .$self->{+INPUT}."'" unless ref$self->{+INPUT};$self->SUPER::init()}sub name {'<REF>'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;my$in=$self->{+INPUT};return 0 unless ref$in;return 0 unless ref$got;my$in_type=rtype($in);my$got_type=rtype($got);return 0 unless$in_type eq $got_type;return 1}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my$in=$self->{+INPUT};my$in_type=rtype($in);my$got_type=rtype($got);my$check=$convert->($$in);return$check->run(id=>['DEREF'=>'$*'],convert=>$convert,seen=>$seen,got=>$$got,exists=>1,)}1;
TEST2_COMPARE_DEEPREF

$fatpacked{"Test2/Compare/Delta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_DELTA';
  package Test2::Compare::Delta;use strict;use warnings;our$VERSION='0.000122';use Test2::Util::HashBase qw{verified id got chk children dne exception note};use Test2::EventFacet::Info::Table;use Test2::Util::Table();use Test2::API qw/context/;use Test2::Util::Ref qw/render_ref rtype/;use Carp qw/croak/;BEGIN {no warnings 'once';*check=\&chk;*set_check=\&set_chk}my@COLUMN_ORDER=qw/PATH GLNs GOT OP CHECK CLNs/;my%COLUMNS=(GOT=>{name=>'GOT',value=>sub {$_[0]->render_got},no_collapse=>1},CHECK=>{name=>'CHECK',value=>sub {$_[0]->render_check},no_collapse=>1},OP=>{name=>'OP',value=>sub {$_[0]->table_op}},PATH=>{name=>'PATH',value=>sub {$_[1]}},'GLNs'=>{name=>'GLNs',alias=>'LNs',value=>sub {$_[0]->table_got_lines}},'CLNs'=>{name=>'CLNs',alias=>'LNs',value=>sub {$_[0]->table_check_lines}},);sub remove_column {my$class=shift;my$header=shift;@COLUMN_ORDER=grep {$_ ne $header}@COLUMN_ORDER;delete$COLUMNS{$header}? 1 : 0}sub add_column {my$class=shift;my$name=shift;croak "Column name is required" unless$name;croak "Column '$name' is already defined" if$COLUMNS{$name};my%params;if (@_==1){%params=(value=>@_,name=>$name)}else {%params=(@_,name=>$name)}my$value=$params{value};croak "You must specify a 'value' callback" unless$value;croak "'value' callback must be a CODE reference" unless rtype($value)eq 'CODE';if ($params{prefix}){unshift@COLUMN_ORDER=>$name}else {push@COLUMN_ORDER=>$name}$COLUMNS{$name}=\%params}sub set_column_alias {my ($class,$name,$alias)=@_;croak "Tried to alias a non-existent column" unless exists$COLUMNS{$name};croak "Missing alias" unless defined$alias;$COLUMNS{$name}->{alias}=$alias}sub init {my$self=shift;croak "Cannot specify both 'check' and 'chk' as arguments" if exists($self->{check})&& exists($self->{+CHK});$self->{+CHK}||= delete$self->{check}if exists$self->{check}}sub render_got {my$self=shift;my$exp=$self->{+EXCEPTION};if ($exp){chomp($exp="$exp");$exp =~ s/\n.*$//g;return "<EXCEPTION: $exp>"}my$dne=$self->{+DNE};return '<DOES NOT EXIST>' if$dne && $dne eq 'got';my$got=$self->{+GOT};return '<UNDEF>' unless defined$got;my$check=$self->{+CHK};my$stringify=defined($check)&& $check->stringify_got;return render_ref($got)if ref$got &&!$stringify;return "$got"}sub render_check {my$self=shift;my$dne=$self->{+DNE};return '<DOES NOT EXIST>' if$dne && $dne eq 'check';my$check=$self->{+CHK};return '<UNDEF>' unless defined$check;return$check->render}sub _full_id {my ($type,$id)=@_;return "<$id>" if!$type || $type eq 'META';return$id if$type eq 'SCALAR';return "{$id}" if$type eq 'HASH';return "{$id} <KEY>" if$type eq 'HASHKEY';return "[$id]" if$type eq 'ARRAY';return "$id()" if$type eq 'METHOD';return "$id" if$type eq 'DEREF';return "<$id>"}sub _arrow_id {my ($path,$type)=@_;return '' unless$path;return ' ' if!$type || $type eq 'META';return '->' if$type eq 'METHOD';return '->' if$type eq 'SCALAR';return '->' if$type eq 'DEREF';return '->' if$path =~ m/(>|\(\))$/;return '->' if$path eq '$VAR';return '->' if$type =~ m/^(HASH|ARRAY)$/ && $path !~ m/(\]|\})$/;return ''}sub _join_id {my ($path,$parts)=@_;my ($type,$key)=@$parts;my$id=_full_id($type,$key);my$join=_arrow_id($path,$type);return "${path}${join}${id}"}sub should_show {my$self=shift;return 1 unless$self->verified;defined(my$check=$self->check)|| return 0;return 0 unless$check->lines;my$file=$check->file || return 0;my$ctx=context();my$cfile=$ctx->trace->file;$ctx->release;return 0 unless$file eq $cfile;return 1}sub filter_visible {my$self=shift;my@deltas;my@queue=(['',$self]);while (my$set=shift@queue){my ($path,$delta)=@$set;push@deltas=>[$path,$delta]if$delta->should_show;my$children=$delta->children || next;next unless @$children;my@new;for my$child (@$children){my$cpath=_join_id($path,$child->id);push@new=>[$cpath,$child]}unshift@queue=>@new}return \@deltas}sub table_header {[map {$COLUMNS{$_}->{alias}|| $_}@COLUMN_ORDER]}sub table_op {my$self=shift;defined(my$check=$self->{+CHK})|| return '!exists';return$check->operator($self->{+GOT})unless$self->{+DNE}&& $self->{+DNE}eq 'got';return$check->operator()}sub table_check_lines {my$self=shift;defined(my$check=$self->{+CHK})|| return '';my$lines=$check->lines || return '';return '' unless @$lines;return join ', '=>@$lines}sub table_got_lines {my$self=shift;defined(my$check=$self->{+CHK})|| return '';return '' if$self->{+DNE}&& $self->{+DNE}eq 'got';my@lines=$check->got_lines($self->{+GOT});return '' unless@lines;return join ', '=>@lines}sub table_rows {my$self=shift;my$deltas=$self->filter_visible;my@rows;for my$set (@$deltas){my ($id,$d)=@$set;my@row;for my$col (@COLUMN_ORDER){my$spec=$COLUMNS{$col};my$val=$spec->{value}->($d,$id);$val='' unless defined$val;push@row=>$val}push@rows=>\@row}return \@rows}sub table {my$self=shift;my@diag;my$header=$self->table_header;my$rows=$self->table_rows;my$xxx=Dumper($rows);my$render_rows=[@$rows];my$max=exists$ENV{TS_MAX_DELTA}? $ENV{TS_MAX_DELTA}: 25;if ($max && @$render_rows > $max){@$render_rows=map {[@$_]}@{$render_rows}[0 .. ($max - 1)];@diag=("************************************************************",sprintf("* Stopped after %-42.42s *","$max differences."),"* Set the TS_MAX_DELTA environment var to raise the limit. *","* Set it to 0 for no limit.                                *","************************************************************",)}my$table_args={header=>$header,collapse=>1,sanitize=>1,mark_tail=>1,no_collapse=>[grep {$COLUMNS{$COLUMN_ORDER[$_]}->{no_collapse}}0 .. $#COLUMN_ORDER],};my$render=join "\n"=>(Test2::Util::Table::table(%$table_args,rows=>$render_rows),@diag);use Data::Dumper;my$table=Test2::EventFacet::Info::Table->new(%$table_args,rows=>$rows,as_string=>$render,xxx=>$xxx,);return$table}sub diag {shift->table}1;
TEST2_COMPARE_DELTA

$fatpacked{"Test2/Compare/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_EVENT';
  package Test2::Compare::Event;use strict;use warnings;use Scalar::Util qw/blessed/;use Test2::Compare::EventMeta();use base 'Test2::Compare::Object';our$VERSION='0.000122';use Test2::Util::HashBase qw/etype/;sub name {my$self=shift;my$etype=$self->etype;return "<EVENT: $etype>"}sub meta_class {'Test2::Compare::EventMeta'}sub object_base {'Test2::Event'}sub got_lines {my$self=shift;my ($event)=@_;return unless$event;return unless blessed($event);return unless$event->isa('Test2::Event');return unless$event->trace;return ($event->trace->line)}1;
TEST2_COMPARE_EVENT

$fatpacked{"Test2/Compare/EventMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_EVENTMETA';
  package Test2::Compare::EventMeta;use strict;use warnings;use base 'Test2::Compare::Meta';our$VERSION='0.000122';use Test2::Util::HashBase;sub get_prop_file {$_[1]->trace->file}sub get_prop_line {$_[1]->trace->line}sub get_prop_package {$_[1]->trace->package}sub get_prop_subname {$_[1]->trace->subname}sub get_prop_debug {$_[1]->trace->debug}sub get_prop_tid {$_[1]->trace->tid}sub get_prop_pid {$_[1]->trace->pid}1;
TEST2_COMPARE_EVENTMETA

$fatpacked{"Test2/Compare/Float.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_FLOAT';
  package Test2::Compare::Float;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000122';our$DEFAULT_TOLERANCE=1e-08;use Test2::Util::HashBase qw/input tolerance precision/;use Test2::Compare::Negatable;sub init {my$self=shift;my$input=$self->{+INPUT};if (exists$self->{+TOLERANCE}and exists$self->{+PRECISION}){confess "can't set both tolerance and precision"}elsif (!exists$self->{+PRECISION}and!exists$self->{+TOLERANCE}){$self->{+TOLERANCE}=$DEFAULT_TOLERANCE}confess "input must be defined for 'Float' check" unless defined$input;confess "input must be a number for 'Float' check" unless length($input)&& $input =~ m/\S/;confess "precision must be an integer for 'Float' check" if exists$self->{+PRECISION}&& $self->{+PRECISION}!~ m/^\d+$/;$self->SUPER::init(@_)}sub name {my$self=shift;my$in=$self->{+INPUT};my$precision=$self->{+PRECISION};if (defined$precision){return sprintf "%.*f",$precision,$in}my$tolerance=$self->{+TOLERANCE};return "$in +/- $tolerance"}sub operator {my$self=shift;return '' unless @_;my ($got)=@_;return '' unless defined($got);return '' unless length($got)&& $got =~ m/\S/;if ($self->{+PRECISION}){return 'ne' if$self->{+NEGATE};return 'eq'}return '!=' if$self->{+NEGATE};return '=='}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 if ref$got;return 0 unless length($got)&& $got =~ m/\S/;my$input=$self->{+INPUT};my$negate=$self->{+NEGATE};my$tolerance=$self->{+TOLERANCE};my$precision=$self->{+PRECISION};my@warnings;my$out;{local$SIG{__WARN__}=sub {push@warnings=>@_};my$equal=($input==$got);if (!$equal){if (defined$tolerance){$equal=1 if $got > $input - $tolerance && $got < $input + $tolerance}else {$equal=sprintf("%.*f",$precision,$got)eq sprintf("%.*f",$precision,$input)}}$out=$negate ?!$equal : $equal}for my$warn (@warnings){if ($warn =~ m/numeric/){$out=0;next}warn$warn}return$out}1;
TEST2_COMPARE_FLOAT

$fatpacked{"Test2/Compare/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_HASH';
  package Test2::Compare::Hash;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/inref meta ending items order for_each_key for_each_val/;use Carp qw/croak confess/;use Scalar::Util qw/reftype/;sub init {my$self=shift;if(defined(my$ref=$self->{+INREF})){croak "Cannot specify both 'inref' and 'items'" if$self->{+ITEMS};croak "Cannot specify both 'inref' and 'order'" if$self->{+ORDER};$self->{+ITEMS}={%$ref};$self->{+ORDER}=[sort keys %$ref]}else {$self->{+ITEMS}=$self->{+ITEMS}? {%{$self->{+ITEMS}}}: {};if ($self->{+ORDER}){my@all=keys %{$self->{+ITEMS}};my%have=map {$_=>1}@{$self->{+ORDER}};my@missing=grep {!$have{$_}}@all;croak "Keys are missing from the 'order' array: " .join(', ',sort@missing)if@missing}else {$self->{+ORDER}=[sort keys %{$self->{+ITEMS}}]}}$self->{+FOR_EACH_KEY}||= [];$self->{+FOR_EACH_VAL}||= [];$self->SUPER::init()}sub name {'<HASH>'}sub meta_class {'Test2::Compare::Meta'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 unless ref($got);return 0 unless reftype($got)eq 'HASH';return 1}sub add_prop {my$self=shift;$self->{+META}=$self->meta_class->new unless defined$self->{+META};$self->{+META}->add_prop(@_)}sub add_field {my$self=shift;my ($name,$check)=@_;croak "field name is required" unless defined$name;croak "field '$name' has already been specified" if exists$self->{+ITEMS}->{$name};push @{$self->{+ORDER}}=>$name;$self->{+ITEMS}->{$name}=$check}sub add_for_each_key {my$self=shift;push @{$self->{+FOR_EACH_KEY}}=>@_}sub add_for_each_val {my$self=shift;push @{$self->{+FOR_EACH_VAL}}=>@_}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$items=$self->{+ITEMS};my$each_key=$self->{+FOR_EACH_KEY};my$each_val=$self->{+FOR_EACH_VAL};my%fields=%$got;my$meta=$self->{+META};push@deltas=>$meta->deltas(%params)if defined$meta;for my$key (@{$self->{+ORDER}}){my$check=$convert->($items->{$key});my$exists=exists$fields{$key};my$val=delete$fields{$key};if ($exists){for my$kcheck (@$each_key){$kcheck=$convert->($kcheck);push@deltas=>$kcheck->run(id=>[HASHKEY=>$key],convert=>$convert,seen=>$seen,exists=>$exists,got=>$key,)}for my$vcheck (@$each_val){$vcheck=$convert->($vcheck);push@deltas=>$vcheck->run(id=>[HASH=>$key],convert=>$convert,seen=>$seen,exists=>$exists,got=>$val,)}}push@deltas=>$check->run(id=>[HASH=>$key],convert=>$convert,seen=>$seen,exists=>$exists,$exists ? (got=>$val): (),)}if (keys%fields){for my$key (sort keys%fields){my$val=$fields{$key};for my$kcheck (@$each_key){$kcheck=$convert->($kcheck);push@deltas=>$kcheck->run(id=>[HASHKEY=>$key],convert=>$convert,seen=>$seen,got=>$key,exists=>1,)}for my$vcheck (@$each_val){$vcheck=$convert->($vcheck);push@deltas=>$vcheck->run(id=>[HASH=>$key],convert=>$convert,seen=>$seen,got=>$val,exists=>1,)}if ($self->{+ENDING}){push@deltas=>$self->delta_class->new(dne=>'check',verified=>undef,id=>[HASH=>$key],got=>$val,check=>undef,$self->{+ENDING}eq 'implicit' ? (note=>'implicit end'): (),)}}}return@deltas}1;
TEST2_COMPARE_HASH

$fatpacked{"Test2/Compare/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_META';
  package Test2::Compare::Meta;use strict;use warnings;use Test2::Compare::Delta();use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/items/;use Carp qw/croak confess/;use Scalar::Util qw/reftype blessed/;sub init {my$self=shift;$self->{+ITEMS}||= [];$self->SUPER::init()}sub name {'<META CHECKS>'}sub verify {my$self=shift;my%params=@_;return$params{exists}? 1 : 0}sub add_prop {my$self=shift;my ($name,$check)=@_;croak "prop name is required" unless defined$name;croak "check is required" unless defined$check;my$meth="get_prop_$name";croak "'$name' is not a known property" unless$self->can($meth);push @{$self->{+ITEMS}}=>[$meth,$check,$name]}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$items=$self->{+ITEMS};for my$set (@$items){my ($meth,$check,$name)=@$set;$check=$convert->($check);my$val=$self->$meth($got);push@deltas=>$check->run(id=>[META=>$name],got=>$val,convert=>$convert,seen=>$seen,)}return@deltas}sub get_prop_blessed {blessed($_[1])}sub get_prop_reftype {reftype($_[1])}sub get_prop_this {$_[1]}sub get_prop_size {my$self=shift;my ($it)=@_;my$type=reftype($it)|| '';return scalar @$it if$type eq 'ARRAY';return scalar keys %$it if$type eq 'HASH';return undef}1;
TEST2_COMPARE_META

$fatpacked{"Test2/Compare/Negatable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_NEGATABLE';
  package Test2::Compare::Negatable;use strict;use warnings;our$VERSION='0.000122';require overload;require Test2::Util::HashBase;sub import {my ($pkg,$file,$line)=caller;my$sub=eval <<"    EOT" or die $@;$sub->();no strict 'refs';*{"$pkg\::clone_negate"}=\&clone_negate;*{"$pkg\::toggle_negate"}=\&toggle_negate}sub clone_negate {my$self=shift;my$clone=$self->clone;$clone->toggle_negate;return$clone}sub toggle_negate {my$self=shift;$self->set_negate($self->negate ? 0 : 1)}1;
  package $pkg;
  #line $line "$file"
  sub { overload->import('!' => 'clone_negate', fallback => 1); Test2::Util::HashBase->import('negate')}
      EOT
TEST2_COMPARE_NEGATABLE

$fatpacked{"Test2/Compare/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_NUMBER';
  package Test2::Compare::Number;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/input/;use Test2::Compare::Negatable;sub init {my$self=shift;my$input=$self->{+INPUT};confess "input must be defined for 'Number' check" unless defined$input;confess "input must be a number for 'Number' check" unless length($input)&& $input =~ m/\S/;$self->SUPER::init(@_)}sub name {my$self=shift;my$in=$self->{+INPUT};return$in}sub operator {my$self=shift;return '' unless @_;my ($got)=@_;return '' unless defined($got);return '' unless length($got)&& $got =~ m/\S/;return '!=' if$self->{+NEGATE};return '=='}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 if ref$got;return 0 unless length($got)&& $got =~ m/\S/;my$input=$self->{+INPUT};my$negate=$self->{+NEGATE};my@warnings;my$out;{local$SIG{__WARN__}=sub {push@warnings=>@_};$out=$negate ? ($input!=$got): ($input==$got)}for my$warn (@warnings){if ($warn =~ m/numeric/){$out=0;next}warn$warn}return$out}1;
TEST2_COMPARE_NUMBER

$fatpacked{"Test2/Compare/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_OBJECT';
  package Test2::Compare::Object;use strict;use warnings;use Test2::Util qw/try/;use Test2::Compare::Meta();use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/calls meta refcheck ending/;use Carp qw/croak confess/;use Scalar::Util qw/reftype blessed/;sub init {my$self=shift;$self->{+CALLS}||= [];$self->SUPER::init()}sub name {'<OBJECT>'}sub meta_class {'Test2::Compare::Meta'}sub object_base {'UNIVERSAL'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 unless ref($got);return 0 unless blessed($got);return 0 unless$got->isa($self->object_base);return 1}sub add_prop {my$self=shift;$self->{+META}=$self->meta_class->new unless defined$self->{+META};$self->{+META}->add_prop(@_)}sub add_field {my$self=shift;$self->{+REFCHECK}=Test2::Compare::Hash->new unless defined$self->{+REFCHECK};croak "Underlying reference does not have fields" unless$self->{+REFCHECK}->can('add_field');$self->{+REFCHECK}->add_field(@_)}sub add_item {my$self=shift;$self->{+REFCHECK}=Test2::Compare::Array->new unless defined$self->{+REFCHECK};croak "Underlying reference does not have items" unless$self->{+REFCHECK}->can('add_item');$self->{+REFCHECK}->add_item(@_)}sub add_call {my$self=shift;my ($meth,$check,$name,$context)=@_;$name ||= ref$meth eq 'ARRAY' ? $meth->[0]: ref$meth eq 'CODE' ? '\&CODE' : $meth;push @{$self->{+CALLS}}=>[$meth,$check,$name,$context || 'scalar']}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$meta=$self->{+META};my$refcheck=$self->{+REFCHECK};push@deltas=>$meta->deltas(%params)if defined$meta;for my$call (@{$self->{+CALLS}}){my ($meth,$check,$name,$context)=@$call;$context ||= 'scalar';$check=$convert->($check);my@args;if (ref($meth)eq 'ARRAY'){($meth,@args)=@{$meth}}my$exists=ref($meth)|| $got->can($meth);my$val;my ($ok,$err)=try {$val=$exists ? ($context eq 'list' ? [$got->$meth(@args)]: $context eq 'hash' ? {$got->$meth(@args)}: $got->$meth(@args)): undef};if (!$ok){push@deltas=>$self->delta_class->new(verified=>undef,id=>[METHOD=>$name],got=>undef,check=>$check,exception=>$err,)}else {push@deltas=>$check->run(id=>[METHOD=>$name],convert=>$convert,seen=>$seen,exists=>$exists,$exists ? (got=>$val): (),)}}return@deltas unless defined$refcheck;$refcheck->set_ending($self->{+ENDING});if ($refcheck->verify(%params)){push@deltas=>$refcheck->deltas(%params)}else {push@deltas=>$self->delta_class->new(verified=>undef,id=>[META=>'Object Ref'],got=>$got,check=>$refcheck,)}return@deltas}1;
TEST2_COMPARE_OBJECT

$fatpacked{"Test2/Compare/OrderedSubset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_ORDEREDSUBSET';
  package Test2::Compare::OrderedSubset;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/inref items/;use Carp qw/croak/;use Scalar::Util qw/reftype/;sub init {my$self=shift;if(my$ref=$self->{+INREF}){croak "Cannot specify both 'inref' and 'items'" if$self->{+ITEMS};croak "'inref' must be an array reference, got '$ref'" unless reftype($ref)eq 'ARRAY';$self->{+ITEMS}=[@{$self->{+INREF}}]}$self->{+ITEMS}||= [];$self->SUPER::init()}sub name {'<ORDERED SUBSET>'}sub verify {my$self=shift;my%params=@_;return 0 unless$params{exists};defined(my$got=$params{got})|| return 0;return 0 unless ref($got);return 0 unless reftype($got)eq 'ARRAY';return 1}sub add_item {my$self=shift;my$check=pop;push @{$self->{+ITEMS}}=>$check}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$state=0;my$items=$self->{+ITEMS};my$idx=0;for my$item (@$items){my$check=$convert->($item);my$i=$idx;my$found;while($i < @$got){my$val=$got->[$i++];next if$check->run(id=>[ARRAY=>$i],convert=>$convert,seen=>$seen,exists=>1,got=>$val,);$idx=$i;$found++;last}next if$found;push@deltas=>Test2::Compare::Delta->new(verified=>0,id=>['ARRAY','?'],check=>$check,dne=>'got',)}return@deltas}1;
TEST2_COMPARE_ORDEREDSUBSET

$fatpacked{"Test2/Compare/Pattern.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_PATTERN';
  package Test2::Compare::Pattern;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/pattern stringify_got/;use Test2::Compare::Negatable;use Carp qw/croak/;sub init {my$self=shift;croak "'pattern' is a required attribute" unless$self->{+PATTERN};$self->{+STRINGIFY_GOT}||= 0;$self->SUPER::init()}sub name {shift->{+PATTERN}.""}sub operator {shift->{+NEGATE}? '!~' : '=~'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined($got);return 0 if ref$got &&!$self->stringify_got;return$got !~ $self->{+PATTERN}if$self->{+NEGATE};return$got =~ $self->{+PATTERN}}1;
TEST2_COMPARE_PATTERN

$fatpacked{"Test2/Compare/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_REF';
  package Test2::Compare::Ref;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/input/;use Test2::Util::Ref qw/render_ref rtype/;use Scalar::Util qw/refaddr/;use Carp qw/croak/;sub init {my$self=shift;croak "'input' is a required attribute" unless$self->{+INPUT};croak "'input' must be a reference, got '" .$self->{+INPUT}."'" unless ref$self->{+INPUT};$self->SUPER::init()}sub operator {'=='}sub name {render_ref($_[0]->{+INPUT})}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;my$in=$self->{+INPUT};return 0 unless ref$in;return 0 unless ref$got;my$in_type=rtype($in);my$got_type=rtype($got);return 0 unless$in_type eq $got_type;return refaddr($in)==refaddr($got)}1;
TEST2_COMPARE_REF

$fatpacked{"Test2/Compare/Regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_REGEX';
  package Test2::Compare::Regex;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/input/;use Test2::Util::Ref qw/render_ref rtype/;use Carp qw/croak/;sub init {my$self=shift;croak "'input' is a required attribute" unless$self->{+INPUT};croak "'input' must be a regex , got '" .$self->{+INPUT}."'" unless rtype($self->{+INPUT})eq 'REGEXP';$self->SUPER::init()}sub stringify_got {1}sub operator {'eq'}sub name {"" .$_[0]->{+INPUT}}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;my$in=$self->{+INPUT};my$got_type=rtype($got)or return 0;return 0 unless$got_type eq 'REGEXP';return "$in" eq "$got"}1;
TEST2_COMPARE_REGEX

$fatpacked{"Test2/Compare/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_SCALAR';
  package Test2::Compare::Scalar;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/item/;use Carp qw/croak confess/;use Scalar::Util qw/reftype blessed/;sub init {my$self=shift;croak "'item' is a required attribute" unless defined$self->{+ITEM};$self->SUPER::init()}sub name {'<SCALAR>'}sub operator {'${...}'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 unless ref($got);return 0 unless reftype($got)eq 'SCALAR' || reftype($got)eq 'VSTRING';return 1}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my$item=$self->{+ITEM};my$check=$convert->($item);return ($check->run(id=>['SCALAR'=>'$*'],got=>$$got,convert=>$convert,seen=>$seen,exists=>1,),)}1;
TEST2_COMPARE_SCALAR

$fatpacked{"Test2/Compare/Set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_SET';
  package Test2::Compare::Set;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/checks _reduction/;use Test2::Compare::Delta();use Carp qw/croak confess/;use Scalar::Util qw/reftype/;sub init {my$self=shift;my$reduction=delete$self->{reduction}|| 'any';$self->{+CHECKS}||= [];$self->set_reduction($reduction);$self->SUPER::init()}sub name {'<CHECK-SET>'}sub operator {$_[0]->{+_REDUCTION}}sub reduction {$_[0]->{+_REDUCTION}}my%VALID=(any=>1,all=>1,none=>1);sub set_reduction {my$self=shift;my ($redu)=@_;croak "'$redu' is not a valid set reduction" unless$VALID{$redu};$self->{+_REDUCTION}=$redu}sub verify {my$self=shift;my%params=@_;return 1}sub add_check {my$self=shift;push @{$self->{+CHECKS}}=>@_}sub deltas {my$self=shift;my%params=@_;my$checks=$self->{+CHECKS};my$reduction=$self->{+_REDUCTION};my$convert=$params{convert};unless ($checks && @$checks){my$file=$self->file;my$lines=$self->lines;my$extra="";if ($file and $lines and @$lines){my$lns=(@$lines > 1 ? 'lines ' : 'line ').join ', ',@$lines;$extra=" (Set defined in $file $lns)"}die "No checks defined for set$extra\n"}my@deltas;my$i=0;for my$check (@$checks){my$c=$convert->($check);my$id=[META=>"Check " .$i++];my@d=$c->run(%params,id=>$id);if ($reduction eq 'any'){return ()unless@d;push@deltas=>@d}elsif ($reduction eq 'all'){push@deltas=>@d}elsif ($reduction eq 'none'){push@deltas=>Test2::Compare::Delta->new(verified=>0,id=>$id,got=>$params{got},check=>$c,)unless@d}else {die "Invalid reduction: $reduction\n"}}return@deltas}1;
TEST2_COMPARE_SET

$fatpacked{"Test2/Compare/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_STRING';
  package Test2::Compare::String;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/input/;use Test2::Compare::Negatable;sub stringify_got {1}sub init {my$self=shift;confess "input must be defined for 'String' check" unless defined$self->{+INPUT};$self->SUPER::init(@_)}sub name {my$self=shift;my$in=$self->{+INPUT};return "$in"}sub operator {my$self=shift;return '' unless @_;my ($got)=@_;return '' unless defined($got);return 'ne' if$self->{+NEGATE};return 'eq'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;my$input=$self->{+INPUT};my$negate=$self->{+NEGATE};return "$input" ne "$got" if$negate;return "$input" eq "$got"}1;
TEST2_COMPARE_STRING

$fatpacked{"Test2/Compare/Undef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_UNDEF';
  package Test2::Compare::Undef;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase;use Test2::Compare::Negatable;sub name {'<UNDEF>'}sub operator {my$self=shift;return 'IS NOT' if$self->{+NEGATE};return 'IS'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return!defined($got)unless$self->{+NEGATE};return defined($got)}1;
TEST2_COMPARE_UNDEF

$fatpacked{"Test2/Compare/Wildcard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_WILDCARD';
  package Test2::Compare::Wildcard;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000122';use Test2::Util::HashBase qw/expect/;use Carp qw/croak/;sub init {my$self=shift;croak "'expect' is a require attribute" unless exists$self->{+EXPECT};$self->SUPER::init()}1;
TEST2_COMPARE_WILDCARD

$fatpacked{"Test2/Event/Times.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_TIMES';
  package Test2::Event::Times;use strict;use warnings;BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase qw/-start -stop -user -sys -cuser -csys/;use Test2::Util::Times qw/render_bench/;our$VERSION='0.000122';sub summary {my$self=shift;return render_bench(@{$self}{(START,STOP,USER,SYS,CUSER,CSYS)})}sub facet_data {my$self=shift;my$data=$self->SUPER::facet_data();$data->{times}={START()=>$self->{+START},STOP()=>$self->{+STOP},USER()=>$self->{+USER},SYS()=>$self->{+SYS},CUSER()=>$self->{+CUSER},CSYS()=>$self->{+CSYS},};return$data}1;
TEST2_EVENT_TIMES

$fatpacked{"Test2/Manual.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL';
  package Test2::Manual;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL

$fatpacked{"Test2/Manual/Anatomy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY';
  package Test2::Manual::Anatomy;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_ANATOMY

$fatpacked{"Test2/Manual/Anatomy/API.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_API';
  package Test2::Manual::Anatomy::API;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_ANATOMY_API

$fatpacked{"Test2/Manual/Anatomy/Context.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_CONTEXT';
  package Test2::Manual::Anatomy::Context;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_ANATOMY_CONTEXT

$fatpacked{"Test2/Manual/Anatomy/EndToEnd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_ENDTOEND';
  package Test2::Manual::Anatomy::EndToEnd;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_ANATOMY_ENDTOEND

$fatpacked{"Test2/Manual/Anatomy/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_EVENT';
  package Test2::Manual::Anatomy::Event;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_ANATOMY_EVENT

$fatpacked{"Test2/Manual/Anatomy/Hubs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_HUBS';
  package Test2::Manual::Anatomy::Hubs;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_ANATOMY_HUBS

$fatpacked{"Test2/Manual/Anatomy/IPC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_IPC';
  package Test2::Manual::Anatomy::IPC;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_ANATOMY_IPC

$fatpacked{"Test2/Manual/Anatomy/Utilities.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_UTILITIES';
  package Test2::Manual::Anatomy::Utilities;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_ANATOMY_UTILITIES

$fatpacked{"Test2/Manual/Concurrency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_CONCURRENCY';
  
TEST2_MANUAL_CONCURRENCY

$fatpacked{"Test2/Manual/Contributing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_CONTRIBUTING';
  package Test2::Manual::Contributing;our$VERSION='0.000122';1;
TEST2_MANUAL_CONTRIBUTING

$fatpacked{"Test2/Manual/Testing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING';
  package Test2::Manual::Testing;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_TESTING

$fatpacked{"Test2/Manual/Testing/Introduction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING_INTRODUCTION';
  package Test2::Manual::Testing::Introduction;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_TESTING_INTRODUCTION

$fatpacked{"Test2/Manual/Testing/Migrating.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING_MIGRATING';
  package Test2::Manual::Testing::Migrating;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_TESTING_MIGRATING

$fatpacked{"Test2/Manual/Testing/Planning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING_PLANNING';
  package Test2::Manual::Testing::Planning;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_TESTING_PLANNING

$fatpacked{"Test2/Manual/Testing/Todo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING_TODO';
  package Test2::Manual::Testing::Todo;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_TESTING_TODO

$fatpacked{"Test2/Manual/Tooling.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING';
  package Test2::Manual::Tooling;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING

$fatpacked{"Test2/Manual/Tooling/FirstTool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_FIRSTTOOL';
  package Test2::Manual::Tooling::FirstTool;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_FIRSTTOOL

$fatpacked{"Test2/Manual/Tooling/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_FORMATTER';
  package Test2::Manual::Tooling::Formatter;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_FORMATTER

$fatpacked{"Test2/Manual/Tooling/Nesting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_NESTING';
  package Test2::Manual::Tooling::Nesting;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_NESTING

$fatpacked{"Test2/Manual/Tooling/Plugin/TestExit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_PLUGIN_TESTEXIT';
  package Test2::Manual::Tooling::Plugin::TestExit;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_PLUGIN_TESTEXIT

$fatpacked{"Test2/Manual/Tooling/Plugin/TestingDone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_PLUGIN_TESTINGDONE';
  package Test2::Manual::Tooling::Plugin::TestingDone;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_PLUGIN_TESTINGDONE

$fatpacked{"Test2/Manual/Tooling/Plugin/ToolCompletes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_PLUGIN_TOOLCOMPLETES';
  package Test2::Manual::Tooling::Plugin::ToolCompletes;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_PLUGIN_TOOLCOMPLETES

$fatpacked{"Test2/Manual/Tooling/Plugin/ToolStarts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_PLUGIN_TOOLSTARTS';
  package Test2::Manual::Tooling::Plugin::ToolStarts;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_PLUGIN_TOOLSTARTS

$fatpacked{"Test2/Manual/Tooling/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_SUBTEST';
  package Test2::Manual::Tooling::Subtest;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_SUBTEST

$fatpacked{"Test2/Manual/Tooling/TestBuilder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_TESTBUILDER';
  package Test2::Manual::Tooling::TestBuilder;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_TESTBUILDER

$fatpacked{"Test2/Manual/Tooling/Testing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_TESTING';
  package Test2::Manual::Tooling::Testing;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_MANUAL_TOOLING_TESTING

$fatpacked{"Test2/Mock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MOCK';
  package Test2::Mock;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak confess/;our@CARP_NOT=(__PACKAGE__);use Scalar::Util qw/weaken reftype blessed/;use Test2::Util qw/pkg_to_file/;use Test2::Util::Stash qw/parse_symbol slot_to_sig get_symbol get_stash purge_symbol/;use Test2::Util::Sub qw/gen_accessor gen_reader gen_writer/;sub new;use Test2::Util::HashBase qw/class parent child _purge_on_destroy _blocked_load _symbols _track sub_tracking call_tracking/;sub new {my$class=shift;croak "Called new() on a blessed instance, did you mean to call \$control->class->new()?" if blessed($class);my$self=bless({},$class);$self->{+SUB_TRACKING}||= {};$self->{+CALL_TRACKING}||= [];my@sets;while (my$arg=shift @_){my$val=shift @_;if ($class->can(uc($arg))){$self->{$arg}=$val;next}push@sets=>[$arg,$val]}croak "The 'class' field is required" unless$self->{+CLASS};for my$set (@sets){my ($meth,$val)=@$set;my$type=reftype($val);confess "'$meth' is not a valid constructor argument for $class" unless$self->can($meth);if (!$type){$self->$meth($val)}elsif($type eq 'HASH'){$self->$meth(%$val)}elsif($type eq 'ARRAY'){$self->$meth(@$val)}else {croak "'$val' is not a valid argument for '$meth'"}}return$self}sub _check {return unless $_[0]->{+CHILD};croak "There is an active child controller, cannot proceed"}sub purge_on_destroy {my$self=shift;($self->{+_PURGE_ON_DESTROY})=@_ if @_;return$self->{+_PURGE_ON_DESTROY}}sub stash {my$self=shift;get_stash($self->{+CLASS})}sub file {my$self=shift;my$file=$self->class;return pkg_to_file($self->class)}sub block_load {my$self=shift;$self->_check();my$file=$self->file;croak "Cannot block the loading of module '" .$self->class ."', already loaded in file $INC{$file}" if$INC{$file};$INC{$file}=__FILE__;$self->{+_BLOCKED_LOAD}=1}my%NEW=(hash=>sub {my ($class,%params)=@_;return bless \%params,$class},array=>sub {my ($class,@params)=@_;return bless \@params,$class},ref=>sub {my ($class,$params)=@_;return bless$params,$class},ref_copy=>sub {my ($class,$params)=@_;my$type=reftype($params);return bless {%$params},$class if$type eq 'HASH';return bless [@$params],$class if$type eq 'ARRAY';croak "Not sure how to construct an '$class' from '$params'"},);sub override_constructor {my$self=shift;my ($name,$type)=@_;$self->_check();my$sub=$NEW{$type}|| croak "'$type' is not a known constructor type";$self->override($name=>$sub)}sub add_constructor {my$self=shift;my ($name,$type)=@_;$self->_check();my$sub=$NEW{$type}|| croak "'$type' is not a known constructor type";$self->add($name=>$sub)}sub autoload {my$self=shift;$self->_check();my$class=$self->class;my$stash=$self->stash;croak "Class '$class' already has an AUTOLOAD" if$stash->{AUTOLOAD}&& *{$stash->{AUTOLOAD}}{CODE};croak "Class '$class' already has an can" if$stash->{can}&& *{$stash->{can}}{CODE};weaken(my$c=$self);my ($file,$line)=(__FILE__,__LINE__ + 3);my$autoload=eval <<EOT || die "Failed generating AUTOLOAD sub: $@";$line=__LINE__ + 3;my$can=eval <<EOT || die "Failed generating can method: $@";{local$self->{+_TRACK}=0;$self->add(AUTOLOAD=>$autoload);$self->add(can=>$can)}}sub before {my$self=shift;my ($name,$sub)=@_;$self->_check();my$orig=$self->current($name);$self->_inject({},$name=>sub {$sub->(@_);$orig->(@_)})}sub after {my$self=shift;my ($name,$sub)=@_;$self->_check();my$orig=$self->current($name);$self->_inject({},$name=>sub {my@out;my$want=wantarray;if ($want){@out=$orig->(@_)}elsif(defined$want){$out[0]=$orig->(@_)}else {$orig->(@_)}$sub->(@_);return@out if$want;return$out[0]if defined$want;return})}sub around {my$self=shift;my ($name,$sub)=@_;$self->_check();my$orig=$self->current($name);$self->_inject({},$name=>sub {$sub->($orig,@_)})}sub add {my$self=shift;$self->_check();$self->_inject({add=>1},@_)}sub override {my$self=shift;$self->_check();$self->_inject({},@_)}sub set {my$self=shift;$self->_check();$self->_inject({set=>1},@_)}sub current {my$self=shift;my ($sym)=@_;return get_symbol($sym,$self->{+CLASS})}sub orig {my$self=shift;my ($sym)=@_;$sym="&$sym" unless$sym =~ m/^[&\$\%\@]/;my$syms=$self->{+_SYMBOLS}or croak "No symbols have been mocked yet";my$ref=$syms->{$sym};croak "Symbol '$sym' is not mocked" unless$ref && @$ref;my ($orig)=@$ref;return$orig}sub track {my$self=shift;($self->{+_TRACK})=@_ if @_;return$self->{+_TRACK}}sub clear_call_tracking {@{shift->{+CALL_TRACKING}}=()}sub clear_sub_tracking {my$self=shift;unless (@_){%{$self->{+SUB_TRACKING}}=();return}for my$item (@_){delete$self->{+SUB_TRACKING}->{$item}}return}sub _parse_inject {my$self=shift;my ($param,$arg)=@_;if ($param =~ m/^-(.*)$/){my$sym=$1;my$sig=slot_to_sig(reftype($arg));my$ref=$arg;return ($sig,$sym,$ref)}return ('&',$param,$arg)if ref($arg)&& reftype($arg)eq 'CODE';my ($is,$field,$val);if(defined($arg)&&!ref($arg)&& $arg =~ m/^(rw|ro|wo)$/){$is=$arg;$field=$param}elsif (!ref($arg)){$val=$arg;$is='val'}elsif (reftype($arg)eq 'HASH'){$field=delete$arg->{field}|| $param;$val=delete$arg->{val};$is=delete$arg->{is};croak "Cannot specify 'is' and 'val' together" if$val && $is;$is ||= $val ? 'val' : 'rw';croak "The following keys are not valid when defining a mocked sub with a hashref: " .join(", "=>keys %$arg)if keys %$arg}else {confess "'$arg' is not a valid argument when defining a mocked sub"}my$sub;if ($is eq 'rw'){$sub=gen_accessor($field)}elsif ($is eq 'ro'){$sub=gen_reader($field)}elsif ($is eq 'wo'){$sub=gen_writer($field)}else {$sub=sub {$val}}return ('&',$param,$sub)}sub _inject {my$self=shift;my ($params,@pairs)=@_;my$add=$params->{add};my$set=$params->{set};my$class=$self->{+CLASS};$self->{+_SYMBOLS}||= {};my$syms=$self->{+_SYMBOLS};while (my$param=shift@pairs){my$arg=shift@pairs;my ($sig,$sym,$ref)=$self->_parse_inject($param,$arg);my$orig=$self->current("$sig$sym");croak "Cannot override '$sig$class\::$sym', symbol is not already defined" unless$orig || $add || $set || ($sig eq '&' && $class->can($sym));croak "Cannot add '$sig$class\::$sym', symbol is already defined" if$add && $orig && (reftype($orig)ne 'SCALAR' || defined($$orig));$syms->{"$sig$sym"}||= [];push @{$syms->{"$sig$sym"}}=>$orig;if ($self->{+_TRACK}&& $sig eq '&'){my$sub_tracker=$self->{+SUB_TRACKING};my$call_tracker=$self->{+CALL_TRACKING};my$sub=$ref;$ref=sub {my$call={sub_name=>$sym,sub_ref=>$sub,args=>[@_]};push @{$sub_tracker->{$param}}=>$call;push @$call_tracker=>$call;goto &$sub}}no strict 'refs';no warnings 'redefine';*{"$class\::$sym"}=$ref}return}sub _set_or_unset {my$self=shift;my ($symbol,$set)=@_;my$class=$self->{+CLASS};return purge_symbol($symbol,$class)unless$set;my$sym=parse_symbol($symbol,$class);no strict 'refs';no warnings 'redefine';*{"$class\::$sym->{name}"}=$set}sub restore {my$self=shift;my ($sym)=@_;$self->_check();$sym="&$sym" unless$sym =~ m/^[&\$\%\@]/;my$syms=$self->{+_SYMBOLS}or croak "No symbols are mocked";my$ref=$syms->{$sym};croak "Symbol '$sym' is not mocked" unless$ref && @$ref;my$old=pop @$ref;delete$syms->{$sym}unless @$ref;return$self->_set_or_unset($sym,$old)}sub reset {my$self=shift;my ($sym)=@_;$self->_check();$sym="&$sym" unless$sym =~ m/^[&\$\%\@]/;my$syms=$self->{+_SYMBOLS}or croak "No symbols are mocked";my$ref=delete$syms->{$sym};croak "Symbol '$sym' is not mocked" unless$ref && @$ref;my ($old)=@$ref;return$self->_set_or_unset($sym,$old)}sub reset_all {my$self=shift;$self->_check();my$syms=$self->{+_SYMBOLS}|| return;$self->reset($_)for keys %$syms;delete$self->{+_SYMBOLS}}sub _purge {my$self=shift;my$stash=$self->stash;delete$stash->{$_}for keys %$stash}sub DESTROY {my$self=shift;delete$self->{+CHILD};$self->reset_all if$self->{+_SYMBOLS};delete$INC{$self->file}if$self->{+_BLOCKED_LOAD};$self->_purge if$self->{+_PURGE_ON_DESTROY}}1;
  package $class;
  #line $line "$file (Generated AUTOLOAD)"
  our \$AUTOLOAD;
      sub {
          my (\$self) = \@_;
          my (\$pkg, \$name) = (\$AUTOLOAD =~ m/^(.*)::([^:]+)\$/g);
          \$AUTOLOAD = undef;
  
          return if \$name eq 'DESTROY';
          my \$sub = sub {
              my \$self = shift;
              (\$self->{\$name}) = \@_ if \@_;
              return \$self->{\$name};
          };
  
          \$c->add(\$name => \$sub);
  
          if (\$c->{_track}) {
              my \$call = {sub_name => \$name, sub_ref => \$sub, args => [\@_]};
              push \@{\$c->{sub_tracking}->{\$name}} => \$call;
              push \@{\$c->{call_tracking}} => \$call;
          }
  
          goto &\$sub;
      }
  EOT
  package $class;
  #line $line "$file (Generated can)"
      sub {
          my (\$self, \$meth) = \@_;
          if (\$self->SUPER::can(\$meth)) {
              return \$self->SUPER::can(\$meth);
          }
          elsif (exists \$self->{\$meth}) {
              return sub { shift->\$meth(\@_) };
          }
          return undef;
      }
  EOT
TEST2_MOCK

$fatpacked{"Test2/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN';
  package Test2::Plugin;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_PLUGIN

$fatpacked{"Test2/Plugin/BailOnFail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_BAILONFAIL';
  package Test2::Plugin::BailOnFail;use strict;use warnings;our$VERSION='0.000122';use Test2::API qw/test2_add_callback_context_release/;my$LOADED=0;sub import {return if$LOADED++;test2_add_callback_context_release(sub {my$ctx=shift;return if$ctx->hub->is_passing;$ctx->bail("(Bail On Fail)")})}1;
TEST2_PLUGIN_BAILONFAIL

$fatpacked{"Test2/Plugin/DieOnFail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_DIEONFAIL';
  package Test2::Plugin::DieOnFail;use strict;use warnings;our$VERSION='0.000122';use Test2::API qw/test2_add_callback_context_release/;my$LOADED=0;sub import {return if$LOADED++;test2_add_callback_context_release(sub {my$ctx=shift;return if$ctx->hub->is_passing;$ctx->throw("(Die On Fail)")})}1;
TEST2_PLUGIN_DIEONFAIL

$fatpacked{"Test2/Plugin/ExitSummary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_EXITSUMMARY';
  package Test2::Plugin::ExitSummary;use strict;use warnings;our$VERSION='0.000122';use Test2::API qw/test2_add_callback_exit/;my$ADDED_HOOK=0;sub import {test2_add_callback_exit(\&summary)unless$ADDED_HOOK++}sub active {$ADDED_HOOK}sub summary {my ($ctx,$real,$new)=@_;return if$INC{'Test/Builder.pm'};my$hub=$ctx->hub;my$plan=$hub->plan;my$count=$hub->count;my$failed=$hub->failed;$ctx->diag('No tests run!')if!$count && (!$plan || $plan ne 'SKIP');$ctx->diag('Tests were run but no plan was declared and done_testing() was not seen.')if$count &&!$plan;$ctx->diag("Looks like your test exited with $real after test #$count.")if$real;$ctx->diag("Did not follow plan: expected $plan, ran $count.")if$plan && $plan =~ m/^[0-9]+$/ && defined$count && $count!=$plan}1;
TEST2_PLUGIN_EXITSUMMARY

$fatpacked{"Test2/Plugin/SRand.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_SRAND';
  package Test2::Plugin::SRand;use strict;use warnings;our$VERSION='0.000122';use Carp qw/carp/;use Test2::API qw{context test2_add_callback_post_load test2_add_callback_exit test2_stack};my$ADDED_HOOK=0;my$SEED;my$FROM;sub seed {$SEED}sub from {$FROM}sub import {my$class=shift;carp "SRand loaded multiple times, re-seeding rand" if defined$SEED;if (@_){($SEED)=@_;$FROM='import arg'}elsif(exists$ENV{T2_RAND_SEED}){$SEED=$ENV{T2_RAND_SEED};$FROM='environment variable'}else {my@ltime=localtime;$SEED=sprintf('%04d%02d%02d',1900 + $ltime[5],1 + $ltime[4],$ltime[3]);$FROM='local date'}$SEED=0 unless$SEED;srand($SEED);if ($ENV{HARNESS_IS_VERBOSE}||!$ENV{HARNESS_ACTIVE}){test2_add_callback_post_load(sub {test2_stack()->top;my ($hub)=test2_stack()->all;$hub->send(Test2::Event::Note->new(trace=>Test2::Util::Trace->new(frame=>[__PACKAGE__,__FILE__,__LINE__,'SRAND']),message=>"Seeded srand with seed '$SEED' from $FROM.",))})}elsif (!$ADDED_HOOK++){test2_add_callback_exit(sub {my ($ctx,$real,$new)=@_;$ctx->diag("Seeded srand with seed '$SEED' from $FROM.")if$real || ($new && $$new)||!$ctx->hub->is_passing})}}1;
TEST2_PLUGIN_SRAND

$fatpacked{"Test2/Plugin/Times.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_TIMES';
  package Test2::Plugin::Times;use strict;use warnings;use Test2::Util::Times qw/render_bench/;use Test2::API qw{test2_add_callback_exit};use Time::HiRes qw/time/;our$VERSION='0.000122';sub import {my$start=time;test2_add_callback_exit(sub {my ($ctx,$real,$new)=@_;my$stop=time;my@times=times();$ctx->send_event('Times',start=>$start,stop=>$stop,user=>$times[0],sys=>$times[1],cuser=>$times[2],csys=>$times[3],)})}1;
TEST2_PLUGIN_TIMES

$fatpacked{"Test2/Plugin/UTF8.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_UTF8';
  package Test2::Plugin::UTF8;use strict;use warnings;our$VERSION='0.000122';use Test2::API qw{test2_add_callback_post_load test2_stack};sub import {my$class=shift;require utf8;utf8->import;test2_add_callback_post_load(sub {my$stack=test2_stack;$stack->top;my$warned=0;for my$hub ($stack->all){my$format=$hub->format || next;unless ($format->can('encoding')){warn "Could not apply UTF8 to unknown formatter ($format)\n" unless$warned++;next}$format->encoding('utf8')}})}1;
TEST2_PLUGIN_UTF8

$fatpacked{"Test2/Require.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE';
  package Test2::Require;use strict;use warnings;our$VERSION='0.000122';use Test2::API qw/context/;use Carp qw/croak/;sub skip {my$class=shift;croak "Class '$class' needs to implement 'skip()'"}sub import {my$class=shift;return if$class eq __PACKAGE__;my$skip=$class->skip(@_);return unless defined$skip;my$ctx=context();$ctx->plan(0,SKIP=>$skip || "No reason given.");$ctx->release}1;
TEST2_REQUIRE

$fatpacked{"Test2/Require/AuthorTesting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_AUTHORTESTING';
  package Test2::Require::AuthorTesting;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000122';sub skip {my$class=shift;return undef if$ENV{'AUTHOR_TESTING'};return 'Author test, set the $AUTHOR_TESTING environment variable to run it'}1;
TEST2_REQUIRE_AUTHORTESTING

$fatpacked{"Test2/Require/EnvVar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_ENVVAR';
  package Test2::Require::EnvVar;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Require';our$VERSION='0.000122';sub skip {my$class=shift;my ($var)=@_;confess "no environment variable specified" unless$var;return undef if$ENV{$var};return "This test only runs if the \$$var environment variable is set"}1;
TEST2_REQUIRE_ENVVAR

$fatpacked{"Test2/Require/Fork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_FORK';
  package Test2::Require::Fork;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000122';use Test2::Util qw/CAN_FORK/;sub skip {return undef if CAN_FORK;return "This test requires a perl capable of forking."}1;
TEST2_REQUIRE_FORK

$fatpacked{"Test2/Require/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_MODULE';
  package Test2::Require::Module;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000122';use Test2::Util qw/pkg_to_file/;sub skip {my$class=shift;my ($module,$ver)=@_;return "Module '$module' is not installed" unless check_installed($module);return undef unless defined$ver;return check_version($module,$ver)}sub check_installed {my ($mod)=@_;my$file=pkg_to_file($mod);return 1 if eval {require$file;1};my$error=$@;return 0 if$error =~ m/Can't locate \Q$file\E in \@INC/;die$error}sub check_version {my ($mod,$ver)=@_;return undef if eval {$mod->VERSION($ver);1};my$have=$mod->VERSION;return "Need '$mod' version $ver, have $have."}1;
TEST2_REQUIRE_MODULE

$fatpacked{"Test2/Require/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_PERL';
  package Test2::Require::Perl;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000122';use Test2::Util qw/pkg_to_file/;use Scalar::Util qw/reftype/;sub skip {my$class=shift;my ($ver)=@_;return undef if eval "no warnings 'portable'; require $ver; 1";my$error=$@;return $1 if$error =~ m/^(Perl \S* required)/i;die$error}1;
TEST2_REQUIRE_PERL

$fatpacked{"Test2/Require/RealFork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_REALFORK';
  package Test2::Require::RealFork;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000122';use Test2::Util qw/CAN_REALLY_FORK/;sub skip {return undef if CAN_REALLY_FORK;return "This test requires a perl capable of true forking."}1;
TEST2_REQUIRE_REALFORK

$fatpacked{"Test2/Require/Threads.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_THREADS';
  package Test2::Require::Threads;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000122';use Test2::Util qw/CAN_THREAD/;sub skip {return undef if CAN_THREAD;return "This test requires a perl capable of threading."}1;
TEST2_REQUIRE_THREADS

$fatpacked{"Test2/Suite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_SUITE';
  package Test2::Suite;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_SUITE

$fatpacked{"Test2/Todo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TODO';
  package Test2::Todo;use strict;use warnings;use Carp qw/croak/;use Test2::Util::HashBase qw/hub _filter reason/;use Test2::API qw/test2_stack/;use overload '""'=>\&reason,fallback=>1;our$VERSION='0.000122';sub init {my$self=shift;my$reason=$self->{+REASON};croak "The 'reason' attribute is required" unless defined$reason;my$hub=$self->{+HUB}||= test2_stack->top;$self->{+_FILTER}=$hub->pre_filter(sub {my ($active_hub,$event)=@_;return Test2::Event::Note->new(%$event)if ref($event)eq 'Test2::Event::Diag';if ($active_hub==$hub){$event->set_todo($reason)if$event->can('set_todo');$event->add_amnesty({tag=>'TODO',details=>$reason});$event->set_effective_pass(1)if$event->isa('Test2::Event::Ok')}else {$event->add_amnesty({tag=>'TODO',details=>$reason,inherited=>1})}return$event},inherit=>1,todo=>$reason,)}sub end {my$self=shift;my$hub=$self->{+HUB}or return;$hub->pre_unfilter($self->{+_FILTER});delete$self->{+HUB};delete$self->{+_FILTER}}sub DESTROY {my$self=shift;$self->end}1;
TEST2_TODO

$fatpacked{"Test2/Tools.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS';
  package Test2::Tools;use strict;use warnings;our$VERSION='0.000122';1;
TEST2_TOOLS

$fatpacked{"Test2/Tools/AsyncSubtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_ASYNCSUBTEST';
  package Test2::Tools::AsyncSubtest;use strict;use warnings;our$VERSION='0.000122';use Test2::IPC;use Test2::AsyncSubtest;use Test2::API qw/context/;use Carp qw/croak/;our@EXPORT=qw/async_subtest fork_subtest thread_subtest/;use base 'Exporter';sub async_subtest {my$name=shift;my ($params,$code);$params=shift(@_)if @_ && ref($_[0])eq 'HASH';$code=shift(@_)if @_ && ref($_[0])eq 'CODE';my$ctx=context();my$subtest=Test2::AsyncSubtest->new(name=>$name,context=>1,hub_init_args=>$params);$subtest->run($code,$subtest)if$code;$ctx->release;return$subtest}sub fork_subtest {my$name=shift;my ($params,$code);$params=shift(@_)if @_ && ref($_[0])eq 'HASH';$code=shift(@_)if @_ && ref($_[0])eq 'CODE';my$ctx=context();croak "fork_subtest requires a CODE reference as the second argument" unless ref($code)eq 'CODE';my$subtest=Test2::AsyncSubtest->new(name=>$name,context=>1,hub_init_args=>$params);$subtest->run_fork($code,$subtest);$ctx->release;return$subtest}sub thread_subtest {my$name=shift;my ($params,$code);$params=shift(@_)if @_ && ref($_[0])eq 'HASH';$code=shift(@_)if @_ && ref($_[0])eq 'CODE';my$ctx=context();croak "thread_subtest requires a CODE reference as the second argument" unless ref($code)eq 'CODE';my$subtest=Test2::AsyncSubtest->new(name=>$name,context=>1,hub_init_args=>$params);$subtest->run_thread($code,$subtest);$ctx->release;return$subtest}1;
TEST2_TOOLS_ASYNCSUBTEST

$fatpacked{"Test2/Tools/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_BASIC';
  package Test2::Tools::Basic;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak/;use Test2::API qw/context/;our@EXPORT=qw{ok pass fail diag note todo skip plan skip_all done_testing bail_out};use base 'Exporter';sub ok($;$@) {my ($bool,$name,@diag)=@_;my$ctx=context();$ctx->ok($bool,$name,\@diag);$ctx->release;return$bool ? 1 : 0}sub pass {my ($name)=@_;my$ctx=context();$ctx->ok(1,$name);$ctx->release;return 1}sub fail {my ($name,@diag)=@_;my$ctx=context();$ctx->ok(0,$name,\@diag);$ctx->release;return 0}sub diag {my$ctx=context();$ctx->diag(join '',grep {defined $_}@_);$ctx->release}sub note {my$ctx=context();$ctx->note(join '',grep {defined $_}@_);$ctx->release}sub todo {my$reason=shift;my$code=shift;require Test2::Todo unless$INC{'Test2/Todo.pm'};my$todo=Test2::Todo->new(reason=>$reason);return$code->()if$code;croak "Cannot use todo() in a void context without a codeblock" unless defined wantarray;return$todo}sub skip {my ($why,$num)=@_;$num ||= 1;my$ctx=context();$ctx->skip("skipped test",$why)for 1 .. $num;$ctx->release;no warnings 'exiting';last SKIP}sub plan {my$plan=shift;my$ctx=context();if ($plan && $plan =~ m/[^0-9]/){if ($plan eq 'tests'){$plan=shift}elsif ($plan eq 'skip_all'){skip_all(@_);$ctx->release;return}}$ctx->plan($plan);$ctx->release}sub skip_all {my ($reason)=@_;my$ctx=context();$ctx->plan(0,SKIP=>$reason);$ctx->release if$ctx}sub done_testing {my$ctx=context();$ctx->hub->finalize($ctx->trace,1);$ctx->release}sub bail_out {my ($reason)=@_;my$ctx=context();$ctx->bail($reason);$ctx->release if$ctx}1;
TEST2_TOOLS_BASIC

$fatpacked{"Test2/Tools/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_CLASS';
  package Test2::Tools::Class;use strict;use warnings;our$VERSION='0.000122';use Test2::API qw/context/;use Test2::Util::Ref qw/render_ref/;use Scalar::Util qw/blessed/;our@EXPORT=qw/can_ok isa_ok DOES_ok/;use base 'Exporter';BEGIN {for my$op (qw/isa can DOES/){my$sub=sub($;@) {my ($thing,@args)=@_;my$ctx=context();my (@items,$name);if (ref($args[0])eq 'ARRAY'){$name=$args[1];@items=@{$args[0]}}else {@items=@args}my$thing_name=ref($thing)? render_ref($thing): defined($thing)? "$thing" : "<undef>";$thing_name =~ s/\n/\\n/g;$thing_name =~ s/#//g;$thing_name =~ s/\(0x[a-f0-9]+\)//gi;$name ||= @items==1 ? "$thing_name\->$op('$items[0]')" : "$thing_name\->$op(...)";unless (defined($thing)&& (blessed($thing)||!ref($thing)&& length($thing))){my$thing=defined($thing)? ref($thing)|| "'$thing'" : '<undef>';$ctx->ok(0,$name,["$thing is neither a blessed reference or a package name."]);$ctx->release;return 0}unless(UNIVERSAL->can($op)|| $thing->can($op)){$ctx->skip($name,"'$op' is not supported on this platform");$ctx->release;return 1}my$file=$ctx->trace->file;my$line=$ctx->trace->line;my@bad;for my$item (@items){my ($bool,$ok,$err);{local ($@,$!);$ok=eval qq/#line $line "$file"\n\$bool = \$thing->$op(\$item); 1/;$err=$@}die$err unless$ok;next if$bool;push@bad=>$item}$ctx->ok(!@bad,$name,[map {"Failed: $thing_name\->$op('$_')"}@bad]);$ctx->release;return!@bad};no strict 'refs';*{$op ."_ok"}=$sub}}1;
TEST2_TOOLS_CLASS

$fatpacked{"Test2/Tools/ClassicCompare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_CLASSICCOMPARE';
  package Test2::Tools::ClassicCompare;use strict;use warnings;our$VERSION='0.000122';our@EXPORT=qw/is is_deeply isnt like unlike cmp_ok/;use base 'Exporter';use Carp qw/carp/;use Scalar::Util qw/reftype/;use Test2::API qw/context/;use Test2::Compare qw/compare strict_convert/;use Test2::Util::Ref qw/rtype render_ref/;use Test2::Util::Table qw/table/;use Test2::Compare::Array();use Test2::Compare::Bag();use Test2::Compare::Custom();use Test2::Compare::Event();use Test2::Compare::Hash();use Test2::Compare::Meta();use Test2::Compare::Number();use Test2::Compare::Object();use Test2::Compare::OrderedSubset();use Test2::Compare::Pattern();use Test2::Compare::Ref();use Test2::Compare::Regex();use Test2::Compare::Scalar();use Test2::Compare::Set();use Test2::Compare::String();use Test2::Compare::Undef();use Test2::Compare::Wildcard();sub is($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my@caller=caller;my$delta=compare($got,$exp,\&is_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub isnt($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my@caller=caller;my$delta=compare($got,$exp,\&isnt_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub is_convert {my ($thing)=@_;return Test2::Compare::Undef->new()unless defined$thing;return Test2::Compare::String->new(input=>$thing)}sub isnt_convert {my ($thing)=@_;return Test2::Compare::Undef->new()unless defined$thing;my$str=Test2::Compare::String->new(input=>$thing,negate=>1)}sub like($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&like_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub unlike($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&unlike_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub like_convert {my ($thing)=@_;return Test2::Compare::Pattern->new(pattern=>$thing,stringify_got=>1,)}sub unlike_convert {my ($thing)=@_;return Test2::Compare::Pattern->new(negate=>1,stringify_got=>1,pattern=>$thing,)}sub is_deeply($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my@caller=caller;my$delta=compare($got,$exp,\&strict_convert);if ($delta){my$count=0;my$implicit=0;my@deltas=($delta);while (my$d=shift@deltas){my$add=$d->children;push@deltas=>@$add if$add && @$add;next if$d->verified;$count++;$implicit++ if$d->note && $d->note eq 'implicit end'}if ($implicit==$count){$ctx->ok(1,$name);my$meth=$ENV{AUTHOR_TESTING}? 'throw' : 'alert';my$type=$delta->render_check;$ctx->$meth(join "\n","!!! NOTICE OF BEHAVIOR CHANGE !!!","This test uses at least 1 $type check without using end() or etc().","The exising behavior is to default to etc() when inside is_deeply().","The new behavior is to default to end().","This test will soon start to fail with the following diagnostics:",$delta->diag,"",)}else {$ctx->fail($name,$delta->diag,@diag)}}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}our%OPS=('=='=>'num','!='=>'num','>='=>'num','<='=>'num','>'=>'num','<'=>'num','<=>'=>'num','eq'=>'str','ne'=>'str','gt'=>'str','lt'=>'str','ge'=>'str','le'=>'str','cmp'=>'str','!~'=>'str','=~'=>'str','&&'=>'logic','||'=>'logic','xor'=>'logic','or'=>'logic','and'=>'logic','//'=>'logic','&'=>'bitwise','|'=>'bitwise','~~'=>'match',);sub cmp_ok($$$;$@) {my ($got,$op,$exp,$name,@diag)=@_;my$ctx=context();my ($pkg,$file,$line)=caller;my$type=$OPS{$op};if (!$type){carp "operator '$op' is not supported (you can add it to %Test2::Tools::ClassicCompare::OPS)";$type='unsupported'}local ($@,$!,$SIG{__DIE__});my$test;my$lived=eval <<"    EOT";my$error=$@;$ctx->send_event('Exception',error=>$error)unless$lived;if ($test && $lived){$ctx->ok(1,$name);$ctx->release;return 1}my ($display_got,$display_exp);if($type eq 'str'){$display_got=defined($got)? "$got" : undef;$display_exp=defined($exp)? "$exp" : undef}elsif($type eq 'num'){$display_got=defined($got)? $got + 0 : undef;$display_exp=defined($exp)? $exp + 0 : undef}else {$display_got=$got;$display_exp=$exp}my$got_ref=ref($got)? render_ref($got): $got;my$exp_ref=ref($exp)? render_ref($exp): $exp;my@table;my$show_both=((defined($got)&& $got_ref ne "$display_got")|| (defined($exp)&& $exp_ref ne "$display_exp"));if ($show_both){@table=table(header=>['TYPE','GOT','OP','CHECK'],rows=>[[$type,$display_got,$op,$lived ? $display_exp : '<EXCEPTION>'],['orig',$got_ref,'',$exp_ref],],)}else {@table=table(header=>['GOT','OP','CHECK'],rows=>[[$display_got,$op,$lived ? $display_exp : '<EXCEPTION>']],)}$ctx->ok(0,$name,[join("\n",@table),@diag]);$ctx->release;return 0}1;
  #line $line "(eval in cmp_ok) $file"
  \$test = (\$got $op \$exp);
  1;
      EOT
TEST2_TOOLS_CLASSICCOMPARE

$fatpacked{"Test2/Tools/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_COMPARE';
  package Test2::Tools::Compare;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak/;use Scalar::Util qw/reftype/;use Test2::API qw/context/;use Test2::Util::Ref qw/rtype/;use Test2::Compare qw{compare get_build push_build pop_build build strict_convert relaxed_convert};use Test2::Compare::Array();use Test2::Compare::Bag();use Test2::Compare::Bool();use Test2::Compare::Custom();use Test2::Compare::Event();use Test2::Compare::Float();use Test2::Compare::Hash();use Test2::Compare::Meta();use Test2::Compare::Number();use Test2::Compare::Object();use Test2::Compare::OrderedSubset();use Test2::Compare::Pattern();use Test2::Compare::Ref();use Test2::Compare::DeepRef();use Test2::Compare::Regex();use Test2::Compare::Scalar();use Test2::Compare::Set();use Test2::Compare::String();use Test2::Compare::Undef();use Test2::Compare::Wildcard();%Carp::Internal=(%Carp::Internal,'Test2::Tools::Compare'=>1,'Test2::Compare::Array'=>1,'Test2::Compare::Bag'=>1,'Test2::Compare::Bool'=>1,'Test2::Compare::Custom'=>1,'Test2::Compare::Event'=>1,'Test2::Compare::Float'=>1,'Test2::Compare::Hash'=>1,'Test2::Compare::Meta'=>1,'Test2::Compare::Number'=>1,'Test2::Compare::Object'=>1,'Test2::Compare::Pattern'=>1,'Test2::Compare::Ref'=>1,'Test2::Compare::Regex'=>1,'Test2::Compare::Scalar'=>1,'Test2::Compare::Set'=>1,'Test2::Compare::String'=>1,'Test2::Compare::Undef'=>1,'Test2::Compare::Wildcard'=>1,'Test2::Compare::OrderedSubset'=>1,);our@EXPORT=qw/is like/;our@EXPORT_OK=qw{is like isnt unlike match mismatch validator hash array bag object meta meta_check number float rounded within string subset bool in_set not_in_set check_set item field call call_list call_hash prop check all_items all_keys all_vals all_values etc end filter_items T F D DF DNE FDNE E U event fail_events exact_ref};use base 'Exporter';sub is($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&strict_convert);if ($delta){my$count=0;my$implicit=0;my@deltas=($delta);while (my$d=shift@deltas){my$add=$d->children;push@deltas=>@$add if$add && @$add;next if$d->verified;$count++;$implicit++ if$d->note && $d->note eq 'implicit end'}if ($implicit==$count){$ctx->ok(1,$name);my$meth=$ENV{AUTHOR_TESTING}? 'throw' : 'alert';my$type=$delta->render_check;$ctx->$meth(join "\n","!!! NOTICE OF BEHAVIOR CHANGE !!!","This test uses at least 1 $type check without using end() or etc().","The old behavior was to default to etc() when inside is().","The old behavior was a bug.","The new behavior is to default to end().","This test will soon start to fail with the following diagnostics:",$delta->diag,"",)}else {$ctx->fail($name,$delta->diag,@diag)}}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub isnt($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&strict_convert);if ($delta){$ctx->ok(1,$name)}else {$ctx->ok(0,$name,["Comparison matched (it should not).",@diag])}$ctx->release;return$delta ? 1 : 0}sub like($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&relaxed_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub unlike($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&relaxed_convert);if ($delta){$ctx->ok(1,$name)}else {$ctx->ok(0,$name,["Comparison matched (it should not).",@diag])}$ctx->release;return$delta ? 1 : 0}sub meta(&) {build('Test2::Compare::Meta',@_)}sub meta_check(&) {build('Test2::Compare::Meta',@_)}sub hash(&) {build('Test2::Compare::Hash',@_)}sub array(&) {build('Test2::Compare::Array',@_)}sub bag(&) {build('Test2::Compare::Bag',@_)}sub object(&) {build('Test2::Compare::Object',@_)}sub subset(&) {build('Test2::Compare::OrderedSubset',@_)}sub U() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ ? 0 : 1},name=>'UNDEFINED',operator=>'!DEFINED()',file=>$caller[1],lines=>[$caller[2]],)}sub D() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ ? 1 : 0},name=>'DEFINED',operator=>'DEFINED()',file=>$caller[1],lines=>[$caller[2]],)}sub DF() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ && (!ref $_ &&!$_)? 1 : 0},name=>'DEFINED BUT FALSE',operator=>'DEFINED() && FALSE()',file=>$caller[1],lines=>[$caller[2]],)}sub DNE() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {my%p=@_;$p{exists}? 0 : 1},name=>'<DOES NOT EXIST>',operator=>'!exists',file=>$caller[1],lines=>[$caller[2]],)}sub E() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {my%p=@_;$p{exists}? 1 : 0},name=>'<DOES EXIST>',operator=>'!exists',file=>$caller[1],lines=>[$caller[2]],)}sub F() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {my%p=@_;$p{got}? 0 : $p{exists}},name=>'FALSE',operator=>'FALSE()',file=>$caller[1],lines=>[$caller[2]],)}sub FDNE() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ && (ref $_ || $_)? 0 : 1},name=>'FALSE',operator=>'FALSE() || !exists',file=>$caller[1],lines=>[$caller[2]],)}sub T() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ && (ref $_ || $_)? 1 : 0},name=>'TRUE',operator=>'TRUE()',file=>$caller[1],lines=>[$caller[2]],)}sub exact_ref($) {my@caller=caller;return Test2::Compare::Ref->new(file=>$caller[1],lines=>[$caller[2]],input=>$_[0],)}sub match($) {my@caller=caller;return Test2::Compare::Pattern->new(file=>$caller[1],lines=>[$caller[2]],pattern=>$_[0],)}sub mismatch($) {my@caller=caller;return Test2::Compare::Pattern->new(file=>$caller[1],lines=>[$caller[2]],negate=>1,pattern=>$_[0],)}sub validator {my$code=pop;my$cname=pop;my$op=pop;my@caller=caller;return Test2::Compare::Custom->new(file=>$caller[1],lines=>[$caller[2]],code=>$code,name=>$cname,operator=>$op,)}sub number($;@) {my ($num,@args)=@_;my@caller=caller;return Test2::Compare::Number->new(file=>$caller[1],lines=>[$caller[2]],input=>$num,@args,)}sub float($;@) {my ($num,@args)=@_;my@caller=caller;return Test2::Compare::Float->new(file=>$caller[1],lines=>[$caller[2]],input=>$num,@args,)}sub rounded($$) {my ($num,$precision)=@_;my@caller=caller;return Test2::Compare::Float->new(file=>$caller[1],lines=>[$caller[2]],input=>$num,precision=>$precision,)}sub within($;$) {my ($num,$tolerance)=@_;my@caller=caller;return Test2::Compare::Float->new(file=>$caller[1],lines=>[$caller[2]],input=>$num,defined$tolerance ? (tolerance=>$tolerance): (),)}sub bool($;@) {my ($bool,@args)=@_;my@caller=caller;return Test2::Compare::Bool->new(file=>$caller[1],lines=>[$caller[2]],input=>$bool,@args,)}sub string($;@) {my ($str,@args)=@_;my@caller=caller;return Test2::Compare::String->new(file=>$caller[1],lines=>[$caller[2]],input=>$str,@args,)}sub filter_items(&) {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support filters" unless$build->can('add_filter');croak "'filter_items' should only ever be called in void context" if defined wantarray;$build->add_filter(@_)}sub all_items {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support all-items" unless$build->can('add_for_each');croak "'all_items' should only ever be called in void context" if defined wantarray;$build->add_for_each(@_)}sub all_keys {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support all-keys" unless$build->can('add_for_each_key');croak "'all_keys' should only ever be called in void context" if defined wantarray;$build->add_for_each_key(@_)}*all_vals=*all_values;sub all_values {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support all-values" unless$build->can('add_for_each_val');croak "'all_values' should only ever be called in void context" if defined wantarray;$build->add_for_each_val(@_)}sub end() {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support 'ending'" unless$build->can('ending');croak "'end' should only ever be called in void context" if defined wantarray;$build->set_ending(1)}sub etc() {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support 'ending'" unless$build->can('ending');croak "'etc' should only ever be called in void context" if defined wantarray;$build->set_ending(0)}my$_call=sub {my ($name,$expect,$context,$func_name)=@_;defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support method calls" unless$build->can('add_call');croak "'$func_name' should only ever be called in void context" if defined wantarray;my@caller=caller;$build->add_call($name,Test2::Compare::Wildcard->new(expect=>$expect,file=>$caller[1],lines=>[$caller[2]],),undef,$context,)};sub call($$) {$_call->(@_,'scalar','call')}sub call_list($$) {$_call->(@_,'list','call_list')}sub call_hash($$) {$_call->(@_,'hash','call_hash')}sub prop($$) {my ($name,$expect)=@_;defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support meta-checks" unless$build->can('add_prop');croak "'prop' should only ever be called in void context" if defined wantarray;my@caller=caller;$build->add_prop($name,Test2::Compare::Wildcard->new(expect=>$expect,file=>$caller[1],lines=>[$caller[2]],),)}sub item($;$) {my@args=@_;my$expect=pop@args;defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support array item checks" unless$build->can('add_item');croak "'item' should only ever be called in void context" if defined wantarray;my@caller=caller;push@args=>Test2::Compare::Wildcard->new(expect=>$expect,file=>$caller[1],lines=>[$caller[2]],);$build->add_item(@args)}sub field($$) {my ($name,$expect)=@_;defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support hash field checks" unless$build->can('add_field');croak "'field' should only ever be called in void context" if defined wantarray;my@caller=caller;$build->add_field($name,Test2::Compare::Wildcard->new(expect=>$expect,file=>$caller[1],lines=>[$caller[2]],),)}sub check($) {my ($check)=@_;defined(my$build=get_build())or croak "No current build!";croak "'$build' is not a check-set" unless$build->can('add_check');croak "'check' should only ever be called in void context" if defined wantarray;my@caller=caller;my$wc=Test2::Compare::Wildcard->new(expect=>$check,file=>$caller[1],lines=>[$caller[2]],);$build->add_check($wc)}sub check_set {return _build_set('all'=>@_)}sub in_set {return _build_set('any'=>@_)}sub not_in_set {return _build_set('none'=>@_)}sub _build_set {my$redux=shift;my ($builder)=@_;my$btype=reftype($builder)|| '';my$set;if ($btype eq 'CODE'){$set=build('Test2::Compare::Set',$builder);$set->set_builder($builder)}else {$set=Test2::Compare::Set->new(checks=>[@_])}$set->set_reduction($redux);return$set}sub fail_events($;$) {my$event=&event(@_);my$diag=event('Diag');return ($event,$diag)if defined wantarray;defined(my$build=get_build())or croak "No current build!";$build->add_item($event);$build->add_item($diag)}sub event($;$) {my ($intype,$spec)=@_;my@caller=caller;croak "type is required" unless$intype;my$type;if ($intype =~ m/^\+(.*)$/){$type=$1}else {$type="Test2::Event::$intype"}my$event;if (!$spec){$event=Test2::Compare::Event->new(etype=>$intype,file=>$caller[1],lines=>[$caller[2]],ending=>0,)}elsif (!ref$spec){croak "'$spec' is not a valid event specification"}elsif (reftype($spec)eq 'CODE'){$event=build('Test2::Compare::Event',$spec);$event->set_etype($intype);$event->set_builder($spec);$event->set_ending(0)unless defined$event->ending}else {my$refcheck=Test2::Compare::Hash->new(inref=>$spec,file=>$caller[1],lines=>[$caller[2]],);$event=Test2::Compare::Event->new(refcheck=>$refcheck,file=>$caller[1],lines=>[$caller[2]],etype=>$intype,ending=>0,)}$event->add_prop('blessed'=>$type);return$event if defined wantarray;defined(my$build=get_build())or croak "No current build!";$build->add_item($event)}1;
TEST2_TOOLS_COMPARE

$fatpacked{"Test2/Tools/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_DEFER';
  package Test2::Tools::Defer;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak/;use Test2::Util qw/get_tid/;use Test2::API qw{test2_add_callback_exit test2_pid test2_tid};our@EXPORT=qw/def do_def/;use base 'Exporter';my%TODO;sub def {my ($func,@args)=@_;my@caller=caller(0);$TODO{$caller[0]}||= [];push @{$TODO{$caller[0]}}=>[$func,\@args,\@caller]}sub do_def {my$for=caller;my$tests=delete$TODO{$for}or croak "No tests to run!";for my$test (@$tests){my ($func,$args,$caller)=@$test;my ($pkg,$file,$line)=@$caller;chomp(my$eval=<<"        EOT");eval$eval and next;chomp(my$error=$@);require Data::Dumper;chomp(my$td=Data::Dumper::Dumper($args));$td =~ s/^\$VAR1 =/\$args: /;die <<"        EOT"}return}sub _verify {my ($context,$exit,$new_exit)=@_;my$not_ok=0;for my$pkg (keys%TODO){my$tests=delete$TODO{$pkg};my$caller=$tests->[0]->[-1];print STDOUT "not ok - deferred tests were not run!\n" unless$not_ok++;print STDERR "# '$pkg' has deferred tests that were never run!\n";print STDERR "#   $caller->[1] at line $caller->[2]\n";$$new_exit ||= 255}}test2_add_callback_exit(\&_verify);1;
  package $pkg;
  # line $line "(eval in Test2::Tools::Defer) $file"
  \&$func(\@\$args);
  1;
          EOT
  Exception: $error
  --eval--
  $eval
  --------
  Tool:   $func
  Caller: $caller->[0], $caller->[1], $caller->[2]
  $td
          EOT
TEST2_TOOLS_DEFER

$fatpacked{"Test2/Tools/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_ENCODING';
  package Test2::Tools::Encoding;use strict;use warnings;use Carp qw/croak/;use Test2::API qw/test2_stack/;use base 'Exporter';our$VERSION='0.000122';our@EXPORT=qw/set_encoding/;sub set_encoding {my$enc=shift;my$format=test2_stack->top->format;unless ($format && eval {$format->can('encoding')}){$format='<undef>' unless defined$format;croak "Unable to set encoding on formatter '$format'"}$format->encoding($enc)}1;
TEST2_TOOLS_ENCODING

$fatpacked{"Test2/Tools/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_EVENT';
  package Test2::Tools::Event;use strict;use warnings;our$VERSION='0.000122';use Test2::Util qw/pkg_to_file/;our@EXPORT=qw/gen_event/;use base 'Exporter';sub gen_event {my ($type,%fields)=@_;$type="Test2::Event::$type" unless$type =~ s/^\+//;require(pkg_to_file($type));$fields{trace}||= Test2::Util::Trace->new(frame=>[caller(0)]);return$type->new(%fields)}1;
TEST2_TOOLS_EVENT

$fatpacked{"Test2/Tools/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_EXCEPTION';
  package Test2::Tools::Exception;use strict;use warnings;our$VERSION='0.000122';use Test2::API qw/context/;our@EXPORT=qw/dies lives try_ok/;use base 'Exporter';sub dies(&) {my$code=shift;local ($@,$!,$?);my$ok=eval {$code->();1};my$err=$@;return undef if$ok;unless ($err){my$ctx=context();$ctx->alert("Got exception as expected, but exception is falsy (undef, '', or 0)...");$ctx->release}return$err}sub lives(&) {my$code=shift;my$err;{local ($@,$!,$?);eval {$code->();1}and return 1;$err=$@}$@=$err;return 0}sub try_ok(&;$) {my ($code,$name)=@_;my$ok=&lives($code);my$err=$@;my$ctx=context();chomp(my$diag="Exception: $err");$ctx->ok($ok,$name,[$diag]);$ctx->release;$@=$err unless$ok;return$ok}1;
TEST2_TOOLS_EXCEPTION

$fatpacked{"Test2/Tools/Exports.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_EXPORTS';
  package Test2::Tools::Exports;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak carp/;use Test2::API qw/context/;use Test2::Util::Stash qw/get_symbol/;our@EXPORT=qw/imported_ok not_imported_ok/;use base 'Exporter';sub imported_ok {my$ctx=context();my$caller=caller;my@missing=grep {!get_symbol($_,$caller)}@_;my$name="Imported symbol";$name .= "s" if @_ > 1;$name .= ": ";my$list=join(", ",@_);substr($list,37,length($list)- 37,'...')if length($list)> 40;$name .= $list;$ctx->ok(!@missing,$name,[map {"'$_' was not imported."}@missing]);$ctx->release;return!@missing}sub not_imported_ok {my$ctx=context();my$caller=caller;my@found=grep {get_symbol($_,$caller)}@_;my$name="Did not imported symbol";$name .= "s" if @_ > 1;$name .= ": ";my$list=join(", ",@_);substr($list,37,length($list)- 37,'...')if length($list)> 40;$name .= $list;$ctx->ok(!@found,$name,[map {"'$_' was imported."}@found]);$ctx->release;return!@found}1;
TEST2_TOOLS_EXPORTS

$fatpacked{"Test2/Tools/GenTemp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_GENTEMP';
  package Test2::Tools::GenTemp;use strict;use warnings;our$VERSION='0.000122';use File::Temp qw/tempdir/;use File::Spec;our@EXPORT=qw{gen_temp};use base 'Exporter';sub gen_temp {my%args=@_;my$tempdir_args=delete$args{'-tempdir'}|| [CLEANUP=>1,TMPDIR=>1];my$tmp=tempdir(@$tempdir_args);gen_dir($tmp,\%args);return$tmp}sub gen_dir {my ($dir,$content)=@_;for my$path (keys %$content){my$fq=File::Spec->catfile($dir,$path);my$inside=$content->{$path};if (ref$inside){mkdir($fq)or die "Could not make dir '$fq': $!";gen_dir($fq,$inside)}else {open(my$fh,'>',$fq)or die "Could not open file '$fq' for writing: $!";print$fh $inside;close($fh)}}}1;
TEST2_TOOLS_GENTEMP

$fatpacked{"Test2/Tools/Grab.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_GRAB';
  package Test2::Tools::Grab;use strict;use warnings;our$VERSION='0.000122';use Test2::Util::Grabber;our@EXPORT=qw/grab/;use base 'Exporter';sub grab {Test2::Util::Grabber->new()}1;
TEST2_TOOLS_GRAB

$fatpacked{"Test2/Tools/Mock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_MOCK';
  package Test2::Tools::Mock;use strict;use warnings;use Carp qw/croak/;use Scalar::Util qw/blessed reftype weaken/;use Test2::Util qw/try/;use Test2::Util::Sub qw/gen_accessor gen_reader gen_writer/;use Test2::Mock();use base 'Exporter';our$VERSION='0.000122';our@CARP_NOT=(__PACKAGE__,'Test2::Mock');our@EXPORT=qw/mock mocked/;our@EXPORT_OK=qw{mock_obj mock_class mock_do mock_build mock_accessor mock_accessors mock_getter mock_getters mock_setter mock_setters mock_building};my%HANDLERS;my%MOCKS;my@BUILD;sub add_handler {my$class=shift;my ($for,$code)=@_;croak "Must specify a package for the mock handler" unless$for;croak "Handlers must be code referneces (got: $code)" unless$code && ref($code)eq 'CODE';push @{$HANDLERS{$for}}=>$code}sub mock_building {return unless@BUILD;return$BUILD[-1]}sub mocked {my$proto=shift;my$class=blessed($proto)|| $proto;my$set=$MOCKS{$class}|| return;pop @$set while @$set &&!defined($set->[-1]);delete$MOCKS{$class}unless @$set;return @$set}sub _delegate {my ($args)=@_;my$do=__PACKAGE__->can('mock_do');my$obj=__PACKAGE__->can('mock_obj');my$class=__PACKAGE__->can('mock_class');my$build=__PACKAGE__->can('mock_build');return$obj unless @$args;my ($proto,$arg1)=@$args;return$obj if ref($proto)&&!blessed($proto);if (blessed($proto)){return$class unless$proto->isa('Test2::Mock');return$build if$arg1 && ref($arg1)&& reftype($arg1)eq 'CODE'}return$class if$proto =~ m/(?:::|')/;return$class if$proto =~ m/^_*[A-Z]/;return$do if Test2::Mock->can($proto);if (my$sub=__PACKAGE__->can("mock_$proto")){shift @$args;return$sub}return undef}sub mock {croak "undef is not a valid first argument to mock()" if @_ &&!defined($_[0]);my$sub=_delegate(\@_);croak "'$_[0]' does not look like a package name, and is not a valid control method" unless$sub;$sub->(@_)}sub mock_build {my ($control,$sub)=@_;croak "mock_build requires a Test2::Mock object as its first argument" unless$control && blessed($control)&& $control->isa('Test2::Mock');croak "mock_build requires a coderef as its second argument" unless$sub && ref($sub)&& reftype($sub)eq 'CODE';push@BUILD=>$control;my ($ok,$err)=&try($sub);pop@BUILD;die$err unless$ok}sub mock_do {my ($meth,@args)=@_;croak "Not currently building a mock" unless@BUILD;my$build=$BUILD[-1];croak "'$meth' is not a valid action for mock_do()" if$meth =~ m/^_/ ||!$build->can($meth);$build->$meth(@args)}sub mock_obj {my ($proto)=@_;if ($proto && ref($proto)&& reftype($proto)ne 'CODE'){shift @_}else {$proto={}}my$class=_generate_class();my$control;if (@_==1 && reftype($_[0])eq 'CODE'){my$orig=shift @_;$control=mock_class($class,sub {my$c=mock_building;$c->block_load(1);$c->purge_on_destroy(1);$c->autoload(1);$orig->(@_)},)}else {$control=mock_class($class,block_load=>1,purge_on_destroy=>1,autoload=>1,@_,)}my$new=bless($proto,$control->class);$new->{'~~MOCK~CONTROL~~'}=$control;return$new}sub _generate_class {my$prefix=__PACKAGE__;for (1 .. 100){my$postfix=join '',map {chr(rand(26)+ 65)}1 .. 32;my$class=$prefix .'::__TEMP__::' .$postfix;my$file=$class;$file =~ s{::}{/}g;$file .= '.pm';next if$INC{$file};my$stash=do {no strict 'refs';\%{"${class}\::"}};next if keys %$stash;return$class}croak "Could not generate a unique class name after 100 attempts"}sub mock_class {my$proto=shift;my$class=blessed($proto)|| $proto;my@args=@_;my$void=!defined(wantarray);my$callback=sub {my ($parent)=reverse mocked($class);my$control;if (@args==1 && ref($args[0])&& reftype($args[0])eq 'CODE'){$control=Test2::Mock->new(class=>$class);mock_build($control,@args)}else {$control=Test2::Mock->new(class=>$class,@args)}if ($parent){$control->{parent}=$parent;weaken($parent->{child}=$control)}$MOCKS{$class}||= [];push @{$MOCKS{$class}}=>$control;weaken($MOCKS{$class}->[-1]);return$control};return$callback->()unless$void;my$level=0;my$caller;while (my@call=caller($level++)){next if$call[0]eq __PACKAGE__;$caller=\@call;last}my$handled;for my$handler (@{$HANDLERS{$caller->[0]}}){$handled++ if$handler->(class=>$class,caller=>$caller,builder=>$callback,args=>\@args,)}croak "mock_class should not be called in a void context without a registered handler" unless$handled}sub mock_accessors {return map {($_=>gen_accessor($_))}@_}sub mock_accessor {my ($field)=@_;return gen_accessor($field)}sub mock_getters {my ($prefix,@list)=@_;return map {("$prefix$_"=>gen_reader($_))}@list}sub mock_getter {my ($field)=@_;return gen_reader($field)}sub mock_setters {my ($prefix,@list)=@_;return map {("$prefix$_"=>gen_writer($_))}@list}sub mock_setter {my ($field)=@_;return gen_writer($field)}1;
TEST2_TOOLS_MOCK

$fatpacked{"Test2/Tools/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_REF';
  package Test2::Tools::Ref;use strict;use warnings;our$VERSION='0.000122';use Scalar::Util qw/reftype refaddr/;use Test2::API qw/context/;use Test2::Util::Ref qw/render_ref/;our@EXPORT=qw/ref_ok ref_is ref_is_not/;use base 'Exporter';sub ref_ok($;$$) {my ($thing,$wanttype,$name)=@_;my$ctx=context();my$gotname=render_ref($thing);my$gottype=reftype($thing);if (!$gottype){$ctx->ok(0,$name,["'$gotname' is not a reference"]);$ctx->release;return 0}if ($wanttype && $gottype ne $wanttype){$ctx->ok(0,$name,["'$gotname' is not a '$wanttype' reference"]);$ctx->release;return 0}$ctx->ok(1,$name);$ctx->release;return 1}sub ref_is($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();$got='<undef>' unless defined$got;$exp='<undef>' unless defined$exp;my$bool=0;if (!ref($got)){$ctx->ok(0,$name,["First argument '$got' is not a reference",@diag])}elsif(!ref($exp)){$ctx->ok(0,$name,["Second argument '$exp' is not a reference",@diag])}else {$bool=refaddr($got)==refaddr($exp);$ctx->ok($bool,$name,["'$got' is not the same reference as '$exp'",@diag])}$ctx->release;return$bool ? 1 : 0}sub ref_is_not($$;$) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();$got='<undef>' unless defined$got;$exp='<undef>' unless defined$exp;my$bool=0;if (!ref($got)){$ctx->ok(0,$name,["First argument '$got' is not a reference",@diag])}elsif(!ref($exp)){$ctx->ok(0,$name,["Second argument '$exp' is not a reference",@diag])}else {$bool=refaddr($got)!=refaddr($exp);$ctx->ok($bool,$name,["'$got' is the same reference as '$exp'",@diag])}$ctx->release;return$bool ? 1 : 0}1;
TEST2_TOOLS_REF

$fatpacked{"Test2/Tools/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_SPEC';
  package Test2::Tools::Spec;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak/;use Test2::Workflow qw/parse_args build current_build root_build init_root build_stack/;use Test2::API qw/test2_add_callback_testing_done/;use Test2::Workflow::Runner();use Test2::Workflow::Task::Action();use Test2::Workflow::Task::Group();use Test2::Tools::Mock();use Importer();use vars qw/@EXPORT @EXPORT_OK/;push@EXPORT=>qw{describe cases};push@EXPORT_OK=>qw{include_workflow include_workflows spec_defaults};my%HANDLED;sub import {my$class=shift;my@caller=caller(0);my%root_args;my%runner_args;my@import;while (my$arg=shift @_){if ($arg =~ s/^-//){my$val=shift @_;if (Test2::Workflow::Runner->can($arg)){$runner_args{$arg}=$val}elsif (Test2::Workflow::Task::Group->can($arg)){$root_args{$arg}=$val}elsif ($arg eq 'root_args'){%root_args=(%root_args,%$val)}elsif ($arg eq 'runner_args'){%runner_args=(%runner_args,%$val)}else {croak "Unrecognized arg: $arg"}}else {push@import=>$arg}}if ($HANDLED{$caller[0]}++){croak "Package $caller[0] has already been initialized" if keys(%root_args)|| keys(%runner_args)}else {my$root=init_root($caller[0],frame=>\@caller,code=>sub {1},%root_args,);my$runner=Test2::Workflow::Runner->new(%runner_args);Test2::Tools::Mock->add_handler($caller[0],sub {my%params=@_;my ($class,$caller,$builder,$args)=@params{qw/class caller builder args/};my$do_it=eval "package $caller->[0];\n#line $caller->[2] \"$caller->[1]\"\nsub { \$runner\->add_mock(\$builder->()) }";if (@{$runner->stack}){$do_it->()}else {my$action=Test2::Workflow::Task::Action->new(code=>$do_it,name=>"mock $class",frame=>$caller,scaffold=>1,);my$build=current_build()|| $root;$build->add_primary_setup($action);$build->add_stash($builder->())unless$build->is_root}return 1});test2_add_callback_testing_done(sub {return unless$root->populated;my$g=$root->compile;$runner->push_task($g);$runner->run})}Importer->import_into($class,$caller[0],@import)}{no warnings 'once';*cases=\&describe;*include_workflows=\&include_workflow}sub describe {my@caller=caller(0);my$want=wantarray;my$build=build(args=>\@_,caller=>\@caller,stack_stop=>defined$want ? 1 : 0);return$build if defined$want;my$current=current_build()|| root_build($caller[0])or croak "No current workflow build!";$current->add_primary($build)}sub include_workflow {my@caller=caller(0);my$build=current_build()|| root_build(\$caller[0])or croak "No current workflow build!";for my$task (@_){croak "include_workflow only accepts Test2::Workflow::Task objects, got: $task" unless$task->isa('Test2::Workflow::Task');$build->add_primary($task)}}sub defaults {my%params=@_;my ($package,$tool)=@params{qw/package tool/};my@stack=(root_build($package),build_stack());return unless@stack;my%out;for my$build (@stack){%out=()if$build->stack_stop;my$new=$build->defaults->{$tool}or next;%out=(%out,%$new)}return \%out}BEGIN {@EXPORT=qw{tests it case before_all around_all after_all before_case around_case after_case before_each around_each after_each};@EXPORT_OK=qw{mini iso miso async masync};my%stages=(case=>['add_variant'],tests=>['add_primary'],it=>['add_primary'],iso=>['add_primary'],miso=>['add_primary'],async=>['add_primary'],masync=>['add_primary'],mini=>['add_primary'],before_all=>['add_setup'],after_all=>['add_teardown'],around_all=>['add_setup','add_teardown'],before_case=>['add_variant_setup'],after_case=>['add_variant_teardown'],around_case=>['add_variant_setup','add_variant_teardown'],before_each=>['add_primary_setup'],after_each=>['add_primary_teardown'],around_each=>['add_primary_setup','add_primary_teardown'],);my%props=(case=>[],tests=>[],it=>[],iso=>[iso=>1],miso=>[iso=>1,flat=>1],async=>[async=>1],masync=>[async=>1,flat=>1],mini=>[flat=>1],before_all=>[scaffold=>1],after_all=>[scaffold=>1],around_all=>[scaffold=>1,around=>1],before_case=>[scaffold=>1],after_case=>[scaffold=>1],around_case=>[scaffold=>1,around=>1],before_each=>[scaffold=>1],after_each=>[scaffold=>1],around_each=>[scaffold=>1,around=>1],);sub spec_defaults {my ($tool,%params)=@_;my@caller=caller(0);croak "'$tool' is not a spec tool" unless exists$props{$tool}|| exists$stages{$tool};my$build=current_build()|| root_build($caller[0])or croak "No current workflow build!";my$old=$build->defaults->{$tool}||= {};$build->defaults->{$tool}={%$old,%params }}my$run="";for my$func (@EXPORT,@EXPORT_OK){$run .= <<"        EOT"}my ($ok,$err);{local $@;$ok=eval "$run\n1";$err=$@}die $@ unless$ok}1;
  #line ${ \(__LINE__ + 1) } "${ \__FILE__ }"
  sub $func {
      my \@caller = caller(0);
      my \$args = parse_args(args => \\\@_, caller => \\\@caller);
      my \$action = Test2::Workflow::Task::Action->new(\@{\$props{$func}}, %\$args);
  
      return \$action if defined wantarray;
  
      my \$build = current_build() || root_build(\$caller[0])
          or croak "No current workflow build!";
  
      if (my \$defaults = defaults(package => \$caller[0], tool => '$func')) {
          for my \$attr (keys \%\$defaults) {
              next if defined \$action->\$attr;
              my \$sub = "set_\$attr";
              \$action->\$sub(\$defaults->{\$attr});
          }
      }
  
      \$build->\$_(\$action) for \@{\$stages{$func}};
  }
          EOT
TEST2_TOOLS_SPEC

$fatpacked{"Test2/Tools/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_SUBTEST';
  package Test2::Tools::Subtest;use strict;use warnings;our$VERSION='0.000122';use Test2::API qw/context run_subtest/;use Test2::Util qw/try/;our@EXPORT=qw/subtest_streamed subtest_buffered/;use base 'Exporter';sub subtest_streamed {my$name=shift;my$params=ref($_[0])eq 'HASH' ? shift(@_): {};my$code=shift;$params->{buffered}=0 unless defined$params->{buffered};my$ctx=context();my$pass=run_subtest("Subtest: $name",$code,$params,@_);$ctx->release;return$pass}sub subtest_buffered {my$name=shift;my$params=ref($_[0])eq 'HASH' ? shift(@_): {};my$code=shift;$params->{buffered}=1 unless defined$params->{buffered};my$ctx=context();my$pass=run_subtest($name,$code,$params,@_);$ctx->release;return$pass}1;
TEST2_TOOLS_SUBTEST

$fatpacked{"Test2/Tools/Target.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_TARGET';
  package Test2::Tools::Target;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak/;use Test2::Util qw/pkg_to_file/;sub import {my$class=shift;my$caller=caller;$class->import_into($caller,@_)}sub import_into {my$class=shift;my$into=shift or croak "no destination package provided";croak "No targets specified" unless @_;my%targets;if (@_==1){($targets{CLASS})=@_}else {%targets=@_}for my$name (keys%targets){my$target=$targets{$name};my$file=pkg_to_file($target);require$file;$name ||= 'CLASS';my$const;{my$const_target="$target";$const=sub() {$const_target}}no strict 'refs';*{"$into\::$name"}=\$target;*{"$into\::$name"}=$const}}1;
TEST2_TOOLS_TARGET

$fatpacked{"Test2/Tools/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_TESTER';
  package Test2::Tools::Tester;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak/;use Module::Pluggable search_path=>['Test2::EventFacet'],require=>1;use Test2::Util::Ref qw/rtype/;use Importer Importer=>'import';our@EXPORT_OK=qw{facets filter_events event_groups};my%TYPES;for my$class (__PACKAGE__->plugins){my$type=$class;$type =~ s/^Test2::EventFacet:://g;next unless$class->isa('Test2::EventFacet');my$key;$key=$class->facet_key if$class->can('facet_key');$key=lc($type)unless defined$key;$TYPES{$type}=$class;$TYPES{lc($type)}=$class;$TYPES{$key}=$class}sub filter_events {my$events=shift;my@match=map {rtype($_)eq 'REGEXP' ? $_ : qr/^\Q$_\E::/}@_;my@out;for my$e (@$events){my$trace=$e->facet_data->{trace}or next;next unless grep {$trace->{frame}->[3]=~ $_}@match;push@out=>$e}return \@out}sub event_groups {my$events=shift;my$out={};for my$e (@$events){my$trace=$e->facet_data->{trace};my$tool=($trace && $trace->{frame}&& $trace->{frame}->[3])? $trace->{frame}->[3]: undef;unless ($tool){push @{$out->{__NA__}}=>$e;next}my ($pkg,$sub)=($tool =~ m/^(.*)(?:::|')([^:']+)$/);push @{$out->{$pkg}->{$sub}}=>$e;push @{$out->{$pkg}->{__ALL__}}=>$e}return$out}sub facets {my ($type,$events)=@_;my ($key,$is_list);my$class=$TYPES{$type};if ($class){$key=$class->facet_key || lc($type);$is_list=$class->is_list}else {$key=lc($type)}my@out;for my$e (@$events){my$fd=$e->facet_data;my$f=$fd->{$key}or next;my$list=defined($is_list)? $is_list : rtype($f)eq 'ARRAY';if ($list){push@out=>map {$class ? $class->new($_): $_}@$f}else {push@out=>$class ? $class->new($f): $f}}return \@out}1;
TEST2_TOOLS_TESTER

$fatpacked{"Test2/Tools/Warnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_WARNINGS';
  package Test2::Tools::Warnings;use strict;use warnings;our$VERSION='0.000122';use Test2::API qw/context/;our@EXPORT=qw/warns warning warnings no_warnings/;use base 'Exporter';sub warns(&) {my$code=shift;my$warnings=0;local$SIG{__WARN__}=sub {$warnings++};$code->();return$warnings}sub no_warnings(&) {return!&warns(@_)}sub warning(&) {my$code=shift;my@warnings;{local$SIG{__WARN__}=sub {push@warnings=>@_};$code->();return unless@warnings}if (@warnings > 1){my$ctx=context();$ctx->alert("Extra warnings in warning { ... }");$ctx->note($_)for@warnings;$ctx->release}return$warnings[0]}sub warnings(&) {my$code=shift;my@warnings;local$SIG{__WARN__}=sub {push@warnings=>@_};$code->();return \@warnings}1;
TEST2_TOOLS_WARNINGS

$fatpacked{"Test2/Util/Grabber.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_GRABBER';
  package Test2::Util::Grabber;use strict;use warnings;our$VERSION='0.000122';use Test2::Hub::Interceptor();use Test2::Util::Trace();use Test2::API qw/test2_stack test2_ipc/;use Test2::Util::HashBase qw/hub finished _events term_size/;sub init {my$self=shift;test2_stack->top();my$hub=test2_stack->new_hub(class=>'Test2::Hub::Interceptor',formatter=>undef,no_ending=>1,);$self->{+HUB}=$hub;my@events;$hub->listen(sub {push@events=>$_[1]});$self->{+_EVENTS}=\@events;$self->{+TERM_SIZE}=$ENV{TS_TERM_SIZE};$ENV{TS_TERM_SIZE}=80}sub flush {my$self=shift;my$out=[@{$self->{+_EVENTS}}];@{$self->{+_EVENTS}}=();return$out}sub events {my$self=shift;return [@{$self->{+_EVENTS}}]}sub finish {my ($self)=@_;$_[0]=undef;if (defined$self->{+TERM_SIZE}){$ENV{TS_TERM_SIZE}=$self->{+TERM_SIZE}}else {delete$ENV{TS_TERM_SIZE}}my$hub=$self->{+HUB};$self->{+FINISHED}=1;test2_stack()->pop($hub);my$dbg=Test2::Util::Trace->new(frame=>[caller(0)],);$hub->finalize($dbg,1)if!$hub->no_ending &&!$hub->state->ended;return$self->flush}sub DESTROY {my$self=shift;return if$self->{+FINISHED};test2_stack->pop($self->{+HUB})}1;
TEST2_UTIL_GRABBER

$fatpacked{"Test2/Util/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_REF';
  package Test2::Util::Ref;use strict;use warnings;our$VERSION='0.000122';use Scalar::Util qw/reftype blessed refaddr/;our@EXPORT_OK=qw/rtype render_ref/;use base 'Exporter';sub rtype {my ($thing)=@_;return '' unless defined$thing;my$rf=ref$thing;my$rt=reftype$thing;return '' unless$rf || $rt;return 'REGEXP' if$rf =~ m/Regex/i;return 'REGEXP' if$rt =~ m/Regex/i;return$rt || ''}sub render_ref {my ($in)=@_;return 'undef' unless defined($in);my$type=rtype($in);return "$in" unless$type;my$class=blessed($in)|| '';my$it=sprintf('0x%x',refaddr($in));my$ref="$type($it)";return$ref unless$class;return "$class=$ref"}1;
TEST2_UTIL_REF

$fatpacked{"Test2/Util/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_STASH';
  package Test2::Util::Stash;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak/;use B;our@EXPORT_OK=qw{get_stash get_glob get_symbol parse_symbol purge_symbol slot_to_sig sig_to_slot};use base 'Exporter';my%SIGMAP=('&'=>'CODE','$'=>'SCALAR','%'=>'HASH','@'=>'ARRAY',);my%SLOTMAP=reverse%SIGMAP;sub slot_to_sig {$SLOTMAP{$_[0]}|| croak "unsupported slot: '$_[0]'"}sub sig_to_slot {$SIGMAP{$_[0]}|| croak "unsupported sigil: $_[0]"}sub get_stash {my$package=shift || caller;no strict 'refs';return \%{"${package}\::"}}sub get_glob {my$sym=_parse_symbol(scalar(caller),@_);no strict 'refs';no warnings 'once';return \*{"$sym->{package}\::$sym->{name}"}}sub parse_symbol {_parse_symbol(scalar(caller),@_)}sub _parse_symbol {my ($caller,$symbol,$package)=@_;if (ref($symbol)){my$pkg=$symbol->{package};croak "Symbol package ($pkg) and package argument ($package) do not match" if$pkg && $package && $pkg ne $package;$symbol->{package}||= $caller;return$symbol}utf8::downgrade($symbol)if $]==5.010000;my ($sig,$pkg,$name)=($symbol =~ m/^(\W?)(.*::)?([^:]+)$/)or croak "Invalid symbol: '$symbol'";$pkg=$pkg ? $pkg eq '::' ? 'main' : substr($pkg,0,-2): undef;croak "Symbol package ($pkg) and package argument ($package) do not match" if$pkg && $package && $pkg ne $package;$sig ||= '&';my$type=$SIGMAP{$sig}|| croak "unsupported sigil: '$sig'";my$real_package=$package || $pkg || $caller;return {name=>$name,sigil=>$sig,type=>$type,symbol=>"${sig}${real_package}::${name}",package=>$real_package,}}sub get_symbol {my$sym=_parse_symbol(scalar(caller),@_);my$name=$sym->{name};my$type=$sym->{type};my$package=$sym->{package};my$symbol=$sym->{symbol};my$stash=get_stash($package);return undef unless exists$stash->{$name};my$glob=get_glob($sym);return *{$glob}{$type}if$type ne 'SCALAR' && defined(*{$glob}{$type});if ($] < 5.010){return undef unless defined(*{$glob}{$type});{local ($@,$!);local$SIG{__WARN__}=sub {1};return *{$glob}{$type}if eval "package $package; my \$y = $symbol; 1"}return undef unless defined *{$glob}{$type};return *{$glob}{$type}if defined ${*{$glob}{$type}};return undef}my$sv=B::svref_2object($glob)->SV;return *{$glob}{$type}if$sv->isa('B::SV');return undef unless$sv->isa('B::SPECIAL');return *{$glob}{$type}if$B::specialsv_name[$$sv]ne 'Nullsv';return undef}sub purge_symbol {my$sym=_parse_symbol(scalar(caller),@_);local*GLOBCLONE=*{get_glob($sym)};delete get_stash($sym->{package})->{$sym->{name}};my$new_glob=get_glob($sym);for my$type (qw/CODE SCALAR HASH ARRAY FORMAT IO/){next if$type eq $sym->{type};my$ref=get_symbol({type=>$type,name=>'GLOBCLONE',sigil=>$SLOTMAP{$type}},__PACKAGE__);next unless$ref;*$new_glob=$ref}return*GLOBCLONE{$sym->{type}}}1;
TEST2_UTIL_STASH

$fatpacked{"Test2/Util/Sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_SUB';
  package Test2::Util::Sub;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak carp/;use B();use Sub::Info;our@EXPORT_OK=qw{sub_info sub_name gen_reader gen_writer gen_accessor};use base 'Exporter';sub gen_reader {my$field=shift;return sub {$_[0]->{$field}}}sub gen_writer {my$field=shift;return sub {$_[0]->{$field}=$_[1]}}sub gen_accessor {my$field=shift;return sub {my$self=shift;($self->{$field})=@_ if @_;return$self->{$field}}}sub sub_name {my ($sub)=@_;croak "sub_name requires a coderef as its only argument" unless ref($sub)eq 'CODE';my$cobj=B::svref_2object($sub);my$name=$cobj->GV->NAME;return$name}sub sub_info {carp "Test2::Util::Sub::sub_info() is deprecated, use Sub::Info::sub_info() instead";Sub::Info::sub_info(@_)}1;
TEST2_UTIL_SUB

$fatpacked{"Test2/Util/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TABLE';
  package Test2::Util::Table;use strict;use warnings;our$VERSION='0.000122';use base 'Term::Table';use Importer Importer=>'import';our@EXPORT_OK=qw/table/;our%EXPORT_GEN=('&term_size'=>sub {require Carp;Carp::cluck "term_size should be imported from Test2::Util::Term, not " .__PACKAGE__;Test2::Util::Term->can('term_size')},);sub table {my%params=@_;$params{collapse}||= 0;$params{sanitize}||= 0;$params{mark_tail}||= 0;$params{show_header}||= 0 unless$params{header}&& @{$params{header}};__PACKAGE__->new(%params)->render}1;
TEST2_UTIL_TABLE

$fatpacked{"Test2/Util/Table/Cell.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TABLE_CELL';
  package Test2::Util::Table::Cell;use strict;use warnings;our$VERSION='0.000122';use base 'Term::Table::Cell';1;
TEST2_UTIL_TABLE_CELL

$fatpacked{"Test2/Util/Table/LineBreak.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TABLE_LINEBREAK';
  package Test2::Util::Table::LineBreak;use strict;use warnings;our$VERSION='0.000122';use base 'Term::Table::LineBreak';1;
TEST2_UTIL_TABLE_LINEBREAK

$fatpacked{"Test2/Util/Term.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TERM';
  package Test2::Util::Term;use strict;use warnings;use Term::Table::Util qw/term_size USE_GCS USE_TERM_READKEY uni_length/;our$VERSION='0.000122';use Importer Importer=>'import';our@EXPORT_OK=qw/term_size USE_GCS USE_TERM_READKEY uni_length/;1;
TEST2_UTIL_TERM

$fatpacked{"Test2/Util/Times.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TIMES';
  package Test2::Util::Times;use strict;use warnings;use List::Util qw/sum/;our$VERSION='0.000122';our@EXPORT_OK=qw/render_bench/;use base 'Exporter';sub render_bench {my ($start,$end,$user,$system,$cuser,$csystem)=@_;my$time=$end - $start;my$duration;if ($time < 10){$duration=sprintf('%1.5fs',$time)}elsif ($time < 60){$duration=sprintf('%2.4fs',$time)}else {my$msec=substr(sprintf('%0.2f',$time - int($time)),-2,2);my$secs=$time % 60;my$mins=int($time / 60)% 60;my$hours=int($time / 60 / 60)% 24;my$days=int($time / 60 / 60 / 24);my@units=(qw/d h m/,'');$duration='';for my$t ($days,$hours,$mins,$secs){my$u=shift@units;next unless$t || $duration;$duration=join ':'=>grep {length($_)}$duration,sprintf('%02u%s',$t,$u)}$duration ||= '0';$duration .= ".$msec" if int($msec);$duration .= 's'}my$bench=sprintf("%s on wallclock (%5.2f usr %5.2f sys + %5.2f cusr %5.2f csys = %5.2f CPU)",$duration,$user,$system,$cuser,$csystem,sum($user,$system,$cuser,$csystem),);$bench =~ s/\s+/ /g;$bench =~ s/(\(|\))\s+/$1/g;return$bench}1;
TEST2_UTIL_TIMES

$fatpacked{"Test2/V0.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_V0';
  package Test2::V0;use strict;use warnings;use Importer;our$VERSION='0.000122';use Carp qw/croak/;use Test2::Plugin::SRand();use Test2::Plugin::UTF8();use Test2::Tools::Target();use Test2::Plugin::ExitSummary;use Test2::API qw/intercept context/;use Test2::Tools::Event qw/gen_event/;use Test2::Tools::Defer qw/def do_def/;use Test2::Tools::Basic qw{ok pass fail diag note todo skip plan skip_all done_testing bail_out};use Test2::Tools::Compare qw{is like isnt unlike match mismatch validator hash array bag object meta meta_check number float rounded within string subset bool in_set not_in_set check_set item field call call_list call_hash prop check all_items all_keys all_vals all_values etc end filter_items T F D DF E DNE FDNE U event fail_events exact_ref};use Test2::Tools::Warnings qw{warns warning warnings no_warnings};use Test2::Tools::ClassicCompare qw/cmp_ok/;use Importer 'Test2::Tools::Subtest'=>(subtest_buffered=>{-as=>'subtest' },);use Test2::Tools::Class qw/can_ok isa_ok DOES_ok/;use Test2::Tools::Encoding qw/set_encoding/;use Test2::Tools::Exports qw/imported_ok not_imported_ok/;use Test2::Tools::Ref qw/ref_ok ref_is ref_is_not/;use Test2::Tools::Mock qw/mock mocked/;use Test2::Tools::Exception qw/try_ok dies lives/;our@EXPORT=qw{ok pass fail diag note todo skip plan skip_all done_testing bail_out intercept context gen_event def do_def cmp_ok warns warning warnings no_warnings subtest can_ok isa_ok DOES_ok set_encoding imported_ok not_imported_ok ref_ok ref_is ref_is_not mock mocked dies lives try_ok is like isnt unlike match mismatch validator hash array bag object meta meta_check number float rounded within string subset bool in_set not_in_set check_set item field call call_list call_hash prop check all_items all_keys all_vals all_values etc end filter_items T F D DF E DNE FDNE U event fail_events exact_ref};my$SRAND;sub import {my$class=shift;my$caller=caller;my (@exports,%options);while (my$arg=shift @_){push@exports=>$arg and next unless substr($arg,0,1)eq '-';$options{$arg}=shift @_}my$srand=delete$options{'-srand'};my$no_srand=delete$options{'-no_srand'};croak "Cannot combine '-srand' and '-no_srand' options" if$no_srand && defined($srand);Test2::Plugin::SRand->import($srand ? $srand : ())if$srand ||!($no_srand || $SRAND++);my$no_pragmas=delete$options{'-no_pragmas'};my$no_strict=delete$options{'-no_strict'}|| $no_pragmas;my$no_warnings=delete$options{'-no_warnings'}|| $no_pragmas;my$no_utf8=delete$options{'-no_utf8'}|| $no_pragmas;strict->import()unless$no_strict;'warnings'->import()unless$no_warnings;Test2::Plugin::UTF8->import()unless$no_utf8;my$target=delete$options{'-target'};Test2::Tools::Target->import_into($caller,$target)if$target;croak "Unknown option(s): " .join(', ',sort keys%options)if keys%options;Importer->import_into($class,$caller,@exports)}1;
TEST2_V0

$fatpacked{"Test2/Workflow.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW';
  package Test2::Workflow;use strict;use warnings;our$VERSION='0.000122';our@EXPORT_OK=qw/parse_args current_build build root_build init_root build_stack/;use base 'Exporter';use Test2::Workflow::Build;use Test2::Workflow::Task::Group;use Test2::API qw/intercept/;use Scalar::Util qw/blessed/;sub parse_args {my%input=@_;my$args=delete$input{args};my%out;my%props;my$caller=$out{frame}=$input{caller}|| caller(defined$input{level}? $input{level}: 1);delete@input{qw/caller level/};for my$arg (@$args){if (my$r=ref($arg)){if ($r eq 'HASH'){%props=(%props,%$arg)}elsif ($r eq 'CODE'){die "Code is already set, did you provide multiple code blocks at $caller->[1] line $caller->[2].\n" if$out{code};$out{code}=$arg}else {die "Not sure what to do with $arg at $caller->[1] line $caller->[2].\n"}next}if ($arg =~ m/^\d+$/){push @{$out{lines}}=>$arg;next}die "Name is already set to '$out{name}', cannot set to '$arg', did you specify multiple names at $caller->[1] line $caller->[2].\n" if$out{name};$out{name}=$arg}die "a name must be provided, and must be truthy at $caller->[1] line $caller->[2].\n" unless$out{name};die "a codeblock must be provided at $caller->[1] line $caller->[2].\n" unless$out{code};return {%props,%out,%input }}{my%ROOT_BUILDS;my@BUILD_STACK;sub root_build {$ROOT_BUILDS{$_[0]}}sub current_build {@BUILD_STACK ? $BUILD_STACK[-1]: undef}sub build_stack {@BUILD_STACK}sub init_root {my ($pkg,%args)=@_;$ROOT_BUILDS{$pkg}||= Test2::Workflow::Build->new(name=>$pkg,flat=>1,iso=>0,async=>0,is_root=>1,%args,);return$ROOT_BUILDS{$pkg}}sub build {my%params=@_;my$args=parse_args(%params);my$build=Test2::Workflow::Build->new(%$args);return$build if$args->{skip};push@BUILD_STACK=>$build;my ($ok,$err);my$events=intercept {my$todo=$args->{todo}? Test2::Todo->new(reason=>$args->{todo}): undef;$ok=eval {$args->{code}->();1};$err=$@;$todo->end if$todo};$build->{stash}=[];$build->set_events($events);pop@BUILD_STACK;unless($ok){my$hub=Test2::API::test2_stack->top;my$count=@$events;my$list=$count ? "Overview of unseen events:\n" .join ""=>map "    " .blessed($_)." " .$_->trace($hub)->debug ."\n",@$events : "";die <<"            EOT"}return$build}}1;
  Exception in build '$args->{name}' with $count unseen event(s).
  $err
  $list
              EOT
TEST2_WORKFLOW

$fatpacked{"Test2/Workflow/BlockBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_BLOCKBASE';
  package Test2::Workflow::BlockBase;use strict;use warnings;our$VERSION='0.000122';use Test2::Util::HashBase qw/code frame _info _lines/;use Sub::Info qw/sub_info/;use List::Util qw/min max/;use Carp qw/croak/;use Test2::Util::Trace();BEGIN {local ($@,$!,$SIG{__DIE__});my$set_name=eval {require Sub::Util;Sub::Util->can('set_subname')}|| eval {require Sub::Name;Sub::Name->can('subname')};*set_subname=$set_name ? sub {my$self=shift;my ($name)=@_;$set_name->($name,$self->{+CODE});delete$self->{+_INFO};return 1}: sub {return 0}}sub init {my$self=shift;croak "The 'code' attribute is required" unless$self->{+CODE};croak "The 'frame' attribute is required" unless$self->{+FRAME};$self->{+_LINES}=delete$self->{lines}if$self->{lines}}sub file {shift->info->{file}}sub lines {shift->info->{lines}}sub package {shift->info->{package}}sub subname {shift->info->{name}}sub info {my$self=shift;unless ($self->{+_INFO}){my$info=sub_info($self->code);my$frame=$self->frame;my$file=$info->{file};my$all_lines=$info->{all_lines};my$pre_lines=$self->{+_LINES};my$lines=$info->{lines}||= [];if ($pre_lines && @$pre_lines){@$lines=@$pre_lines}else {@$lines=(min(@$all_lines,$frame->[2]),max(@$all_lines,$frame->[2]),)if$frame->[1]eq $file}$lines->[0]-- if$lines->[0]!=$lines->[1];$self->{+_INFO}=$info}return$self->{+_INFO}}sub trace {my$self=shift;my ($hub,%params)=@_;croak "'hub' is required" unless$hub;return Test2::Util::Trace->new(frame=>$self->frame,detail=>$self->debug,buffered=>$hub->buffered,nested=>$hub->nested,hid=>$hub->hid,huuid=>$hub->uuid,%params,)}sub debug {my$self=shift;my$file=$self->file;my$lines=$self->lines;my$line_str=@$lines==1 ? "around line $lines->[0]" : "around lines $lines->[0] -> $lines->[1]";return "at $file $line_str."}sub throw {my$self=shift;my ($msg)=@_;die "$msg " .$self->debug ."\n"}1;
TEST2_WORKFLOW_BLOCKBASE

$fatpacked{"Test2/Workflow/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_BUILD';
  package Test2::Workflow::Build;use strict;use warnings;our$VERSION='0.000122';use Test2::Workflow::Task::Group;our@BUILD_FIELDS;BEGIN {@BUILD_FIELDS=qw{primary variant setup teardown variant_setup variant_teardown primary_setup primary_teardown stash}}use base 'Test2::Workflow::Task';use Test2::Util::HashBase@BUILD_FIELDS,qw/events defaults stack_stop/;sub init {my$self=shift;{local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->SUPER::init()}$self->{$_}||= []for@BUILD_FIELDS;$self->{+DEFAULTS}||= {}}for my$field (@BUILD_FIELDS){my$code=sub {my$self=shift;push @{$self->{$field}}=>@_};no strict 'refs';*{"add_$field"}=$code}sub populated {my$self=shift;for my$field (@BUILD_FIELDS){return 1 if @{$self->{$field}}}return 0}sub compile {my$self=shift;warn "Workflow build '$self->{+NAME}' is empty " .$self->debug ."\n" unless$self->populated || $self->{+SKIP};my ($primary_setup,$primary_teardown)=@_;$primary_setup ||= [];$primary_teardown ||= [];my$variant=$self->{+VARIANT};my$setup=$self->{+SETUP};my$teardown=$self->{+TEARDOWN};my$variant_setup=$self->{+VARIANT_SETUP};my$variant_teardown=$self->{+VARIANT_TEARDOWN};$primary_setup=[@$primary_setup,@{$self->{+PRIMARY_SETUP}}];$primary_teardown=[@{$self->{+PRIMARY_TEARDOWN}},@$primary_teardown];my$primary=[map {$_->isa(__PACKAGE__)? $_->compile($primary_setup,$primary_teardown): $_}@{$self->{+PRIMARY}},];if (@$primary_setup || @$primary_teardown){$primary=[map {my$p=$_->clone;$_->isa('Test2::Workflow::Task::Action')? Test2::Workflow::Task::Group->new(before=>$primary_setup,primary=>[$p ],take=>$p,after=>$primary_teardown,): $_}@$primary ]}if (@$variant){$primary=[map {my$v=$_->clone;Test2::Workflow::Task::Group->new(before=>$variant_setup,primary=>$primary,after=>$variant_teardown,variant=>$v,take=>$v,)}@$variant ]}my%params=map {Test2::Workflow::Task::Group->can($_)? ($_=>$self->{$_}): ()}keys %$self;delete$params{$_}for@BUILD_FIELDS;return Test2::Workflow::Task::Group->new(%params,before=>$setup,after=>$teardown,primary=>$primary,)}1;
TEST2_WORKFLOW_BUILD

$fatpacked{"Test2/Workflow/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_RUNNER';
  package Test2::Workflow::Runner;use strict;use warnings;our$VERSION='0.000122';use Test2::API();use Test2::Todo();use Test2::AsyncSubtest();use Test2::Util qw/get_tid CAN_REALLY_FORK/;use Scalar::Util qw/blessed/;use Time::HiRes qw/sleep/;use List::Util qw/shuffle min/;use Carp qw/confess/;use Test2::Util::HashBase qw{stack no_fork no_threads max slots pid tid rand subtests filter};use overload('fallback'=>1,'&{}'=>sub {my$self=shift;sub {@_=($self);goto&run}},);sub init {my$self=shift;$self->{+STACK}=[];$self->{+SUBTESTS}=[];$self->{+PID}=$$;$self->{+TID}=get_tid();$self->{+NO_FORK}||= $ENV{T2_WORKFLOW_NO_FORK}||!CAN_REALLY_FORK();my$can_thread=Test2::AsyncSubtest->CAN_REALLY_THREAD();my$should_thread=($ENV{T2_WORKFLOW_USE_THREADS}|| $ENV{T2_DO_THREAD_TESTS})&&!$ENV{T2_WORKFLOW_NO_THREADS};$self->{+NO_THREADS}||=!($can_thread && $should_thread);$self->{+RAND}=1 unless defined$self->{+RAND};my@max=grep {defined $_}$self->{+MAX},$ENV{T2_WORKFLOW_ASYNC};my$max=@max ? min(@max): 3;$self->{+MAX}=$max;$self->{+SLOTS}=[]if$max;unless(defined($self->{+FILTER})){if (my$raw=$ENV{T2_WORKFLOW}){my ($file,$line,$name);if ($raw =~ m/^(.*)\s+(\d+)$/){($file,$line)=($1,$2)}elsif($raw =~ m/^(\d+)$/){$line=$1}else {$name=$raw}$self->{+FILTER}={file=>$file,line=>$line,name=>$name,}}}if (my$task=delete$self->{task}){$self->push_task($task)}}sub is_local {my$self=shift;return 0 unless$self->{+PID}==$$;return 0 unless$self->{+TID}==get_tid();return 1}sub send_event {my$self=shift;my ($type,%params)=@_;my$class;if ($type =~ m/\+(.*)$/){$class=$1}else {$class="Test2::Event::$type"}my$hub=Test2::API::test2_stack()->top();my$e=$class->new(trace=>Test2::Util::Trace->new(frame=>[caller(0)],buffered=>$hub->buffered,nested=>$hub->nested,hid=>$hub->hid,huuid=>$hub->uuid,),%params,);$hub->send($e)}sub current_subtest {my$self=shift;my$stack=$self->{+STACK}or return undef;for my$state (reverse @$stack){next unless$state->{subtest};return$state->{subtest}}return undef}sub run {my$self=shift;my$stack=$self->stack;my$c=0;while (@$stack){$self->cull;my$state=$stack->[-1];my$task=$state->{task};unless($state->{started}++){my$skip=$task->skip;my$filter;if (my$f=$self->{+FILTER}){my$in_var=grep {$_->{filter_satisfied}}@$stack;$filter=$task->filter($f)unless$in_var;$state->{filter_satisfied}=1 if$filter->{satisfied}}$skip ||= $filter->{skip}if$filter;if ($skip){$state->{ended}++;$self->send_event('Skip',reason=>$skip || $filter,name=>$task->name,pass=>1,effective_pass=>1,);pop @$stack;next}if ($task->flat){my$st=$self->current_subtest;my$hub=$st ? $st->hub : Test2::API::test2_stack->top;$state->{todo}=Test2::Todo->new(reason=>$task->todo,hub=>$hub)if$task->todo;$hub->send($_)for @{$task->events}}else {my$st=Test2::AsyncSubtest->new(name=>$task->name,frame=>$task->frame,);$state->{subtest}=$st;$state->{todo}=Test2::Todo->new(reason=>$task->todo,hub=>$st->hub)if$task->todo;for my$e (@{$task->events}){my$hub=$st->hub;$e->trace->{buffered}=$hub->buffered;$e->trace->{nested}=$hub->nested;$e->trace->{hid}=$hub->hid;$e->trace->{huuid}=$hub->uuid;$hub->send($e)}my$slot=$self->isolate($state);if (defined($slot)){push @{$self->{+SUBTESTS}}=>[$st,$task]unless$st->finished;$state->{subtest}=undef;$state->{ended}=1}}}if ($state->{ended}){$state->{todo}->end()if$state->{todo};$state->{subtest}->stop()if$state->{subtest};return if$state->{in_thread};if(my$guard=delete$state->{in_fork}){$state->{subtest}->detach;$guard->dismiss;exit 0}pop @$stack;next}if($state->{subtest}&&!$state->{subtest_started}++){push @{$self->{+SUBTESTS}}=>[$state->{subtest},$task];$state->{subtest}->start()}if ($task->isa('Test2::Workflow::Task::Action')){$state->{PID}=$$;my$ok=eval {$task->code->($self);1};unless ($state->{PID}==$$){print STDERR "Task '" .$task->name ."' started in pid $state->{PID}, but ended in pid $$, did you forget to exit after forking?\n";exit 255}$task->exception($@)unless$ok;$state->{ended}=1;next}if (!$state->{stage}|| $state->{stage}eq 'BEFORE'){$state->{before}=(defined$state->{before})? $state->{before}: 0;if (my$add=$task->before->[$state->{before}++]){if ($add->around){$state->{PID}=$$;my$ok=eval {$add->code->($self);1};my$err=$@;my$complete=$state->{stage}&& $state->{stage}eq 'AFTER';unless ($state->{PID}==$$){print STDERR "Task '" .$task->name ."' started in pid $state->{PID}, but ended in pid $$, did you forget to exit after forking?\n";exit 255}unless($ok && $complete){$state->{ended}=1;$state->{stage}='AFTER';$task->exception($ok ? "'around' task failed to continue into the workflow chain.\n" : $err)}}else {$self->push_task($add)}}else {$state->{stage}='VARIANT'}}elsif ($state->{stage}eq 'VARIANT'){if (my$v=$task->variant){$self->push_task($v)}$state->{stage}='PRIMARY'}elsif ($state->{stage}eq 'PRIMARY'){unless (defined$state->{order}){my$rand=defined($task->rand)? $task->rand : $self->rand;$state->{order}=[0 .. scalar(@{$task->primary})- 1];@{$state->{order}}=shuffle(@{$state->{order}})if$rand}my$num=shift @{$state->{order}};if (defined$num){$self->push_task($task->primary->[$num])}else {$state->{stage}='AFTER'}}elsif ($state->{stage}eq 'AFTER'){$state->{after}=(defined$state->{after})? $state->{after}: 0;if (my$add=$task->after->[$state->{after}++]){return if$add->around;$self->push_task($add)}else {$state->{ended}=1}}}$self->finish}sub push_task {my$self=shift;my ($task)=@_;confess "No Task!" unless$task;confess "Bad Task ($task)!" unless blessed($task)&& $task->isa('Test2::Workflow::Task');if ($task->isa('Test2::Workflow::Build')){confess "Can only push a Build instance when initializing the stack" if @{$self->{+STACK}};$task=$task->compile()}push @{$self->{+STACK}}=>{task=>$task,name=>$task->name,}}sub add_mock {my$self=shift;my ($mock)=@_;my$stack=$self->{+STACK};confess "Nothing on the stack!" unless$stack && @$stack;my ($state)=grep {!$_->{task}->scaffold}reverse @$stack;push @{$state->{mocks}}=>$mock}sub isolate {my$self=shift;my ($state)=@_;return if$state->{task}->skip;my$iso=$state->{task}->iso;my$async=$state->{task}->async;return undef unless$iso || $async;unless($self->{+MAX}&& $self->is_local){return undef unless$iso}my$slot=0;while($self->{+MAX}&& $self->is_local){$self->cull;for my$s (1 .. $self->{+MAX}){my$st=$self->{+SLOTS}->[$s];next if$st &&!$st->finished;$self->{+SLOTS}->[$s]=undef;$slot=$s;last}last if$slot;sleep(0.02)}my$st=$state->{subtest}or confess "Cannot isolate a task without a subtest";if (!$self->no_fork){my$out=$st->fork;if (blessed($out)){$state->{in_fork}=$out;return undef}else {$self->send_event('Note',message=>"Forked PID $out to run: " .$state->{task}->name,);$state->{pid}=$out}}elsif (!$self->no_threads){$state->{in_thread}=1;my$thr=$st->run_thread(\&run,$self);$state->{thread}=$thr;delete$state->{in_thread};$self->send_event('Note',message=>"Started Thread-ID " .$thr->tid ." to run: " .$state->{task}->name,)}else {$st->finish(skip=>"No isolation method available");return 0}if($slot){$self->{+SLOTS}->[$slot]=$st}else {$st->finish}return$slot}sub cull {my$self=shift;my$subtests=delete$self->{+SUBTESTS}|| return;my@new;for my$set (reverse @$subtests){my ($st,$task)=@$set;next if$st->finished;if (!$st->active && $st->ready){$st->finish();next}unshift@new=>$set}$self->{+SUBTESTS}=\@new;return}sub finish {my$self=shift;while(@{$self->{+SUBTESTS}}){$self->cull;sleep(0.02)if @{$self->{+SUBTESTS}}}}1;
TEST2_WORKFLOW_RUNNER

$fatpacked{"Test2/Workflow/Task.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_TASK';
  package Test2::Workflow::Task;use strict;use warnings;our$VERSION='0.000122';use Test2::API();use Test2::Event::Exception();use List::Util qw/min max/;use Scalar::Util qw/blessed/;use Carp qw/croak/;our@CARP_NOT=qw/Test2::Util::HashBase/;use base 'Test2::Workflow::BlockBase';use Test2::Util::HashBase qw/name flat async iso todo skip scaffold events is_root/;for my$attr (FLAT,ISO,ASYNC,TODO,SKIP,SCAFFOLD){my$old=__PACKAGE__->can("set_$attr");my$new=sub {my$self=shift;my$out=$self->$old(@_);$self->verify_scaffold;return$out};no strict 'refs';no warnings 'redefine';*{"set_$attr"}=$new}sub init {my$self=shift;$self->{+EVENTS}||= [];{local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->SUPER::init()}$self->throw("the 'name' attribute is required")unless$self->{+NAME};$self->throw("the 'flat' attribute cannot be combined with 'iso' or 'async'")if$self->{+FLAT}&& ($self->{+ISO}|| $self->{+ASYNC});$self->set_subname($self->package ."::<$self->{+NAME}>");$self->verify_scaffold}sub clone {my$self=shift;return bless {%$self},blessed($self)}sub verify_scaffold {my$self=shift;return unless$self->{+SCAFFOLD};croak "The 'flat' attribute must be true for scaffolding" if defined($self->{+FLAT})&&!$self->{+FLAT};$self->{+FLAT}=1;for my$attr (ISO,ASYNC,TODO,SKIP){croak "The '$attr' attribute cannot be used on scaffolding" if$self->{$attr}}}sub exception {my$self=shift;my ($err)=@_;my$hub=Test2::API::test2_stack->top;my$trace=$self->trace($hub);$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>$err,),)}sub filter {my$self=shift;my ($filter)=@_;return unless$filter;return if$self->{+IS_ROOT};return if$self->{+SCAFFOLD};if (my$name=$filter->{name}){my$ok=0;unless(ref($name)){$ok ||= $self->{+NAME}eq $name;$ok ||= $self->subname eq $name}if (ref($name)eq 'Regexp'){$ok ||= $self->{+NAME}=~ $name;$ok ||= $self->subname =~ $name}elsif ($name =~ m{^/}){my$pattern=eval "qr$name" or die "'$name' does not appear to be a valid pattern";$ok ||= $self->{+NAME}=~ $pattern;$ok ||= $self->subname =~ $pattern}return {skip=>"Does not match name filter '$name'"}unless$ok}if (my$file=$filter->{file}){return {skip=>"Does not match file filter '$file'"}unless$self->file eq $file}if (my$line=$filter->{line}){my$lines=$self->lines;return {skip=>"Does not match line filter '$line' (no lines)"}unless$lines && @$lines;my$min=min(@$lines);my$max=max(@$lines);return {skip=>"Does not match line filter '$min <= $line <= $max'"}unless$min <= $line && $max >= $line}return}1;
TEST2_WORKFLOW_TASK

$fatpacked{"Test2/Workflow/Task/Action.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_TASK_ACTION';
  package Test2::Workflow::Task::Action;use strict;use warnings;our$VERSION='0.000122';use base 'Test2::Workflow::Task';use Test2::Util::HashBase qw/around/;1;
TEST2_WORKFLOW_TASK_ACTION

$fatpacked{"Test2/Workflow/Task/Group.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_TASK_GROUP';
  package Test2::Workflow::Task::Group;use strict;use warnings;our$VERSION='0.000122';use Carp qw/croak/;use Test2::Workflow::Task::Action;use base 'Test2::Workflow::Task';use Test2::Util::HashBase qw/before after primary rand variant/;sub init {my$self=shift;if (my$take=delete$self->{take}){$self->{$_}=delete$take->{$_}for ISO,ASYNC,TODO,SKIP;$self->{$_}=$take->{$_}for FLAT,SCAFFOLD,NAME,CODE,FRAME;$take->{+FLAT}=1;$take->{+SCAFFOLD}=1}{local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->SUPER::init()}$self->{+BEFORE}||= [];$self->{+AFTER}||= [];$self->{+PRIMARY}||= []}sub filter {my$self=shift;my ($filter)=@_;return if$self->{+IS_ROOT};my$result=$self->SUPER::filter($filter);my$child_ok=0;for my$c (@{$self->{+PRIMARY}}){next if$c->{+SCAFFOLD};my$res=$c->filter($filter);$child_ok++ if!$res || $res->{satisfied};last if$child_ok}unless($result){return {satisfied=>1}if$self->{+VARIANT}||!$child_ok;return}return if$child_ok;return$result}1;
TEST2_WORKFLOW_TASK_GROUP

$fatpacked{"Tie/Handle/Offset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_OFFSET';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::Offset;our$VERSION='0.004';use Tie::Handle;our@ISA=qw/Tie::Handle/;sub offset {my$self=shift;if (@_){return ${*$self}{offset}=shift}else {return ${*$self}{offset}}}sub TIEHANDLE {my$class=shift;my$params;$params=pop if ref $_[-1]eq 'HASH';my$self=\do {no warnings 'once';local*HANDLE};bless$self,$class;$self->OPEN(@_)if (@_);if ($params->{offset}){seek($self,$self->offset($params->{offset}),0)}return$self}sub TELL {my$cur=tell($_[0])- $_[0]->offset;return$cur > 0 ? $cur : 0}sub SEEK {my ($self,$pos,$whence)=@_;my$rc;if ($whence==0 || $whence==1){$rc=seek($self,$pos + $self->offset,$whence)}elsif (_size($self)+ $pos < $self->offset){$rc=''}else {$rc=seek($self,$pos,$whence)}return$rc}sub OPEN {$_[0]->offset(0);$_[0]->CLOSE if defined($_[0]->FILENO);@_==2 ? open($_[0],$_[1]): open($_[0],$_[1],$_[2])}sub _size {my ($self)=@_;my$cur=tell($self);seek($self,0,2);my$size=tell($self);seek($self,$cur,0);return$size}sub EOF {eof($_[0])}sub FILENO {fileno($_[0])}sub CLOSE {close($_[0])}sub BINMODE {binmode($_[0])}sub READ {read($_[0],$_[1],$_[2])}sub READLINE {my$fh=$_[0];<$fh>}sub GETC {getc($_[0])}sub WRITE {my$fh=$_[0];print$fh substr($_[1],0,$_[2])}1;
TIE_HANDLE_OFFSET

$fatpacked{"Tie/Handle/SkipHeader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_SKIPHEADER';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::SkipHeader;our$VERSION='0.004';use Tie::Handle::Offset;our@ISA=qw/Tie::Handle::Offset/;sub TIEHANDLE {my$class=shift;pop if ref $_[-1]eq 'HASH';return$class->SUPER::TIEHANDLE(@_)}sub OPEN {my$self=shift;my$rc=$self->SUPER::OPEN(@_);while (my$line=<$self>){last if$line =~ /\A\s*\Z/}$self->offset(tell($self));return$rc}1;
TIE_HANDLE_SKIPHEADER

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.30';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}_subname(caller().'::try {...} '=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;_subname(caller().'::catch {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;_subname(caller().'::finally {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;use strict;use warnings;our$VERSION='1.76';our ($ABS_REMOTE_LEADING_DOTS,$ABS_ALLOW_RELATIVE_SCHEME,$DEFAULT_QUERY_FORM_DELIMITER);my%implements;our$reserved=q(;/?:@&=+$,[]);our$mark=q(-_.!~*'());our$unreserved="A-Za-z0-9\Q$mark\E";our$uric=quotemeta($reserved).$unreserved ."%";our$scheme_re='[a-zA-Z][a-zA-Z0-9.+\-]*';use Carp ();use URI::Escape ();use overload ('""'=>sub {${$_[0]}},'=='=>sub {_obj_eq(@_)},'!='=>sub {!_obj_eq(@_)},fallback=>1,);sub _obj_eq {return overload::StrVal($_[0])eq overload::StrVal($_[1])}sub new {my($class,$uri,$scheme)=@_;$uri=defined ($uri)? "$uri" : "";$uri =~ s/^<(?:URL:)?(.*)>$/$1/;$uri =~ s/^"(.*)"$/$1/;$uri =~ s/^\s+//;$uri =~ s/\s+$//;my$impclass;if ($uri =~ m/^($scheme_re):/so){$scheme=$1}else {if (($impclass=ref($scheme))){$scheme=$scheme->scheme}elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o){$scheme=$1}}$impclass ||= implementor($scheme)|| do {require URI::_foreign;$impclass='URI::_foreign'};return$impclass->_init($uri,$scheme)}sub new_abs {my($class,$uri,$base)=@_;$uri=$class->new($uri,$base);$uri->abs($base)}sub _init {my$class=shift;my($str,$scheme)=@_;$str=$class->_uric_escape($str);$str="$scheme:$str" unless$str =~ /^$scheme_re:/o || $class->_no_scheme_ok;my$self=bless \$str,$class;$self}sub _uric_escape {my($class,$str)=@_;$str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;utf8::downgrade($str);return$str}my%require_attempted;sub implementor {my($scheme,$impclass)=@_;if (!$scheme || $scheme !~ /\A$scheme_re\z/o){require URI::_generic;return "URI::_generic"}$scheme=lc($scheme);if ($impclass){my$old=$implements{$scheme};$impclass->_init_implementor($scheme);$implements{$scheme}=$impclass;return$old}my$ic=$implements{$scheme};return$ic if$ic;$ic="URI::$scheme";$ic =~ s/\+/_P/g;$ic =~ s/\./_O/g;$ic =~ s/\-/_/g;no strict 'refs';unless (@{"${ic}::ISA"}){if (not exists$require_attempted{$ic}){my$_old_error=$@;eval "require $ic";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}return undef unless @{"${ic}::ISA"}}$ic->_init_implementor($scheme);$implements{$scheme}=$ic;$ic}sub _init_implementor {my($class,$scheme)=@_}sub clone {my$self=shift;my$other=$$self;bless \$other,ref$self}sub TO_JSON {${$_[0]}}sub _no_scheme_ok {0}sub _scheme {my$self=shift;unless (@_){return undef unless $$self =~ /^($scheme_re):/o;return $1}my$old;my$new=shift;if (defined($new)&& length($new)){Carp::croak("Bad scheme '$new'")unless$new =~ /^$scheme_re$/o;$old=$1 if $$self =~ s/^($scheme_re)://o;my$newself=URI->new("$new:$$self");$$self=$$newself;bless$self,ref($newself)}else {if ($self->_no_scheme_ok){$old=$1 if $$self =~ s/^($scheme_re)://o;Carp::carp("Oops, opaque part now look like scheme")if $^W && $$self =~ m/^$scheme_re:/o}else {$old=$1 if $$self =~ m/^($scheme_re):/o}}return$old}sub scheme {my$scheme=shift->_scheme(@_);return undef unless defined$scheme;lc($scheme)}sub has_recognized_scheme {my$self=shift;return ref($self)!~ /^URI::_(?:foreign|generic)\z/}sub opaque {my$self=shift;unless (@_){$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;return $1}$$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;my$old_scheme=$1;my$old_opaque=$2;my$old_frag=$3;my$new_opaque=shift;$new_opaque="" unless defined$new_opaque;$new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_opaque);$$self=defined($old_scheme)? $old_scheme : "";$$self .= $new_opaque;$$self .= $old_frag if defined$old_frag;$old_opaque}sub path {goto&opaque}sub fragment {my$self=shift;unless (@_){return undef unless $$self =~ /\#(.*)/s;return $1}my$old;$old=$1 if $$self =~ s/\#(.*)//s;my$new_frag=shift;if (defined$new_frag){$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;utf8::downgrade($new_frag);$$self .= "#$new_frag"}$old}sub as_string {my$self=shift;$$self}sub as_iri {my$self=shift;my$str=$$self;if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg){require Encode;my$enc=Encode::find_encoding("UTF-8");my$u="";while (length$str){$u .= $enc->decode($str,Encode::FB_QUIET());if (length$str){$u .= URI::Escape::escape_char(substr($str,0,1,""))}}$str=$u}return$str}sub canonical {my$self=shift;my$scheme=$self->_scheme || "";my$uc_scheme=$scheme =~ /[A-Z]/;my$esc=$$self =~ /%[a-fA-F0-9]{2}/;return$self unless$uc_scheme || $esc;my$other=$self->clone;if ($uc_scheme){$other->_scheme(lc$scheme)}if ($esc){$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge}return$other}sub eq {my($self,$other)=@_;$self=URI->new($self,$other)unless ref$self;$other=URI->new($other,$self)unless ref$other;ref($self)eq ref($other)&& $self->canonical->as_string eq $other->canonical->as_string}sub abs {$_[0]}sub rel {$_[0]}sub secure {0}sub STORABLE_freeze {my($self,$cloning)=@_;return $$self}sub STORABLE_thaw {my($self,$cloning,$str)=@_;$$self=$str}1;
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;use strict;use warnings;use Exporter 5.57 'import';our%escapes;our@EXPORT=qw(uri_escape uri_unescape uri_escape_utf8);our@EXPORT_OK=qw(%escapes);our$VERSION="3.31";use Carp ();for (0..255){$escapes{chr($_)}=sprintf("%%%02X",$_)}my%subst;my%Unsafe=(RFC2732=>qr/[^A-Za-z0-9\-_.!~*'()]/,RFC3986=>qr/[^A-Za-z0-9\-\._~]/,);sub uri_escape {my($text,$patn)=@_;return undef unless defined$text;if (defined$patn){unless (exists$subst{$patn}){(my$tmp=$patn)=~ s,/,\\/,g;eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";Carp::croak("uri_escape: $@")if $@}&{$subst{$patn}}($text)}else {$text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge}$text}sub _fail_hi {my$chr=shift;Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead",ord($chr))}sub uri_escape_utf8 {my$text=shift;return undef unless defined$text;utf8::encode($text);return uri_escape($text,@_)}sub uri_unescape {my$str=shift;if (@_ && wantarray){my@str=($str,@_);for (@str){s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}return@str}$str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined$str;$str}sub escape_char {my$dummy=substr($_[0],0,0);if (utf8::is_utf8($_[0])){my$s=shift;utf8::encode($s);unshift(@_,$s)}return join '',@URI::Escape::escapes{split //,$_[0]}}1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;use strict;use warnings;use Exporter 5.57 'import';our@EXPORT_OK=qw(uf_uri uf_uristr uf_url uf_urlstr);our$VERSION="4.20";our ($MY_COUNTRY,$DEBUG);sub MY_COUNTRY() {for ($MY_COUNTRY){return $_ if defined;$_=$ENV{COUNTRY};return $_ if defined;my@srcs=($ENV{LC_ALL},$ENV{LANG});if (my$httplang=$ENV{HTTP_ACCEPT_LANGUAGE}){for$httplang (split(/\s*,\s*/,$httplang)){if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/){unshift(@srcs,"${1}_${2}");last}}}for (@srcs){next unless defined;return lc($1)if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/}require Net::Domain;my$fqdn=Net::Domain::hostfqdn();$_=lc($1)if$fqdn =~ /\.([a-zA-Z]{2})$/;return $_ if defined;return ($_=0)}}our%LOCAL_GUESSING=('us'=>[qw(www.ACME.gov www.ACME.mil)],'gb'=>[qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],'au'=>[qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],'il'=>[qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],);$LOCAL_GUESSING{uk}=$LOCAL_GUESSING{gb};sub uf_uristr ($) {local($_)=@_;print STDERR "uf_uristr: resolving $_\n" if$DEBUG;return unless defined;s/^\s+//;s/\s+$//;if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i){$_="http://$_"}elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i){$_=lc($1)."://$_"}elsif ($^O ne "MacOS" && (m,^/, || m,^\.\.?/, || m,^[a-zA-Z]:[/\\],)){$_="file:$_"}elsif ($^O eq "MacOS" && m/:/){unless (m/^(ftp|gopher|news|wais|http|https|mailto):/){require URI::file;my$a=URI::file->new($_)->as_string;$_=($a =~ m/^file:/)? $a : "file:$a"}}elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/){$_="mailto:$_"}elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/){if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/){my$host=$1;my$scheme="http";if (/^:(\d+)\b/){if ($1 =~ /^[56789]?443$/){$scheme="https"}elsif ($1 eq "21"){$scheme="ftp"}}if ($host !~ /\./ && $host ne "localhost"){my@guess;if (exists$ENV{URL_GUESS_PATTERN}){@guess=map {s/\bACME\b/$host/;$_}split(' ',$ENV{URL_GUESS_PATTERN})}else {if (MY_COUNTRY()){my$special=$LOCAL_GUESSING{MY_COUNTRY()};if ($special){my@special=@$special;push(@guess,map {s/\bACME\b/$host/;$_}@special)}else {push(@guess,"www.$host." .MY_COUNTRY())}}push(@guess,map "www.$host.$_","com","org","net","edu","int")}my$guess;for$guess (@guess){print STDERR "uf_uristr: gethostbyname('$guess.')..." if$DEBUG;if (gethostbyname("$guess.")){print STDERR "yes\n" if$DEBUG;$host=$guess;last}print STDERR "no\n" if$DEBUG}}$_="$scheme://$host$_"}else {}}print STDERR "uf_uristr: ==> $_\n" if$DEBUG;$_}sub uf_uri ($) {require URI;URI->new(uf_uristr($_[0]))}*uf_urlstr=\*uf_uristr;sub uf_url ($) {require URI::URL;URI::URL->new(uf_uristr($_[0]))}1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;use strict;use warnings;use URI ();use overload '""'=>sub {shift->as_string};our$VERSION='1.76';sub new {my($class,$uri,$scheme)=@_;utf8::upgrade($uri);return bless {uri=>URI->new($uri,$scheme),},$class}sub clone {my$self=shift;return bless {uri=>$self->{uri}->clone,},ref($self)}sub as_string {my$self=shift;return$self->{uri}->as_iri}our$AUTOLOAD;sub AUTOLOAD {my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);no strict 'refs';*$method=sub {shift->{uri}->$method(@_)};goto &$method}sub DESTROY {}1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;use strict;use warnings;our$VERSION='1.76';sub URI::_query::query_param {my$self=shift;my@old=$self->query_form;if (@_==0){my (%seen,$i);return grep!($i++ % 2 || $seen{$_}++),@old}my$key=shift;my@i=grep $_ % 2==0 && $old[$_]eq $key,0 .. $#old;if (@_){my@new=@old;my@new_i=@i;my@vals=map {ref($_)eq 'ARRAY' ? @$_ : $_}@_;while (@new_i > @vals){splice@new,pop@new_i,2}if (@vals > @new_i){my$i=@new_i ? $new_i[-1]+ 2 : @new;my@splice=splice@vals,@new_i,@vals - @new_i;splice@new,$i,0,map {$key=>$_}@splice}if (@vals){@new[map $_ + 1,@new_i ]=@vals}$self->query_form(\@new)}return wantarray ? @old[map $_+1,@i]: @i ? $old[$i[0]+1]: undef}sub URI::_query::query_param_append {my$self=shift;my$key=shift;my@vals=map {ref $_ eq 'ARRAY' ? @$_ : $_}@_;$self->query_form($self->query_form,$key=>\@vals);return}sub URI::_query::query_param_delete {my$self=shift;my$key=shift;my@old=$self->query_form;my@vals;for (my$i=@old - 2;$i >= 0;$i -= 2){next if$old[$i]ne $key;push(@vals,(splice(@old,$i,2))[1])}$self->query_form(\@old)if@vals;return wantarray ? reverse@vals : $vals[-1]}sub URI::_query::query_form_hash {my$self=shift;my@old=$self->query_form;if (@_){$self->query_form(@_==1 ? %{shift(@_)}: @_)}my%hash;while (my($k,$v)=splice(@old,0,2)){if (exists$hash{$k}){for ($hash{$k}){$_=[$_]unless ref($_)eq "ARRAY";push(@$_,$v)}}else {$hash{$k}=$v}}return \%hash}1;
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;use strict;use warnings;our$VERSION='1.76';use Exporter 5.57 'import';our@EXPORT_OK=qw(uri_split uri_join);use URI::Escape ();sub uri_split {return $_[0]=~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,}sub uri_join {my($scheme,$auth,$path,$query,$frag)=@_;my$uri=defined($scheme)? "$scheme:" : "";$path="" unless defined$path;if (defined$auth){$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$uri .= "//$auth";$path="/$path" if length($path)&& $path !~ m,^/,}elsif ($path =~ m,^//,){$uri .= "//"}unless (length$uri){$path =~ s,(:), URI::Escape::escape_char($1),e while$path =~ m,^[^:/?\#]+:,}$path =~ s,([?\#]), URI::Escape::escape_char($1),eg;$uri .= $path;if (defined$query){$query =~ s,(\#), URI::Escape::escape_char($1),eg;$uri .= "?$query"}$uri .= "#$frag" if defined$frag;$uri}1;
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;use strict;use warnings;use parent 'URI::WithBase';our$VERSION="5.04";use Exporter 5.57 'import';our@EXPORT=qw(url);sub url ($;$) {URI::URL->new(@_)}use URI::Escape qw(uri_unescape);sub new {my$class=shift;my$self=$class->SUPER::new(@_);$self->[0]=$self->[0]->canonical;$self}sub newlocal {my$class=shift;require URI::file;bless [URI::file->new_abs(shift)],$class}{package URI::_foreign;sub _init {my$class=shift;die "Unknown URI::URL scheme $_[1]:" if$URI::URL::STRICT;$class->SUPER::_init(@_)}}sub strict {my$old=$URI::URL::STRICT;$URI::URL::STRICT=shift if @_;$old}sub print_on {my$self=shift;require Data::Dumper;print STDERR Data::Dumper::Dumper($self)}sub _try {my$self=shift;my$method=shift;scalar(eval {$self->$method(@_)})}sub crack {my$self=shift;(scalar($self->scheme),$self->_try("user"),$self->_try("password"),$self->_try("host"),$self->_try("port"),$self->_try("path"),$self->_try("params"),$self->_try("query"),scalar($self->fragment),)}sub full_path {my$self=shift;my$path=$self->path_query;$path="/" unless length$path;$path}sub netloc {shift->authority(@_)}sub epath {my$path=shift->SUPER::path(@_);$path =~ s/;.*//;$path}sub eparams {my$self=shift;my@p=$self->path_segments;return undef unless ref($p[-1]);@p=@{$p[-1]};shift@p;join(";",@p)}sub params {shift->eparams(@_)}sub path {my$self=shift;my$old=$self->epath(@_);return unless defined wantarray;return '/' if!defined($old)||!length($old);Carp::croak("Path components contain '/' (you must call epath)")if$old =~ /%2[fF]/ and!@_;$old="/$old" if$old !~ m|^/| && defined$self->netloc;return uri_unescape($old)}sub path_components {shift->path_segments(@_)}sub query {my$self=shift;my$old=$self->equery(@_);if (defined(wantarray)&& defined($old)){if ($old =~ /%(?:26|2[bB]|3[dD])/){my$mess;for ($old){$mess="Query contains both '+' and '%2B'" if /\+/ && /%2[bB]/;$mess="Form query contains escaped '=' or '&'" if /=/ && /%(?:3[dD]|26)/}if ($mess){Carp::croak("$mess (you must call equery)")}}return uri_unescape($old)}undef}sub abs {my$self=shift;my$base=shift;my$allow_scheme=shift;$allow_scheme=$URI::URL::ABS_ALLOW_RELATIVE_SCHEME unless defined$allow_scheme;local$URI::ABS_ALLOW_RELATIVE_SCHEME=$allow_scheme;local$URI::ABS_REMOTE_LEADING_DOTS=$URI::URL::ABS_REMOTE_LEADING_DOTS;$self->SUPER::abs($base)}sub frag {shift->fragment(@_)}sub keywords {shift->query_keywords(@_)}sub local_path {shift->file}sub unix_path {shift->file("unix")}sub dos_path {shift->file("dos")}sub mac_path {shift->file("mac")}sub vms_path {shift->file("vms")}sub address {shift->to(@_)}sub encoded822addr {shift->to(@_)}sub URI::mailto::authority {shift->to(@_)}sub groupart {shift->_group(@_)}sub article {shift->message(@_)}1;
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;use strict;use warnings;use URI;use Scalar::Util 'blessed';our$VERSION="2.20";use overload '""'=>"as_string",fallback=>1;sub as_string;sub new {my($class,$uri,$base)=@_;my$ibase=$base;if ($base && blessed($base)&& $base->isa(__PACKAGE__)){$base=$base->abs;$ibase=$base->[0]}bless [URI->new($uri,$ibase),$base],$class}sub new_abs {my$class=shift;my$self=$class->new(@_);$self->abs}sub _init {my$class=shift;my($str,$scheme)=@_;bless [URI->new($str,$scheme),undef],$class}sub eq {my($self,$other)=@_;$other=$other->[0]if blessed($other)and $other->isa(__PACKAGE__);$self->[0]->eq($other)}our$AUTOLOAD;sub AUTOLOAD {my$self=shift;my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);return if$method eq "DESTROY";$self->[0]->$method(@_)}sub can {my$self=shift;$self->SUPER::can(@_)|| (ref($self)? $self->[0]->can(@_): undef)}sub base {my$self=shift;my$base=$self->[1];if (@_){my$new_base=shift;$new_base=$new_base->abs if ref($new_base)&& $new_base->isa(__PACKAGE__);$self->[1]=$new_base}return unless defined wantarray;if (defined($base)&&!ref($base)){$base=ref($self)->new($base);$self->[1]=$base unless @_}$base}sub clone {my$self=shift;my$base=$self->[1];$base=$base->clone if ref($base);bless [$self->[0]->clone,$base],ref($self)}sub abs {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->abs($base,@_),$base],ref($self)}sub rel {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->rel($base,@_),$base],ref($self)}1;
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;use strict;use warnings;use parent 'URI::_generic';our$VERSION='1.76';1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;use strict;use warnings;use parent qw(URI URI::_query);use URI::Escape qw(uri_unescape);use Carp ();our$VERSION='1.76';my$ACHAR=$URI::uric;$ACHAR =~ s,\\[/?],,g;my$PCHAR=$URI::uric;$PCHAR =~ s,\\[?],,g;sub _no_scheme_ok {1}sub authority {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;if (@_){my$auth=shift;$$self=$1;my$rest=$3;if (defined$auth){$auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($auth);$$self .= "//$auth"}_check_path($rest,$$self);$$self .= $rest}$2}sub path {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub path_query {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub _check_path {my($path,$pre)=@_;my$prefix;if ($pre =~ m,/,){$prefix="/" if length($path)&& $path !~ m,^[/?\#],}else {if ($path =~ m,^//,){Carp::carp("Path starting with double slash is confusing")if $^W}elsif (!length($pre)&& $path =~ m,^[^:/?\#]+:,){Carp::carp("Path might look like scheme, './' prepended")if $^W;$prefix="./"}}substr($_[0],0,0)=$prefix if defined$prefix}sub path_segments {my$self=shift;my$path=$self->path;if (@_){my@arg=@_;for (@arg){if (ref($_)){my@seg=@$_;$seg[0]=~ s/%/%25/g;for (@seg){s/;/%3B/g}$_=join(";",@seg)}else {s/%/%25/g;s/;/%3B/g}s,/,%2F,g}$self->path(join("/",@arg))}return$path unless wantarray;map {/;/ ? $self->_split_segment($_): uri_unescape($_)}split('/',$path,-1)}sub _split_segment {my$self=shift;require URI::_segment;URI::_segment->new(@_)}sub abs {my$self=shift;my$base=shift || Carp::croak("Missing base argument");if (my$scheme=$self->scheme){return$self unless$URI::ABS_ALLOW_RELATIVE_SCHEME;$base=URI->new($base)unless ref$base;return$self unless$scheme eq $base->scheme}$base=URI->new($base)unless ref$base;my$abs=$self->clone;$abs->scheme($base->scheme);return$abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;$abs->authority($base->authority);my$path=$self->path;return$abs if$path =~ m,^/,;if (!length($path)){my$abs=$base->clone;my$query=$self->query;$abs->query($query)if defined$query;my$fragment=$self->fragment;$abs->fragment($fragment)if defined$fragment;return$abs}my$p=$base->path;$p =~ s,[^/]+$,,;$p .= $path;my@p=split('/',$p,-1);shift(@p)if@p &&!length($p[0]);my$i=1;while ($i < @p){if ($p[$i-1]eq "."){splice(@p,$i-1,1);$i-- if$i > 1}elsif ($p[$i]eq ".." && $p[$i-1]ne ".."){splice(@p,$i-1,2);if ($i > 1){$i--;push(@p,"")if$i==@p}}else {$i++}}$p[-1]="" if@p && $p[-1]eq ".";if ($URI::ABS_REMOTE_LEADING_DOTS){shift@p while@p && $p[0]=~ /^\.\.?$/}$abs->path("/" .join("/",@p));$abs}sub rel {my$self=shift;my$base=shift || Carp::croak("Missing base argument");my$rel=$self->clone;$base=URI->new($base)unless ref$base;my$scheme=$rel->scheme;my$auth=$rel->canonical->authority;my$path=$rel->path;if (!defined($scheme)&&!defined($auth)){return$rel}my$bscheme=$base->scheme;my$bauth=$base->canonical->authority;my$bpath=$base->path;for ($bscheme,$bauth,$auth){$_='' unless defined}unless ($scheme eq $bscheme && $auth eq $bauth){return$rel}for ($path,$bpath){$_="/$_" unless m,^/,}$rel->scheme(undef);$rel->authority(undef);my$li=1;while (1){my$i=index($path,'/',$li);last if$i < 0 || $i!=index($bpath,'/',$li)|| substr($path,$li,$i-$li)ne substr($bpath,$li,$i-$li);$li=$i+1}substr($path,0,$li)='';substr($bpath,0,$li)='';if ($path eq $bpath && defined($rel->fragment)&& !defined($rel->query)){$rel->path("")}else {$path=('../' x $bpath =~ tr|/|/|).$path;$path="./" if$path eq "";$rel->path($path)}$rel}1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;use strict;use warnings;use URI::_punycode qw(encode_punycode decode_punycode);use Carp qw(croak);our$VERSION='1.76';BEGIN {*URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS="$]" < 5.008_003 ? sub () {1}: sub () {0}}my$ASCII=qr/^[\x00-\x7F]*\z/;sub encode {my$idomain=shift;my@labels=split(/\./,$idomain,-1);my@last_empty;push(@last_empty,pop@labels)if@labels > 1 && $labels[-1]eq "";for (@labels){$_=ToASCII($_)}return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;return join(".",@labels,@last_empty)}sub decode {my$domain=shift;return join(".",map ToUnicode($_),split(/\./,$domain,-1))}sub nameprep {my$label=shift;$label=lc($label);return$label}sub check_size {my$label=shift;croak "Label empty" if$label eq "";croak "Label too long" if length($label)> 63;return$label}sub ToASCII {my$label=shift;return check_size($label)if$label =~ $ASCII;$label=nameprep($label);return check_size($label)if$label =~ $ASCII;if ($label =~ /^xn--/){croak "Label starts with ACE prefix"}$label=encode_punycode($label);$label="xn--$label";return check_size($label)}sub ToUnicode {my$label=shift;$label=nameprep($label)unless$label =~ $ASCII;return$label unless$label =~ /^xn--/;my$result=decode_punycode(substr($label,4));my$label2=ToASCII($result);if (lc($label)ne $label2){croak "IDNA does not round-trip: '\L$label\E' vs '$label2'"}return$result}1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  package URI::_ldap;use strict;use warnings;our$VERSION='1.76';use URI::Escape qw(uri_unescape);sub _ldap_elem {my$self=shift;my$elem=shift;my$query=$self->query;my@bits=(split(/\?/,defined($query)? $query : ""),("")x4);my$old=$bits[$elem];if (@_){my$new=shift;$new =~ s/\?/%3F/g;$bits[$elem]=$new;$query=join("?",@bits);$query =~ s/\?+$//;$query=undef unless length($query);$self->query($query)}$old}sub dn {my$old=shift->path(@_);$old =~ s:^/::;uri_unescape($old)}sub attributes {my$self=shift;my$old=_ldap_elem($self,0,@_ ? join(",",map {my$tmp=$_;$tmp =~ s/,/%2C/g;$tmp}@_): ());return$old unless wantarray;map {uri_unescape($_)}split(/,/,$old)}sub _scope {my$self=shift;my$old=_ldap_elem($self,1,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub scope {my$old=&_scope;$old="base" unless length$old;$old}sub _filter {my$self=shift;my$old=_ldap_elem($self,2,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub filter {my$old=&_filter;$old="(objectClass=*)" unless length$old;$old}sub extensions {my$self=shift;my@ext;while (@_){my$key=shift;my$value=shift;push(@ext,join("=",map {$_="" unless defined;s/,/%2C/g;$_}$key,$value))}@ext=join(",",@ext)if@ext;my$old=_ldap_elem($self,3,@ext);return$old unless wantarray;map {uri_unescape($_)}map {/^([^=]+)=(.*)$/}split(/,/,$old)}sub canonical {my$self=shift;my$other=$self->_nonldap_canonical;$other=$other->clone if$other==$self;$other->dn(_normalize_dn($other->dn));$other->attributes(map lc,$other->attributes);my$old_scope=$other->scope;my$new_scope=lc($old_scope);$new_scope="" if$new_scope eq "base";$other->scope($new_scope)if$new_scope ne $old_scope;my$old_filter=$other->filter;$other->filter("")if lc($old_filter)eq "(objectclass=*)" || lc($old_filter)eq "objectclass=*";my@ext=$other->extensions;for (my$i=0;$i < @ext;$i += 2){my$etype=$ext[$i]=lc($ext[$i]);if ($etype =~ /^!?bindname$/){$ext[$i+1]=_normalize_dn($ext[$i+1])}}$other->extensions(@ext)if@ext;$other}sub _normalize_dn {my$dn=shift;return$dn;my@dn=split(/([+,])/,$dn);for (@dn){s/^([a-zA-Z]+=)/lc($1)/e}join("",@dn)}1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;use strict;use warnings;use parent qw(URI::_server URI::_userpass);our$VERSION='1.76';1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;use strict;use warnings;our$VERSION='1.76';use Exporter 'import';our@EXPORT=qw(encode_punycode decode_punycode);use integer;our$DEBUG=0;use constant BASE=>36;use constant TMIN=>1;use constant TMAX=>26;use constant SKEW=>38;use constant DAMP=>700;use constant INITIAL_BIAS=>72;use constant INITIAL_N=>128;my$Delimiter=chr 0x2D;my$BasicRE=qr/[\x00-\x7f]/;sub _croak {require Carp;Carp::croak(@_)}sub digit_value {my$code=shift;return ord($code)- ord("A")if$code =~ /[A-Z]/;return ord($code)- ord("a")if$code =~ /[a-z]/;return ord($code)- ord("0")+ 26 if$code =~ /[0-9]/;return}sub code_point {my$digit=shift;return$digit + ord('a')if 0 <= $digit && $digit <= 25;return$digit + ord('0')- 26 if 26 <= $digit && $digit <= 36;die 'NOT COME HERE'}sub adapt {my($delta,$numpoints,$firsttime)=@_;$delta=$firsttime ? $delta / DAMP : $delta / 2;$delta += $delta / $numpoints;my$k=0;while ($delta > ((BASE - TMIN)* TMAX)/ 2){$delta /= BASE - TMIN;$k += BASE}return$k + (((BASE - TMIN + 1)* $delta)/ ($delta + SKEW))}sub decode_punycode {my$code=shift;my$n=INITIAL_N;my$i=0;my$bias=INITIAL_BIAS;my@output;if ($code =~ s/(.*)$Delimiter//o){push@output,map ord,split //,$1;return _croak('non-basic code point')unless $1 =~ /^$BasicRE*$/o}while ($code){my$oldi=$i;my$w=1;LOOP: for (my$k=BASE;1;$k += BASE){my$cp=substr($code,0,1,'');my$digit=digit_value($cp);defined$digit or return _croak("invalid punycode input");$i += $digit * $w;my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$digit < $t;$w *= (BASE - $t)}$bias=adapt($i - $oldi,@output + 1,$oldi==0);warn "bias becomes $bias" if$DEBUG;$n += $i / (@output + 1);$i=$i % (@output + 1);splice(@output,$i,0,$n);warn join " ",map sprintf('%04x',$_),@output if$DEBUG;$i++}return join '',map chr,@output}sub encode_punycode {my$input=shift;my@input=split //,$input;my$n=INITIAL_N;my$delta=0;my$bias=INITIAL_BIAS;my@output;my@basic=grep /$BasicRE/,@input;my$h=my$b=@basic;push@output,@basic;push@output,$Delimiter if$b && $h < @input;warn "basic codepoints: (@output)" if$DEBUG;while ($h < @input){my$m=min(grep {$_ >= $n}map ord,@input);warn sprintf "next code point to insert is %04x",$m if$DEBUG;$delta += ($m - $n)* ($h + 1);$n=$m;for my$i (@input){my$c=ord($i);$delta++ if$c < $n;if ($c==$n){my$q=$delta;LOOP: for (my$k=BASE;1;$k += BASE){my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$q < $t;my$cp=code_point($t + (($q - $t)% (BASE - $t)));push@output,chr($cp);$q=($q - $t)/ (BASE - $t)}push@output,chr(code_point($q));$bias=adapt($delta,$h + 1,$h==$b);warn "bias becomes $bias" if$DEBUG;$delta=0;$h++}}$delta++;$n++}return join '',@output}sub min {my$min=shift;for (@_){$min=$_ if $_ <= $min}return$min}1;
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;use strict;use warnings;use URI ();use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub query {my$self=shift;$$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;if (@_){my$q=shift;$$self=$1;if (defined$q){$q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($q);$$self .= "?$q"}$$self .= $3}$2}sub query_form {my$self=shift;my$old=$self->query;if (@_){my$delim;my$r=$_[0];if (ref($r)eq "ARRAY"){$delim=$_[1];@_=@$r}elsif (ref($r)eq "HASH"){$delim=$_[1];@_=map {$_=>$r->{$_}}sort keys %$r}$delim=pop if @_ % 2;my@query;while (my($key,$vals)=splice(@_,0,2)){$key='' unless defined$key;$key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$key =~ s/ /+/g;$vals=[ref($vals)eq "ARRAY" ? @$vals : $vals];for my$val (@$vals){$val='' unless defined$val;$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$val =~ s/ /+/g;push(@query,"$key=$val")}}if (@query){unless ($delim){$delim=$1 if$old && $old =~ /([&;])/;$delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&"}$self->query(join($delim,@query))}else {$self->query(undef)}}return if!defined($old)||!length($old)||!defined(wantarray);return unless$old =~ /=/;map {s/\+/ /g;uri_unescape($_)}map {/=/ ? split(/=/,$_,2): ($_=>'')}split(/[&;]/,$old)}sub query_keywords {my$self=shift;my$old=$self->query;if (@_){my@copy=@_;@copy=@{$copy[0]}if@copy==1 && ref($copy[0])eq "ARRAY";for (@copy){s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg}$self->query(@copy ? join('+',@copy): undef)}return if!defined($old)||!defined(wantarray);return if$old =~ /=/;map {uri_unescape($_)}split(/\+/,$old,-1)}sub equery {goto&query}1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;use strict;use warnings;use URI::Escape qw(uri_unescape);use overload '""'=>sub {$_[0]->[0]},fallback=>1;our$VERSION='1.76';sub new {my$class=shift;my@segment=split(';',shift,-1);$segment[0]=uri_unescape($segment[0]);bless \@segment,$class}1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;use strict;use warnings;use parent 'URI::_generic';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _uric_escape {my($class,$str)=@_;if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";if (_host_escape($host)){$str="$scheme//$ui$host$port$rest"}}return$class->SUPER::_uric_escape($str)}sub _host_escape {return unless $_[0]=~ /[^$URI::uric]/;eval {require URI::_idna;$_[0]=URI::_idna::encode($_[0])};return 0 if $@;return 1}sub as_iri {my$self=shift;my$str=$self->SUPER::as_iri;if ($str =~ /\bxn--/){if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";require URI::_idna;$host=URI::_idna::decode($host);$str="$scheme//$ui$host$port$rest"}}return$str}sub userinfo {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/.*@//;my$ui=shift;if (defined$ui){$ui =~ s/@/%40/g;$new="$ui\@$new"}$self->authority($new)}return undef if!defined($old)|| $old !~ /(.*)@/;return $1}sub host {my$self=shift;my$old=$self->authority;if (@_){my$tmp=$old;$tmp="" unless defined$tmp;my$ui=($tmp =~ /(.*@)/)? $1 : "";my$port=($tmp =~ /(:\d+)$/)? $1 : "";my$new=shift;$new="" unless defined$new;if (length$new){$new =~ s/[@]/%40/g;if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/){$new =~ s/(:\d*)\z// || die "Assert";$port=$1}$new="[$new]" if$new =~ /:/ && $new !~ /^\[/;_host_escape($new)}$self->authority("$ui$new$port")}return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:\d+$//;$old =~ s{^\[(.*)\]$}{$1};return uri_unescape($old)}sub ihost {my$self=shift;my$old=$self->host(@_);if ($old =~ /(^|\.)xn--/){require URI::_idna;$old=URI::_idna::decode($old)}return$old}sub _port {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new =~ s/:\d*$//;my$port=shift;$new .= ":$port" if defined$port;$self->authority($new)}return $1 if defined($old)&& $old =~ /:(\d*)$/;return}sub port {my$self=shift;my$port=$self->_port(@_);$port=$self->default_port if!defined($port)|| $port eq "";$port}sub host_port {my$self=shift;my$old=$self->authority;$self->host(shift)if @_;return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:$//;$old .= ":" .$self->port unless$old =~ /:\d+$/;$old}sub default_port {undef}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$host=$other->host || "";my$port=$other->_port;my$uc_host=$host =~ /[A-Z]/;my$def_port=defined($port)&& ($port eq "" || $port==$self->default_port);if ($uc_host || $def_port){$other=$other->clone if$other==$self;$other->host(lc$host)if$uc_host;$other->port(undef)if$def_port}$other}1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;use strict;use warnings;use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub user {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$pass=defined($info)? $info : "";$pass =~ s/^[^:]*//;if (!defined($new)&&!length($pass)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$new =~ s/:/%3A/g;$self->userinfo("$new$pass")}}return undef unless defined$info;$info =~ s/:.*//;uri_unescape($info)}sub password {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$user=defined($info)? $info : "";$user =~ s/:.*//;if (!defined($new)&&!length($user)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$self->userinfo("$user:$new")}}return undef unless defined$info;return undef unless$info =~ s/^[^:]*://;uri_unescape($info)}1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;use strict;use warnings;use parent 'URI';our$VERSION='1.76';use MIME::Base64 qw(encode_base64 decode_base64);use URI::Escape qw(uri_unescape);sub media_type {my$self=shift;my$opaque=$self->opaque;$opaque =~ /^([^,]*),?/ or die;my$old=$1;my$base64;$base64=$1 if$old =~ s/(;base64)$//i;if (@_){my$new=shift;$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/,/%2C/g;$base64="" unless defined$base64;$opaque =~ s/^[^,]*,?/$new$base64,/;$self->opaque($opaque)}return uri_unescape($old)if$old;"text/plain;charset=US-ASCII"}sub data {my$self=shift;my($enc,$data)=split(",",$self->opaque,2);unless (defined$data){$data="";$enc="" unless defined$enc}my$base64=($enc =~ /;base64$/i);if (@_){$enc =~ s/;base64$//i if$base64;my$new=shift;$new="" unless defined$new;my$uric_count=_uric_count($new);my$urienc_len=$uric_count + (length($new)- $uric_count)* 3;my$base64_len=int((length($new)+2)/ 3)* 4;$base64_len += 7;if ($base64_len < $urienc_len || $_[0]){$enc .= ";base64";$new=encode_base64($new,"")}else {$new =~ s/%/%25/g}$self->opaque("$enc,$new")}return unless defined wantarray;$data=uri_unescape($data);return$base64 ? decode_base64($data): $data}my$ENC=$URI::uric;$ENC =~ s/%//;eval <<EOT;die $@ if $@;1;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;use strict;use warnings;use parent 'URI::_generic';our$VERSION="4.21";use URI::Escape qw(uri_unescape);our$DEFAULT_AUTHORITY="";our%OS_CLASS=(os2=>"OS2",mac=>"Mac",MacOS=>"Mac",MSWin32=>"Win32",win32=>"Win32",msdos=>"FAT",dos=>"FAT",qnx=>"QNX",);sub os_class {my($OS)=shift || $^O;my$class="URI::file::" .($OS_CLASS{$OS}|| "Unix");no strict 'refs';unless (%{"$class\::"}){eval "require $class";die $@ if $@}$class}sub host {uri_unescape(shift->authority(@_))}sub new {my($class,$path,$os)=@_;os_class($os)->new($path)}sub new_abs {my$class=shift;my$file=$class->new(@_);return$file->abs($class->cwd)unless $$file =~ /^file:/;$file}sub cwd {my$class=shift;require Cwd;my$cwd=Cwd::cwd();$cwd=VMS::Filespec::unixpath($cwd)if $^O eq 'VMS';$cwd=$class->new($cwd);$cwd .= "/" unless substr($cwd,-1,1)eq "/";$cwd}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$scheme=$other->scheme;my$auth=$other->authority;return$other if!defined($scheme)&&!defined($auth);if (!defined($auth)|| $auth eq "" || lc($auth)eq "localhost" || (defined($DEFAULT_AUTHORITY)&& lc($auth)eq lc($DEFAULT_AUTHORITY))){if ((defined($auth)|| defined($DEFAULT_AUTHORITY))&& (!defined($auth)||!defined($DEFAULT_AUTHORITY)|| $auth ne $DEFAULT_AUTHORITY)){$other=$other->clone if$self==$other;$other->authority($DEFAULT_AUTHORITY)}}$other}sub file {my($self,$os)=@_;os_class($os)->file($self)}sub dir {my($self,$os)=@_;os_class($os)->dir($self)}1;
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;use strict;use warnings;use URI::Escape qw();our$VERSION='1.76';sub new {my$class=shift;my$path=shift;$path="" unless defined$path;my($auth,$escaped_auth,$escaped_path);($auth,$escaped_auth)=$class->_file_extract_authority($path);($path,$escaped_path)=$class->_file_extract_path($path);if (defined$auth){$auth =~ s,%,%25,g unless$escaped_auth;$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$auth="//$auth";if (defined$path){$path="/$path" unless substr($path,0,1)eq "/"}else {$path=""}}else {return undef unless defined$path;$auth=""}$path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless$escaped_path;$path =~ s/\#/%23/g;my$uri=$auth .$path;$uri="file:$uri" if substr($uri,0,1)eq "/";URI->new($uri,"file")}sub _file_extract_authority {my($class,$path)=@_;return undef unless$class->_file_is_absolute($path);return$URI::file::DEFAULT_AUTHORITY}sub _file_extract_path {return undef}sub _file_is_absolute {return 0}sub _file_is_localhost {shift;my$host=lc(shift);return 1 if$host eq "localhost";eval {require Net::Domain;lc(Net::Domain::hostfqdn()|| '')eq $host || lc(Net::Domain::hostname()|| '')eq $host}}sub file {undef}sub dir {my$self=shift;$self->file(@_)}1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='1.76';sub fix_path {shift;for (@_){my@p=map uc,split(/\./,$_,-1);return if@p > 2;@p=("")unless@p;$_=substr($p[0],0,8);if (@p > 1){my$ext=substr($p[1],0,3);$_ .= ".$ext" if length$ext}}1}1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_path {my$class=shift;my$path=shift;my@pre;if ($path =~ s/^(:+)//){if (length($1)==1){@pre=(".")unless length($path)}else {@pre=("..")x (length($1)- 1)}}else {$pre[0]=""}my$isdir=($path =~ s/:$//);$path =~ s,([%/;]), URI::Escape::escape_char($1),eg;my@path=split(/:/,$path,-1);for (@path){if ($_ eq "." || $_ eq ".."){$_="%2E" x length($_)}$_=".." unless length($_)}push (@path,"")if$isdir;(join("/",@pre,@path),1)}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined$auth){if (lc($auth)ne "localhost" && $auth ne ""){my$u_auth=uri_unescape($auth);if (!$class->_file_is_localhost($u_auth)){@path=("",$auth)}}}my@ps=split("/",$uri->path,-1);shift@ps if@path;push(@path,@ps);my$pre="";if (!@path){return}elsif ($path[0]eq ""){shift(@path);if (@path==1){return if$path[0]eq "";push(@path,"")}@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}else {$pre=":";@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}return unless$pre || @path;for (@path){s/;.*//;$_=uri_unescape($_);return if /\0/;return if /:/}$pre .join(":",@path)}sub dir {my$class=shift;my$path=$class->file(@_);return unless defined$path;$path .= ":" unless$path =~ /:$/;$path}1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='1.76';sub _file_extract_authority {my$class=shift;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ m#^[a-zA-Z]{1,2}:#){return ""}return}sub file {my$p=&URI::file::Win32::file;return unless defined$p;$p =~ s,\\,/,g;$p}1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;use strict;use warnings;use parent 'URI::file::Unix';our$VERSION='1.76';sub _file_extract_path {my($class,$path)=@_;$path =~ s,(.)//+,$1/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;$path}1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_path {my($class,$path)=@_;$path =~ s,//+,/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^/,}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined($auth)){if (lc($auth)ne "localhost" && $auth ne ""){$auth=uri_unescape($auth);unless ($class->_file_is_localhost($auth)){push(@path,"","",$auth)}}}my@ps=$uri->path_segments;shift@ps if@path;push(@path,@ps);for (@path){return undef if /\0/;return undef if /\//}return join("/",@path)}1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_authority {my$class=shift;return$class->SUPER::_file_extract_authority($_[0])if defined$URI::file::DEFAULT_AUTHORITY;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ s,^([a-zA-Z]:),,){my$auth=$1;$auth .= "relative" if $_[0]!~ m,^[\\/],;return$auth}return undef}sub _file_extract_path {my($class,$path)=@_;$path =~ s,\\,/,g;$path =~ s,(/\.)+/,/,g;if (defined$URI::file::DEFAULT_AUTHORITY){$path =~ s,^([a-zA-Z]:),/$1,}return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],}sub file {my$class=shift;my$uri=shift;my$auth=$uri->authority;my$rel;if (defined$auth){$auth=uri_unescape($auth);if ($auth =~ /^([a-zA-Z])[:|](relative)?/){$auth=uc($1).":";$rel++ if $2}elsif (lc($auth)eq "localhost"){$auth=""}elsif (length$auth){$auth="\\\\" .$auth}}else {$auth=""}my@path=$uri->path_segments;for (@path){return undef if /\0/;return undef if /\//}return undef unless$class->fix_path(@path);my$path=join("\\",@path);$path =~ s/^\\// if$rel;$path=$auth .$path;$path =~ s,^\\([a-zA-Z])[:|],\u$1:,;return$path}sub fix_path {1}1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_server URI::_userpass);sub default_port {21}sub path {shift->path_query(@_)}sub _user {shift->SUPER::user(@_)}sub _password {shift->SUPER::password(@_)}sub user {my$self=shift;my$user=$self->_user(@_);$user="anonymous" unless defined$user;$user}sub password {my$self=shift;my$pass=$self->_password(@_);unless (defined$pass){my$user=$self->user;if ($user eq 'anonymous' || $user eq 'ftp'){$pass='anonymous@'}}$pass}1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {70}sub _gopher_type {my$self=shift;my$path=$self->path_query;$path =~ s,^/,,;my$gtype=$1 if$path =~ s/^(.)//s;if (@_){my$new_type=shift;if (defined($new_type)){Carp::croak("Bad gopher type '$new_type'")unless length($new_type)==1;substr($path,0,0)=$new_type;$self->path_query($path)}else {Carp::croak("Can't delete gopher type when selector is present")if length($path);$self->path_query(undef)}}return$gtype}sub gopher_type {my$self=shift;my$gtype=$self->_gopher_type(@_);$gtype="1" unless defined$gtype;$gtype}sub gtype {goto&gopher_type}sub selector {shift->_gfield(0,@_)}sub search {shift->_gfield(1,@_)}sub string {shift->_gfield(2,@_)}sub _gfield {my$self=shift;my$fno=shift;my$path=$self->path_query;$path =~ s/\?/\t/;$path=uri_unescape($path);$path =~ s,^/,,;my$gtype=$1 if$path =~ s,^(.),,s;my@path=split(/\t/,$path,3);if (@_){my$new=shift;$path[$fno]=$new;pop(@path)while@path &&!defined($path[-1]);for (@path){$_="" unless defined}$path=$gtype;$path="1" unless defined$path;$path .= join("\t",@path);$self->path_query($path)}$path[$fno]}1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';sub default_port {80}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$slash_path=defined($other->authority)&& !length($other->path)&&!defined($other->query);if ($slash_path){$other=$other->clone if$other==$self;$other->path("/")}$other}1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {443}sub secure {1}1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  package URI::ldap;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_ldap URI::_server);sub default_port {389}sub _nonldap_canonical {my$self=shift;$self->URI::_server::canonical(@_)}1;
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_ldap URI::_generic);require URI::Escape;sub un_path {my$self=shift;my$old=URI::Escape::uri_unescape($self->authority);if (@_){my$p=shift;$p =~ s/:/%3A/g;$p =~ s/\@/%40/g;$self->authority($p)}return$old}sub _nonldap_canonical {my$self=shift;$self->URI::_generic::canonical(@_)}1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;use strict;use warnings;our$VERSION='1.76';use parent 'URI::ldap';sub default_port {636}sub secure {1}1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;use strict;use warnings;our$VERSION='1.76';use parent qw(URI URI::_query);sub to {my$self=shift;my@old=$self->headers;if (@_){my@new=@old;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){splice(@new,$i,2);redo}}my$to=shift;$to="" unless defined$to;unshift(@new,"to"=>$to);$self->headers(@new)}return unless defined wantarray;my@to;while (@old){my$h=shift@old;my$v=shift@old;push(@to,$v)if lc($h)eq "to"}join(",",@to)}sub headers {my$self=shift;my$opaque="to=" .$self->opaque;$opaque =~ s/\?/&/;if (@_){my@new=@_;my@to;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){push(@to,(splice(@new,$i,2))[1]);redo}}my$new=join(",",@to);$new =~ s/%/%25/g;$new =~ s/\?/%3F/g;$self->opaque($new);$self->query_form(@new)if@new}return unless defined wantarray;URI->new("mailto:?$opaque")->query_form}1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {1755}1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);use Carp ();sub default_port {119}sub _group {my$self=shift;my$old=$self->path;if (@_){my($group,$from,$to)=@_;if ($group =~ /\@/){$group =~ s/^<(.*)>$/$1/}$group =~ s,%,%25,g;$group =~ s,/,%2F,g;my$path=$group;if (defined$from){$path .= "/$from";$path .= "-$to" if defined$to}$self->path($path)}$old =~ s,^/,,;if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray){my$extra=$1;return (uri_unescape($old),split(/-/,$extra))}uri_unescape($old)}sub group {my$self=shift;if (@_){Carp::croak("Group name can't contain '\@'")if $_[0]=~ /\@/}my@old=$self->_group(@_);return if$old[0]=~ /\@/;wantarray ? @old : $old[0]}sub message {my$self=shift;if (@_){Carp::croak("Message must contain '\@'")unless $_[0]=~ /\@/}my$old=$self->_group(@_);return undef unless$old =~ /\@/;return$old}1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;use strict;use warnings;our$VERSION='1.76';use parent 'URI::news';1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {110}sub user {my$self=shift;my$old=$self->userinfo;if (@_){my$new_info=$old;$new_info="" unless defined$new_info;$new_info =~ s/^[^;]*//;my$new=shift;if (!defined($new)&&!length($new_info)){$self->userinfo(undef)}else {$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/;/%3B/g;$self->userinfo("$new$new_info")}}return undef unless defined$old;$old =~ s/;.*//;return uri_unescape($old)}sub auth {my$self=shift;my$old=$self->userinfo;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/(^[^;]*)//;my$user=$1;$new =~ s/;auth=[^;]*//i;my$auth=shift;if (defined$auth){$auth =~ s/%/%25/g;$auth =~ s/;/%3B/g;$new=";AUTH=$auth$new"}$self->userinfo("$user$new")}return undef unless defined$old;$old =~ s/^[^;]*//;return uri_unescape($1)if$old =~ /;auth=(.*)/i;return}1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {513}1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_server URI::_userpass);sub default_port {873}1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {554}1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;use strict;use warnings;our$VERSION='1.76';use parent 'URI::rtsp';sub default_port {554}1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;use strict;use warnings;use parent 'URI::ssh';our$VERSION='1.76';1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  package URI::sip;use strict;use warnings;use parent qw(URI::_server URI::_userpass);use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub default_port {5060}sub authority {my$self=shift;$$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;my$old=$2;if (@_){my$auth=shift;$$self=defined($1)? $1 : "";my$rest=$3;if (defined$auth){$auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;$$self .= "$auth"}$$self .= $rest}$old}sub params_form {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my@args=@_;$$self=$1 .$2;my$rest=$4;my@new;for (my$i=0;$i < @args;$i += 2){push(@new,"$args[$i]=$args[$i+1]")}$paramstr=join(";",@new);$$self .= ";" .$paramstr .$rest}$paramstr =~ s/^;//o;return split(/[;=]/,$paramstr)}sub params {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my$new=shift;$$self=$1 .$2;my$rest=$4;$$self .= $paramstr .$rest}$paramstr =~ s/^;//o;return$paramstr}sub path {}sub path_query {}sub path_segments {}sub abs {shift}sub rel {shift}sub query_keywords {}1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;use strict;use warnings;our$VERSION='1.76';use parent 'URI::sip';sub default_port {5061}sub secure {1}1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;use strict;use warnings;our$VERSION='1.76';use parent 'URI::news';sub default_port {563}sub secure {1}1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {22}sub secure {1}1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {23}1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {23}1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;use strict;use warnings;our$VERSION='1.76';use parent 'URI';use Carp qw(carp);my%implementor;my%require_attempted;sub _init {my$class=shift;my$self=$class->SUPER::_init(@_);my$nid=$self->nid;my$impclass=$implementor{$nid};return$impclass->_urn_init($self,$nid)if$impclass;$impclass="URI::urn";if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/){my$id=$nid;$id =~ s/-/_/g;$id="_$id" if$id =~ /^\d/;$impclass="URI::urn::$id";no strict 'refs';unless (@{"${impclass}::ISA"}){if (not exists$require_attempted{$impclass}){my$_old_error=$@;eval "require $impclass";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}$impclass="URI::urn" unless @{"${impclass}::ISA"}}}else {carp("Illegal namespace identifier '$nid' for URN '$self'")if $^W}$implementor{$nid}=$impclass;return$impclass->_urn_init($self,$nid)}sub _urn_init {my($class,$self,$nid)=@_;bless$self,$class}sub _nid {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;$v =~ s/[^:]*/$new/;$self->opaque($v)}$opaque =~ s/:.*//s;return$opaque}sub nid {my$self=shift;my$nid=$self->_nid(@_);$nid=lc($nid)if defined($nid);return$nid}sub nss {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;if (defined$new){$v =~ s/(:|\z).*/:$new/}else {$v =~ s/:.*//s}$self->opaque($v)}return undef unless$opaque =~ s/^[^:]*://;return$opaque}sub canonical {my$self=shift;my$nid=$self->_nid;my$new=$self->SUPER::canonical;return$new if$nid !~ /[A-Z]/ || $nid =~ /%/;$new=$new->clone if$new==$self;$new->nid(lc($nid));return$new}1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;use strict;use warnings;our$VERSION='1.76';use parent 'URI::urn';use Carp qw(carp);BEGIN {require Business::ISBN;local $^W=0;warn "Using Business::ISBN version " .Business::ISBN->VERSION ." which is deprecated.\nUpgrade to Business::ISBN version 2\n" if Business::ISBN->VERSION < 2}sub _isbn {my$nss=shift;$nss=$nss->nss if ref($nss);my$isbn=Business::ISBN->new($nss);$isbn=undef if$isbn &&!$isbn->is_valid;return$isbn}sub _nss_isbn {my$self=shift;my$nss=$self->nss(@_);my$isbn=_isbn($nss);$isbn=$isbn->as_string if$isbn;return($nss,$isbn)}sub isbn {my$self=shift;my$isbn;(undef,$isbn)=$self->_nss_isbn(@_);return$isbn}sub isbn_publisher_code {my$isbn=shift->_isbn || return undef;return$isbn->publisher_code}BEGIN {my$group_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code'};sub isbn_group_code {my$isbn=shift->_isbn || return undef;return$isbn->$group_method}}sub isbn_country_code {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn_group_code instead";no strict 'refs';&isbn_group_code}BEGIN {my$isbn13_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean'};sub isbn13 {my$isbn=shift->_isbn || return undef;my$thingy=$isbn->$isbn13_method;return eval {$thingy->can('as_string')}? $thingy->as_string([]): $thingy}}sub isbn_as_ean {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn13 instead";no strict 'refs';&isbn13}sub canonical {my$self=shift;my($nss,$isbn)=$self->_nss_isbn;my$new=$self->SUPER::canonical;return$new unless$nss && $isbn && $nss ne $isbn;$new=$new->clone if$new==$self;$new->nss($isbn);return$new}1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;use strict;use warnings;our$VERSION='1.76';use parent 'URI::urn';sub oid {my$self=shift;my$old=$self->nss;if (@_){$self->nss(join(".",@_))}return split(/\./,$old)if wantarray;return$old}1;
URI_URN_OID

$fatpacked{"Win32/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WIN32_SHELLQUOTE';
  package Win32::ShellQuote;use strict;use warnings FATAL=>'all';use base 'Exporter';use Carp;our$VERSION='0.003001';$VERSION=eval$VERSION;our@EXPORT_OK=qw(quote_native quote_cmd quote_system_list quote_system_string quote_system quote_system_cmd quote_literal cmd_escape unquote_native cmd_unescape);our%EXPORT_TAGS=(all=>[@EXPORT_OK]);sub quote_native {return join q{ },quote_system_list(@_)}sub quote_cmd {return cmd_escape(quote_native(@_))}sub quote_system_list {return map {quote_literal($_,1)}@_}sub quote_system_string {my$args=quote_native(@_);if (_has_shell_metachars($args)){$args=cmd_escape($args)}return$args}sub quote_system {if (@_ > 1){return quote_system_list(@_)}else {return quote_system_string(@_)}}sub quote_system_cmd {my$args=quote_native(@_);if (!_has_shell_metachars($args)){return '%PATH:~0,0%' .cmd_escape($args)}return cmd_escape($args)}sub cmd_escape {my$string=shift;if ($string =~ /[\r\n\0]/){croak "can't quote newlines to pass through cmd.exe"}$string =~ s/([()%!^"<>&|])/^$1/g;return$string}sub quote_literal {my ($text,$force)=@_;if (!$force && $text ne '' && $text !~ /[ \t\n\x0b"]/){}else {$text =~ s{(\\*)(?="|\z)}{$1$1}g;$text =~ s{"}{\\"}g;$text=qq{"$text"}}return$text}sub _has_shell_metachars {my$string=shift;return 1 if$string =~ /%/;$string =~ s/(['"]).*?(\1|\z)//sg;return$string =~ /[<>|]/}sub unquote_native {local ($_)=@_;my@argv;my$length=length or return@argv;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub cmd_unescape {my ($string)=@_;no warnings 'uninitialized';$string =~ s/\^(.?)|([^^"]+)|("[^"]*(?:"|\z))/$1$2$3/gs;return$string}1;
WIN32_SHELLQUOTE

$fatpacked{"lib/core/only.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_CORE_ONLY';
  package lib::core::only;use strict;use warnings FATAL=>'all';use Config;sub import {@INC=@Config{qw(privlibexp archlibexp)};return}1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCAL_LIB';
  package local::lib;use 5.006;BEGIN {if ($ENV{RELEASE_TESTING}){require strict;strict->import;require warnings;warnings->import}}use Config ();our$VERSION='2.000024';$VERSION=eval$VERSION;BEGIN {*_WIN32=($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'symbian')? sub(){1}: sub(){0};*_USE_FSPEC=($^O eq 'MacOS' || $^O eq 'VMS' || $INC{'File/Spec.pm'})? sub(){1}: sub(){0}}my$_archname=$Config::Config{archname};my$_version=$Config::Config{version};my@_inc_version_list=reverse split / /,$Config::Config{inc_version_list};my$_path_sep=$Config::Config{path_sep};our$_DIR_JOIN=_WIN32 ? '\\' : '/';our$_DIR_SPLIT=(_WIN32 || $^O eq 'cygwin')? qr{[\\/]} : qr{/};our$_ROOT=_WIN32 ? do {my$UNC=qr{[\\/]{2}[^\\/]+[\\/][^\\/]+};qr{^(?:$UNC|[A-Za-z]:|)$_DIR_SPLIT}}: qr{^/};our$_PERL;sub _perl {if (!$_PERL){($_PERL,my$exe)=$^X =~ /((?:.*$_DIR_SPLIT)?(.+))/;$_PERL='perl' if$exe !~ /perl/;if (_is_abs($_PERL)){}elsif (-x $Config::Config{perlpath}){$_PERL=$Config::Config{perlpath}}elsif ($_PERL =~ $_DIR_SPLIT && -x $_PERL){$_PERL=_rel2abs($_PERL)}else {($_PERL)=map {/(.*)/}grep {-x $_}map {($_,_WIN32 ? ("$_.exe"): ())}map {join($_DIR_JOIN,$_,$_PERL)}split /\Q$_path_sep\E/,$ENV{PATH}}}$_PERL}sub _cwd {if (my$cwd =defined&Cwd::sys_cwd ? \&Cwd::sys_cwd : defined&Cwd::cwd ? \&Cwd::cwd : undef){no warnings 'redefine';*_cwd=$cwd;goto &$cwd}my$drive=shift;return Win32::Cwd()if _WIN32 && defined&Win32::Cwd &&!$drive;local@ENV{qw(PATH IFS CDPATH ENV BASH_ENV)};my$cmd=$drive ? "eval { Cwd::getdcwd(q($drive)) }" : 'getcwd';my$perl=_perl;my$cwd=`"$perl" -MCwd -le "print $cmd"`;chomp$cwd;if (!length$cwd && $drive){$cwd=$drive}$cwd =~ s/$_DIR_SPLIT?$/$_DIR_JOIN/;$cwd}sub _catdir {if (_USE_FSPEC){require File::Spec;File::Spec->catdir(@_)}else {my$dir=join($_DIR_JOIN,@_);$dir =~ s{($_DIR_SPLIT)(?:\.?$_DIR_SPLIT)+}{$1}g;$dir}}sub _is_abs {if (_USE_FSPEC){require File::Spec;File::Spec->file_name_is_absolute($_[0])}else {$_[0]=~ $_ROOT}}sub _rel2abs {my ($dir,$base)=@_;return$dir if _is_abs($dir);$base=_WIN32 && $dir =~ s/^([A-Za-z]:)// ? _cwd("$1"): $base ? _rel2abs($base): _cwd;return _catdir($base,$dir)}our$_DEVNULL;sub _devnull {return$_DEVNULL ||= _USE_FSPEC ? (require File::Spec,File::Spec->devnull): _WIN32 ? 'nul' : $^O eq 'os2' ? '/dev/nul' : '/dev/null'}sub import {my ($class,@args)=@_;if ($0 eq '-'){push@args,@ARGV;require Cwd}my@steps;my%opts;my%attr;my$shelltype;while (@args){my$arg=shift@args;if ($arg =~ /\xE2\x88\x92/){die <<'DEATH'}elsif ($arg eq '--self-contained'){die <<'DEATH'}elsif($arg =~ /^--deactivate(?:=(.*))?$/){my$path=defined $1 ? $1 : shift@args;push@steps,['deactivate',$path]}elsif ($arg eq '--deactivate-all'){push@steps,['deactivate_all']}elsif ($arg =~ /^--shelltype(?:=(.*))?$/){$shelltype=defined $1 ? $1 : shift@args}elsif ($arg eq '--no-create'){$opts{no_create}=1}elsif ($arg eq '--quiet'){$attr{quiet}=1}elsif ($arg =~ /^--/){die "Unknown import argument: $arg"}else {push@steps,['activate',$arg,\%opts]}}if (!@steps){push@steps,['activate',undef,\%opts]}my$self=$class->new(%attr);for (@steps){my ($method,@args)=@$_;$self=$self->$method(@args)}if ($0 eq '-'){print$self->environment_vars_string($shelltype);exit 0}else {$self->setup_local_lib}}sub new {my$class=shift;bless {@_},$class}sub clone {my$self=shift;bless {%$self,@_},ref$self}sub inc {$_[0]->{inc}||= \@INC}sub libs {$_[0]->{libs}||= [\'PERL5LIB' ]}sub bins {$_[0]->{bins}||= [\'PATH' ]}sub roots {$_[0]->{roots}||= [\'PERL_LOCAL_LIB_ROOT' ]}sub extra {$_[0]->{extra}||= {}}sub quiet {$_[0]->{quiet}}sub _as_list {my$list=shift;grep length,map {!(ref $_ && ref $_ eq 'SCALAR')? $_ : (defined$ENV{$$_}? split(/\Q$_path_sep/,$ENV{$$_}): ())}ref$list ? @$list : $list}sub _remove_from {my ($list,@remove)=@_;return @$list if!@remove;my%remove=map {$_=>1}@remove;grep!$remove{$_},_as_list($list)}my@_lib_subdirs=([$_version,$_archname],[$_version],[$_archname],(map [$_],@_inc_version_list),[],);sub install_base_bin_path {my ($class,$path)=@_;return _catdir($path,'bin')}sub install_base_perl_path {my ($class,$path)=@_;return _catdir($path,'lib','perl5')}sub install_base_arch_path {my ($class,$path)=@_;_catdir($class->install_base_perl_path($path),$_archname)}sub lib_paths_for {my ($class,$path)=@_;my$base=$class->install_base_perl_path($path);return map {_catdir($base,@$_)}@_lib_subdirs}sub _mm_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;if ($path =~ s/ /\\ /g){$path=qq{"$path"}}return$path}sub _mb_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;return qq{"$path"}}sub installer_options_for {my ($class,$path)=@_;return (PERL_MM_OPT=>defined$path ? "INSTALL_BASE="._mm_escape_path($path): undef,PERL_MB_OPT=>defined$path ? "--install_base "._mb_escape_path($path): undef,)}sub active_paths {my ($self)=@_;$self=ref$self ? $self : $self->new;return grep {my$active_ll=$self->install_base_perl_path($_);grep {$_ eq $active_ll}@{$self->inc}}_as_list($self->roots)}sub deactivate {my ($self,$path)=@_;$self=$self->new unless ref$self;$path=$self->resolve_path($path);$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (!grep {$_ eq $path}@active_lls){warn "Tried to deactivate inactive local::lib '$path'\n";return$self}my%args=(bins=>[_remove_from($self->bins,$self->install_base_bin_path($path))],libs=>[_remove_from($self->libs,$self->install_base_perl_path($path))],inc=>[_remove_from($self->inc,$self->lib_paths_for($path))],roots=>[_remove_from($self->roots,$path)],);$args{extra}={$self->installer_options_for($args{roots}[0])};$self->clone(%args)}sub deactivate_all {my ($self)=@_;$self=$self->new unless ref$self;my@active_lls=$self->active_paths;my%args;if (@active_lls){%args=(bins=>[_remove_from($self->bins,map$self->install_base_bin_path($_),@active_lls)],libs=>[_remove_from($self->libs,map$self->install_base_perl_path($_),@active_lls)],inc=>[_remove_from($self->inc,map$self->lib_paths_for($_),@active_lls)],roots=>[_remove_from($self->roots,@active_lls)],)}$args{extra}={$self->installer_options_for(undef)};$self->clone(%args)}sub activate {my ($self,$path,$opts)=@_;$opts ||= {};$self=$self->new unless ref$self;$path=$self->resolve_path($path);$self->ensure_dir_structure_for($path,{quiet=>$self->quiet })unless$opts->{no_create};$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (grep {$_ eq $path}@active_lls[1 .. $#active_lls]){$self=$self->deactivate($path)}my%args;if ($opts->{always}||!@active_lls || $active_lls[0]ne $path){%args=(bins=>[$self->install_base_bin_path($path),@{$self->bins}],libs=>[$self->install_base_perl_path($path),@{$self->libs}],inc=>[$self->lib_paths_for($path),@{$self->inc}],roots=>[$path,@{$self->roots}],)}$args{extra}={$self->installer_options_for($path)};$self->clone(%args)}sub normalize_path {my ($self,$path)=@_;$path=(Win32::GetShortPathName($path)|| $path)if $^O eq 'MSWin32';return$path}sub build_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_activate_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_deactivate_environment_vars_for {my$self=$_[0]->new->deactivate($_[1]);$self->build_environment_vars}sub build_deact_all_environment_vars_for {my$self=$_[0]->new->deactivate_all;$self->build_environment_vars}sub build_environment_vars {my$self=shift;(PATH=>join($_path_sep,_as_list($self->bins)),PERL5LIB=>join($_path_sep,_as_list($self->libs)),PERL_LOCAL_LIB_ROOT=>join($_path_sep,_as_list($self->roots)),%{$self->extra},)}sub setup_local_lib_for {my$self=$_[0]->new->activate($_[1]);$self->setup_local_lib}sub setup_local_lib {my$self=shift;require Carp::Heavy if$INC{'Carp.pm'};$self->setup_env_hash;@INC=@{$self->inc}}sub setup_env_hash_for {my$self=$_[0]->new->activate($_[1]);$self->setup_env_hash}sub setup_env_hash {my$self=shift;my%env=$self->build_environment_vars;for my$key (keys%env){if (defined$env{$key}){$ENV{$key}=$env{$key}}else {delete$ENV{$key}}}}sub print_environment_vars_for {print $_[0]->environment_vars_string_for(@_[1..$#_])}sub environment_vars_string_for {my$self=$_[0]->new->activate($_[1],{always=>1});$self->environment_vars_string}sub environment_vars_string {my ($self,$shelltype)=@_;$shelltype ||= $self->guess_shelltype;my$extra=$self->extra;my@envs=(PATH=>$self->bins,PERL5LIB=>$self->libs,PERL_LOCAL_LIB_ROOT=>$self->roots,map {$_=>$extra->{$_}}sort keys %$extra,);$self->_build_env_string($shelltype,\@envs)}sub _build_env_string {my ($self,$shelltype,$envs)=@_;my@envs=@$envs;my$build_method="build_${shelltype}_env_declaration";my$out='';while (@envs){my ($name,$value)=(shift(@envs),shift(@envs));if (ref$value && @$value==1 && ref$value->[0]&& ref$value->[0]eq 'SCALAR' && ${$value->[0]}eq $name){next}$out .= $self->$build_method($name,$value)}my$wrap_method="wrap_${shelltype}_output";if ($self->can($wrap_method)){return$self->$wrap_method($out)}return$out}sub build_bourne_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'${%s:-}',qr/["\\\$!`]/,'\\%s');if (!defined$value){return qq{unset $name;\n}}$value =~ s/(^|\G|$_path_sep)\$\{$name:-\}$_path_sep/$1\${$name}\${$name:+$_path_sep}/g;$value =~ s/$_path_sep\$\{$name:-\}$/\${$name:+$_path_sep\${$name}}/;qq{${name}="$value"; export ${name};\n}}sub build_csh_env_declaration {my ($class,$name,$args)=@_;my ($value,@vars)=$class->_interpolate($args,'${%s}',qr/["\$]/,'"\\%s"');if (!defined$value){return qq{unsetenv $name;\n}}my$out='';for my$var (@vars){$out .= qq{if ! \$?$name setenv $name '';\n}}my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$\{$name\}(?:$_path_sep|$)//g){$out .= qq{if "\${$name}" != '' setenv $name "$value";\n};$out .= qq{if "\${$name}" == '' }}$out .= qq{setenv $name "$value_without";\n};return$out}sub build_cmd_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'%%%s%%',qr(%),'%s');if (!$value){return qq{\@set $name=\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)%$name%(?:$_path_sep|$)//g){$out .= qq{\@if not "%$name%"=="" set "$name=$value"\n};$out .= qq{\@if "%$name%"=="" }}$out .= qq{\@set "$name=$value_without"\n};return$out}sub build_powershell_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$env:%s',qr/["\$]/,'`%s');if (!$value){return qq{Remove-Item -ErrorAction 0 Env:\\$name;\n}}my$maybe_path_sep=qq{\$(if("\$env:$name"-eq""){""}else{"$_path_sep"})};$value =~ s/(^|\G|$_path_sep)\$env:$name$_path_sep/$1\$env:$name"+$maybe_path_sep+"/g;$value =~ s/$_path_sep\$env:$name$/"+$maybe_path_sep+\$env:$name+"/;qq{\$env:$name = \$("$value");\n}}sub wrap_powershell_output {my ($class,$out)=@_;return$out || " \n"}sub build_fish_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$%s',qr/[\\"'$ ]/,'\\%s');if (!defined$value){return qq{set -e $name;\n}}if ($name =~ /^(?:CD|MAN)?PATH$/){$value =~ s/$_path_sep/ /g;my$silent=$name =~ /^(?:CD)?PATH$/ ? " ^"._devnull : '';return qq{set -x $name $value$silent;\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$$name(?:$_path_sep|$)//g){$out .= qq{set -q $name; and set -x $name $value;\n};$out .= qq{set -q $name; or }}$out .= qq{set -x $name $value_without;\n};$out}sub _interpolate {my ($class,$args,$var_pat,$escape,$escape_pat)=@_;return unless defined$args;my@args=ref$args ? @$args : $args;return unless@args;my@vars=map {$$_}grep {ref $_ eq 'SCALAR'}@args;my$string=join$_path_sep,map {ref $_ eq 'SCALAR' ? sprintf($var_pat,$$_): do {s/($escape)/sprintf($escape_pat, $1)/ge;$_}}@args;return wantarray ? ($string,\@vars): $string}sub pipeline;sub pipeline {my@methods=@_;my$last=pop(@methods);if (@methods){\sub {my ($obj,@args)=@_;$obj->${pipeline@methods}($obj->$last(@args))}}else {\sub {shift->$last(@_)}}}sub resolve_path {my ($class,$path)=@_;$path=$class->${pipeline qw(resolve_relative_path resolve_home_path resolve_empty_path)}($path);$path}sub resolve_empty_path {my ($class,$path)=@_;if (defined$path){$path}else {'~/perl5'}}sub resolve_home_path {my ($class,$path)=@_;$path =~ /^~([^\/]*)/ or return$path;my$user=$1;my$homedir=do {if (!length($user)&& defined$ENV{HOME}){$ENV{HOME}}else {require File::Glob;File::Glob::bsd_glob("~$user",File::Glob::GLOB_TILDE())}};unless (defined$homedir){require Carp;require Carp::Heavy;Carp::croak("Couldn't resolve homedir for " .(defined$user ? $user : 'current user'))}$path =~ s/^~[^\/]*/$homedir/;$path}sub resolve_relative_path {my ($class,$path)=@_;_rel2abs($path)}sub ensure_dir_structure_for {my ($class,$path,$opts)=@_;$opts ||= {};my@dirs;for my$dir ($class->lib_paths_for($path),$class->install_base_bin_path($path),){my$d=$dir;while (!-d $d){push@dirs,$d;require File::Basename;$d=File::Basename::dirname($d)}}warn "Attempting to create directory ${path}\n" if!$opts->{quiet}&& @dirs;my%seen;for my$dir (reverse@dirs){next if$seen{$dir}++;mkdir$dir or -d $dir or die "Unable to create $dir: $!"}return}sub guess_shelltype {my$shellbin =defined$ENV{SHELL}&& length$ENV{SHELL}? ($ENV{SHELL}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' && exists$ENV{'!EXITCODE'})? 'bash' : ($^O eq 'MSWin32' && $ENV{PROMPT}&& $ENV{COMSPEC})? ($ENV{COMSPEC}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' &&!$ENV{PROMPT})? 'powershell.exe' : 'sh';for ($shellbin){return /csh$/ ? 'csh' : /fish$/ ? 'fish' : /command(?:\.com)?$/i ? 'cmd' : /cmd(?:\.exe)?$/i ? 'cmd' : /4nt(?:\.exe)?$/i ? 'cmd' : /powershell(?:\.exe)?$/i ? 'powershell' : 'bourne'}}1;
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
  FATAL: The local::lib --self-contained flag has never worked reliably and the
  original author, Mark Stosberg, was unable or unwilling to maintain it. As
  such, this flag has been removed from the local::lib codebase in order to
  prevent misunderstandings and potentially broken builds. The local::lib authors
  recommend that you look at the lib::core::only module shipped with this
  distribution in order to create a more robust environment that is equivalent to
  what --self-contained provided (although quite possibly not what you originally
  thought it provided due to the poor quality of the documentation, for which we
  apologise).
  DEATH
LOCAL_LIB

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;use Moo::_strictures;use Moo::_Utils qw(_load_module);sub moo {print <<'EOMOO';exit 0}BEGIN {my$package;sub import {moo()if $0 eq '-';$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;_load_module($package)}}use Filter::Simple sub {s/^/package $package;\nuse Moo;\n/}}1;
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
OO

$fatpacked{"strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES';
  package strictures;use strict;use warnings FATAL=>'all';BEGIN {*_PERL_LT_5_8_4=("$]" < 5.008004)? sub(){1}: sub(){0};*_CAN_GOTO_VERSION=("$]" >= 5.010000)? sub(){1}: sub(){0}}our$VERSION='2.000006';$VERSION =~ tr/_//d;our@WARNING_CATEGORIES=grep {exists$warnings::Offsets{$_}}qw(closure chmod deprecated exiting experimental experimental::alpha_assertions experimental::autoderef experimental::bitwise experimental::const_attr experimental::declared_refs experimental::lexical_subs experimental::lexical_topic experimental::postderef experimental::private_use experimental::re_strict experimental::refaliasing experimental::regex_sets experimental::script_run experimental::signatures experimental::smartmatch experimental::win32_perlio glob imprecision io closed exec layer newline pipe syscalls unopened locale misc missing numeric once overflow pack portable recursion redefine redundant regexp severe debugging inplace internal malloc shadow signal substr syntax ambiguous bareword digit illegalproto parenthesis precedence printf prototype qw reserved semicolon taint threads uninitialized umask unpack untie utf8 non_unicode nonchar surrogate void void_unusual y2k);sub VERSION {{no warnings;local $@;if (defined $_[1]&& eval {&UNIVERSAL::VERSION;1}){$^H |= 0x20000 unless _PERL_LT_5_8_4;$^H{strictures_enable}=int $_[1]}}_CAN_GOTO_VERSION ? goto&UNIVERSAL::VERSION : &UNIVERSAL::VERSION}our%extra_load_states;our$Smells_Like_VCS;sub import {my$class=shift;my%opts=@_==1 ? %{$_[0]}: @_;if (!exists$opts{version}){$opts{version}=exists $^H{strictures_enable}? delete $^H{strictures_enable}: int$VERSION}$opts{file}=(caller)[1];$class->_enable(\%opts)}sub _enable {my ($class,$opts)=@_;my$version=$opts->{version};$version='undef' if!defined$version;my$method="_enable_$version";if (!$class->can($method)){require Carp;Carp::croak("Major version specified as $version - not supported!")}$class->$method($opts)}sub _enable_1 {my ($class,$opts)=@_;strict->import;warnings->import(FATAL=>'all');if (_want_extra($opts->{file})){_load_extras(qw(indirect multidimensional bareword::filehandles));indirect->unimport(':fatal')if$extra_load_states{indirect};multidimensional->unimport if$extra_load_states{multidimensional};bareword::filehandles->unimport if$extra_load_states{'bareword::filehandles'}}}our@V2_NONFATAL=grep {exists$warnings::Offsets{$_}}('exec','recursion','internal','malloc','newline','experimental','deprecated','portable',);our@V2_DISABLE=grep {exists$warnings::Offsets{$_}}('once');sub _enable_2 {my ($class,$opts)=@_;strict->import;warnings->import;warnings->import(FATAL=>@WARNING_CATEGORIES);warnings->unimport(FATAL=>@V2_NONFATAL);warnings->import(@V2_NONFATAL);warnings->unimport(@V2_DISABLE);if (_want_extra($opts->{file})){_load_extras(qw(indirect multidimensional bareword::filehandles));indirect->unimport(':fatal')if$extra_load_states{indirect};multidimensional->unimport if$extra_load_states{multidimensional};bareword::filehandles->unimport if$extra_load_states{'bareword::filehandles'}}}sub _want_extra_env {if (exists$ENV{PERL_STRICTURES_EXTRA}){if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}){die 'PERL_STRICTURES_EXTRA checks are not available on perls older' ."than 5.8.4: please unset \$ENV{PERL_STRICTURES_EXTRA}\n"}return$ENV{PERL_STRICTURES_EXTRA}? 1 : 0}return undef}sub _want_extra {my$file=shift;my$want_env=_want_extra_env();return$want_env if defined$want_env;return (!_PERL_LT_5_8_4 and $file =~ /^(?:t|xt|lib|blib)[\\\/]/ and defined$Smells_Like_VCS ? $Smells_Like_VCS : ($Smells_Like_VCS=!!(-e '.git' || -e '.svn' || -e '.hg' || -e '.bzr' || (-e '../../dist.ini' && (-e '../../.git' || -e '../../.svn' || -e '../../.hg' || -e '../../.bzr')))))}sub _load_extras {my@extras=@_;my@failed;for my$mod (@extras){next if exists$extra_load_states{$mod};$extra_load_states{$mod}=eval "require $mod; 1;" or do {push@failed,$mod;(my$file=$mod)=~ s|::|/|g;delete$INC{"${file}.pm"}}}if (@failed){my$failed=join ' ',@failed;my$extras=join ' ',@extras;print STDERR <<EOE}}1;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan $extras
  
  but these modules are not required by your users.
  EOE
STRICTURES

$fatpacked{"strictures/extra.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES_EXTRA';
  package strictures::extra;use strict;use warnings FATAL=>'all';sub import {$ENV{PERL_STRICTURES_EXTRA}=1}sub unimport {$ENV{PERL_STRICTURES_EXTRA}=0}1;
STRICTURES_EXTRA

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;

use App::ccu;
$App::ccu::GIT_DESCRIBE = 'no tags';
$App::ccu::GIT_URL = 'https://github.com/akiym/cpanfile-check-updates/tree/514a571';

use App::ccu::CLI;

exit(App::ccu::CLI->new->run(@ARGV));
